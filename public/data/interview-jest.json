{
  "id": "jest",
  "name": "Câu hỏi phỏng vấn Jest Testing",
  "description": "Tổng hợp câu hỏi phỏng vấn về Jest - JavaScript Testing Framework với các câu hỏi so sánh",
  "questions": [
    {
      "question": "So sánh toBe() vs toEqual() trong Jest?",
      "answer": "<p><strong>Sự khác biệt chính:</strong></p><p><code>toBe()</code> sử dụng <code>Object.is()</code> để so sánh strict equality (===), trong khi <code>toEqual()</code> so sánh deep equality - kiểm tra từng property của objects/arrays.</p><p><strong>Khi nào dùng toBe():</strong></p><p>Dùng cho primitive values (number, string, boolean) và kiểm tra reference của objects.</p><pre><code>// ✅ ĐÚNG - So sánh primitive values\r\ntest('primitive values', () => {\r\n  expect(2 + 2).toBe(4);\r\n  expect('hello').toBe('hello');\r\n  expect(true).toBe(true);\r\n});\r\n\r\n// ✅ ĐÚNG - So sánh reference\r\ntest('same reference', () => {\r\n  const user = { name: 'John' };\r\n  const sameUser = user;\r\n  expect(sameUser).toBe(user); // Cùng reference\r\n});\r\n\r\n// ❌ SAI - Khác reference mặc dù giá trị giống nhau\r\ntest('different objects', () => {\r\n  expect({ name: 'John' }).toBe({ name: 'John' }); // FAIL!\r\n});</code></pre><p><strong>Khi nào dùng toEqual():</strong></p><p>Dùng để so sánh nội dung của objects, arrays, không quan tâm reference.</p><pre><code>// ✅ ĐÚNG - So sánh objects\r\ntest('object equality', () => {\r\n  const user1 = { name: 'John', age: 30 };\r\n  const user2 = { name: 'John', age: 30 };\r\n  \r\n  expect(user1).toEqual(user2); // PASS - nội dung giống nhau\r\n  expect(user1).not.toBe(user2); // PASS - khác reference\r\n});\r\n\r\n// ✅ ĐÚNG - So sánh arrays\r\ntest('array equality', () => {\r\n  expect([1, 2, 3]).toEqual([1, 2, 3]); // PASS\r\n  expect([1, 2, 3]).not.toBe([1, 2, 3]); // PASS - khác reference\r\n});\r\n\r\n// ✅ ĐÚNG - Deep nested objects\r\ntest('nested objects', () => {\r\n  const data1 = {\r\n    user: { name: 'John', address: { city: 'HN' } }\r\n  };\r\n  const data2 = {\r\n    user: { name: 'John', address: { city: 'HN' } }\r\n  };\r\n  \r\n  expect(data1).toEqual(data2); // PASS\r\n});</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>toBe()</th><th>toEqual()</th></tr><tr><td>So sánh với ===</td><td>Deep equality comparison</td></tr><tr><td>Kiểm tra reference</td><td>Kiểm tra nội dung</td></tr><tr><td>Dùng cho primitives</td><td>Dùng cho objects/arrays</td></tr><tr><td>Nhanh hơn</td><td>Chậm hơn (deep check)</td></tr></table>",
      "level": "middle"
    },
    {
      "question": "So sánh Mock vs Spy trong Jest?",
      "answer": "<p><strong>Mock Function (jest.fn()):</strong></p><p>Tạo một fake function hoàn toàn mới, thay thế implementation gốc.</p><pre><code>// Mock function không có implementation\r\nconst mockFn = jest.fn();\r\n\r\nmockFn('hello');\r\nconsole.log(mockFn.mock.calls); // [['hello']]\r\n\r\n// Mock với return value\r\nconst mockAdd = jest.fn((a, b) => a + b);\r\nexpect(mockAdd(2, 3)).toBe(5);\r\n\r\n// Mock module\r\njest.mock('./api', () => ({\r\n  fetchUser: jest.fn(() => Promise.resolve({ name: 'John' }))\r\n}));</code></pre><p><strong>Spy (jest.spyOn()):</strong></p><p>Theo dõi (spy) một method thực sự, vẫn giữ nguyên implementation gốc (trừ khi bạn override).</p><pre><code>const user = {\r\n  getName: () => 'John',\r\n  getAge: () => 30\r\n};\r\n\r\n// Spy - vẫn gọi implementation gốc\r\nconst spy = jest.spyOn(user, 'getName');\r\n\r\nconst name = user.getName();\r\n\r\nexpect(name).toBe('John'); // Vẫn return 'John'\r\nexpect(spy).toHaveBeenCalled(); // Nhưng được track\r\n\r\n// Restore về implementation gốc\r\nspy.mockRestore();</code></pre><p><strong>So sánh chi tiết:</strong></p><table><tr><th>Mock (jest.fn)</th><th>Spy (jest.spyOn)</th></tr><tr><td>Tạo function hoàn toàn mới</td><td>Wrap existing function</td></tr><tr><td>Không gọi code gốc</td><td>Mặc định vẫn gọi code gốc</td></tr><tr><td>Dùng khi muốn fake behavior</td><td>Dùng khi muốn track calls</td></tr><tr><td>Không cần implementation gốc</td><td>Cần có implementation gốc</td></tr><tr><td>Không thể restore</td><td>Có thể mockRestore()</td></tr></table><p><strong>Khi nào dùng Mock:</strong></p><pre><code>// Mock API calls - không muốn gọi API thật\r\njest.mock('axios');\r\nimport axios from 'axios';\r\n\r\ntest('fetches user', async () => {\r\n  axios.get.mockResolvedValue({ data: { name: 'John' } });\r\n  \r\n  const user = await fetchUser();\r\n  expect(user.name).toBe('John');\r\n});</code></pre><p><strong>Khi nào dùng Spy:</strong></p><pre><code>// Spy để track method calls nhưng vẫn chạy logic gốc\r\ntest('calls console.log', () => {\r\n  const spy = jest.spyOn(console, 'log');\r\n  \r\n  myFunction(); // Vẫn log ra console\r\n  \r\n  expect(spy).toHaveBeenCalledWith('expected message');\r\n  spy.mockRestore();\r\n});</code></pre><p><strong>Override Spy implementation:</strong></p><pre><code>const spy = jest.spyOn(user, 'getName');\r\n\r\n// Override để return giá trị khác\r\nspy.mockReturnValue('Jane');\r\n\r\nexpect(user.getName()).toBe('Jane'); // Không gọi code gốc nữa\r\n\r\nspy.mockRestore(); // Restore lại\r\nexpect(user.getName()).toBe('John'); // Lại chạy code gốc</code></pre>",
      "level": "middle"
    },
    {
      "question": "So sánh shallow vs mount trong Vue Test Utils?",
      "answer": "<p><strong>Shallow Rendering (shallowMount):</strong></p><p>Render component nhưng stub (fake) tất cả child components, chỉ test component hiện tại isolated.</p><pre><code>import { shallowMount } from '@vue/test-utils';\r\nimport ParentComponent from './ParentComponent.vue';\r\n\r\ntest('shallow mount', () => {\r\n  const wrapper = shallowMount(ParentComponent);\r\n  \r\n  // Child components được stub (không render thật)\r\n  // Chỉ test logic của ParentComponent\r\n  expect(wrapper.find('.parent-class').exists()).toBe(true);\r\n});</code></pre><p><strong>Full Mount (mount):</strong></p><p>Render component và TẤT CẢ child components, test toàn bộ component tree.</p><pre><code>import { mount } from '@vue/test-utils';\r\nimport ParentComponent from './ParentComponent.vue';\r\n\r\ntest('full mount', () => {\r\n  const wrapper = mount(ParentComponent);\r\n  \r\n  // Child components được render thật\r\n  // Test cả parent và children\r\n  expect(wrapper.findComponent(ChildComponent).exists()).toBe(true);\r\n});</code></pre><p><strong>Ví dụ cụ thể:</strong></p><pre><code>// ParentComponent.vue\r\n&lt;template&gt;\r\n  &lt;div class=\"parent\"&gt;\r\n    &lt;h1&gt;{{ title }}&lt;/h1&gt;\r\n    &lt;ChildComponent :data=\"childData\" /&gt;\r\n  &lt;/div&gt;\r\n&lt;/template&gt;\r\n\r\n// ChildComponent.vue\r\n&lt;template&gt;\r\n  &lt;div class=\"child\"&gt;{{ data }}&lt;/div&gt;\r\n&lt;/template&gt;</code></pre><pre><code>// Với shallowMount\r\nconst wrapper = shallowMount(ParentComponent);\r\nconsole.log(wrapper.html());\r\n// Output:\r\n// &lt;div class=\"parent\"&gt;\r\n//   &lt;h1&gt;Title&lt;/h1&gt;\r\n//   &lt;child-component-stub data=\"...\"&gt;&lt;/child-component-stub&gt;\r\n// &lt;/div&gt;\r\n\r\n// Với mount\r\nconst wrapper = mount(ParentComponent);\r\nconsole.log(wrapper.html());\r\n// Output:\r\n// &lt;div class=\"parent\"&gt;\r\n//   &lt;h1&gt;Title&lt;/h1&gt;\r\n//   &lt;div class=\"child\"&gt;Child data&lt;/div&gt;\r\n// &lt;/div&gt;</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>shallowMount</th><th>mount</th></tr><tr><td>Stub child components</td><td>Render tất cả children</td></tr><tr><td>Test isolated</td><td>Test integration</td></tr><tr><td>Nhanh hơn</td><td>Chậm hơn</td></tr><tr><td>Unit test</td><td>Integration test</td></tr><tr><td>Không test child behavior</td><td>Test cả child behavior</td></tr></table><p><strong>Khi nào dùng shallowMount:</strong></p><ul><li>Unit test component logic riêng biệt</li><li>Component có nhiều children phức tạp</li><li>Muốn test nhanh, focused</li><li>Không quan tâm child components hoạt động thế nào</li></ul><pre><code>test('emits event when button clicked', () => {\r\n  const wrapper = shallowMount(MyComponent);\r\n  \r\n  wrapper.find('button').trigger('click');\r\n  \r\n  expect(wrapper.emitted('submit')).toBeTruthy();\r\n});</code></pre><p><strong>Khi nào dùng mount:</strong></p><ul><li>Integration test - test tương tác parent-child</li><li>Test slots, provide/inject</li><li>Test component với children có behavior quan trọng</li><li>E2E-like testing</li></ul><pre><code>test('parent passes data to child correctly', () => {\r\n  const wrapper = mount(ParentComponent, {\r\n    props: { userId: 1 }\r\n  });\r\n  \r\n  const child = wrapper.findComponent(ChildComponent);\r\n  expect(child.props('userId')).toBe(1);\r\n  expect(child.text()).toContain('User 1');\r\n});</code></pre>",
      "level": "middle"
    },
    {
      "question": "So sánh jest.mock() vs jest.spyOn() vs Manual Mocks?",
      "answer": "<p><strong>1. jest.mock() - Auto Mock Modules:</strong></p><p>Tự động mock toàn bộ module, thay thế tất cả exports.</p><pre><code>// userService.js\r\nexport const getUser = () => fetch('/api/user');\r\nexport const saveUser = (data) => fetch('/api/user', { method: 'POST', body: data });\r\n\r\n// test.js\r\nimport { getUser, saveUser } from './userService';\r\n\r\njest.mock('./userService');\r\n\r\ntest('auto mock', () => {\r\n  // Tất cả functions đều được mock tự động\r\n  getUser.mockResolvedValue({ name: 'John' });\r\n  saveUser.mockResolvedValue({ success: true });\r\n  \r\n  // Test code...\r\n});</code></pre><p><strong>2. jest.spyOn() - Spy on Existing Methods:</strong></p><p>Spy trên method thực sự, vẫn giữ implementation gốc hoặc có thể override.</p><pre><code>import * as userService from './userService';\r\n\r\ntest('spy on method', () => {\r\n  const spy = jest.spyOn(userService, 'getUser');\r\n  \r\n  // Mặc định vẫn gọi implementation gốc\r\n  userService.getUser();\r\n  \r\n  expect(spy).toHaveBeenCalled();\r\n  \r\n  // Có thể override\r\n  spy.mockResolvedValue({ name: 'Jane' });\r\n  \r\n  spy.mockRestore(); // Restore về gốc\r\n});</code></pre><p><strong>3. Manual Mocks - Custom Mock Implementation:</strong></p><p>Tạo mock file riêng trong thư mục __mocks__, tự định nghĩa implementation.</p><pre><code>// __mocks__/axios.js\r\nconst mockAxios = {\r\n  get: jest.fn(() => Promise.resolve({ data: {} })),\r\n  post: jest.fn(() => Promise.resolve({ data: {} })),\r\n  defaults: {\r\n    headers: { common: {} }\r\n  }\r\n};\r\n\r\nexport default mockAxios;\r\n\r\n// test.js\r\nimport axios from 'axios';\r\n\r\njest.mock('axios'); // Tự động dùng __mocks__/axios.js\r\n\r\ntest('uses manual mock', () => {\r\n  axios.get.mockResolvedValue({ data: { name: 'John' } });\r\n  // Test code...\r\n});</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>jest.mock()</th><th>jest.spyOn()</th><th>Manual Mocks</th></tr><tr><td>Mock toàn bộ module</td><td>Mock specific method</td><td>Custom mock implementation</td></tr><tr><td>Auto-generated mocks</td><td>Wrap existing function</td><td>Developer-defined</td></tr><tr><td>Không gọi code gốc</td><td>Có thể gọi code gốc</td><td>Không gọi code gốc</td></tr><tr><td>Đơn giản, nhanh</td><td>Linh hoạt, có thể restore</td><td>Reusable, phức tạp hơn</td></tr><tr><td>Cho entire module</td><td>Cho specific function</td><td>Cho external dependencies</td></tr></table><p><strong>Khi nào dùng jest.mock():</strong></p><ul><li>Mock external libraries (axios, fetch)</li><li>Mock toàn bộ module nhanh chóng</li><li>Không cần implementation gốc</li></ul><pre><code>jest.mock('axios');\r\nimport axios from 'axios';\r\n\r\ntest('mock axios', async () => {\r\n  axios.get.mockResolvedValue({ data: { users: [] } });\r\n  \r\n  const result = await fetchUsers();\r\n  \r\n  expect(axios.get).toHaveBeenCalledWith('/api/users');\r\n  expect(result).toEqual({ users: [] });\r\n});</code></pre><p><strong>Khi nào dùng jest.spyOn():</strong></p><ul><li>Spy trên internal methods</li><li>Cần restore về original implementation</li><li>Muốn track calls nhưng vẫn chạy code gốc</li></ul><pre><code>import * as utils from './utils';\r\n\r\ntest('spy on internal function', () => {\r\n  const spy = jest.spyOn(utils, 'formatDate');\r\n  \r\n  const result = processUser({ date: '2024-01-01' });\r\n  \r\n  expect(spy).toHaveBeenCalledWith('2024-01-01');\r\n  \r\n  spy.mockRestore();\r\n});</code></pre><p><strong>Khi nào dùng Manual Mocks:</strong></p><ul><li>Mock phức tạp, dùng nhiều lần</li><li>Mock external dependencies (node_modules)</li><li>Cần consistent mock behavior across tests</li></ul><pre><code>// __mocks__/database.js\r\nclass MockDatabase {\r\n  constructor() {\r\n    this.data = [];\r\n  }\r\n  \r\n  query = jest.fn((sql) => {\r\n    return Promise.resolve(this.data);\r\n  });\r\n  \r\n  insert = jest.fn((record) => {\r\n    this.data.push(record);\r\n    return Promise.resolve(record);\r\n  });\r\n}\r\n\r\nexport default MockDatabase;</code></pre>",
      "level": "senior"
    },
    {
      "question": "So sánh beforeEach vs beforeAll và afterEach vs afterAll?",
      "answer": "<p><strong>beforeEach vs beforeAll:</strong></p><p><code>beforeEach</code> chạy trước MỖI test case, còn <code>beforeAll</code> chạy MỘT LẦN trước tất cả tests.</p><pre><code>describe('User tests', () => {\r\n  let user;\r\n  let db;\r\n  \r\n  // Chạy 1 LẦN trước tất cả tests\r\n  beforeAll(() => {\r\n    db = connectDatabase();\r\n    console.log('Database connected');\r\n  });\r\n  \r\n  // Chạy trước MỖI test\r\n  beforeEach(() => {\r\n    user = { name: 'John', age: 30 };\r\n    console.log('User created for test');\r\n  });\r\n  \r\n  test('user has name', () => {\r\n    expect(user.name).toBe('John');\r\n  });\r\n  \r\n  test('user has age', () => {\r\n    expect(user.age).toBe(30);\r\n  });\r\n});\r\n\r\n// Output:\r\n// Database connected (1 lần)\r\n// User created for test (trước test 1)\r\n// User created for test (trước test 2)</code></pre><p><strong>afterEach vs afterAll:</strong></p><p><code>afterEach</code> chạy sau MỖI test case, còn <code>afterAll</code> chạy MỘT LẦN sau tất cả tests.</p><pre><code>describe('Cleanup tests', () => {\r\n  let tempFile;\r\n  let connection;\r\n  \r\n  beforeAll(() => {\r\n    connection = createConnection();\r\n  });\r\n  \r\n  beforeEach(() => {\r\n    tempFile = createTempFile();\r\n  });\r\n  \r\n  // Cleanup sau MỖI test\r\n  afterEach(() => {\r\n    deleteTempFile(tempFile);\r\n    console.log('Temp file deleted');\r\n  });\r\n  \r\n  // Cleanup 1 LẦN sau tất cả tests\r\n  afterAll(() => {\r\n    connection.close();\r\n    console.log('Connection closed');\r\n  });\r\n  \r\n  test('creates file', () => {\r\n    expect(tempFile).toBeDefined();\r\n  });\r\n  \r\n  test('writes to file', () => {\r\n    writeToFile(tempFile, 'data');\r\n    expect(readFile(tempFile)).toBe('data');\r\n  });\r\n});</code></pre><p><strong>Execution Order:</strong></p><pre><code>describe('Execution order', () => {\r\n  beforeAll(() => console.log('1 - beforeAll'));\r\n  afterAll(() => console.log('6 - afterAll'));\r\n  \r\n  beforeEach(() => console.log('2 - beforeEach'));\r\n  afterEach(() => console.log('4 - afterEach'));\r\n  \r\n  test('first test', () => console.log('3 - test 1'));\r\n  \r\n  beforeEach(() => console.log('5 - beforeEach'));\r\n  afterEach(() => console.log('7 - afterEach'));\r\n  \r\n  test('second test', () => console.log('6 - test 2'));\r\n});\r\n\r\n// Output:\r\n// 1 - beforeAll\r\n// 2 - beforeEach\r\n// 3 - test 1\r\n// 4 - afterEach\r\n// 5 - beforeEach\r\n// 6 - test 2\r\n// 7 - afterEach\r\n// 8 - afterAll</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>beforeEach</th><th>beforeAll</th></tr><tr><td>Chạy trước MỖI test</td><td>Chạy 1 LẦN trước tất cả</td></tr><tr><td>Reset state mỗi test</td><td>Setup shared resources</td></tr><tr><td>Isolation giữa tests</td><td>Tối ưu performance</td></tr><tr><td>Dùng cho test data</td><td>Dùng cho DB connection</td></tr></table><table><tr><th>afterEach</th><th>afterAll</th></tr><tr><td>Chạy sau MỖI test</td><td>Chạy 1 LẦN sau tất cả</td></tr><tr><td>Cleanup mỗi test</td><td>Cleanup shared resources</td></tr><tr><td>Prevent test pollution</td><td>Final teardown</td></tr><tr><td>Dùng cho temp files</td><td>Dùng cho close connections</td></tr></table><p><strong>Khi nào dùng beforeEach/afterEach:</strong></p><pre><code>// Khi cần fresh state cho mỗi test\r\ndescribe('Shopping cart', () => {\r\n  let cart;\r\n  \r\n  beforeEach(() => {\r\n    cart = new ShoppingCart(); // Fresh cart mỗi test\r\n  });\r\n  \r\n  afterEach(() => {\r\n    cart.clear(); // Cleanup sau mỗi test\r\n  });\r\n  \r\n  test('adds item', () => {\r\n    cart.addItem({ id: 1 });\r\n    expect(cart.items.length).toBe(1);\r\n  });\r\n  \r\n  test('removes item', () => {\r\n    cart.addItem({ id: 1 });\r\n    cart.removeItem(1);\r\n    expect(cart.items.length).toBe(0);\r\n  });\r\n});</code></pre><p><strong>Khi nào dùng beforeAll/afterAll:</strong></p><pre><code>// Khi setup/teardown expensive (DB, server)\r\ndescribe('Database tests', () => {\r\n  let db;\r\n  \r\n  beforeAll(async () => {\r\n    db = await connectToDatabase(); // Expensive operation\r\n  });\r\n  \r\n  afterAll(async () => {\r\n    await db.disconnect(); // Cleanup connection\r\n  });\r\n  \r\n  test('queries users', async () => {\r\n    const users = await db.query('SELECT * FROM users');\r\n    expect(users).toBeDefined();\r\n  });\r\n  \r\n  test('inserts user', async () => {\r\n    await db.insert('users', { name: 'John' });\r\n    expect(await db.count('users')).toBeGreaterThan(0);\r\n  });\r\n});</code></pre>",
      "level": "middle"
    },
    {
      "question": "So sánh Snapshot Testing vs Traditional Assertions?",
      "answer": "<p><strong>Snapshot Testing:</strong></p><p>Lưu toàn bộ output của component/object vào file, so sánh với lần test sau.</p><pre><code>import renderer from 'react-test-renderer';\r\nimport Button from './Button';\r\n\r\ntest('button snapshot', () => {\r\n  const tree = renderer\r\n    .create(&lt;Button label=\"Click me\" variant=\"primary\" /&gt;)\r\n    .toJSON();\r\n  \r\n  expect(tree).toMatchSnapshot();\r\n});\r\n\r\n// Snapshot file được tạo:\r\n// exports[`button snapshot 1`] = `\r\n// &lt;button class=\"btn btn-primary\"&gt;\r\n//   Click me\r\n// &lt;/button&gt;\r\n// `;</code></pre><p><strong>Traditional Assertions:</strong></p><p>Assert từng property/behavior cụ thể.</p><pre><code>import { render, screen } from '@testing-library/react';\r\nimport Button from './Button';\r\n\r\ntest('button renders correctly', () => {\r\n  render(&lt;Button label=\"Click me\" variant=\"primary\" /&gt;);\r\n  \r\n  const button = screen.getByRole('button');\r\n  \r\n  expect(button).toHaveTextContent('Click me');\r\n  expect(button).toHaveClass('btn');\r\n  expect(button).toHaveClass('btn-primary');\r\n});</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>Snapshot Testing</th><th>Traditional Assertions</th></tr><tr><td>Test toàn bộ output</td><td>Test specific properties</td></tr><tr><td>Viết test nhanh</td><td>Viết test chậm hơn</td></tr><tr><td>Catch unintended changes</td><td>Test expected behavior</td></tr><tr><td>Khó review changes</td><td>Dễ hiểu assertions</td></tr><tr><td>Brittle (dễ break)</td><td>Focused, stable</td></tr><tr><td>Tốt cho UI components</td><td>Tốt cho logic/behavior</td></tr></table><p><strong>Ưu điểm Snapshot Testing:</strong></p><ul><li><strong>Nhanh chóng:</strong> Không cần viết nhiều assertions</li><li><strong>Comprehensive:</strong> Catch mọi thay đổi trong output</li><li><strong>Easy to start:</strong> Chỉ cần toMatchSnapshot()</li></ul><pre><code>// Test complex object structure\r\ntest('user profile data', () => {\r\n  const profile = {\r\n    user: { name: 'John', age: 30 },\r\n    settings: { theme: 'dark', lang: 'vi' },\r\n    permissions: ['read', 'write']\r\n  };\r\n  \r\n  expect(profile).toMatchSnapshot();\r\n});</code></pre><p><strong>Nhược điểm Snapshot Testing:</strong></p><ul><li><strong>False positives:</strong> Thay đổi nhỏ cũng làm test fail</li><li><strong>Lazy updates:</strong> Dễ update snapshot không review kỹ</li><li><strong>Hard to debug:</strong> Khó hiểu tại sao snapshot khác</li></ul><pre><code>// Thay đổi nhỏ làm snapshot fail\r\n// Old: &lt;button class=\"btn\"&gt;Click&lt;/button&gt;\r\n// New: &lt;button class=\"btn \"&gt;Click&lt;/button&gt; (thêm space)\r\n// Test fails!</code></pre><p><strong>Ưu điểm Traditional Assertions:</strong></p><ul><li><strong>Explicit:</strong> Rõ ràng test cái gì</li><li><strong>Stable:</strong> Chỉ fail khi behavior thực sự thay đổi</li><li><strong>Self-documenting:</strong> Assertions = documentation</li></ul><pre><code>test('cart calculates total correctly', () => {\r\n  const cart = new ShoppingCart();\r\n  \r\n  cart.addItem({ price: 100 });\r\n  cart.addItem({ price: 200 });\r\n  \r\n  // Rõ ràng test total price\r\n  expect(cart.getTotal()).toBe(300);\r\n});</code></pre><p><strong>Best Practice: Kết hợp cả hai:</strong></p><pre><code>describe('Button component', () => {\r\n  // Snapshot cho UI structure\r\n  test('renders correctly', () => {\r\n    const tree = renderer\r\n      .create(&lt;Button label=\"Click\" /&gt;)\r\n      .toJSON();\r\n    \r\n    expect(tree).toMatchSnapshot();\r\n  });\r\n  \r\n  // Traditional assertions cho behavior\r\n  test('calls onClick when clicked', () => {\r\n    const handleClick = jest.fn();\r\n    render(&lt;Button label=\"Click\" onClick={handleClick} /&gt;);\r\n    \r\n    fireEvent.click(screen.getByRole('button'));\r\n    \r\n    expect(handleClick).toHaveBeenCalledTimes(1);\r\n  });\r\n  \r\n  // Traditional assertions cho critical behavior\r\n  test('disables button when loading', () => {\r\n    render(&lt;Button label=\"Click\" loading /&gt;);\r\n    \r\n    expect(screen.getByRole('button')).toBeDisabled();\r\n  });\r\n});</code></pre><p><strong>Khi nào dùng Snapshot:</strong></p><ul><li>UI components (React, Vue components)</li><li>Complex object structures</li><li>Output ít thay đổi</li><li>Quick regression testing</li></ul><p><strong>Khi nào dùng Traditional Assertions:</strong></p><ul><li>Business logic</li><li>User interactions</li><li>Critical behaviors</li><li>API responses</li></ul>",
      "level": "senior"
    },
    {
      "question": "So sánh Unit Tests vs Integration Tests trong Jest?",
      "answer": "<p><strong>Unit Tests:</strong></p><p>Test các đơn vị code riêng lẻ (functions, classes, components) isolated, mock tất cả dependencies.</p><pre><code>// utils/calculator.js\r\nexport function add(a, b) {\r\n  return a + b;\r\n}\r\n\r\nexport function multiply(a, b) {\r\n  return a * b;\r\n}\r\n\r\n// calculator.test.js - UNIT TEST\r\nimport { add, multiply } from './calculator';\r\n\r\ndescribe('Calculator Utils', () => {\r\n  test('adds two numbers', () => {\r\n    expect(add(2, 3)).toBe(5);\r\n    expect(add(-1, 1)).toBe(0);\r\n  });\r\n  \r\n  test('multiplies two numbers', () => {\r\n    expect(multiply(3, 4)).toBe(12);\r\n    expect(multiply(0, 5)).toBe(0);\r\n  });\r\n});</code></pre><p><strong>Integration Tests:</strong></p><p>Test nhiều units làm việc cùng nhau, test tương tác giữa components/modules.</p><pre><code>// userService.js\r\nimport { fetchUser } from './api';\r\nimport { formatUserData } from './formatter';\r\n\r\nexport async function getUserProfile(userId) {\r\n  const user = await fetchUser(userId);\r\n  return formatUserData(user);\r\n}\r\n\r\n// userService.test.js - INTEGRATION TEST\r\nimport { getUserProfile } from './userService';\r\nimport * as api from './api';\r\n\r\n// Mock chỉ external dependency (API)\r\njest.mock('./api');\r\n\r\ntest('gets and formats user profile', async () => {\r\n  // Mock API response\r\n  api.fetchUser.mockResolvedValue({\r\n    id: 1,\r\n    first_name: 'John',\r\n    last_name: 'Doe'\r\n  });\r\n  \r\n  // Test cả getUserProfile và formatUserData integration\r\n  const profile = await getUserProfile(1);\r\n  \r\n  expect(profile).toEqual({\r\n    id: 1,\r\n    fullName: 'John Doe'\r\n  });\r\n  \r\n  expect(api.fetchUser).toHaveBeenCalledWith(1);\r\n});</code></pre><p><strong>Ví dụ với React Components:</strong></p><pre><code>// UNIT TEST - Test component isolated\r\nimport { render, screen } from '@testing-library/react';\r\nimport UserCard from './UserCard';\r\n\r\ntest('UserCard renders user info', () => {\r\n  const user = { name: 'John', email: 'john@example.com' };\r\n  \r\n  render(&lt;UserCard user={user} /&gt;);\r\n  \r\n  expect(screen.getByText('John')).toBeInTheDocument();\r\n  expect(screen.getByText('john@example.com')).toBeInTheDocument();\r\n});\r\n\r\n// INTEGRATION TEST - Test component với children và state\r\nimport { render, screen, fireEvent } from '@testing-library/react';\r\nimport UserProfile from './UserProfile';\r\n\r\ntest('UserProfile loads and displays user data', async () => {\r\n  // Mock API\r\n  global.fetch = jest.fn(() =>\r\n    Promise.resolve({\r\n      json: () => Promise.resolve({ name: 'John', posts: 5 })\r\n    })\r\n  );\r\n  \r\n  render(&lt;UserProfile userId={1} /&gt;);\r\n  \r\n  // Test loading state\r\n  expect(screen.getByText('Loading...')).toBeInTheDocument();\r\n  \r\n  // Test data loads và renders\r\n  await waitFor(() => {\r\n    expect(screen.getByText('John')).toBeInTheDocument();\r\n    expect(screen.getByText('5 posts')).toBeInTheDocument();\r\n  });\r\n  \r\n  // Test user interaction\r\n  fireEvent.click(screen.getByText('Show Details'));\r\n  \r\n  expect(screen.getByTestId('user-details')).toBeVisible();\r\n});</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>Unit Tests</th><th>Integration Tests</th></tr><tr><td>Test 1 đơn vị isolated</td><td>Test nhiều units cùng nhau</td></tr><tr><td>Mock tất cả dependencies</td><td>Mock chỉ external dependencies</td></tr><tr><td>Nhanh, đơn giản</td><td>Chậm hơn, phức tạp hơn</td></tr><tr><td>Easy to debug</td><td>Harder to debug</td></tr><tr><td>Test implementation</td><td>Test behavior</td></tr><tr><td>Nhiều tests</td><td>Ít tests hơn</td></tr></table><p><strong>Test Pyramid Strategy:</strong></p><pre><code>        /\\    E2E Tests (ít nhất, chậm nhất)\r\n       /  \\   \r\n      /    \\  Integration Tests (vừa phải)\r\n     /      \\ \r\n    /________\\ Unit Tests (nhiều nhất, nhanh nhất)</code></pre><p><strong>Unit Test Example - Mock everything:</strong></p><pre><code>// orderService.js\r\nimport { getUser } from './userService';\r\nimport { calculateTotal } from './priceCalculator';\r\nimport { sendEmail } from './emailService';\r\n\r\nexport async function createOrder(userId, items) {\r\n  const user = await getUser(userId);\r\n  const total = calculateTotal(items);\r\n  await sendEmail(user.email, `Order total: ${total}`);\r\n  \r\n  return { userId, items, total };\r\n}\r\n\r\n// orderService.test.js - UNIT TEST\r\njest.mock('./userService');\r\njest.mock('./priceCalculator');\r\njest.mock('./emailService');\r\n\r\nimport { createOrder } from './orderService';\r\nimport { getUser } from './userService';\r\nimport { calculateTotal } from './priceCalculator';\r\nimport { sendEmail } from './emailService';\r\n\r\ntest('creates order', async () => {\r\n  // Mock tất cả dependencies\r\n  getUser.mockResolvedValue({ email: 'user@example.com' });\r\n  calculateTotal.mockReturnValue(100);\r\n  sendEmail.mockResolvedValue(true);\r\n  \r\n  const order = await createOrder(1, [{ id: 1, price: 100 }]);\r\n  \r\n  expect(order).toEqual({\r\n    userId: 1,\r\n    items: [{ id: 1, price: 100 }],\r\n    total: 100\r\n  });\r\n  \r\n  expect(getUser).toHaveBeenCalledWith(1);\r\n  expect(calculateTotal).toHaveBeenCalled();\r\n  expect(sendEmail).toHaveBeenCalled();\r\n});</code></pre><p><strong>Integration Test Example - Mock chỉ external APIs:</strong></p><pre><code>// orderService.integration.test.js - INTEGRATION TEST\r\njest.mock('./emailService'); // Chỉ mock external service\r\n\r\nimport { createOrder } from './orderService';\r\nimport { sendEmail } from './emailService';\r\n\r\ntest('creates order with real calculation', async () => {\r\n  // Mock chỉ email service (external dependency)\r\n  sendEmail.mockResolvedValue(true);\r\n  \r\n  // getUser và calculateTotal chạy thật\r\n  const order = await createOrder(1, [\r\n    { id: 1, price: 50 },\r\n    { id: 2, price: 30 }\r\n  ]);\r\n  \r\n  // Test tích hợp thực sự\r\n  expect(order.total).toBe(80); // Real calculation\r\n  expect(sendEmail).toHaveBeenCalledWith(\r\n    expect.any(String),\r\n    'Order total: 80'\r\n  );\r\n});</code></pre><p><strong>Best Practices:</strong></p><ul><li>70% Unit tests - test logic, pure functions</li><li>20% Integration tests - test workflows, features</li><li>10% E2E tests - test critical user journeys</li></ul>",
      "level": "senior"
    },
    {
      "question": "So sánh synchronous vs asynchronous testing trong Jest?",
      "answer": "<p><strong>Synchronous Tests:</strong></p><p>Test code chạy đồng bộ, không có async operations, return ngay lập tức.</p><pre><code>// Synchronous function\r\nfunction add(a, b) {\r\n  return a + b;\r\n}\r\n\r\nfunction multiply(a, b) {\r\n  return a * b;\r\n}\r\n\r\n// Synchronous tests\r\ntest('adds numbers synchronously', () => {\r\n  const result = add(2, 3);\r\n  expect(result).toBe(5);\r\n});\r\n\r\ntest('multiplies numbers', () => {\r\n  expect(multiply(4, 5)).toBe(20);\r\n});</code></pre><p><strong>Asynchronous Tests - Callbacks:</strong></p><p>Dùng callback <code>done</code> để Jest biết khi nào test xong.</p><pre><code>function fetchData(callback) {\r\n  setTimeout(() => {\r\n    callback({ name: 'John' });\r\n  }, 100);\r\n}\r\n\r\ntest('fetches data with callback', (done) => {\r\n  fetchData((data) => {\r\n    try {\r\n      expect(data.name).toBe('John');\r\n      done(); // PHẢI gọi done()\r\n    } catch (error) {\r\n      done(error);\r\n    }\r\n  });\r\n});</code></pre><p><strong>Asynchronous Tests - Promises:</strong></p><p>Return promise hoặc dùng resolves/rejects.</p><pre><code>function fetchUser() {\r\n  return Promise.resolve({ name: 'John', age: 30 });\r\n}\r\n\r\n// Cách 1: Return promise\r\ntest('fetches user with promise', () => {\r\n  return fetchUser().then(user => {\r\n    expect(user.name).toBe('John');\r\n  });\r\n});\r\n\r\n// Cách 2: resolves/rejects\r\ntest('resolves to user', () => {\r\n  return expect(fetchUser()).resolves.toEqual({\r\n    name: 'John',\r\n    age: 30\r\n  });\r\n});\r\n\r\ntest('rejects with error', () => {\r\n  return expect(fetchInvalidUser()).rejects.toThrow('Not found');\r\n});</code></pre><p><strong>Asynchronous Tests - Async/Await (Recommended):</strong></p><p>Cách hiện đại, dễ đọc nhất.</p><pre><code>test('fetches user with async/await', async () => {\r\n  const user = await fetchUser();\r\n  \r\n  expect(user.name).toBe('John');\r\n  expect(user.age).toBe(30);\r\n});\r\n\r\ntest('handles errors with async/await', async () => {\r\n  await expect(fetchInvalidUser()).rejects.toThrow('Not found');\r\n});\r\n\r\n// Hoặc try/catch\r\ntest('catches errors', async () => {\r\n  try {\r\n    await fetchInvalidUser();\r\n  } catch (error) {\r\n    expect(error.message).toBe('Not found');\r\n  }\r\n});</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>Synchronous</th><th>Asynchronous</th></tr><tr><td>Không có waiting</td><td>Phải wait cho async operations</td></tr><tr><td>Return ngay</td><td>Return Promise hoặc use done()</td></tr><tr><td>Đơn giản, nhanh</td><td>Phức tạp hơn, chậm hơn</td></tr><tr><td>Dùng cho pure functions</td><td>Dùng cho API calls, timers</td></tr><tr><td>Không cần special syntax</td><td>Cần async/await hoặc done()</td></tr></table><p><strong>Common Mistakes với Async Tests:</strong></p><pre><code>// ❌ SAI - Quên return promise\r\ntest('wrong async test', () => {\r\n  fetchUser().then(user => {\r\n    expect(user.name).toBe('John'); // Test passes trước khi assertion chạy!\r\n  });\r\n});\r\n\r\n// ✅ ĐÚNG - Return promise\r\ntest('correct async test', () => {\r\n  return fetchUser().then(user => {\r\n    expect(user.name).toBe('John');\r\n  });\r\n});\r\n\r\n// ❌ SAI - Quên await\r\ntest('wrong async/await', async () => {\r\n  const user = fetchUser(); // Quên await!\r\n  expect(user.name).toBe('John'); // user là Promise, không phải object\r\n});\r\n\r\n// ✅ ĐÚNG - Có await\r\ntest('correct async/await', async () => {\r\n  const user = await fetchUser();\r\n  expect(user.name).toBe('John');\r\n});</code></pre><p><strong>Testing Multiple Async Operations:</strong></p><pre><code>// Synchronous - sequential\r\ntest('multiple sync operations', () => {\r\n  const result1 = add(1, 2);\r\n  const result2 = multiply(result1, 3);\r\n  \r\n  expect(result2).toBe(9);\r\n});\r\n\r\n// Asynchronous - sequential\r\ntest('multiple async operations', async () => {\r\n  const user = await fetchUser(1);\r\n  const posts = await fetchUserPosts(user.id);\r\n  const comments = await fetchPostComments(posts[0].id);\r\n  \r\n  expect(comments.length).toBeGreaterThan(0);\r\n});\r\n\r\n// Asynchronous - parallel\r\ntest('parallel async operations', async () => {\r\n  const [user, posts, settings] = await Promise.all([\r\n    fetchUser(1),\r\n    fetchPosts(),\r\n    fetchSettings()\r\n  ]);\r\n  \r\n  expect(user).toBeDefined();\r\n  expect(posts.length).toBeGreaterThan(0);\r\n  expect(settings.theme).toBe('dark');\r\n});</code></pre><p><strong>Timeouts:</strong></p><pre><code>// Default timeout 5 seconds\r\ntest('slow async operation', async () => {\r\n  const data = await slowFetch();\r\n  expect(data).toBeDefined();\r\n}, 10000); // 10 seconds timeout\r\n\r\n// Global timeout\r\njest.setTimeout(30000);</code></pre>",
      "level": "middle"
    },
    {
      "question": "So sánh jest.fn() vs jest.spyOn() khi mock methods của một class?",
      "answer": "<p><strong>Context:</strong></p><p>Khi test class methods, có 2 cách chính: tạo mock function mới (jest.fn) hoặc spy on existing method (jest.spyOn).</p><p><strong>Sử dụng jest.fn() - Replace method:</strong></p><pre><code>class UserService {\r\n  constructor() {\r\n    this.users = [];\r\n  }\r\n  \r\n  getUser(id) {\r\n    return this.users.find(u => u.id === id);\r\n  }\r\n  \r\n  saveUser(user) {\r\n    this.users.push(user);\r\n    return user;\r\n  }\r\n}\r\n\r\n// Mock bằng jest.fn()\r\ntest('mock with jest.fn', () => {\r\n  const service = new UserService();\r\n  \r\n  // Replace method bằng mock function\r\n  service.getUser = jest.fn().mockReturnValue({ id: 1, name: 'John' });\r\n  \r\n  const user = service.getUser(1);\r\n  \r\n  expect(user.name).toBe('John');\r\n  expect(service.getUser).toHaveBeenCalledWith(1);\r\n  \r\n  // Không thể restore về original implementation\r\n});</code></pre><p><strong>Sử dụng jest.spyOn() - Spy on method:</strong></p><pre><code>test('spy with jest.spyOn', () => {\r\n  const service = new UserService();\r\n  \r\n  // Spy on existing method\r\n  const spy = jest.spyOn(service, 'getUser');\r\n  \r\n  // Mặc định vẫn gọi implementation gốc\r\n  service.users = [{ id: 1, name: 'John' }];\r\n  const user = service.getUser(1);\r\n  \r\n  expect(user.name).toBe('John'); // Real implementation\r\n  expect(spy).toHaveBeenCalledWith(1); // Nhưng được track\r\n  \r\n  // Có thể override implementation\r\n  spy.mockReturnValue({ id: 2, name: 'Jane' });\r\n  expect(service.getUser(1).name).toBe('Jane');\r\n  \r\n  // Restore về original\r\n  spy.mockRestore();\r\n  expect(service.getUser(1).name).toBe('John'); // Lại chạy real code\r\n});</code></pre><p><strong>Bảng so sánh cho Class Methods:</strong></p><table><tr><th>jest.fn()</th><th>jest.spyOn()</th></tr><tr><td>Tạo mock function mới</td><td>Wrap existing method</td></tr><tr><td>Cần reassign: obj.method = jest.fn()</td><td>Không cần reassign</td></tr><tr><td>Mất original implementation</td><td>Giữ nguyên implementation</td></tr><tr><td>Không restore được</td><td>Có thể mockRestore()</td></tr><tr><td>Đơn giản hơn</td><td>Linh hoạt hơn</td></tr></table><p><strong>Use Case 1: Mock để avoid side effects:</strong></p><pre><code>class PaymentService {\r\n  processPayment(amount) {\r\n    // Gọi external payment gateway\r\n    return externalAPI.charge(amount);\r\n  }\r\n}\r\n\r\ntest('process payment without calling API', () => {\r\n  const service = new PaymentService();\r\n  \r\n  // Mock để không gọi API thật\r\n  service.processPayment = jest.fn().mockResolvedValue({\r\n    success: true,\r\n    transactionId: '123'\r\n  });\r\n  \r\n  const result = await service.processPayment(100);\r\n  \r\n  expect(result.success).toBe(true);\r\n  expect(service.processPayment).toHaveBeenCalledWith(100);\r\n});</code></pre><p><strong>Use Case 2: Spy để track calls nhưng vẫn chạy logic:</strong></p><pre><code>class Logger {\r\n  log(message) {\r\n    console.log(`[LOG] ${message}`);\r\n  }\r\n}\r\n\r\ntest('tracks log calls', () => {\r\n  const logger = new Logger();\r\n  const spy = jest.spyOn(logger, 'log');\r\n  \r\n  // Vẫn chạy console.log thật\r\n  logger.log('Test message');\r\n  \r\n  expect(spy).toHaveBeenCalledWith('Test message');\r\n  \r\n  spy.mockRestore();\r\n});</code></pre><p><strong>Mock Static Methods:</strong></p><pre><code>class MathUtils {\r\n  static add(a, b) {\r\n    return a + b;\r\n  }\r\n}\r\n\r\n// Với jest.fn()\r\ntest('mock static method', () => {\r\n  MathUtils.add = jest.fn().mockReturnValue(10);\r\n  \r\n  expect(MathUtils.add(2, 3)).toBe(10);\r\n});\r\n\r\n// Với jest.spyOn()\r\ntest('spy on static method', () => {\r\n  const spy = jest.spyOn(MathUtils, 'add');\r\n  \r\n  expect(MathUtils.add(2, 3)).toBe(5); // Real implementation\r\n  expect(spy).toHaveBeenCalled();\r\n  \r\n  spy.mockReturnValue(10);\r\n  expect(MathUtils.add(2, 3)).toBe(10);\r\n  \r\n  spy.mockRestore();\r\n});</code></pre><p><strong>Best Practice:</strong></p><ul><li>Dùng <code>jest.spyOn()</code> khi muốn preserve original behavior hoặc restore sau</li><li>Dùng <code>jest.fn()</code> khi muốn completely replace implementation</li><li>Luôn <code>mockRestore()</code> trong afterEach nếu dùng spyOn</li></ul><pre><code>describe('UserService', () => {\r\n  let service;\r\n  let getUserSpy;\r\n  \r\n  beforeEach(() => {\r\n    service = new UserService();\r\n    getUserSpy = jest.spyOn(service, 'getUser');\r\n  });\r\n  \r\n  afterEach(() => {\r\n    getUserSpy.mockRestore(); // Cleanup\r\n  });\r\n  \r\n  test('tracks calls', () => {\r\n    service.getUser(1);\r\n    expect(getUserSpy).toHaveBeenCalledWith(1);\r\n  });\r\n});</code></pre>",
      "level": "senior"
    },
    {
      "question": "So sánh mockReturnValue vs mockResolvedValue vs mockRejectedValue?",
      "answer": "<p><strong>Sự khác biệt chính:</strong></p><p>3 methods này dùng để set return value cho mock functions, nhưng khác nhau về synchronous/asynchronous behavior.</p><p><strong>mockReturnValue - Synchronous Return:</strong></p><p>Return giá trị đồng bộ ngay lập tức, không phải Promise.</p><pre><code>const mockFn = jest.fn();\r\n\r\n// Return giá trị synchronous\r\nmockFn.mockReturnValue(42);\r\n\r\nconst result = mockFn();\r\nconsole.log(result); // 42 (không phải Promise)\r\n\r\nexpect(mockFn()).toBe(42);\r\nexpect(result).toBe(42);</code></pre><pre><code>// Ví dụ thực tế - Mock calculator\r\nfunction calculate(a, b, operation) {\r\n  return operation(a, b);\r\n}\r\n\r\ntest('mock sync operation', () => {\r\n  const mockAdd = jest.fn();\r\n  mockAdd.mockReturnValue(10);\r\n  \r\n  const result = calculate(5, 5, mockAdd);\r\n  \r\n  expect(result).toBe(10);\r\n  expect(mockAdd).toHaveBeenCalledWith(5, 5);\r\n});</code></pre><p><strong>mockResolvedValue - Promise Success:</strong></p><p>Return Promise resolved với giá trị, dùng cho async functions thành công.</p><pre><code>const mockFn = jest.fn();\r\n\r\n// Return Promise resolved\r\nmockFn.mockResolvedValue({ name: 'John' });\r\n\r\nconst result = await mockFn();\r\nconsole.log(result); // { name: 'John' }\r\n\r\n// Tương đương với:\r\nmockFn.mockReturnValue(Promise.resolve({ name: 'John' }));</code></pre><pre><code>// Ví dụ thực tế - Mock API call\r\nimport axios from 'axios';\r\n\r\njest.mock('axios');\r\n\r\ntest('fetches user data successfully', async () => {\r\n  // Mock API response\r\n  axios.get.mockResolvedValue({\r\n    data: { id: 1, name: 'John', email: 'john@example.com' }\r\n  });\r\n  \r\n  const user = await fetchUser(1);\r\n  \r\n  expect(user.name).toBe('John');\r\n  expect(axios.get).toHaveBeenCalledWith('/api/users/1');\r\n});</code></pre><p><strong>mockRejectedValue - Promise Failure:</strong></p><p>Return Promise rejected với error, dùng cho async functions thất bại.</p><pre><code>const mockFn = jest.fn();\r\n\r\n// Return Promise rejected\r\nmockFn.mockRejectedValue(new Error('Network error'));\r\n\r\ntry {\r\n  await mockFn();\r\n} catch (error) {\r\n  console.log(error.message); // 'Network error'\r\n}\r\n\r\n// Tương đương với:\r\nmockFn.mockReturnValue(Promise.reject(new Error('Network error')));</code></pre><pre><code>// Ví dụ thực tế - Mock API error\r\ntest('handles API error', async () => {\r\n  // Mock API error\r\n  axios.get.mockRejectedValue(new Error('User not found'));\r\n  \r\n  await expect(fetchUser(999)).rejects.toThrow('User not found');\r\n  \r\n  // Hoặc với try/catch\r\n  try {\r\n    await fetchUser(999);\r\n  } catch (error) {\r\n    expect(error.message).toBe('User not found');\r\n  }\r\n});</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>mockReturnValue</th><th>mockResolvedValue</th><th>mockRejectedValue</th></tr><tr><td>Return đồng bộ</td><td>Return Promise resolved</td><td>Return Promise rejected</td></tr><tr><td>Không phải Promise</td><td>Promise.resolve(value)</td><td>Promise.reject(error)</td></tr><tr><td>Không cần await</td><td>Cần await</td><td>Cần await/catch</td></tr><tr><td>Cho sync functions</td><td>Cho async success</td><td>Cho async errors</td></tr></table><p><strong>Multiple Return Values:</strong></p><pre><code>// mockReturnValue - nhiều lần gọi\r\nconst mockFn = jest.fn();\r\n\r\nmockFn\r\n  .mockReturnValueOnce(1)\r\n  .mockReturnValueOnce(2)\r\n  .mockReturnValue(3);\r\n\r\nexpect(mockFn()).toBe(1);\r\nexpect(mockFn()).toBe(2);\r\nexpect(mockFn()).toBe(3);\r\nexpect(mockFn()).toBe(3); // Default\r\n\r\n// mockResolvedValue - nhiều lần gọi\r\nconst asyncMock = jest.fn();\r\n\r\nasyncMock\r\n  .mockResolvedValueOnce({ status: 'pending' })\r\n  .mockResolvedValueOnce({ status: 'processing' })\r\n  .mockResolvedValue({ status: 'completed' });\r\n\r\nexpect(await asyncMock()).toEqual({ status: 'pending' });\r\nexpect(await asyncMock()).toEqual({ status: 'processing' });\r\nexpect(await asyncMock()).toEqual({ status: 'completed' });\r\n\r\n// mockRejectedValue - mixed success/error\r\nconst apiMock = jest.fn();\r\n\r\napiMock\r\n  .mockResolvedValueOnce({ data: 'success' })\r\n  .mockRejectedValueOnce(new Error('Server error'))\r\n  .mockResolvedValue({ data: 'recovered' });\r\n\r\nexpect(await apiMock()).toEqual({ data: 'success' });\r\nawait expect(apiMock()).rejects.toThrow('Server error');\r\nexpect(await apiMock()).toEqual({ data: 'recovered' });</code></pre><p><strong>Ví dụ thực tế - Test retry logic:</strong></p><pre><code>async function fetchWithRetry(url, maxRetries = 3) {\r\n  for (let i = 0; i < maxRetries; i++) {\r\n    try {\r\n      return await fetch(url);\r\n    } catch (error) {\r\n      if (i === maxRetries - 1) throw error;\r\n    }\r\n  }\r\n}\r\n\r\ntest('retries on failure then succeeds', async () => {\r\n  global.fetch = jest.fn();\r\n  \r\n  // Fail 2 lần, thành công lần 3\r\n  fetch\r\n    .mockRejectedValueOnce(new Error('Timeout'))\r\n    .mockRejectedValueOnce(new Error('Timeout'))\r\n    .mockResolvedValue({ data: 'success' });\r\n  \r\n  const result = await fetchWithRetry('/api/data');\r\n  \r\n  expect(result).toEqual({ data: 'success' });\r\n  expect(fetch).toHaveBeenCalledTimes(3);\r\n});\r\n\r\ntest('throws after max retries', async () => {\r\n  global.fetch = jest.fn();\r\n  \r\n  // Fail tất cả các lần\r\n  fetch.mockRejectedValue(new Error('Network error'));\r\n  \r\n  await expect(fetchWithRetry('/api/data', 3))\r\n    .rejects.toThrow('Network error');\r\n  \r\n  expect(fetch).toHaveBeenCalledTimes(3);\r\n});</code></pre><p><strong>Common Mistake:</strong></p><pre><code>// ❌ SAI - Dùng mockReturnValue cho async function\r\nconst mockAsync = jest.fn();\r\nmockAsync.mockReturnValue({ data: 'value' }); // Không phải Promise!\r\n\r\nconst result = await mockAsync(); // TypeError!\r\n\r\n// ✅ ĐÚNG - Dùng mockResolvedValue\r\nmockAsync.mockResolvedValue({ data: 'value' });\r\nconst result = await mockAsync(); // { data: 'value' }</code></pre>",
      "level": "middle"
    },
    {
      "question": "So sánh toHaveBeenCalled vs toHaveBeenCalledWith vs toHaveBeenCalledTimes?",
      "answer": "<p><strong>Sự khác biệt:</strong></p><p>3 matchers này dùng để assert mock function calls, nhưng kiểm tra các aspects khác nhau.</p><p><strong>toHaveBeenCalled - Chỉ kiểm tra đã gọi chưa:</strong></p><p>Kiểm tra function có được gọi ít nhất 1 lần hay không, không quan tâm arguments hoặc số lần.</p><pre><code>const mockFn = jest.fn();\r\n\r\nmockFn('hello');\r\nmockFn('world');\r\n\r\nexpect(mockFn).toHaveBeenCalled(); // ✅ PASS\r\n\r\n// Tương đương với:\r\nexpect(mockFn.mock.calls.length).toBeGreaterThan(0);</code></pre><pre><code>// Ví dụ thực tế\r\ntest('callback is called on button click', () => {\r\n  const handleClick = jest.fn();\r\n  render(&lt;Button onClick={handleClick} /&gt;);\r\n  \r\n  fireEvent.click(screen.getByRole('button'));\r\n  \r\n  // Chỉ cần biết callback được gọi\r\n  expect(handleClick).toHaveBeenCalled();\r\n});</code></pre><p><strong>toHaveBeenCalledWith - Kiểm tra arguments:</strong></p><p>Kiểm tra function có được gọi với arguments cụ thể hay không (ít nhất 1 lần).</p><pre><code>const mockFn = jest.fn();\r\n\r\nmockFn('hello', 'world');\r\nmockFn('foo', 'bar');\r\n\r\nexpect(mockFn).toHaveBeenCalledWith('hello', 'world'); // ✅ PASS\r\nexpect(mockFn).toHaveBeenCalledWith('foo', 'bar'); // ✅ PASS\r\nexpect(mockFn).toHaveBeenCalledWith('not', 'called'); // ❌ FAIL</code></pre><pre><code>// Ví dụ thực tế - Test API call\r\ntest('fetches user with correct ID', async () => {\r\n  const mockFetch = jest.spyOn(global, 'fetch');\r\n  mockFetch.mockResolvedValue({\r\n    json: () => Promise.resolve({ name: 'John' })\r\n  });\r\n  \r\n  await fetchUser(123);\r\n  \r\n  // Kiểm tra fetch được gọi với URL đúng\r\n  expect(mockFetch).toHaveBeenCalledWith('/api/users/123');\r\n});</code></pre><p><strong>toHaveBeenCalledTimes - Kiểm tra số lần:</strong></p><p>Kiểm tra function được gọi chính xác bao nhiêu lần.</p><pre><code>const mockFn = jest.fn();\r\n\r\nmockFn('first');\r\nmockFn('second');\r\nmockFn('third');\r\n\r\nexpect(mockFn).toHaveBeenCalledTimes(3); // ✅ PASS\r\nexpect(mockFn).toHaveBeenCalledTimes(2); // ❌ FAIL</code></pre><pre><code>// Ví dụ thực tế - Test retry mechanism\r\ntest('retries exactly 3 times on failure', async () => {\r\n  const mockApi = jest.fn();\r\n  mockApi.mockRejectedValue(new Error('Failed'));\r\n  \r\n  try {\r\n    await fetchWithRetry(mockApi, { maxRetries: 3 });\r\n  } catch (error) {\r\n    // Expected to fail\r\n  }\r\n  \r\n  // Kiểm tra đã retry đúng số lần\r\n  expect(mockApi).toHaveBeenCalledTimes(3);\r\n});</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>toHaveBeenCalled</th><th>toHaveBeenCalledWith</th><th>toHaveBeenCalledTimes</th></tr><tr><td>Gọi ít nhất 1 lần?</td><td>Gọi với args cụ thể?</td><td>Gọi đúng N lần?</td></tr><tr><td>Không check arguments</td><td>Check arguments</td><td>Không check arguments</td></tr><tr><td>Không check số lần</td><td>Không check số lần</td><td>Check exact count</td></tr><tr><td>Least specific</td><td>Most specific args</td><td>Most specific count</td></tr></table><p><strong>Kết hợp các matchers:</strong></p><pre><code>const mockFn = jest.fn();\r\n\r\nmockFn('user', 1);\r\nmockFn('user', 2);\r\nmockFn('product', 3);\r\n\r\n// Tất cả đều PASS\r\nexpect(mockFn).toHaveBeenCalled();\r\nexpect(mockFn).toHaveBeenCalledWith('user', 1);\r\nexpect(mockFn).toHaveBeenCalledWith('product', 3);\r\nexpect(mockFn).toHaveBeenCalledTimes(3);</code></pre><p><strong>Advanced Matchers:</strong></p><pre><code>const mockFn = jest.fn();\r\n\r\nmockFn('hello', 'world');\r\nmockFn('foo', 'bar');\r\n\r\n// toHaveBeenLastCalledWith - check lần gọi cuối\r\nexpect(mockFn).toHaveBeenLastCalledWith('foo', 'bar');\r\n\r\n// toHaveBeenNthCalledWith - check lần thứ N\r\nexpect(mockFn).toHaveBeenNthCalledWith(1, 'hello', 'world');\r\nexpect(mockFn).toHaveBeenNthCalledWith(2, 'foo', 'bar');</code></pre><p><strong>Ví dụ thực tế phức tạp:</strong></p><pre><code>// Thành phần logger với multiple calls\r\nclass Logger {\r\n  constructor(transport) {\r\n    this.transport = transport;\r\n  }\r\n  \r\n  log(level, message) {\r\n    this.transport.send(level, message, new Date());\r\n  }\r\n}\r\n\r\ntest('logger sends correct messages', () => {\r\n  const mockTransport = {\r\n    send: jest.fn()\r\n  };\r\n  \r\n  const logger = new Logger(mockTransport);\r\n  \r\n  logger.log('info', 'User logged in');\r\n  logger.log('error', 'Database connection failed');\r\n  logger.log('info', 'User logged out');\r\n  \r\n  // Kiểm tra đã gọi\r\n  expect(mockTransport.send).toHaveBeenCalled();\r\n  \r\n  // Kiểm tra số lần gọi\r\n  expect(mockTransport.send).toHaveBeenCalledTimes(3);\r\n  \r\n  // Kiểm tra gọi với arguments cụ thể\r\n  expect(mockTransport.send).toHaveBeenCalledWith(\r\n    'error',\r\n    'Database connection failed',\r\n    expect.any(Date)\r\n  );\r\n  \r\n  // Kiểm tra lần gọi đầu tiên\r\n  expect(mockTransport.send).toHaveBeenNthCalledWith(\r\n    1,\r\n    'info',\r\n    'User logged in',\r\n    expect.any(Date)\r\n  );\r\n  \r\n  // Kiểm tra lần gọi cuối\r\n  expect(mockTransport.send).toHaveBeenLastCalledWith(\r\n    'info',\r\n    'User logged out',\r\n    expect.any(Date)\r\n  );\r\n});</code></pre><p><strong>Khi nào dùng matcher nào:</strong></p><ul><li><strong>toHaveBeenCalled:</strong> Khi chỉ cần biết function có chạy không (event handlers, callbacks)</li><li><strong>toHaveBeenCalledWith:</strong> Khi cần verify arguments (API calls, function params)</li><li><strong>toHaveBeenCalledTimes:</strong> Khi cần verify số lần (retry logic, loops, optimization)</li></ul>",
      "level": "middle"
    },
    {
      "question": "So sánh waitFor vs findBy vs waitForElementToBeRemoved trong React Testing Library?",
      "answer": "<p><strong>Context:</strong></p><p>Cả 3 đều dùng để handle async operations trong tests, nhưng use cases khác nhau.</p><p><strong>waitFor - Generic async utility:</strong></p><p>Chờ đợi cho đến khi callback không throw error, dùng cho bất kỳ async assertion nào.</p><pre><code>import { render, screen, waitFor } from '@testing-library/react';\r\n\r\ntest('data loads and displays', async () => {\r\n  render(&lt;UserProfile userId={1} /&gt;);\r\n  \r\n  // Wait cho đến khi assertion pass\r\n  await waitFor(() => {\r\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\r\n  });\r\n  \r\n  // Hoặc wait cho state change\r\n  await waitFor(() => {\r\n    expect(screen.queryByText('Loading...')).not.toBeInTheDocument();\r\n  });\r\n});</code></pre><pre><code>// waitFor với options\r\nawait waitFor(\r\n  () => {\r\n    expect(screen.getByRole('alert')).toHaveTextContent('Success');\r\n  },\r\n  {\r\n    timeout: 3000, // Max wait time\r\n    interval: 100  // Check interval\r\n  }\r\n);</code></pre><p><strong>findBy - Query + waitFor combined:</strong></p><p>Kết hợp query và wait, return element khi tìm thấy. Shorthand cho getBy + waitFor.</p><pre><code>test('element appears after loading', async () => {\r\n  render(&lt;AsyncComponent /&gt;);\r\n  \r\n  // findBy tự động wait và return element\r\n  const element = await screen.findByText('Loaded Data');\r\n  \r\n  expect(element).toBeInTheDocument();\r\n});\r\n\r\n// Tương đương với:\r\nawait waitFor(() => {\r\n  expect(screen.getByText('Loaded Data')).toBeInTheDocument();\r\n});\r\nconst element = screen.getByText('Loaded Data');</code></pre><pre><code>// findBy variants\r\nawait screen.findByRole('button', { name: 'Submit' });\r\nawait screen.findByLabelText('Email');\r\nawait screen.findByTestId('user-card');\r\n\r\n// findAllBy for multiple elements\r\nconst items = await screen.findAllByRole('listitem');\r\nexpect(items).toHaveLength(5);</code></pre><p><strong>waitForElementToBeRemoved - Wait for removal:</strong></p><p>Chờ element biến mất khỏi DOM, dùng cho loading states, modals, notifications.</p><pre><code>test('loading spinner disappears', async () => {\r\n  render(&lt;DataFetcher /&gt;);\r\n  \r\n  const spinner = screen.getByTestId('loading-spinner');\r\n  \r\n  // Wait cho spinner biến mất\r\n  await waitForElementToBeRemoved(spinner);\r\n  \r\n  // Sau khi spinner mất, data đã load\r\n  expect(screen.getByText('Data loaded')).toBeInTheDocument();\r\n});</code></pre><pre><code>// Hoặc dùng với query function\r\nawait waitForElementToBeRemoved(() =>\r\n  screen.queryByText('Loading...')\r\n);</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>waitFor</th><th>findBy</th><th>waitForElementToBeRemoved</th></tr><tr><td>Generic async wait</td><td>Query + wait shorthand</td><td>Wait for removal</td></tr><tr><td>Dùng callback</td><td>Return element</td><td>Wait element disappear</td></tr><tr><td>Flexible, any assertion</td><td>Chỉ cho queries</td><td>Chỉ cho removal</td></tr><tr><td>Manual assertion</td><td>Auto assertion</td><td>Auto assertion</td></tr></table><p><strong>Ví dụ thực tế - Loading flow:</strong></p><pre><code>function UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  \r\n  useEffect(() => {\r\n    fetchUser(userId)\r\n      .then(data => {\r\n        setUser(data);\r\n        setLoading(false);\r\n      });\r\n  }, [userId]);\r\n  \r\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\r\n  return &lt;div&gt;{user.name}&lt;/div&gt;;\r\n}\r\n\r\n// Test với cả 3 approaches\r\ntest('loads user data - waitFor', async () => {\r\n  render(&lt;UserProfile userId={1} /&gt;);\r\n  \r\n  await waitFor(() => {\r\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\r\n  });\r\n});\r\n\r\ntest('loads user data - findBy', async () => {\r\n  render(&lt;UserProfile userId={1} /&gt;);\r\n  \r\n  const name = await screen.findByText('John Doe');\r\n  expect(name).toBeInTheDocument();\r\n});\r\n\r\ntest('loads user data - waitForElementToBeRemoved', async () => {\r\n  render(&lt;UserProfile userId={1} /&gt;);\r\n  \r\n  await waitForElementToBeRemoved(() =>\r\n    screen.queryByText('Loading...')\r\n  );\r\n  \r\n  expect(screen.getByText('John Doe')).toBeInTheDocument();\r\n});</code></pre><p><strong>Khi nào dùng cái nào:</strong></p><pre><code>// ✅ Dùng findBy - Simplest, most common\r\ntest('element appears', async () => {\r\n  render(&lt;Component /&gt;);\r\n  const element = await screen.findByText('Loaded');\r\n  expect(element).toBeInTheDocument();\r\n});\r\n\r\n// ✅ Dùng waitFor - Complex assertions\r\ntest('multiple conditions', async () => {\r\n  render(&lt;Component /&gt;);\r\n  \r\n  await waitFor(() => {\r\n    expect(screen.getByRole('button')).toBeEnabled();\r\n    expect(screen.getByText('Ready')).toBeInTheDocument();\r\n  });\r\n});\r\n\r\n// ✅ Dùng waitForElementToBeRemoved - Loading/Modal removal\r\ntest('modal closes', async () => {\r\n  render(&lt;Component /&gt;);\r\n  \r\n  const modal = screen.getByRole('dialog');\r\n  fireEvent.click(screen.getByText('Close'));\r\n  \r\n  await waitForElementToBeRemoved(modal);\r\n});</code></pre><p><strong>Common Mistakes:</strong></p><pre><code>// ❌ SAI - Dùng getBy cho async (throw ngay)\r\ntest('wrong async test', async () => {\r\n  render(&lt;AsyncComponent /&gt;);\r\n  \r\n  const element = screen.getByText('Loaded'); // Throws immediately!\r\n});\r\n\r\n// ✅ ĐÚNG - Dùng findBy\r\ntest('correct async test', async () => {\r\n  render(&lt;AsyncComponent /&gt;);\r\n  \r\n  const element = await screen.findByText('Loaded');\r\n});\r\n\r\n// ❌ SAI - Quên await\r\ntest('forgot await', async () => {\r\n  render(&lt;AsyncComponent /&gt;);\r\n  \r\n  screen.findByText('Loaded'); // Returns Promise, not element!\r\n});\r\n\r\n// ✅ ĐÚNG - Có await\r\ntest('with await', async () => {\r\n  render(&lt;AsyncComponent /&gt;);\r\n  \r\n  const element = await screen.findByText('Loaded');\r\n});</code></pre>",
      "level": "senior"
    },
    {
      "question": "So sánh test.skip vs test.only vs test.todo?",
      "answer": "<p><strong>Sự khác biệt:</strong></p><p>3 modifiers này giúp control test execution flow trong quá trình development.</p><p><strong>test.skip - Bỏ qua test:</strong></p><p>Skip test này, không chạy nhưng vẫn hiển thị trong results.</p><pre><code>describe('User tests', () => {\r\n  test('creates user', () => {\r\n    // Test này chạy bình thường\r\n    expect(createUser()).toBeDefined();\r\n  });\r\n  \r\n  test.skip('updates user', () => {\r\n    // Test này bị skip, không chạy\r\n    expect(updateUser()).toBeDefined();\r\n  });\r\n  \r\n  test('deletes user', () => {\r\n    // Test này chạy bình thường\r\n    expect(deleteUser()).toBeDefined();\r\n  });\r\n});\r\n\r\n// Output:\r\n// ✓ creates user\r\n// ○ skipped updates user\r\n// ✓ deletes user</code></pre><pre><code>// Skip cả test suite\r\ndescribe.skip('Integration tests', () => {\r\n  test('test 1', () => {});\r\n  test('test 2', () => {});\r\n  // Tất cả tests trong suite này đều bị skip\r\n});</code></pre><p><strong>test.only - Chỉ chạy test này:</strong></p><p>Chỉ chạy test được đánh dấu .only, skip tất cả tests khác.</p><pre><code>describe('User tests', () => {\r\n  test('creates user', () => {\r\n    // Bị skip\r\n    expect(createUser()).toBeDefined();\r\n  });\r\n  \r\n  test.only('updates user', () => {\r\n    // CHỈ test này chạy\r\n    expect(updateUser()).toBeDefined();\r\n  });\r\n  \r\n  test('deletes user', () => {\r\n    // Bị skip\r\n    expect(deleteUser()).toBeDefined();\r\n  });\r\n});\r\n\r\n// Output:\r\n// ○ skipped creates user\r\n// ✓ updates user\r\n// ○ skipped deletes user</code></pre><pre><code>// Multiple .only - chạy tất cả .only tests\r\ntest.only('test 1', () => {}); // Chạy\r\ntest('test 2', () => {});       // Skip\r\ntest.only('test 3', () => {}); // Chạy\r\ntest('test 4', () => {});       // Skip</code></pre><p><strong>test.todo - Placeholder test:</strong></p><p>Đánh dấu test cần viết sau, không có implementation, không chạy.</p><pre><code>describe('User tests', () => {\r\n  test('creates user', () => {\r\n    expect(createUser()).toBeDefined();\r\n  });\r\n  \r\n  test.todo('should validate email format');\r\n  \r\n  test.todo('should hash password before saving');\r\n  \r\n  test('deletes user', () => {\r\n    expect(deleteUser()).toBeDefined();\r\n  });\r\n});\r\n\r\n// Output:\r\n// ✓ creates user\r\n// ✎ todo should validate email format\r\n// ✎ todo should hash password before saving\r\n// ✓ deletes user</code></pre><p><strong>Bảng so sánh:</strong></p><table><tr><th>test.skip</th><th>test.only</th><th>test.todo</th></tr><tr><td>Bỏ qua test</td><td>Chỉ chạy test này</td><td>Placeholder cho future test</td></tr><tr><td>Có implementation</td><td>Có implementation</td><td>Không có implementation</td></tr><tr><td>Tạm thời disable</td><td>Focus vào test cụ thể</td><td>Planning/reminder</td></tr><tr><td>Shows as skipped</td><td>Only one runs</td><td>Shows as todo</td></tr></table><p><strong>Use Cases thực tế:</strong></p><pre><code>// test.skip - Khi test đang fail, cần fix sau\r\ndescribe('Payment processing', () => {\r\n  test('processes credit card', () => {\r\n    // Working test\r\n  });\r\n  \r\n  test.skip('processes PayPal', () => {\r\n    // Temporarily broken, need to fix API integration\r\n    // TODO: Fix PayPal API changes\r\n  });\r\n});\r\n\r\n// test.only - Debug một test cụ thể\r\ndescribe('Complex feature', () => {\r\n  test.only('the failing test I am debugging', () => {\r\n    // Focus on this test only\r\n    expect(complexFunction()).toBe(expected);\r\n  });\r\n  \r\n  test('other test 1', () => {});\r\n  test('other test 2', () => {});\r\n});\r\n\r\n// test.todo - Planning tests\r\ndescribe('New feature', () => {\r\n  test('basic functionality works', () => {\r\n    // Implemented\r\n  });\r\n  \r\n  test.todo('should handle edge case A');\r\n  test.todo('should validate input');\r\n  test.todo('should work with async operations');\r\n  test.todo('should handle errors gracefully');\r\n});</code></pre><p><strong>Combining with describe:</strong></p><pre><code>// describe.skip - Skip entire suite\r\ndescribe.skip('Legacy features', () => {\r\n  test('old test 1', () => {});\r\n  test('old test 2', () => {});\r\n});\r\n\r\n// describe.only - Run only this suite\r\ndescribe.only('Current feature', () => {\r\n  test('test 1', () => {}); // Runs\r\n  test('test 2', () => {}); // Runs\r\n});\r\n\r\ndescribe('Other feature', () => {\r\n  test('test 3', () => {}); // Skipped\r\n});</code></pre><p><strong>Best Practices:</strong></p><pre><code>// ❌ Không nên commit .only vào codebase\r\ntest.only('debug this', () => {\r\n  // This will skip all other tests in CI!\r\n});\r\n\r\n// ✅ Dùng .only local, remove trước khi commit\r\ntest('normal test', () => {});\r\n\r\n// ✅ Dùng .skip tạm thời, thêm TODO comment\r\ntest.skip('broken test', () => {\r\n  // TODO: Fix this after API changes\r\n});\r\n\r\n// ✅ Dùng .todo cho planning\r\ntest.todo('implement feature X');\r\ntest.todo('add validation for field Y');</code></pre><p><strong>Git hook để prevent .only trong commits:</strong></p><pre><code>// .husky/pre-commit\r\n#!/bin/sh\r\n\r\nif git diff --cached | grep -E '(test|it|describe)\\.only'; then\r\n  echo \"❌ Error: .only found in tests\"\r\n  echo \"Remove .only before committing\"\r\n  exit 1\r\nfi</code></pre><p><strong>Jest configuration:</strong></p><pre><code>// jest.config.js\r\nmodule.exports = {\r\n  // Fail if .only is found in CI\r\n  testFailOnOnly: process.env.CI,\r\n  \r\n  // Show todo tests in output\r\n  verbose: true\r\n};</code></pre>",
      "level": "middle"
    }
  ]
}
