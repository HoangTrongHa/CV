{
  "id": "vuejs",
  "name": "Câu hỏi phỏng vấn Vue.js 3",
  "description": "Tổng hợp câu hỏi phỏng vấn Vue.js 3 từ Fresher đến Senior",
  "questions": [
    {
      "question": "Vue.js là gì?",
      "answer": "<p>Vue.js là một framework JavaScript progressive để xây dựng giao diện người dùng. Khác với các framework nguyên khối, Vue được thiết kế từ đầu để có thể áp dụng dần dần. Thư viện lõi tập trung vào lớp view và rất dễ tích hợp với các thư viện khác hoặc các dự án hiện có.</p><p><strong>Đặc điểm chính:</strong></p><ul><li>Reactive và component-based</li><li>Virtual DOM</li><li>Kích thước nhỏ (~20KB gzipped)</li><li>Hiệu suất cao</li><li>Dễ học và dễ sử dụng</li></ul>",
      "level": "fresher"
    },
    {
      "question": "Ưu điểm của Vue.js?",
      "answer": "<p><ul><li><strong>Dễ học:</strong> Cú pháp đơn giản, dễ hiểu, phù hợp cho người mới</li><li><strong>Kích thước nhỏ:</strong> Chỉ khoảng 20KB min+gzip</li><li><strong>Tài liệu tốt:</strong> Documentation rất chi tiết và dễ hiểu</li><li><strong>Hiệu suất cao:</strong> Virtual DOM và hệ thống reactivity tối ưu</li><li><strong>Component-based:</strong> Tái sử dụng code dễ dàng</li><li><strong>Two-way binding:</strong> Đồng bộ dữ liệu tự động</li><li><strong>Ecosystem phong phú:</strong> Vue Router, Pinia, Vuex, Nuxt.js</li><li><strong>TypeScript support:</strong> Hỗ trợ TypeScript tốt</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Vue 2 vs Vue 3: Những thay đổi chính?",
      "answer": "<p><strong>Composition API:</strong></p><ul><li>Thay thế Options API</li><li>Tổ chức code theo logic thay vì option type</li><li>Dễ reuse logic hơn</li></ul><p><strong>Performance:</strong></p><ul><li>Virtual DOM viết lại, nhanh hơn 2x</li><li>Tree-shaking tốt hơn</li><li>Bundle size nhỏ hơn</li></ul><p><strong>TypeScript:</strong></p><ul><li>Được viết hoàn toàn bằng TypeScript</li><li>Type inference tốt hơn nhiều</li></ul><p><strong>Fragments:</strong></p><ul><li>Cho phép multiple root elements trong template</li><li>Không cần wrapper div nữa</li><li>Code sạch hơn, ít DOM nodes hơn</li></ul><pre><code>&lt;template&gt;\r\n  &lt;h1&gt;Title&lt;/h1&gt;\r\n  &lt;p&gt;Content&lt;/p&gt;\r\n  &lt;!-- Vue 2 phải wrap trong div --&gt;\r\n&lt;/template&gt;</code></pre><p><strong>Teleport:</strong></p><ul><li>Render component content ở vị trí khác trong DOM</li><li>Dùng cho modals, tooltips, notifications</li><li>Logic vẫn trong component nhưng DOM ở nơi khác</li></ul><pre><code>&lt;Teleport to=\"body\"&gt;\r\n  &lt;div class=\"modal\"&gt;Modal content&lt;/div&gt;\r\n&lt;/Teleport&gt;</code></pre><p><strong>Suspense:</strong></p><ul><li>Handle async dependencies trong component tree</li><li>Hiển thị fallback UI khi đang load</li><li>Dùng với async setup() hoặc async components</li></ul><pre><code>&lt;Suspense&gt;\r\n  &lt;template #default&gt;\r\n    &lt;AsyncComponent /&gt;\r\n  &lt;/template&gt;\r\n  &lt;template #fallback&gt;\r\n    &lt;Loading /&gt;\r\n  &lt;/template&gt;\r\n&lt;/Suspense&gt;</code></pre>",
      "level": "fresher"
    },
    {
      "question": "v-model vs v-bind: Khác nhau như thế nào?",
      "answer": "<p><strong>v-bind (hoặc :) - One-way binding:</strong></p><p>Bind data từ parent/component state xuống attribute hoặc prop, chỉ một chiều từ data → view. Khi data thay đổi, view tự động update nhưng ngược lại thì không.</p><pre><code>&lt;template&gt;\n  &lt;!-- Bind vào HTML attribute --&gt;\n  &lt;input :value=\"message\" /&gt;\n  &lt;img :src=\"imageUrl\" /&gt;\n  &lt;button :disabled=\"isLoading\"&gt;Submit&lt;/button&gt;\n  \n  &lt;!-- Bind vào component prop --&gt;\n  &lt;ChildComponent :user=\"currentUser\" /&gt;\n  &lt;MyInput :modelValue=\"text\" /&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nconst message = ref('Hello')\nconst imageUrl = ref('/logo.png')\nconst isLoading = ref(false)\n\n// Khi message thay đổi → input value update\n// Nhưng khi user type vào input → message KHÔNG thay đổi\n&lt;/script&gt;</code></pre><p><strong>v-model - Two-way binding:</strong></p><p>Kết hợp v-bind và v-on để tạo two-way data binding. Data đồng bộ hai chiều: data ↔ view. Thay đổi ở view sẽ update data và ngược lại.</p><pre><code>&lt;template&gt;\n  &lt;!-- Two-way binding cho form inputs --&gt;\n  &lt;input v-model=\"message\" /&gt;\n  &lt;textarea v-model=\"description\"&gt;&lt;/textarea&gt;\n  &lt;input type=\"checkbox\" v-model=\"isChecked\" /&gt;\n  &lt;input type=\"radio\" value=\"A\" v-model=\"selectedOption\" /&gt;\n  &lt;select v-model=\"selectedCity\"&gt;\n    &lt;option value=\"hanoi\"&gt;Hà Nội&lt;/option&gt;\n    &lt;option value=\"hcm\"&gt;TP HCM&lt;/option&gt;\n  &lt;/select&gt;\n  \n  &lt;!-- Two-way binding cho custom components --&gt;\n  &lt;CustomInput v-model=\"text\" /&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nconst message = ref('Hello')\n\n// Khi message thay đổi → input value update\n// Khi user type vào input → message TỰ ĐỘNG update\n&lt;/script&gt;</code></pre><p><strong>v-model là syntax sugar của v-bind + v-on:</strong></p><pre><code>&lt;!-- v-model --&gt;\n&lt;input v-model=\"message\" /&gt;\n\n&lt;!-- Tương đương với --&gt;\n&lt;input \n  :value=\"message\" \n  @input=\"message = $event.target.value\"\n/&gt;\n\n&lt;!-- Với component --&gt;\n&lt;CustomInput v-model=\"text\" /&gt;\n\n&lt;!-- Tương đương với --&gt;\n&lt;CustomInput \n  :modelValue=\"text\"\n  @update:modelValue=\"text = $event\"\n/&gt;</code></pre><p><strong>Bảng so sánh chi tiết:</strong></p><table><tr><th>Aspect</th><th>v-bind (:)</th><th>v-model</th></tr><tr><td><strong>Data flow</strong></td><td>One-way: data → view</td><td>Two-way: data ↔ view</td></tr><tr><td><strong>Syntax</strong></td><td>:attribute=\"value\"</td><td>v-model=\"value\"</td></tr><tr><td><strong>Update data</strong></td><td>Manual (cần event handler)</td><td>Auto update</td></tr><tr><td><strong>Use case</strong></td><td>Display data, bind attributes</td><td>Form inputs, two-way sync</td></tr><tr><td><strong>Components</strong></td><td>:propName=\"value\"</td><td>v-model=\"value\" (shorthand)</td></tr><tr><td><strong>Multiple bindings</strong></td><td>Unlimited</td><td>Multiple v-model (Vue 3)</td></tr><tr><td><strong>Tương đương</strong></td><td>N/A</td><td>:value + @input</td></tr></table><p><strong>Ví dụ thực tế so sánh:</strong></p><pre><code>&lt;script setup&gt;\nimport { ref } from 'vue'\n\nconst searchQuery = ref('')\nconst username = ref('John')\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;!-- ❌ v-bind - One-way, user type không update data --&gt;\n  &lt;input :value=\"searchQuery\" placeholder=\"Search...\" /&gt;\n  &lt;p&gt;Search: {{ searchQuery }}&lt;/p&gt; &lt;!-- Không thay đổi khi user type --&gt;\n  \n  &lt;!-- ✅ v-model - Two-way, auto sync --&gt;\n  &lt;input v-model=\"username\" placeholder=\"Username\" /&gt;\n  &lt;p&gt;Username: {{ username }}&lt;/p&gt; &lt;!-- Tự động update khi user type --&gt;\n  \n  &lt;!-- Nếu muốn dùng v-bind và vẫn có two-way, phải thêm @input --&gt;\n  &lt;input \n    :value=\"searchQuery\" \n    @input=\"searchQuery = $event.target.value\"\n    placeholder=\"Search...\"\n  /&gt;\n  &lt;!-- Nhưng cách này dài dòng, nên dùng v-model --&gt;\n&lt;/template&gt;</code></pre><p><strong>v-model với modifiers:</strong></p><pre><code>&lt;!-- .lazy - Update sau blur thay vì mỗi keystroke --&gt;\n&lt;input v-model.lazy=\"message\" /&gt;\n\n&lt;!-- .number - Auto convert thành number --&gt;\n&lt;input v-model.number=\"age\" type=\"number\" /&gt;\n\n&lt;!-- .trim - Auto trim whitespace --&gt;\n&lt;input v-model.trim=\"username\" /&gt;\n\n&lt;!-- Kết hợp multiple modifiers --&gt;\n&lt;input v-model.trim.lazy=\"email\" /&gt;</code></pre><p><strong>v-model với form elements:</strong></p><pre><code>&lt;script setup&gt;\nconst text = ref('')\nconst checked = ref(false)\nconst checkedItems = ref([])\nconst selected = ref('')\nconst multiSelect = ref([])\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;!-- Text input --&gt;\n  &lt;input v-model=\"text\" /&gt;\n  \n  &lt;!-- Checkbox - single --&gt;\n  &lt;input type=\"checkbox\" v-model=\"checked\" /&gt;\n  &lt;!-- checked = true/false --&gt;\n  \n  &lt;!-- Checkbox - multiple --&gt;\n  &lt;input type=\"checkbox\" value=\"Vue\" v-model=\"checkedItems\" /&gt;\n  &lt;input type=\"checkbox\" value=\"React\" v-model=\"checkedItems\" /&gt;\n  &lt;!-- checkedItems = ['Vue', 'React'] --&gt;\n  \n  &lt;!-- Radio --&gt;\n  &lt;input type=\"radio\" value=\"A\" v-model=\"selected\" /&gt;\n  &lt;input type=\"radio\" value=\"B\" v-model=\"selected\" /&gt;\n  &lt;!-- selected = 'A' hoặc 'B' --&gt;\n  \n  &lt;!-- Select - single --&gt;\n  &lt;select v-model=\"selected\"&gt;\n    &lt;option value=\"option1\"&gt;Option 1&lt;/option&gt;\n    &lt;option value=\"option2\"&gt;Option 2&lt;/option&gt;\n  &lt;/select&gt;\n  \n  &lt;!-- Select - multiple --&gt;\n  &lt;select v-model=\"multiSelect\" multiple&gt;\n    &lt;option value=\"vue\"&gt;Vue&lt;/option&gt;\n    &lt;option value=\"react\"&gt;React&lt;/option&gt;\n  &lt;/select&gt;\n  &lt;!-- multiSelect = ['vue', 'react'] --&gt;\n&lt;/template&gt;</code></pre><p><strong>v-model với custom components (Vue 3):</strong></p><pre><code>&lt;!-- Parent Component --&gt;\n&lt;script setup&gt;\nconst searchText = ref('')\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;SearchInput v-model=\"searchText\" /&gt;\n  &lt;p&gt;Search: {{ searchText }}&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;!-- SearchInput.vue - Child Component --&gt;\n&lt;script setup&gt;\ndefineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n\nconst updateValue = (event) => {\n  emit('update:modelValue', event.target.value)\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;input \n    :value=\"modelValue\" \n    @input=\"updateValue\"\n    placeholder=\"Type to search...\"\n  /&gt;\n&lt;/template&gt;\n\n&lt;!-- Hoặc dùng computed để đơn giản hơn --&gt;\n&lt;script setup&gt;\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n\nconst value = computed({\n  get: () => props.modelValue,\n  set: (val) => emit('update:modelValue', val)\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;input v-model=\"value\" /&gt;\n&lt;/template&gt;</code></pre><p><strong>Multiple v-model trong Vue 3:</strong></p><pre><code>&lt;!-- Parent --&gt;\n&lt;UserForm \n  v-model:firstName=\"firstName\"\n  v-model:lastName=\"lastName\"\n  v-model:email=\"email\"\n/&gt;\n\n&lt;!-- UserForm.vue --&gt;\n&lt;script setup&gt;\ndefineProps(['firstName', 'lastName', 'email'])\nconst emit = defineEmits([\n  'update:firstName',\n  'update:lastName', \n  'update:email'\n])\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;input \n    :value=\"firstName\" \n    @input=\"emit('update:firstName', $event.target.value)\"\n  /&gt;\n  &lt;input \n    :value=\"lastName\" \n    @input=\"emit('update:lastName', $event.target.value)\"\n  /&gt;\n  &lt;input \n    :value=\"email\" \n    @input=\"emit('update:email', $event.target.value)\"\n  /&gt;\n&lt;/template&gt;</code></pre><p><strong>Khi nào dùng cái nào?</strong></p><p><strong>Dùng v-bind (:) khi:</strong></p><ul><li>Chỉ cần hiển thị data (one-way)</li><li>Bind attributes như src, href, class, style, disabled</li><li>Pass props xuống child components</li><li>Không cần user input update data</li><li>Control data flow chặt chẽ hơn</li></ul><pre><code>&lt;!-- Display only --&gt;\n&lt;img :src=\"user.avatar\" :alt=\"user.name\" /&gt;\n&lt;a :href=\"product.url\"&gt;{{ product.name }}&lt;/a&gt;\n&lt;button :disabled=\"!canSubmit\"&gt;Submit&lt;/button&gt;\n\n&lt;!-- Pass props --&gt;\n&lt;ProductCard :product=\"selectedProduct\" /&gt;</code></pre><p><strong>Dùng v-model khi:</strong></p><ul><li>Form inputs cần two-way binding</li><li>User input cần sync với data ngay lập tức</li><li>Custom components với two-way communication</li><li>Search, filter, form fields</li><li>Real-time validation</li></ul><pre><code>&lt;!-- Form inputs --&gt;\n&lt;input v-model=\"username\" /&gt;\n&lt;textarea v-model=\"bio\"&gt;&lt;/textarea&gt;\n&lt;select v-model=\"country\"&gt;...&lt;/select&gt;\n\n&lt;!-- Search/Filter --&gt;\n&lt;input v-model=\"searchQuery\" placeholder=\"Search...\" /&gt;\n&lt;input v-model=\"minPrice\" type=\"number\" /&gt;\n\n&lt;!-- Custom component với two-way sync --&gt;\n&lt;ColorPicker v-model=\"selectedColor\" /&gt;\n&lt;DatePicker v-model=\"selectedDate\" /&gt;</code></pre><p><strong>Common mistakes:</strong></p><pre><code>&lt;!-- ❌ WRONG - v-model cho non-input elements --&gt;\n&lt;div v-model=\"text\"&gt;&lt;/div&gt;  &lt;!-- Sai, div không có input event --&gt;\n&lt;p v-model=\"message\"&gt;&lt;/p&gt;  &lt;!-- Sai --&gt;\n\n&lt;!-- ❌ WRONG - Dùng v-bind cho form input mà quên @input --&gt;\n&lt;input :value=\"username\" /&gt;  &lt;!-- User type nhưng data không update --&gt;\n\n&lt;!-- ✅ CORRECT --&gt;\n&lt;input v-model=\"username\" /&gt;  &lt;!-- Two-way auto sync --&gt;\n\n&lt;!-- hoặc --&gt;\n&lt;input :value=\"username\" @input=\"username = $event.target.value\" /&gt;</code></pre><p><strong>Performance considerations:</strong></p><ul><li>v-model có overhead nhẹ hơn manual v-bind + @input (Vue optimize internally)</li><li>Với v-model.lazy, giảm số lần update (update on blur thay vì mỗi keystroke)</li><li>v-bind nhẹ hơn nếu chỉ display, không cần two-way</li></ul><p><strong>Best practices:</strong></p><ul><li>✅ Dùng v-model cho form inputs và custom components cần two-way binding</li><li>✅ Dùng v-bind cho display-only, attributes, one-way props</li><li>✅ Dùng modifiers (.lazy, .number, .trim) để optimize v-model</li><li>✅ Multiple v-model cho complex components (Vue 3)</li><li>✅ Document rõ v-model behavior trong custom components</li><li>❌ KHÔNG dùng v-model cho elements không support input</li><li>❌ KHÔNG abuse v-model - dùng khi cần two-way, không phải everywhere</li></ul>",
      "level": "fresher"
    },
    {
      "question": "v-bind vs {{}} (Interpolation): Khác nhau như thế nào?",
      "answer": "<p><strong>ref():</strong></p><ul><li>Tạo reactive reference cho primitive values</li><li>Truy cập qua .value</li><li>Unwrap tự động trong template</li></ul><pre><code>const count = ref(0)\nconsole.log(count.value) // 0\ncount.value++</code></pre><p><strong>reactive():</strong></p><ul><li>Tạo reactive proxy cho objects</li><li>Không cần .value</li><li>Deep reactivity</li></ul><pre><code>const state = reactive({ count: 0 })\nconsole.log(state.count) // 0\nstate.count++</code></pre><p><strong>Khi nào dùng gì?</strong></p><ul><li>ref: primitive values, single values</li><li>reactive: objects, multiple related values</li></ul>",
      "level": "middle"
    },
    {
      "question": "Computed vs Watch vs WatchEffect?",
      "answer": "<p><strong>computed:</strong></p><ul><li>Cached based on dependencies</li><li>Chỉ re-compute khi dependency thay đổi</li><li>Return value</li><li>Dùng cho derived state</li></ul><pre><code>const fullName = computed(() => \n  firstName.value + ' ' + lastName.value\n)</code></pre><p><strong>watch:</strong></p><ul><li>Side effects khi data thay đổi</li><li>Lazy by default</li><li>Access old và new value</li><li>Watch specific sources</li></ul><pre><code>watch(count, (newVal, oldVal) => {\n  console.log(`Count changed from ${oldVal} to ${newVal}`)\n})</code></pre><p><strong>watchEffect:</strong></p><ul><li>Tự động track dependencies</li><li>Chạy ngay lập tức</li><li>Không access old value</li><li>Cleanup tự động</li></ul><pre><code>watchEffect(() => {\n  console.log(`Count is ${count.value}`)\n})</code></pre>",
      "level": "middle"
    },
    {
      "question": "Lifecycle hooks trong Vue 3 Composition API?",
      "answer": "<p>Lifecycle hooks trong Vue 3 Composition API tương tự Options API nhưng có prefix 'on' và được gọi trong setup().</p><p><strong>Setup phase:</strong></p><ul><li><code>setup()</code> - Chạy trước tất cả hooks, thay thế beforeCreate và created. Đây là nơi khởi tạo reactive state và logic.</li></ul><p><strong>Mounting (Gắn kết component):</strong></p><ul><li><code>onBeforeMount()</code> - Gọi trước khi component được mount vào DOM. Template đã compiled nhưng chưa render.</li><li><code>onMounted()</code> - Gọi sau khi component đã mount, DOM đã available. Dùng cho DOM manipulation, fetch data, setup third-party libraries.</li></ul><pre><code>onMounted(() => {\n  console.log('Component mounted')\n  // Access DOM, call APIs\n})</code></pre><p><strong>Updating (Cập nhật):</strong></p><ul><li><code>onBeforeUpdate()</code> - Gọi trước khi component re-render do reactive data thay đổi</li><li><code>onUpdated()</code> - Gọi sau khi component đã re-render và DOM updated. Tránh update state ở đây để tránh infinite loop.</li></ul><p><strong>Unmounting (Hủy component):</strong></p><ul><li><code>onBeforeUnmount()</code> - Gọi trước khi component bị unmount</li><li><code>onUnmounted()</code> - Gọi sau khi component đã unmount. Dùng để cleanup: remove listeners, clear timers, cancel requests.</li></ul><pre><code>onUnmounted(() => {\n  clearInterval(timer)\n  window.removeEventListener('resize', handler)\n})</code></pre><p><strong>Error handling:</strong></p><ul><li><code>onErrorCaptured()</code> - Bắt lỗi từ child components, dùng để tạo error boundaries</li></ul><p><strong>Server-side:</strong></p><ul><li><code>onServerPrefetch()</code> - SSR only, fetch data trên server trước khi render</li></ul>",
      "level": "middle"
    },
    {
      "question": "nextTick() trong Vue là gì? Khi nào cần dùng?",
      "answer": "<p><strong>nextTick() là gì?</strong></p><p>nextTick() là utility function đợi cho đến khi DOM được update sau khi data thay đổi. Vue update DOM <strong>asynchronously</strong> (batch updates), không phải ngay lập tức khi bạn thay đổi data. nextTick() giúp bạn access DOM sau khi Vue đã apply những thay đổi.</p><p><strong>Tại sao cần nextTick?</strong></p><p>Vue sử dụng <strong>async update queue</strong> để batch DOM updates, tối ưu performance:</p><ol><li>Bạn thay đổi reactive data</li><li>Vue queue update, không update DOM ngay</li><li>Trong cùng một event loop tick, nhiều data changes được batch lại</li><li>Ở tick tiếp theo, Vue flush queue và update DOM một lần</li></ol><p><strong>Cú pháp:</strong></p><pre><code>import { nextTick } from 'vue'\n\n// Async/await (khuyến khích)\nawait nextTick()\n\n// Promise\nnextTick().then(() => {\n  // DOM updated\n})\n\n// Callback\nnextTick(() => {\n  // DOM updated\n})</code></pre><p><strong>Ví dụ cơ bản:</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, nextTick } from 'vue'\n\nconst count = ref(0)\nconst message = ref('Initial')\n\nconst updateAndLog = async () => {\n  count.value++\n  \n  // DOM chưa update\n  console.log(document.querySelector('.count').textContent) // '0'\n  \n  // Đợi DOM update\n  await nextTick()\n  \n  // DOM đã update\n  console.log(document.querySelector('.count').textContent) // '1'\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div class=\"count\"&gt;{{ count }}&lt;/div&gt;\n  &lt;button @click=\"updateAndLog\"&gt;Update&lt;/button&gt;\n&lt;/template&gt;</code></pre><p><strong>Use case 1: Focus element sau khi render</strong></p><pre><code>const showInput = ref(false)\nconst inputRef = ref(null)\n\nconst openInput = async () => {\n  showInput.value = true\n  \n  // inputRef.value vẫn null ở đây\n  \n  await nextTick()\n  \n  // Giờ input đã render, có thể focus\n  inputRef.value.focus()\n}</code></pre><p><strong>Use case 2: Scroll to element sau khi thêm vào list</strong></p><pre><code>const items = ref(['Item 1'])\nconst listRef = ref(null)\n\nconst addItem = async () => {\n  items.value.push(`Item ${items.value.length + 1}`)\n  \n  await nextTick()\n  \n  // Scroll to bottom sau khi item mới được render\n  listRef.value.scrollTop = listRef.value.scrollHeight\n}</code></pre><p><strong>Use case 3: Access computed dimensions sau update</strong></p><pre><code>const content = ref('Short text')\nconst containerRef = ref(null)\n\nconst expandContent = async () => {\n  content.value = 'Very long text...'.repeat(100)\n  \n  await nextTick()\n  \n  // Lấy height sau khi content expanded\n  const height = containerRef.value.offsetHeight\n  console.log('New height:', height)\n}</code></pre><p><strong>Use case 4: Update editor hoặc third-party library</strong></p><pre><code>const editorContent = ref('')\n\nconst updateEditor = async (newContent) => {\n  editorContent.value = newContent\n  \n  await nextTick()\n  \n  // Refresh editor sau khi Vue update DOM\n  editor.refresh()\n}</code></pre><p><strong>nextTick trong Options API:</strong></p><pre><code>export default {\n  data() {\n    return {\n      message: 'Hello'\n    }\n  },\n  methods: {\n    async updateMessage() {\n      this.message = 'Updated'\n      \n      // this.$nextTick\n      await this.$nextTick()\n      \n      // hoặc callback\n      this.$nextTick(() => {\n        console.log('DOM updated')\n      })\n    }\n  }\n}</code></pre><p><strong>So sánh với onUpdated():</strong></p><table><tr><th>Aspect</th><th>nextTick()</th><th>onUpdated()</th></tr><tr><td>Khi chạy</td><td>Sau next DOM update</td><td>Mỗi lần component update</td></tr><tr><td>Use case</td><td>Specific update cần handle</td><td>Mọi DOM update</td></tr><tr><td>Control</td><td>Call khi cần</td><td>Auto trigger</td></tr><tr><td>Performance</td><td>Efficient, on-demand</td><td>Runs cho mọi update</td></tr></table><p><strong>Khi nào dùng nextTick?</strong></p><ul><li>✅ Cần access/manipulate DOM sau khi data thay đổi</li><li>✅ Focus/scroll to elements vừa render</li><li>✅ Get computed dimensions/positions</li><li>✅ Update third-party libraries sau Vue update</li><li>✅ Đảm bảo DOM reflect latest state</li><li>❌ KHÔNG cần nếu chỉ work với reactive data (Vue auto handle)</li><li>❌ KHÔNG dùng cho mọi data change (overhead)</li></ul><p><strong>Best practices:</strong></p><ul><li>Dùng async/await cho code readable hơn callback</li><li>Chỉ dùng khi thực sự cần access DOM</li><li>Combine với ref templates để access DOM elements</li><li>Tránh abuse - không phải lúc nào cũng cần</li></ul><p><strong>Internal implementation (đơn giản hóa):</strong></p><pre><code>// Vue queue pending updates\nconst queue = []\nlet pending = false\n\nfunction queueUpdate(update) {\n  queue.push(update)\n  if (!pending) {\n    pending = true\n    Promise.resolve().then(flushQueue)\n  }\n}\n\nfunction flushQueue() {\n  queue.forEach(update => update())\n  queue.length = 0\n  pending = false\n}</code></pre>",
      "level": "middle"
    },
    {
      "question": "Props vs Emit: Communication giữa components?",
      "answer": "<p><strong>Props (Parent → Child):</strong></p><pre><code>// Parent\n&lt;ChildComponent :message=\"hello\" /&gt;\n\n// Child\nconst props = defineProps({\n  message: String\n})</code></pre><p><strong>Emit (Child → Parent):</strong></p><pre><code>// Child\nconst emit = defineEmits(['update'])\nemit('update', newValue)\n\n// Parent\n&lt;ChildComponent @update=\"handleUpdate\" /&gt;</code></pre><p><strong>Best practices:</strong></p><ul><li>Props down, events up (one-way data flow)</li><li>Validate props với type và validator</li><li>Emit events với tên rõ ràng</li><li>Dùng v-model cho two-way binding</li></ul>",
      "level": "fresher"
    },
    {
      "question": "v-if vs v-show: Khi nào dùng?",
      "answer": "<p><strong>v-if:</strong></p><ul><li>Conditional rendering - destroy/create DOM</li><li>Lazy rendering</li><li>Higher toggle cost</li><li>Dùng khi: điều kiện ít thay đổi</li></ul><pre><code>&lt;div v-if=\"isVisible\"&gt;Content&lt;/div&gt;</code></pre><p><strong>v-show:</strong></p><ul><li>Toggle CSS display property</li><li>Always render DOM</li><li>Higher initial render cost</li><li>Dùng khi: toggle thường xuyên</li></ul><pre><code>&lt;div v-show=\"isVisible\"&gt;Content&lt;/div&gt;</code></pre><p><strong>Performance tip:</strong></p><ul><li>v-show cho elements toggle nhiều</li><li>v-if cho conditional logic phức tạp</li><li>v-if với v-else-if, v-else</li></ul>",
      "level": "fresher"
    },
    {
      "question": "v-bind vs {{}} (Interpolation): Khác nhau như thế nào?",
      "answer": "<p><strong>{{}} (Mustache/Interpolation):</strong></p><p>Dùng để render text content bên trong HTML tags. Vue tự động escape HTML để prevent XSS attacks.</p><pre><code>&lt;template&gt;\n  &lt;p&gt;{{ message }}&lt;/p&gt;\n  &lt;div&gt;Hello {{ username }}, you have {{ count }} messages&lt;/div&gt;\n  &lt;span&gt;{{ firstName + ' ' + lastName }}&lt;/span&gt;\n  &lt;h1&gt;{{ computed_value }}&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nconst message = ref('Hello Vue!')\nconst username = ref('John')\nconst count = ref(5)\n&lt;/script&gt;\n\n&lt;!-- Rendered HTML --&gt;\n&lt;p&gt;Hello Vue!&lt;/p&gt;\n&lt;div&gt;Hello John, you have 5 messages&lt;/div&gt;</code></pre><p><strong>v-bind (hoặc shorthand :):</strong></p><p>Dùng để bind data vào HTML attributes một cách reactive. Có thể bind vào bất kỳ attribute nào (src, href, class, style, disabled, v.v.).</p><pre><code>&lt;template&gt;\n  &lt;!-- Full syntax --&gt;\n  &lt;img v-bind:src=\"imageUrl\" v-bind:alt=\"imageAlt\" /&gt;\n  \n  &lt;!-- Shorthand (khuyến khích dùng) --&gt;\n  &lt;img :src=\"imageUrl\" :alt=\"imageAlt\" /&gt;\n  \n  &lt;a :href=\"url\"&gt;Link&lt;/a&gt;\n  &lt;button :disabled=\"isDisabled\"&gt;Submit&lt;/button&gt;\n  &lt;div :class=\"className\"&gt;&lt;/div&gt;\n  &lt;div :style=\"{ color: textColor }\"&gt;&lt;/div&gt;\n  &lt;input :value=\"inputValue\" :placeholder=\"placeholderText\" /&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nconst imageUrl = ref('/images/logo.png')\nconst imageAlt = ref('Company Logo')\nconst url = ref('https://example.com')\nconst isDisabled = ref(false)\nconst className = ref('active')\nconst textColor = ref('red')\n&lt;/script&gt;</code></pre><p><strong>Bảng so sánh chi tiết:</strong></p><table><tr><th>Aspect</th><th>{{}} Interpolation</th><th>v-bind / :</th></tr><tr><td><strong>Vị trí sử dụng</strong></td><td>Bên TRONG tags (text content)</td><td>Trong HTML attributes</td></tr><tr><td><strong>Syntax</strong></td><td>{{ expression }}</td><td>v-bind:attr=\"value\" hoặc :attr=\"value\"</td></tr><tr><td><strong>Use case</strong></td><td>Hiển thị text, numbers, computed values</td><td>Bind attributes: src, href, class, style, disabled, etc.</td></tr><tr><td><strong>HTML rendering</strong></td><td>Auto-escape HTML (safe from XSS)</td><td>Depends on attribute (class/style objects, boolean attrs)</td></tr><tr><td><strong>Reactivity</strong></td><td>✅ Reactive - auto update</td><td>✅ Reactive - auto update</td></tr><tr><td><strong>JavaScript expressions</strong></td><td>✅ Support</td><td>✅ Support</td></tr><tr><td><strong>Ví dụ</strong></td><td>&lt;p&gt;{{ name }}&lt;/p&gt;</td><td>&lt;img :src=\"url\" /&gt;</td></tr></table><p><strong>Tại sao KHÔNG thể dùng {{}} trong attributes?</strong></p><pre><code>&lt;!-- ❌ WRONG - Sẽ KHÔNG work --&gt;\n&lt;img src=\"{{ imageUrl }}\" /&gt;\n&lt;a href=\"{{ linkUrl }}\"&gt;Click&lt;/a&gt;\n&lt;div class=\"{{ className }}\"&gt;&lt;/div&gt;\n\n&lt;!-- ✅ CORRECT - Phải dùng v-bind --&gt;\n&lt;img :src=\"imageUrl\" /&gt;\n&lt;a :href=\"linkUrl\"&gt;Click&lt;/a&gt;\n&lt;div :class=\"className\"&gt;&lt;/div&gt;\n\n&lt;!-- Lý do:\n  - Vue chỉ process {{}} trong text content\n  - Attributes cần v-bind để reactive binding\n  - Browser parse attributes trước khi Vue can process {{}}\n--&gt;</code></pre><p><strong>Khi nào dùng cái nào?</strong></p><p><strong>Dùng {{}} khi:</strong></p><ul><li>Hiển thị text content bên trong tags</li><li>Render numbers, strings, computed values</li><li>Combine multiple values thành text</li><li>Show dynamic messages, labels, paragraphs</li></ul><pre><code>&lt;template&gt;\n  &lt;h1&gt;{{ pageTitle }}&lt;/h1&gt;\n  &lt;p&gt;Welcome, {{ user.firstName }} {{ user.lastName }}&lt;/p&gt;\n  &lt;span&gt;Total: ${{ totalPrice.toFixed(2) }}&lt;/span&gt;\n  &lt;div&gt;{{ isLoggedIn ? 'Logged In' : 'Please Login' }}&lt;/div&gt;\n&lt;/template&gt;</code></pre><p><strong>Dùng v-bind (:) khi:</strong></p><ul><li>Bind vào HTML attributes (src, href, alt, title, etc.)</li><li>Dynamic classes và styles</li><li>Component props</li><li>Boolean attributes (disabled, checked, selected)</li><li>Data attributes (data-*)</li></ul><pre><code>&lt;template&gt;\n  &lt;!-- Images --&gt;\n  &lt;img :src=\"product.image\" :alt=\"product.name\" /&gt;\n  \n  &lt;!-- Links --&gt;\n  &lt;a :href=\"user.website\" :target=\"linkTarget\"&gt;Website&lt;/a&gt;\n  \n  &lt;!-- Dynamic classes --&gt;\n  &lt;div :class=\"{ active: isActive, disabled: isDisabled }\"&gt;&lt;/div&gt;\n  &lt;div :class=\"[baseClass, errorClass]\"&gt;&lt;/div&gt;\n  \n  &lt;!-- Dynamic styles --&gt;\n  &lt;div :style=\"{ color: textColor, fontSize: fontSize + 'px' }\"&gt;&lt;/div&gt;\n  \n  &lt;!-- Boolean attributes --&gt;\n  &lt;button :disabled=\"isLoading\"&gt;Submit&lt;/button&gt;\n  &lt;input :checked=\"isChecked\" type=\"checkbox\" /&gt;\n  \n  &lt;!-- Component props --&gt;\n  &lt;MyComponent :user=\"currentUser\" :count=\"itemCount\" /&gt;\n  \n  &lt;!-- Data attributes --&gt;\n  &lt;div :data-id=\"product.id\" :data-category=\"product.category\"&gt;&lt;/div&gt;\n&lt;/template&gt;</code></pre><p><strong>JavaScript expressions support:</strong></p><p>Cả hai đều support JavaScript expressions:</p><pre><code>&lt;template&gt;\n  &lt;!-- {{}} với expressions --&gt;\n  &lt;p&gt;{{ count * 2 }}&lt;/p&gt;\n  &lt;p&gt;{{ message.toUpperCase() }}&lt;/p&gt;\n  &lt;p&gt;{{ isActive ? 'Active' : 'Inactive' }}&lt;/p&gt;\n  \n  &lt;!-- v-bind với expressions --&gt;\n  &lt;div :id=\"'item-' + index\"&gt;&lt;/div&gt;\n  &lt;img :src=\"'/images/' + filename + '.jpg'\" /&gt;\n  &lt;button :disabled=\"count &lt; 1 || isLoading\"&gt;Buy&lt;/button&gt;\n  &lt;div :class=\"isActive ? 'active' : 'inactive'\"&gt;&lt;/div&gt;\n&lt;/template&gt;</code></pre><p><strong>HTML content: v-html vs {{}}:</strong></p><pre><code>&lt;template&gt;\n  &lt;!-- {{}} - Auto escape HTML (SAFE) --&gt;\n  &lt;div&gt;{{ htmlContent }}&lt;/div&gt;\n  &lt;!-- Render: &lt;strong&gt;Bold&lt;/strong&gt; (as text) --&gt;\n  \n  &lt;!-- v-html - Render raw HTML (DANGER: XSS risk) --&gt;\n  &lt;div v-html=\"htmlContent\"&gt;&lt;/div&gt;\n  &lt;!-- Render: <strong>Bold</strong> (as HTML) --&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nconst htmlContent = ref('&lt;strong&gt;Bold&lt;/strong&gt;')\n&lt;/script&gt;\n\n&lt;!-- WARNING: \n  - Chỉ dùng v-html với trusted content\n  - KHÔNG dùng v-html với user input (XSS risk)\n  - {{}} tự động escape, safe by default\n--&gt;</code></pre><p><strong>v-bind shorthand variations:</strong></p><pre><code>&lt;template&gt;\n  &lt;!-- Normal v-bind --&gt;\n  &lt;img :src=\"imageUrl\" :alt=\"altText\" /&gt;\n  \n  &lt;!-- Bind entire object --&gt;\n  &lt;div v-bind=\"objectAttrs\"&gt;&lt;/div&gt;\n  &lt;!-- Equivalent to: --&gt;\n  &lt;div :id=\"objectAttrs.id\" :class=\"objectAttrs.class\"&gt;&lt;/div&gt;\n  \n  &lt;!-- Dynamic attribute name (Vue 2.6+) --&gt;\n  &lt;div :[attributeName]=\"value\"&gt;&lt;/div&gt;\n  &lt;!-- If attributeName = 'id', renders: &lt;div id=\"value\"&gt; --&gt;\n  \n  &lt;!-- .prop modifier - bind as DOM property --&gt;\n  &lt;div :text-content.prop=\"text\"&gt;&lt;/div&gt;\n  \n  &lt;!-- .camel modifier - convert kebab-case to camelCase --&gt;\n  &lt;svg :view-box.camel=\"viewBox\"&gt;&lt;/svg&gt;\n  &lt;!-- Renders: viewBox attribute --&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nconst objectAttrs = ref({\n  id: 'my-div',\n  class: 'container',\n  'data-value': '123'\n})\n&lt;/script&gt;</code></pre><p><strong>Common mistakes:</strong></p><pre><code>&lt;!-- ❌ WRONG --&gt;\n&lt;img src=\"{{ imageUrl }}\" /&gt;  &lt;!-- {{}} không work trong attributes --&gt;\n&lt;a href=\"{{ url }}\"&gt;Link&lt;/a&gt;  &lt;!-- Phải dùng v-bind --&gt;\n&lt;div class=\"{{ active }}\"&gt;&lt;/div&gt;  &lt;!-- Sai syntax --&gt;\n\n&lt;!-- ❌ WRONG - Dùng v-bind cho text content --&gt;\n&lt;p :text=\"message\"&gt;&lt;/p&gt;  &lt;!-- Không có 'text' attribute --&gt;\n&lt;div :content=\"text\"&gt;&lt;/div&gt;  &lt;!-- Sai cách --&gt;\n\n&lt;!-- ✅ CORRECT --&gt;\n&lt;img :src=\"imageUrl\" /&gt;\n&lt;a :href=\"url\"&gt;Link&lt;/a&gt;\n&lt;div :class=\"active\"&gt;&lt;/div&gt;\n\n&lt;!-- ✅ CORRECT - Dùng {{}} cho text content --&gt;\n&lt;p&gt;{{ message }}&lt;/p&gt;\n&lt;div&gt;{{ text }}&lt;/div&gt;</code></pre><p><strong>Performance considerations:</strong></p><ul><li>Cả {{}} và v-bind đều reactive - auto update khi data thay đổi</li><li>Không có performance difference đáng kể giữa hai cách</li><li>Vue optimize cả hai efficiently trong Virtual DOM</li><li>Dùng v-once nếu data không bao giờ thay đổi để optimize</li></ul><pre><code>&lt;!-- Static content - chỉ render 1 lần --&gt;\n&lt;p v-once&gt;{{ staticMessage }}&lt;/p&gt;\n&lt;img v-once :src=\"logoUrl\" /&gt;</code></pre><p><strong>Best practices:</strong></p><ul><li>✅ Dùng {{}} cho text content trong tags</li><li>✅ Dùng v-bind (:) cho HTML attributes</li><li>✅ Prefer shorthand : thay vì v-bind:</li><li>✅ Auto-escape HTML bằng {{}} (safe by default)</li><li>✅ Chỉ dùng v-html khi absolutely necessary với trusted content</li><li>❌ KHÔNG dùng {{}} trong attributes</li><li>❌ KHÔNG dùng v-html với user input (XSS risk)</li><li>❌ KHÔNG mix string concatenation trong attributes (dùng template literals)</li></ul>",
      "level": "fresher"
    },
    {
      "question": "v-for và :key directive",
      "answer": "<p><strong>v-for:</strong></p><pre><code>&lt;li v-for=\"item in items\" :key=\"item.id\"&gt;\n  {{ item.name }}\n&lt;/li&gt;</code></pre><p><strong>Tại sao cần :key?</strong></p><ul><li>Giúp Vue identify từng node</li><li>Reuse và reorder elements hiệu quả</li><li>Tránh side-effects khi update list</li><li>Maintain component state</li></ul><p><strong>Key best practices:</strong></p><ul><li>Dùng unique, stable ID (không dùng index)</li><li>Không dùng random values</li><li>String hoặc number</li><li>Nhất quán trong app</li></ul><p><strong>Lưu ý:</strong></p><ul><li>Không dùng v-if và v-for cùng element</li><li>v-if có priority cao hơn v-for</li><li>Wrap bằng template nếu cần</li></ul>",
      "level": "fresher"
    },
    {
      "question": "Slot trong Vue.js là gì?",
      "answer": "<p><strong>Default slot:</strong></p><pre><code>// Parent\n&lt;MyComponent&gt;\n  &lt;p&gt;Content here&lt;/p&gt;\n&lt;/MyComponent&gt;\n\n// MyComponent\n&lt;div&gt;\n  &lt;slot /&gt;\n&lt;/div&gt;</code></pre><p><strong>Named slots:</strong></p><pre><code>// Parent\n&lt;MyComponent&gt;\n  &lt;template #header&gt;\n    &lt;h1&gt;Title&lt;/h1&gt;\n  &lt;/template&gt;\n  &lt;template #footer&gt;\n    &lt;p&gt;Footer&lt;/p&gt;\n  &lt;/template&gt;\n&lt;/MyComponent&gt;\n\n// MyComponent\n&lt;div&gt;\n  &lt;slot name=\"header\" /&gt;\n  &lt;slot /&gt; &lt;!-- default --&gt;\n  &lt;slot name=\"footer\" /&gt;\n&lt;/div&gt;</code></pre><p><strong>Scoped slots:</strong></p><pre><code>// Child\n&lt;slot :user=\"user\" :count=\"count\" /&gt;\n\n// Parent\n&lt;template #default=\"{ user, count }\"&gt;\n  {{ user.name }} - {{ count }}\n&lt;/template&gt;</code></pre>",
      "level": "middle"
    },
    {
      "question": "Provide/Inject pattern trong Vue 3?",
      "answer": "<p><strong>Provide/Inject là gì?</strong></p><p>Provide/Inject là cơ chế để truyền dữ liệu từ ancestor component xuống descendant components bất kể cấp độ lồng nhau, không cần props drilling qua nhiều levels.</p><p><strong>Provide (Component cha/ancestor):</strong></p><pre><code>import { provide, ref } from 'vue'\n\n// Provide reactive value\nconst theme = ref('dark')\nprovide('theme', theme)\n\n// Provide object\nprovide('config', {\n  theme: 'dark',\n  apiUrl: 'https://api.example.com'\n})\n\n// Provide với Symbol key (recommended)\nconst ThemeKey = Symbol()\nprovide(ThemeKey, theme)</code></pre><p><strong>Inject (Component con/descendant):</strong></p><pre><code>import { inject } from 'vue'\n\n// Inject value\nconst theme = inject('theme')\n\n// Inject với default value\nconst theme = inject('theme', 'light')\n\n// Inject với Symbol\nconst theme = inject(ThemeKey)</code></pre><p><strong>Use cases thực tế:</strong></p><ul><li><strong>Prop drilling:</strong> Tránh truyền props qua nhiều component levels</li><li><strong>Plugin systems:</strong> Plugin provide services cho toàn app</li><li><strong>Theme/Config:</strong> Chia sẻ theme, i18n, config globally</li><li><strong>Dependency injection:</strong> Inject services như API client, auth</li></ul><p><strong>Lưu ý quan trọng:</strong></p><ul><li><strong>Không thay thế props/emit:</strong> Vẫn dùng props/emit cho parent-child trực tiếp</li><li><strong>Data flow:</strong> Khó trace hơn props, nên document rõ ràng</li><li><strong>TypeScript:</strong> Dùng Symbol keys và type definitions để type-safe</li><li><strong>Reactivity:</strong> Provide ref/reactive để maintain reactivity</li><li><strong>App-level:</strong> Provide ở app.provide() cho global state</li></ul><p><strong>Ví dụ thực tế:</strong></p><pre><code>// App.vue\nconst user = ref(null)\nconst setUser = (newUser) => user.value = newUser\nprovide('user', { user, setUser })\n\n// Bất kỳ component con nào\nconst { user, setUser } = inject('user')</code></pre>",
      "level": "middle"
    },
    {
      "question": "Composables trong Vue 3 là gì?",
      "answer": "<p><strong>Composable là gì?</strong></p><p>Composable là function sử dụng Composition API để đóng gói và tái sử dụng stateful logic. Đây là pattern quan trọng trong Vue 3 giúp chia sẻ logic giữa các components một cách hiệu quả.</p><p><strong>Ví dụ useCounter:</strong></p><pre><code>// composables/useCounter.js\nimport { ref } from 'vue'\n\nexport function useCounter(initialValue = 0) {\n  const count = ref(initialValue)\n  \n  const increment = () => count.value++\n  const decrement = () => count.value--\n  const reset = () => count.value = initialValue\n  \n  return {\n    count,\n    increment,\n    decrement,\n    reset\n  }\n}</code></pre><p><strong>Sử dụng trong component:</strong></p><pre><code>import { useCounter } from '@/composables/useCounter'\n\nconst { count, increment, decrement } = useCounter(10)\n// Có thể dùng ở nhiều components khác nhau</code></pre><p><strong>Best practices khi viết Composables:</strong></p><ul><li><strong>Naming:</strong> Luôn prefix với 'use' (useCounter, useMouse, useFetch)</li><li><strong>Return values:</strong> Return reactive values để components có thể reactivity</li><li><strong>Parameters:</strong> Accept parameters để flexible và reusable</li><li><strong>Cleanup:</strong> Cleanup side effects trong onUnmounted (timers, listeners)</li><li><strong>Single responsibility:</strong> Mỗi composable nên làm một việc và làm tốt</li></ul><p><strong>Lợi ích:</strong></p><ul><li>Tái sử dụng logic dễ dàng giữa các components</li><li>Code dễ test hơn Options API</li><li>TypeScript support tốt</li><li>Tổ chức code theo logic thay vì lifecycle</li></ul>",
      "level": "middle"
    },
    {
      "question": "Pinia vs Vuex: Sự khác biệt?",
      "answer": "<p><strong>Pinia (recommended for Vue 3):</strong></p><ul><li>TypeScript support tốt hơn</li><li>Không cần mutations</li><li>Không cần modules/namespaces</li><li>Đơn giản hơn, ít boilerplate</li><li>Devtools support tốt</li><li>Composition API friendly</li></ul><pre><code>// Pinia store\nimport { defineStore } from 'pinia'\n\nexport const useUserStore = defineStore('user', {\n  state: () => ({\n    name: 'John'\n  }),\n  actions: {\n    updateName(newName) {\n      this.name = newName\n    }\n  }\n})</code></pre><p><strong>Vuex:</strong></p><ul><li>Mature, stable</li><li>Phức tạp hơn (state, mutations, actions, getters)</li><li>Cần commit mutations</li><li>Module system phức tạp</li></ul><p><strong>Migration:</strong> Vue 3 nên dùng Pinia</p>",
      "level": "middle"
    },
    {
      "question": "Làm thế nào để quản lý shared state trong Vue?",
      "answer": "<p><strong>Shared State là gì?</strong></p><p>Shared state là dữ liệu được chia sẻ và sử dụng bởi nhiều components trong ứng dụng. Việc quản lý shared state hiệu quả là quan trọng để tránh prop drilling và maintain data consistency.</p><p><strong>1. Pinia (Recommended - Official State Management):</strong></p><p>Pinia là state management library chính thức cho Vue 3, thay thế Vuex.</p><pre><code>// stores/user.js\nimport { defineStore } from 'pinia'\n\nexport const useUserStore = defineStore('user', {\n  // State\n  state: () => ({\n    user: null,\n    isAuthenticated: false,\n    token: null\n  }),\n  \n  // Getters (like computed)\n  getters: {\n    fullName: (state) => `${state.user?.firstName} ${state.user?.lastName}`,\n    isAdmin: (state) => state.user?.role === 'admin'\n  },\n  \n  // Actions\n  actions: {\n    async login(credentials) {\n      const response = await api.login(credentials)\n      this.user = response.user\n      this.token = response.token\n      this.isAuthenticated = true\n    },\n    \n    logout() {\n      this.user = null\n      this.token = null\n      this.isAuthenticated = false\n    }\n  }\n})\n\n// Sử dụng trong component\nimport { useUserStore } from '@/stores/user'\n\nconst userStore = useUserStore()\n\n// Access state\nconsole.log(userStore.user)\nconsole.log(userStore.fullName) // getter\n\n// Call actions\nuserStore.login({ email, password })\nuserStore.logout()</code></pre><p><strong>Lợi ích của Pinia:</strong></p><ul><li>TypeScript support tuyệt vời</li><li>Không cần mutations (đơn giản hơn Vuex)</li><li>Devtools integration</li><li>Hot module replacement</li><li>Modular by design</li><li>Plugin system</li></ul><p><strong>2. Provide/Inject Pattern:</strong></p><p>Dùng cho shared state trong component tree, không cần external library.</p><pre><code>// App.vue hoặc parent component\nimport { provide, ref, readonly } from 'vue'\n\nconst theme = ref('dark')\nconst setTheme = (newTheme) => {\n  theme.value = newTheme\n}\n\n// Provide state và methods\nprovide('theme', {\n  theme: readonly(theme), // Readonly để tránh mutation trực tiếp\n  setTheme\n})\n\n// Child component (bất kỳ level nào)\nimport { inject } from 'vue'\n\nconst { theme, setTheme } = inject('theme')\n\n// Sử dụng\nconsole.log(theme.value) // 'dark'\nsetTheme('light')</code></pre><p><strong>Advanced Provide/Inject với TypeScript:</strong></p><pre><code>// types/injection-keys.ts\nimport type { InjectionKey, Ref } from 'vue'\n\nexport interface ThemeState {\n  theme: Readonly<Ref<string>>\n  setTheme: (theme: string) => void\n}\n\nexport const ThemeKey: InjectionKey<ThemeState> = Symbol('theme')\n\n// App.vue\nprovide(ThemeKey, {\n  theme: readonly(theme),\n  setTheme\n})\n\n// Child component\nconst themeState = inject(ThemeKey)\nif (themeState) {\n  themeState.setTheme('dark')\n}</code></pre><p><strong>3. Composables với Reactive State:</strong></p><p>Tạo composable với reactive state được share giữa components.</p><pre><code>// composables/useAuth.js\nimport { ref, computed } from 'vue'\n\n// State ngoài function - SHARED across all components\nconst user = ref(null)\nconst token = ref(null)\n\nexport function useAuth() {\n  const isAuthenticated = computed(() => !!user.value)\n  \n  const login = async (credentials) => {\n    const response = await api.login(credentials)\n    user.value = response.user\n    token.value = response.token\n  }\n  \n  const logout = () => {\n    user.value = null\n    token.value = null\n  }\n  \n  return {\n    // State\n    user: readonly(user),\n    token: readonly(token),\n    \n    // Computed\n    isAuthenticated,\n    \n    // Actions\n    login,\n    logout\n  }\n}\n\n// Sử dụng trong nhiều components\n// Component A\nconst { user, login } = useAuth()\nawait login({ email, password })\n\n// Component B - cùng user state\nconst { user, isAuthenticated } = useAuth()\nconsole.log(user.value) // Same user từ Component A</code></pre><p><strong>Lưu ý quan trọng:</strong> State phải được declare NGOÀI composable function để share giữa components.</p><pre><code>// ❌ WRONG - Mỗi component có state riêng\nexport function useCounter() {\n  const count = ref(0) // Mỗi lần gọi tạo count mới\n  return { count }\n}\n\n// ✅ CORRECT - Shared state\nconst count = ref(0) // Shared\nexport function useCounter() {\n  return { count }\n}</code></pre><p><strong>4. Reactive Global Object:</strong></p><p>Tạo global reactive object đơn giản.</p><pre><code>// store/global.js\nimport { reactive } from 'vue'\n\nexport const globalState = reactive({\n  user: null,\n  notifications: [],\n  settings: {\n    theme: 'dark',\n    language: 'vi'\n  }\n})\n\n// Component A\nimport { globalState } from '@/store/global'\n\nglobalState.user = { name: 'John' }\n\n// Component B\nimport { globalState } from '@/store/global'\n\nconsole.log(globalState.user) // { name: 'John' }</code></pre><p><strong>5. Vuex (Legacy - Vẫn được dùng):</strong></p><pre><code>// store/index.js\nimport { createStore } from 'vuex'\n\nconst store = createStore({\n  state: {\n    count: 0,\n    user: null\n  },\n  \n  mutations: {\n    INCREMENT(state) {\n      state.count++\n    },\n    SET_USER(state, user) {\n      state.user = user\n    }\n  },\n  \n  actions: {\n    async fetchUser({ commit }, userId) {\n      const user = await api.getUser(userId)\n      commit('SET_USER', user)\n    }\n  },\n  \n  getters: {\n    isAuthenticated: (state) => !!state.user\n  }\n})\n\n// Component\nimport { useStore } from 'vuex'\n\nconst store = useStore()\n\n// Access state\nstore.state.count\n\n// Commit mutation\nstore.commit('INCREMENT')\n\n// Dispatch action\nstore.dispatch('fetchUser', 123)</code></pre><p><strong>6. Browser Storage (LocalStorage/SessionStorage):</strong></p><pre><code>// utils/storage.js\nexport const storage = {\n  get(key) {\n    const item = localStorage.getItem(key)\n    try {\n      return JSON.parse(item)\n    } catch {\n      return item\n    }\n  },\n  \n  set(key, value) {\n    localStorage.setItem(key, JSON.stringify(value))\n  },\n  \n  remove(key) {\n    localStorage.removeItem(key)\n  }\n}\n\n// Composable với localStorage sync\nimport { ref, watch } from 'vue'\n\nexport function useLocalStorage(key, defaultValue) {\n  const data = ref(storage.get(key) ?? defaultValue)\n  \n  // Auto save khi thay đổi\n  watch(data, (newValue) => {\n    storage.set(key, newValue)\n  }, { deep: true })\n  \n  return data\n}\n\n// Sử dụng\nconst settings = useLocalStorage('settings', {\n  theme: 'dark',\n  language: 'vi'\n})\n\nsettings.value.theme = 'light' // Auto save to localStorage</code></pre><p><strong>7. Event Bus (Không khuyến khích - Legacy pattern):</strong></p><pre><code>// eventBus.js\nimport mitt from 'mitt'\nexport const eventBus = mitt()\n\n// Component A - Emit event\nimport { eventBus } from '@/eventBus'\n\neventBus.emit('user-logged-in', { user })\n\n// Component B - Listen event\nimport { onMounted, onUnmounted } from 'vue'\nimport { eventBus } from '@/eventBus'\n\nconst handleLogin = (data) => {\n  console.log('User logged in:', data.user)\n}\n\nonMounted(() => {\n  eventBus.on('user-logged-in', handleLogin)\n})\n\nonUnmounted(() => {\n  eventBus.off('user-logged-in', handleLogin)\n})</code></pre><p><strong>⚠️ Không nên dùng Event Bus vì:</strong></p><ul><li>Khó debug và trace data flow</li><li>Memory leaks nếu quên cleanup</li><li>Không type-safe</li><li>Prefer Pinia hoặc Provide/Inject</li></ul><p><strong>So sánh các phương pháp:</strong></p><table><tr><th>Method</th><th>Use Case</th><th>Pros</th><th>Cons</th></tr><tr><td><strong>Pinia</strong></td><td>App-wide state, complex state</td><td>TypeScript, Devtools, Modular, Official</td><td>External dependency</td></tr><tr><td><strong>Provide/Inject</strong></td><td>Component tree state</td><td>Built-in, Simple, No deps</td><td>Khó trace, No devtools</td></tr><tr><td><strong>Composables</strong></td><td>Reusable logic + state</td><td>Flexible, Composable, Simple</td><td>Manual setup</td></tr><tr><td><strong>Global Reactive</strong></td><td>Simple global state</td><td>Very simple, No setup</td><td>No structure, No devtools</td></tr><tr><td><strong>Vuex</strong></td><td>Legacy projects</td><td>Mature, Proven</td><td>Verbose, Mutations overhead</td></tr><tr><td><strong>LocalStorage</strong></td><td>Persistent data</td><td>Survives reload</td><td>String only, Size limit</td></tr></table><p><strong>Khi nào dùng cái nào?</strong></p><ul><li><strong>Dùng Pinia khi:</strong> App lớn, cần state management professional, TypeScript, multiple stores, devtools</li><li><strong>Dùng Provide/Inject khi:</strong> State trong component tree, plugin system, theme/config sharing</li><li><strong>Dùng Composables khi:</strong> Shared logic + state, không quá phức tạp, cần flexibility</li><li><strong>Dùng Global Reactive khi:</strong> App nhỏ, prototype, state đơn giản</li><li><strong>Dùng Vuex khi:</strong> Legacy project hoặc team đã quen Vuex</li><li><strong>Dùng LocalStorage khi:</strong> Cần persist data, settings, cache</li></ul><p><strong>Best Practices:</strong></p><ul><li>✅ Prefer Pinia cho production apps</li><li>✅ Dùng Provide/Inject cho plugin và themes</li><li>✅ Composables cho reusable logic</li><li>✅ Readonly() để prevent direct mutations</li><li>✅ TypeScript với InjectionKey cho type safety</li><li>❌ KHÔNG dùng Event Bus (deprecated pattern)</li><li>❌ KHÔNG mutate state trực tiếp (dùng actions/methods)</li><li>❌ KHÔNG mix nhiều patterns trong cùng app</li></ul><p><strong>Example: Combine Pinia + Composables:</strong></p><pre><code>// store/cart.js - Pinia for app-wide state\nexport const useCartStore = defineStore('cart', {\n  state: () => ({\n    items: []\n  }),\n  actions: {\n    addItem(item) {\n      this.items.push(item)\n    }\n  }\n})\n\n// composables/useCheckout.js - Composable for logic\nimport { useCartStore } from '@/store/cart'\n\nexport function useCheckout() {\n  const cartStore = useCartStore()\n  \n  const checkout = async () => {\n    await api.checkout(cartStore.items)\n    cartStore.items = []\n  }\n  \n  return { checkout }\n}\n\n// Component - Clean separation\nconst cartStore = useCartStore()\nconst { checkout } = useCheckout()\n\nawait checkout()</code></pre>",
      "level": "middle"
    },
    {
      "question": "Async Components và Code Splitting trong Vue?",
      "answer": "<p><strong>Async Components là gì?</strong></p><p>Async components cho phép lazy load components chỉ khi cần thiết, giúp giảm bundle size ban đầu và tăng performance.</p><p><strong>Cách sử dụng cơ bản:</strong></p><pre><code>import { defineAsyncComponent } from 'vue'\n\n// Lazy load component\nconst AsyncComp = defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n)\n\n// Dùng như component bình thường\n&lt;AsyncComp /&gt;</code></pre><p><strong>Với loading và error states:</strong></p><pre><code>const AsyncComp = defineAsyncComponent({\n  // Loader function\n  loader: () => import('./MyComponent.vue'),\n  \n  // Component hiển thị khi đang load\n  loadingComponent: LoadingSpinner,\n  \n  // Component hiển thị khi có lỗi\n  errorComponent: ErrorComponent,\n  \n  // Delay trước khi show loading (ms)\n  delay: 200,\n  \n  // Timeout nếu load quá lâu (ms)\n  timeout: 3000\n})</code></pre><p><strong>Route-based code splitting:</strong></p><p>Chia code theo routes để mỗi page load riêng chunk:</p><pre><code>const routes = [\n  {\n    path: '/users',\n    // Lazy load route component\n    component: () => import('./views/Users.vue')\n  },\n  {\n    path: '/admin',\n    component: () => import('./views/Admin.vue')\n  }\n]</code></pre><p><strong>Benefits (Lợi ích):</strong></p><ul><li><strong>Smaller initial bundle:</strong> Giảm bundle size ban đầu, load nhanh hơn</li><li><strong>Lazy loading:</strong> Chỉ load khi user cần (vào route, click button)</li><li><strong>Better performance:</strong> Faster Time to Interactive (TTI)</li><li><strong>Parallel loading:</strong> Browser có thể load nhiều chunks song song</li><li><strong>Better caching:</strong> Chunks ít thay đổi được cache lâu hơn</li></ul><p><strong>Khi nào nên dùng:</strong></p><ul><li>Components lớn, ít dùng (modals, admin panels)</li><li>Route-based splitting cho SPA</li><li>Third-party heavy components (charts, editors)</li></ul>",
      "level": "middle"
    },
    {
      "question": "Custom Directives trong Vue?",
      "answer": "<p><strong>Custom Directives là gì?</strong></p><p>Custom directives cho phép tạo các directives riêng để tái sử dụng DOM manipulation logic. Khác với components (quản lý data và template), directives tập trung vào low-level DOM operations.</p><p><strong>Tạo directive đơn giản:</strong></p><pre><code>// directives/focus.js\nexport const vFocus = {\n  // Tự động focus khi element mounted\n  mounted(el) {\n    el.focus()\n  }\n}</code></pre><p><strong>Directive với lifecycle đầy đủ:</strong></p><pre><code>export const vColor = {\n  // Trước khi mount\n  beforeMount(el, binding) {\n    el.style.color = binding.value\n  },\n  \n  // Khi data update\n  updated(el, binding) {\n    // binding.value là giá trị mới\n    // binding.oldValue là giá trị cũ\n    el.style.color = binding.value\n  }\n}</code></pre><p><strong>Sử dụng directive:</strong></p><pre><code>&lt;!-- Local registration --&gt;\n&lt;script setup&gt;\nimport { vFocus } from './directives/focus'\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;input v-focus /&gt;\n  &lt;p v-color=\"'red'\"&gt;Red text&lt;/p&gt;\n&lt;/template&gt;</code></pre><p><strong>Register global directive:</strong></p><pre><code>// main.js\nimport { vFocus } from './directives/focus'\n\napp.directive('focus', vFocus)\n// Dùng ở mọi nơi: &lt;input v-focus /&gt;</code></pre><p><strong>Directive Lifecycle hooks:</strong></p><ul><li><code>beforeMount</code> - Trước khi element mount</li><li><code>mounted</code> - Element đã mount, có thể access DOM</li><li><code>beforeUpdate</code> - Trước khi component update</li><li><code>updated</code> - Sau khi component updated</li><li><code>beforeUnmount</code> - Trước khi unmount</li><li><code>unmounted</code> - Cleanup khi unmount</li></ul><p><strong>Directive arguments và modifiers:</strong></p><pre><code>// &lt;div v-example:arg.modifier=\"value\"&gt;\napp.directive('example', {\n  mounted(el, binding) {\n    console.log(binding.arg)      // 'arg'\n    console.log(binding.modifiers) // { modifier: true }\n    console.log(binding.value)     // 'value'\n  }\n})</code></pre><p><strong>Use cases:</strong></p><ul><li>Auto-focus inputs</li><li>Click outside detection</li><li>Scroll behavior</li><li>Tooltips</li><li>Lazy loading images</li><li>Permission-based element hiding</li></ul>",
      "level": "middle"
    },
    {
      "question": "Teleport trong Vue 3?",
      "answer": "<p><strong>Teleport:</strong> Render component content ở nơi khác trong DOM tree, outside component hierarchy.</p><pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;My Component&lt;/h1&gt;\n    \n    &lt;Teleport to=\"body\"&gt;\n      &lt;div class=\"modal\"&gt;\n        Modal content\n      &lt;/div&gt;\n    &lt;/Teleport&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre><p><strong>Use cases:</strong></p><ul><li>Modals</li><li>Tooltips</li><li>Notifications</li><li>Full-screen components</li></ul><p><strong>Multiple Teleports:</strong></p><pre><code>&lt;Teleport to=\"#modal-container\"&gt;\n  &lt;Modal /&gt;\n&lt;/Teleport&gt;\n\n&lt;Teleport to=\"#toast-container\"&gt;\n  &lt;Toast /&gt;\n&lt;/Teleport&gt;</code></pre><p><strong>Disabled prop:</strong></p><pre><code>&lt;Teleport to=\"body\" :disabled=\"isMobile\"&gt;\n  &lt;Modal /&gt;\n&lt;/Teleport&gt;</code></pre>",
      "level": "middle"
    },
    {
      "question": "Suspense trong Vue 3?",
      "answer": "<p><strong>Suspense:</strong> Handle async dependencies trong component tree.</p><pre><code>&lt;Suspense&gt;\n  &lt;template #default&gt;\n    &lt;AsyncComponent /&gt;\n  &lt;/template&gt;\n  \n  &lt;template #fallback&gt;\n    &lt;LoadingSpinner /&gt;\n  &lt;/template&gt;\n&lt;/Suspense&gt;</code></pre><p><strong>Với async setup:</strong></p><pre><code>// AsyncComponent.vue\n&lt;script setup&gt;\nconst data = await fetch('/api/data')\n&lt;/script&gt;</code></pre><p><strong>Multiple async components:</strong></p><pre><code>&lt;Suspense&gt;\n  &lt;template #default&gt;\n    &lt;UserProfile /&gt;\n    &lt;UserPosts /&gt;\n    &lt;UserComments /&gt;\n  &lt;/template&gt;\n  \n  &lt;template #fallback&gt;\n    &lt;Loading /&gt;\n  &lt;/template&gt;\n&lt;/Suspense&gt;</code></pre><p><strong>Error handling:</strong></p><pre><code>import { onErrorCaptured } from 'vue'\n\nonErrorCaptured((err) =&gt; {\n  console.error('Async error:', err)\n  return false\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "Reactivity Transform và $ref, $computed?",
      "answer": "<p><strong>Note:</strong> Reactivity Transform đã bị deprecated trong Vue 3.3, nhưng vẫn hữu ích để biết.</p><p><strong>$ref (trước đây):</strong></p><pre><code>// Thay vì\nconst count = ref(0)\nconsole.log(count.value)\n\n// Dùng $ref\nlet count = $ref(0)\nconsole.log(count) // no .value needed</code></pre><p><strong>$computed:</strong></p><pre><code>let double = $computed(() => count * 2)</code></pre><p><strong>Tại sao deprecated?</strong></p><ul><li>Cognitive overhead</li><li>Khác biệt giữa compile-time và runtime</li><li>TypeScript integration issues</li><li>Confusion cho developers</li></ul><p><strong>Alternative:</strong> Dùng ref/reactive như bình thường</p>",
      "level": "senior"
    },
    {
      "question": "Performance Optimization trong Vue?",
      "answer": "<p><strong>1. v-once:</strong></p><pre><code>&lt;div v-once&gt;{{ heavyComputation() }}&lt;/div&gt;</code></pre><p><strong>2. v-memo (Vue 3.2+):</strong></p><pre><code>&lt;div v-memo=\"[valueA, valueB]\"&gt;\n  Only re-render when valueA or valueB changes\n&lt;/div&gt;</code></pre><p><strong>3. Computed caching:</strong></p><pre><code>const filtered = computed(() => \n  items.value.filter(i => i.active)\n)</code></pre><p><strong>4. Virtual scrolling:</strong></p><ul><li>Dùng thư viện vue-virtual-scroller</li><li>Render only visible items</li></ul><p><strong>5. Lazy loading:</strong></p><ul><li>Code splitting</li><li>Route-based chunks</li><li>Async components</li></ul><p><strong>6. KeepAlive:</strong></p><pre><code>&lt;KeepAlive&gt;\n  &lt;component :is=\"currentView\" /&gt;\n&lt;/KeepAlive&gt;</code></pre><p><strong>7. Shallow reactive:</strong></p><pre><code>import { shallowRef, shallowReactive } from 'vue'\nconst state = shallowReactive({ deep: { object: 1 } })</code></pre>",
      "level": "senior"
    },
    {
      "question": "Làm thế nào để tối ưu một Vue app chạy chậm?",
      "answer": "<p><strong>Tổng quan về Performance Optimization:</strong></p><p>Khi Vue app chạy chậm, cần identify bottlenecks và áp dụng optimizations phù hợp. Dưới đây là checklist đầy đủ từ detection đến solutions.</p><p><strong>BƯỚC 1: PHÁT HIỆN VẤN ĐỀ (Detection & Profiling)</strong></p><p><strong>1.1. Vue DevTools Performance:</strong></p><pre><code>// Enable performance tracking\napp.config.performance = true\n\n// Trong Vue DevTools:\n// - Performance tab: xem component render times\n// - Timeline: track events, lifecycle, updates\n// - Component inspector: check re-renders</code></pre><p><strong>1.2. Chrome DevTools:</strong></p><ul><li><strong>Performance tab:</strong> Record và analyze CPU usage, rendering</li><li><strong>Lighthouse:</strong> Overall performance score và suggestions</li><li><strong>Network tab:</strong> Check bundle sizes, load times</li><li><strong>Memory tab:</strong> Detect memory leaks</li></ul><p><strong>1.3. Debug render triggers:</strong></p><pre><code>import { onRenderTracked, onRenderTriggered } from 'vue'\n\n// Track mọi dependency\nonRenderTracked((event) => {\n  console.log('Tracked:', event)\n})\n\n// Log khi component re-render\nonRenderTriggered((event) => {\n  console.log('Re-render triggered by:', event)\n  console.log('Key:', event.key)\n  console.log('Type:', event.type) // 'get', 'set', etc.\n})</code></pre><p><strong>BƯỚC 2: COMPONENT OPTIMIZATION</strong></p><p><strong>2.1. v-once cho static content:</strong></p><pre><code>&lt;!-- Content không bao giờ thay đổi --&gt;\n&lt;div v-once&gt;\n  &lt;h1&gt;{{ staticTitle }}&lt;/h1&gt;\n  &lt;p&gt;{{ staticDescription }}&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;!-- Tránh re-render unnecessarily --&gt;\n&lt;footer v-once&gt;\n  &lt;p&gt;© 2024 Company Name&lt;/p&gt;\n&lt;/footer&gt;</code></pre><p><strong>2.2. v-memo (Vue 3.2+) - Conditional re-render:</strong></p><pre><code>&lt;!-- Chỉ re-render khi valueA hoặc valueB thay đổi --&gt;\n&lt;div v-memo=\"[valueA, valueB]\"&gt;\n  &lt;p&gt;{{ expensiveComputation(valueA, valueB) }}&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;!-- List items với v-memo --&gt;\n&lt;div \n  v-for=\"item in list\" \n  :key=\"item.id\"\n  v-memo=\"[item.id, item.selected]\"\n&gt;\n  &lt;!-- Chỉ re-render khi id hoặc selected thay đổi --&gt;\n  &lt;p&gt;{{ item.name }}&lt;/p&gt;\n&lt;/div&gt;</code></pre><p><strong>2.3. Computed caching thay vì methods:</strong></p><pre><code>// ❌ BAD - Gọi mỗi lần render\n&lt;template&gt;\n  &lt;div&gt;{{ filterItems() }}&lt;/div&gt;\n&lt;/template&gt;\n\nconst filterItems = () => {\n  // Chạy mỗi render cycle\n  return items.value.filter(i => i.active)\n}\n\n// ✅ GOOD - Cached, chỉ re-compute khi items thay đổi\nconst filteredItems = computed(() => {\n  return items.value.filter(i => i.active)\n})\n\n&lt;template&gt;\n  &lt;div&gt;{{ filteredItems }}&lt;/div&gt;\n&lt;/template&gt;</code></pre><p><strong>2.4. Shallow reactivity cho large objects:</strong></p><pre><code>import { shallowRef, shallowReactive } from 'vue'\n\n// ❌ BAD - Deep reactivity cho large array\nconst largeList = reactive([\n  { id: 1, data: { /* nested */ } },\n  // ... 10000 items\n])\n\n// ✅ GOOD - Shallow reactivity\nconst largeList = shallowReactive([\n  { id: 1, data: { /* nested */ } },\n  // ... 10000 items\n])\n// Chỉ track array itself, không track nested properties\n\n// Hoặc shallowRef cho objects\nconst config = shallowRef({\n  deep: { nested: { object: 'value' } }\n})\n// Chỉ trigger update khi replace toàn bộ object</code></pre><p><strong>BƯỚC 3: LIST RENDERING OPTIMIZATION</strong></p><p><strong>3.1. Virtual scrolling cho long lists:</strong></p><pre><code>// npm install vue-virtual-scroller\nimport { RecycleScroller } from 'vue-virtual-scroller'\nimport 'vue-virtual-scroller/dist/vue-virtual-scroller.css'\n\n&lt;template&gt;\n  &lt;RecycleScroller\n    :items=\"items\"\n    :item-size=\"50\"\n    key-field=\"id\"\n    v-slot=\"{ item }\"\n  &gt;\n    &lt;div class=\"item\"&gt;\n      {{ item.name }}\n    &lt;/div&gt;\n  &lt;/RecycleScroller&gt;\n&lt;/template&gt;\n\n&lt;!-- Chỉ render visible items thay vì 10000 items --&gt;</code></pre><p><strong>3.2. Pagination/Infinite scroll:</strong></p><pre><code>const pageSize = 50\nconst currentPage = ref(1)\n\nconst displayedItems = computed(() => {\n  const start = (currentPage.value - 1) * pageSize\n  const end = start + pageSize\n  return allItems.value.slice(start, end)\n})\n\n// Infinite scroll\nconst loadMore = () => {\n  currentPage.value++\n}</code></pre><p><strong>3.3. Proper :key usage:</strong></p><pre><code>// ❌ BAD - Dùng index\n&lt;div v-for=\"(item, index) in items\" :key=\"index\"&gt;\n  &lt;!-- Vue không track correctly khi items reorder --&gt;\n&lt;/div&gt;\n\n// ✅ GOOD - Dùng unique ID\n&lt;div v-for=\"item in items\" :key=\"item.id\"&gt;\n  &lt;!-- Vue có thể reuse DOM efficiently --&gt;\n&lt;/div&gt;</code></pre><p><strong>BƯỚC 4: CODE SPLITTING & LAZY LOADING</strong></p><p><strong>4.1. Route-based code splitting:</strong></p><pre><code>const routes = [\n  {\n    path: '/',\n    component: () => import('./views/Home.vue')\n  },\n  {\n    path: '/dashboard',\n    // Lazy load heavy components\n    component: () => import('./views/Dashboard.vue')\n  },\n  {\n    path: '/admin',\n    // Load only when user accesses\n    component: () => import('./views/Admin.vue')\n  }\n]</code></pre><p><strong>4.2. Async components:</strong></p><pre><code>import { defineAsyncComponent } from 'vue'\n\n// Lazy load heavy component\nconst HeavyChart = defineAsyncComponent(() =>\n  import('./components/HeavyChart.vue')\n)\n\n// Với loading state\nconst AsyncModal = defineAsyncComponent({\n  loader: () => import('./components/Modal.vue'),\n  loadingComponent: LoadingSpinner,\n  delay: 200,\n  errorComponent: ErrorDisplay\n})</code></pre><p><strong>4.3. Dynamic imports:</strong></p><pre><code>// Chỉ load khi cần\nconst loadEditor = async () => {\n  const { Editor } = await import('./heavy-editor')\n  return new Editor()\n}\n\nconst handleEditClick = async () => {\n  const editor = await loadEditor()\n  editor.open()\n}</code></pre><p><strong>BƯỚC 5: BUNDLE OPTIMIZATION</strong></p><p><strong>5.1. Analyze bundle size:</strong></p><pre><code>// vite.config.js\nimport { visualizer } from 'rollup-plugin-visualizer'\n\nexport default {\n  plugins: [\n    visualizer({\n      open: true,\n      gzipSize: true,\n      brotliSize: true\n    })\n  ]\n}</code></pre><p><strong>5.2. Tree shaking:</strong></p><pre><code>// ❌ BAD - Import toàn bộ library\nimport _ from 'lodash'\n_.debounce(fn, 100)\n\n// ✅ GOOD - Import specific function\nimport debounce from 'lodash/debounce'\ndebounce(fn, 100)\n\n// Hoặc dùng lodash-es\nimport { debounce } from 'lodash-es'</code></pre><p><strong>5.3. Remove unused code:</strong></p><pre><code>// vite.config.js\nexport default {\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          'vendor': ['vue', 'vue-router'],\n          'charts': ['chart.js', 'vue-chartjs']\n        }\n      }\n    }\n  }\n}</code></pre><p><strong>BƯỚC 6: DATA FETCHING OPTIMIZATION</strong></p><p><strong>6.1. Debounce/Throttle API calls:</strong></p><pre><code>import { debounce } from 'lodash-es'\n\nconst searchQuery = ref('')\n\n// Debounce search API\nconst debouncedSearch = debounce(async (query) => {\n  const results = await api.search(query)\n  searchResults.value = results\n}, 300)\n\nwatch(searchQuery, (newQuery) => {\n  debouncedSearch(newQuery)\n})</code></pre><p><strong>6.2. Cache API responses:</strong></p><pre><code>const cache = new Map()\n\nconst fetchData = async (id) => {\n  if (cache.has(id)) {\n    return cache.get(id)\n  }\n  \n  const data = await api.fetch(id)\n  cache.set(id, data)\n  return data\n}</code></pre><p><strong>6.3. Parallel requests:</strong></p><pre><code>// ❌ BAD - Sequential\nconst user = await fetchUser()\nconst posts = await fetchPosts()\nconst comments = await fetchComments()\n\n// ✅ GOOD - Parallel\nconst [user, posts, comments] = await Promise.all([\n  fetchUser(),\n  fetchPosts(),\n  fetchComments()\n])</code></pre><p><strong>BƯỚC 7: REACTIVITY OPTIMIZATION</strong></p><p><strong>7.1. Tránh unnecessary reactivity:</strong></p><pre><code>// ❌ BAD - Constants không cần reactive\nconst config = reactive({\n  API_URL: 'https://api.example.com',\n  MAX_RETRIES: 3\n})\n\n// ✅ GOOD - Plain object cho constants\nconst config = {\n  API_URL: 'https://api.example.com',\n  MAX_RETRIES: 3\n}</code></pre><p><strong>7.2. markRaw cho non-reactive data:</strong></p><pre><code>import { markRaw } from 'vue'\n\n// Heavy third-party instance không cần reactive\nconst editor = markRaw(new HeavyEditor())\n\n// Large data structures\nconst largeData = markRaw({\n  // Thousands of objects\n})</code></pre><p><strong>7.3. Batch updates:</strong></p><pre><code>// ❌ BAD - Multiple reactive updates\ncount.value++\nname.value = 'John'\nactive.value = true\n// 3 separate re-renders\n\n// ✅ GOOD - Batch với nextTick\nimport { nextTick } from 'vue'\n\ncount.value++\nname.value = 'John'\nactive.value = true\nawait nextTick()\n// 1 re-render cho tất cả changes</code></pre><p><strong>BƯỚC 8: DOM OPTIMIZATION</strong></p><p><strong>8.1. v-show vs v-if:</strong></p><pre><code>// Toggle thường xuyên - dùng v-show\n&lt;Modal v-show=\"isOpen\" /&gt;\n\n// Conditional render ít khi - dùng v-if\n&lt;AdminPanel v-if=\"isAdmin\" /&gt;</code></pre><p><strong>8.2. KeepAlive cho expensive components:</strong></p><pre><code>&lt;KeepAlive :max=\"10\"&gt;\n  &lt;component :is=\"currentView\" /&gt;\n&lt;/KeepAlive&gt;\n\n&lt;!-- Với routes --&gt;\n&lt;router-view v-slot=\"{ Component }\"&gt;\n  &lt;KeepAlive&gt;\n    &lt;component :is=\"Component\" /&gt;\n  &lt;/KeepAlive&gt;\n&lt;/router-view&gt;</code></pre><p><strong>8.3. Functional components cho presentational:</strong></p><pre><code>// Simple presentational component\nconst ListItem = (props) => {\n  return h('div', { class: 'item' }, props.text)\n}\n\n// No reactive overhead</code></pre><p><strong>BƯỚC 9: IMAGE & ASSET OPTIMIZATION</strong></p><p><strong>9.1. Lazy load images:</strong></p><pre><code>&lt;img \n  :src=\"imageSrc\" \n  loading=\"lazy\"\n  decoding=\"async\"\n/&gt;\n\n&lt;!-- Hoặc dùng directive --&gt;\n&lt;img v-lazy=\"imageSrc\" /&gt;</code></pre><p><strong>9.2. Image optimization:</strong></p><pre><code>// vite.config.js\nimport viteImagemin from 'vite-plugin-imagemin'\n\nexport default {\n  plugins: [\n    viteImagemin({\n      gifsicle: { optimizationLevel: 3 },\n      mozjpeg: { quality: 80 },\n      pngquant: { quality: [0.8, 0.9] },\n      svgo: { plugins: [{ removeViewBox: false }] }\n    })\n  ]\n}</code></pre><p><strong>9.3. WebP/AVIF formats:</strong></p><pre><code>&lt;picture&gt;\n  &lt;source srcset=\"image.avif\" type=\"image/avif\" /&gt;\n  &lt;source srcset=\"image.webp\" type=\"image/webp\" /&gt;\n  &lt;img src=\"image.jpg\" alt=\"Fallback\" /&gt;\n&lt;/picture&gt;</code></pre><p><strong>BƯỚC 10: MEMORY LEAK PREVENTION</strong></p><p><strong>10.1. Cleanup trong onUnmounted:</strong></p><pre><code>import { onMounted, onUnmounted } from 'vue'\n\nconst interval = ref(null)\n\nonMounted(() => {\n  interval.value = setInterval(() => {\n    // Do something\n  }, 1000)\n})\n\nonUnmounted(() => {\n  // ✅ CRITICAL - Clear interval\n  if (interval.value) {\n    clearInterval(interval.value)\n  }\n})</code></pre><p><strong>10.2. Remove event listeners:</strong></p><pre><code>const handleResize = () => { /* ... */ }\n\nonMounted(() => {\n  window.addEventListener('resize', handleResize)\n})\n\nonUnmounted(() => {\n  // ✅ Remove listener\n  window.removeEventListener('resize', handleResize)\n})</code></pre><p><strong>10.3. Cancel pending requests:</strong></p><pre><code>const controller = new AbortController()\n\nconst fetchData = async () => {\n  const response = await fetch('/api/data', {\n    signal: controller.signal\n  })\n  return response.json()\n}\n\nonUnmounted(() => {\n  // Cancel pending requests\n  controller.abort()\n})</code></pre><p><strong>PERFORMANCE CHECKLIST:</strong></p><table><tr><th>Category</th><th>Technique</th><th>Impact</th></tr><tr><td>Rendering</td><td>v-once, v-memo, computed</td><td>🔥 High</td></tr><tr><td>Lists</td><td>Virtual scrolling, pagination</td><td>🔥 High</td></tr><tr><td>Code</td><td>Lazy loading, code splitting</td><td>🔥 High</td></tr><tr><td>Bundle</td><td>Tree shaking, manual chunks</td><td>🟡 Medium</td></tr><tr><td>Data</td><td>Debounce, cache, parallel</td><td>🔥 High</td></tr><tr><td>Reactivity</td><td>Shallow, markRaw, batch</td><td>🟡 Medium</td></tr><tr><td>DOM</td><td>v-show, KeepAlive</td><td>🟢 Low-Medium</td></tr><tr><td>Assets</td><td>Lazy images, WebP, optimize</td><td>🟡 Medium</td></tr><tr><td>Memory</td><td>Cleanup, remove listeners</td><td>🔥 Critical</td></tr></table><p><strong>Quick wins (Low effort, High impact):</strong></p><ul><li>✅ Enable production mode build</li><li>✅ Add v-once cho static content</li><li>✅ Dùng computed thay vì methods</li><li>✅ Lazy load routes</li><li>✅ Add loading=\"lazy\" cho images</li><li>✅ Cleanup trong onUnmounted</li></ul><p><strong>Tools để monitor:</strong></p><ul><li>Vue DevTools (Performance, Timeline)</li><li>Chrome DevTools (Performance, Lighthouse)</li><li>webpack-bundle-analyzer / rollup-plugin-visualizer</li><li>Google PageSpeed Insights</li><li>WebPageTest</li></ul>",
      "level": "senior"
    },
    {
      "question": "Vue Router: Navigation Guards?",
      "answer": "<p><strong>Global guards:</strong></p><pre><code>// beforeEach\nrouter.beforeEach((to, from, next) => {\n  if (to.meta.requiresAuth && !isAuthenticated) {\n    next('/login')\n  } else {\n    next()\n  }\n})\n\n// afterEach\nrouter.afterEach((to, from) => {\n  document.title = to.meta.title\n})</code></pre><p><strong>Per-route guards:</strong></p><pre><code>{\n  path: '/admin',\n  component: Admin,\n  beforeEnter: (to, from, next) => {\n    if (hasAdminRole()) next()\n    else next('/forbidden')\n  }\n}</code></pre><p><strong>In-component guards:</strong></p><pre><code>// Options API\nexport default {\n  beforeRouteEnter(to, from, next) {},\n  beforeRouteUpdate(to, from, next) {},\n  beforeRouteLeave(to, from, next) {}\n}\n\n// Composition API\nimport { onBeforeRouteLeave } from 'vue-router'\n\nonBeforeRouteLeave((to, from) => {\n  const answer = window.confirm('Unsaved changes!')\n  if (!answer) return false\n})</code></pre>",
      "level": "middle"
    },
    {
      "question": "defineModel trong Vue 3.3+?",
      "answer": "<p><strong>defineModel:</strong> Simplified v-model implementation</p><p><strong>Trước Vue 3.3:</strong></p><pre><code>const props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n\nconst value = computed({\n  get: () => props.modelValue,\n  set: (val) => emit('update:modelValue', val)\n})</code></pre><p><strong>Với defineModel:</strong></p><pre><code>const model = defineModel()\n// That's it!</code></pre><p><strong>Multiple v-models:</strong></p><pre><code>const firstName = defineModel('firstName')\nconst lastName = defineModel('lastName')\n\n// Usage\n&lt;MyComponent \n  v-model:firstName=\"first\" \n  v-model:lastName=\"last\" \n/&gt;</code></pre><p><strong>With options:</strong></p><pre><code>const model = defineModel({\n  type: String,\n  required: true,\n  default: ''\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "Testing Vue Components?",
      "answer": "<p><strong>Vue Test Utils:</strong></p><pre><code>import { mount } from '@vue/test-utils'\nimport MyComponent from './MyComponent.vue'\n\ntest('renders message', () => {\n  const wrapper = mount(MyComponent, {\n    props: { msg: 'Hello' }\n  })\n  \n  expect(wrapper.text()).toContain('Hello')\n})</code></pre><p><strong>Testing user interaction:</strong></p><pre><code>test('button click', async () => {\n  const wrapper = mount(Counter)\n  \n  await wrapper.find('button').trigger('click')\n  \n  expect(wrapper.find('.count').text()).toBe('1')\n})</code></pre><p><strong>Testing Composables:</strong></p><pre><code>import { useCounter } from './useCounter'\n\ntest('useCounter', () => {\n  const { count, increment } = useCounter()\n  \n  expect(count.value).toBe(0)\n  increment()\n  expect(count.value).toBe(1)\n})</code></pre><p><strong>Mocking:</strong></p><pre><code>const wrapper = mount(MyComponent, {\n  global: {\n    mocks: {\n      $route: { params: { id: '1' } }\n    },\n    stubs: ['RouterLink']\n  }\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "Server-Side Rendering với Vue?",
      "answer": "<p><strong>Benefits của SSR:</strong></p><ul><li>Better SEO</li><li>Faster initial load</li><li>Better social media sharing</li></ul><p><strong>Nuxt.js:</strong> Framework cho Vue SSR</p><pre><code>// pages/index.vue\r\nexport default {\r\n  async asyncData() {\r\n    const data = await $fetch('/api/data')\r\n    return { data }\r\n  }\r\n}</code></pre><p><strong>Hydration:</strong></p><ul><li>Server render HTML</li><li>Client hydrate thành interactive app</li><li>Tránh hydration mismatch</li></ul><p><strong>Vite SSR:</strong></p><pre><code>// server.js\r\nimport { createSSRApp } from 'vue'\r\nimport { renderToString } from 'vue/server-renderer'\r\n\r\nconst app = createSSRApp(App)\r\nconst html = await renderToString(app)</code></pre><p><strong>Lưu ý:</strong></p><ul><li>Không dùng window, document trong setup</li><li>Lifecycle hooks khác nhau</li><li>State management cần special handling</li></ul>",
      "level": "senior"
    },
    {
      "question": "TypeScript với Vue 3?",
      "answer": "<p><strong>defineComponent:</strong></p><pre><code>import { defineComponent } from 'vue'\n\nexport default defineComponent({\n  props: {\n    name: String,\n    count: Number\n  },\n  setup(props) {\n    // props is typed\n    console.log(props.name)\n  }\n})</code></pre><p><strong>Script setup với TypeScript:</strong></p><pre><code>&lt;script setup lang=\"ts\"&gt;\ninterface Props {\n  name: string\n  count?: number\n}\n\nconst props = defineProps&lt;Props&gt;()\n\nconst emit = defineEmits&lt;{\n  update: [value: string]\n  delete: [id: number]\n}&gt;()\n&lt;/script&gt;</code></pre><p><strong>Composables typing:</strong></p><pre><code>export function useUser() {\n  const user = ref&lt;User | null&gt;(null)\n  \n  const login = async (credentials: Credentials): Promise&lt;void&gt; => {\n    user.value = await api.login(credentials)\n  }\n  \n  return { user, login }\n}</code></pre>",
      "level": "senior"
    },
    {
      "question": "Khi nào không nên dùng Vue?",
      "answer": "<p><strong>Vue không phù hợp khi:</strong></p><ul><li><strong>App cực kỳ phức tạp:</strong> React/Angular có ecosystem lớn hơn cho enterprise</li><li><strong>Native mobile chủ yếu:</strong> React Native mature hơn</li><li><strong>Team đã expertise framework khác:</strong> Switching cost cao</li><li><strong>Cần strong typing từ đầu:</strong> Angular có TypeScript built-in sâu hơn</li><li><strong>Corporate backing quan trọng:</strong> React (Meta), Angular (Google) vs Vue (community-driven)</li></ul><p><strong>Vue phù hợp khi:</strong></p><ul><li>Cần learning curve thấp</li><li>Team nhỏ, prototype nhanh</li><li>Progressive enhancement</li><li>Balance giữa flexibility và structure</li><li>Documentation quality quan trọng</li></ul>",
      "level": "senior"
    },
    {
      "question": "Security best practices trong Vue?",
      "answer": "<p><strong>1. XSS Prevention:</strong></p><ul><li>Vue tự động escape HTML trong {{ }}</li><li>KHÔNG dùng v-html với user input</li><li>Sanitize data trước khi render</li></ul><pre><code>// BAD\n&lt;div v-html=\"userInput\"&gt;&lt;/div&gt;\n\n// GOOD\n&lt;div&gt;{{ sanitize(userInput) }}&lt;/div&gt;</code></pre><p><strong>2. CSRF Protection:</strong></p><ul><li>Dùng CSRF tokens</li><li>SameSite cookies</li><li>Verify origin headers</li></ul><p><strong>3. Authentication:</strong></p><ul><li>NEVER store tokens trong localStorage (XSS risk)</li><li>Dùng HttpOnly cookies</li><li>Implement proper session management</li></ul><p><strong>4. API Security:</strong></p><ul><li>Validate inputs</li><li>Rate limiting</li><li>CORS configuration</li><li>HTTPS only</li></ul><p><strong>5. Dependencies:</strong></p><ul><li>Regular updates</li><li>Audit npm packages</li><li>Use lock files</li></ul>",
      "level": "senior"
    },
    {
      "question": "Error Handling trong Vue?",
      "answer": "<p><strong>Global error handler:</strong></p><pre><code>const app = createApp(App)\n\napp.config.errorHandler = (err, instance, info) => {\n  console.error('Global error:', err)\n  console.log('Component:', instance)\n  console.log('Error info:', info)\n  // Send to logging service\n}</code></pre><p><strong>Component error boundary:</strong></p><pre><code>import { onErrorCaptured } from 'vue'\n\nonErrorCaptured((err, instance, info) => {\n  console.error('Caught error:', err)\n  // Return false to stop propagation\n  return false\n})</code></pre><p><strong>Async error handling:</strong></p><pre><code>const fetchData = async () => {\n  try {\n    const data = await api.getData()\n    return data\n  } catch (error) {\n    console.error('Fetch error:', error)\n    // Handle error\n  }\n}</code></pre><p><strong>Router error handling:</strong></p><pre><code>router.onError((error) => {\n  console.error('Router error:', error)\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "State Management patterns ngoài Pinia/Vuex?",
      "answer": "<p><strong>1. Provide/Inject pattern:</strong></p><pre><code>// store.js\nimport { reactive, provide, inject } from 'vue'\n\nconst StoreSymbol = Symbol()\n\nexport function createStore() {\n  const state = reactive({\n    count: 0\n  })\n  \n  const increment = () => state.count++\n  \n  return { state, increment }\n}\n\nexport function provideStore() {\n  provide(StoreSymbol, createStore())\n}\n\nexport function useStore() {\n  return inject(StoreSymbol)\n}</code></pre><p><strong>2. Composable-based state:</strong></p><pre><code>// useGlobalState.js\nconst state = reactive({\n  user: null\n})\n\nexport function useGlobalState() {\n  return { state }\n}</code></pre><p><strong>3. Event bus (không khuyến khích):</strong></p><pre><code>import mitt from 'mitt'\nconst emitter = mitt()\n\nexport { emitter }</code></pre><p><strong>4. Browser storage:</strong></p><ul><li>LocalStorage</li><li>SessionStorage</li><li>IndexedDB</li></ul>",
      "level": "senior"
    },
    {
      "question": "Migration từ Vue 2 lên Vue 3?",
      "answer": "<p><strong>Breaking changes chính:</strong></p><ul><li>Global API thành instance API</li><li>v-model changes</li><li>Filters removed</li><li>$listeners merged vào $attrs</li><li>Functional components changes</li></ul><p><strong>Migration build:</strong></p><pre><code>npm install @vue/compat\n\n// vite.config.js\nexport default {\n  resolve: {\n    alias: {\n      vue: '@vue/compat'\n    }\n  }\n}</code></pre><p><strong>Step by step:</strong></p><ol><li>Update dependencies</li><li>Run migration build</li><li>Fix deprecation warnings</li><li>Update syntax (Options → Composition)</li><li>Test thoroughly</li><li>Remove compat mode</li></ol><p><strong>Tools:</strong></p><ul><li>Vue 3 Migration Guide</li><li>ESLint plugin</li><li>Vue DevTools</li></ul>",
      "level": "senior"
    },
    {
      "question": "Memory leaks trong Vue: Nguyên nhân và cách tránh?",
      "answer": "<p><strong>Nguyên nhân phổ biến:</strong></p><p><strong>1. Event listeners không cleanup:</strong></p><pre><code>// BAD\nonMounted(() => {\n  window.addEventListener('resize', handler)\n})\n\n// GOOD\nonMounted(() => {\n  window.addEventListener('resize', handler)\n})\n\nonUnmounted(() => {\n  window.removeEventListener('resize', handler)\n})</code></pre><p><strong>2. Timers không clear:</strong></p><pre><code>// BAD\nconst timer = setInterval(() => {}, 1000)\n\n// GOOD\nconst timer = setInterval(() => {}, 1000)\n\nonUnmounted(() => {\n  clearInterval(timer)\n})</code></pre><p><strong>3. DOM references:</strong></p><pre><code>// Avoid keeping DOM references\nconst element = ref(null)\n\nonUnmounted(() => {\n  element.value = null\n})</code></pre><p><strong>4. Subscriptions không unsubscribe:</strong></p><pre><code>let subscription\n\nonMounted(() => {\n  subscription = store.subscribe(handler)\n})\n\nonUnmounted(() => {\n  subscription()\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "Debugging Vue applications?",
      "answer": "<p><strong>1. Vue DevTools:</strong></p><ul><li>Component inspector</li><li>Vuex/Pinia state</li><li>Events timeline</li><li>Performance profiling</li></ul><p><strong>2. Console debugging:</strong></p><pre><code>// Component name trong console\nexport default {\n  name: 'MyComponent',\n  setup() {\n    console.log('Setup running')\n  }\n}</code></pre><p><strong>3. Debug hooks:</strong></p><pre><code>import { onRenderTracked, onRenderTriggered } from 'vue'\n\nonRenderTracked((event) => {\n  console.log('Tracked:', event)\n})\n\nonRenderTriggered((event) => {\n  console.log('Triggered:', event)\n})</code></pre><p><strong>4. Error tracking:</strong></p><ul><li>Sentry</li><li>LogRocket</li><li>Bugsnag</li></ul><p><strong>5. Performance:</strong></p><ul><li>Chrome DevTools Performance tab</li><li>Lighthouse</li><li>Vue DevTools Performance</li></ul>",
      "level": "senior"
    },
    {
      "question": "nextTick() trong Vue 2 vs Vue 3: API khác biệt như thế nào?",
      "answer": "<p><strong>Vue 2 - this.$nextTick():</strong></p><p>Trong Vue 2 Options API, nextTick được access qua instance method <code>this.$nextTick()</code>:</p><pre><code>// Vue 2 - Options API\nexport default {\n  data() {\n    return {\n      message: 'Hello'\n    }\n  },\n  methods: {\n    updateMessage() {\n      this.message = 'Updated'\n      \n      // Method 1: Callback\n      this.$nextTick(function() {\n        // 'this' context được preserve\n        console.log(this.$el.textContent)\n      })\n      \n      // Method 2: Arrow function\n      this.$nextTick(() => {\n        console.log(this.$el.textContent)\n      })\n      \n      // Method 3: Promise (Vue 2.1+)\n      this.$nextTick().then(() => {\n        console.log(this.$el.textContent)\n      })\n    }\n  }\n}</code></pre><p><strong>Vue 2 - Global Vue.nextTick():</strong></p><pre><code>import Vue from 'vue'\n\n// Global API\nVue.nextTick(() => {\n  // DOM updated\n})\n\n// hoặc Promise\nVue.nextTick().then(() => {\n  // DOM updated\n})</code></pre><p><strong>Vue 3 - Import from 'vue':</strong></p><p>Vue 3 chuyển sang Composition API, nextTick trở thành standalone function:</p><pre><code>// Vue 3 - Composition API\nimport { ref, nextTick } from 'vue'\n\nexport default {\n  setup() {\n    const message = ref('Hello')\n    \n    const updateMessage = async () => {\n      message.value = 'Updated'\n      \n      // Method 1: async/await (recommended)\n      await nextTick()\n      console.log('DOM updated')\n      \n      // Method 2: Promise\n      nextTick().then(() => {\n        console.log('DOM updated')\n      })\n      \n      // Method 3: Callback (legacy support)\n      nextTick(() => {\n        console.log('DOM updated')\n      })\n    }\n    \n    return { message, updateMessage }\n  }\n}</code></pre><p><strong>Vue 3 - Script Setup (modern syntax):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, nextTick } from 'vue'\n\nconst count = ref(0)\nconst elementRef = ref(null)\n\nconst increment = async () => {\n  count.value++\n  \n  await nextTick()\n  \n  // Access updated DOM\n  console.log(elementRef.value.textContent)\n}\n&lt;/script&gt;</code></pre><p><strong>Vue 3 - Options API (vẫn support):</strong></p><pre><code>// Vue 3 vẫn support this.$nextTick()\nexport default {\n  methods: {\n    updateData() {\n      this.message = 'New'\n      \n      // Vẫn work như Vue 2\n      this.$nextTick(() => {\n        console.log('Updated')\n      })\n    }\n  }\n}</code></pre><p><strong>Bảng so sánh Vue 2 vs Vue 3:</strong></p><table><tr><th>Aspect</th><th>Vue 2</th><th>Vue 3</th></tr><tr><td>Instance method</td><td>this.$nextTick()</td><td>this.$nextTick() (Options API)</td></tr><tr><td>Global API</td><td>Vue.nextTick()</td><td>nextTick() import</td></tr><tr><td>Composition API</td><td>Không có</td><td>import { nextTick } from 'vue'</td></tr><tr><td>Callback support</td><td>✅ Primary way</td><td>✅ Legacy support</td></tr><tr><td>Promise support</td><td>✅ Vue 2.1+</td><td>✅ Recommended</td></tr><tr><td>async/await</td><td>✅ Supported</td><td>✅ Recommended way</td></tr><tr><td>Tree-shaking</td><td>❌ Global API</td><td>✅ Import only when used</td></tr></table><p><strong>Migration từ Vue 2 sang Vue 3:</strong></p><pre><code>// Vue 2\nexport default {\n  methods: {\n    async doSomething() {\n      this.data = 'new value'\n      await this.$nextTick()\n      console.log(this.$el)\n    }\n  }\n}\n\n// Vue 3 - Composition API (recommended)\nimport { ref, nextTick } from 'vue'\n\nexport default {\n  setup() {\n    const data = ref('old value')\n    const el = ref(null)\n    \n    const doSomething = async () => {\n      data.value = 'new value'\n      await nextTick()\n      console.log(el.value)\n    }\n    \n    return { data, el, doSomething }\n  }\n}\n\n// Vue 3 - Options API (nếu chưa migrate)\nexport default {\n  methods: {\n    async doSomething() {\n      this.data = 'new value'\n      await this.$nextTick() // Vẫn work!\n      console.log(this.$el)\n    }\n  }\n}</code></pre><p><strong>Internal implementation khác biệt:</strong></p><p><strong>Vue 2:</strong> Sử dụng microtask queue (Promise) hoặc fallback về macro task (setTimeout) tùy browser support.</p><p><strong>Vue 3:</strong> Luôn dùng Promise microtask, performance tốt hơn và consistent hơn.</p><p><strong>Best practices cho Vue 3:</strong></p><ul><li><strong>Composition API:</strong> Import và dùng async/await với nextTick()</li><li><strong>Tree-shaking:</strong> Chỉ import khi cần, giảm bundle size</li><li><strong>TypeScript:</strong> Type inference tốt hơn với import</li><li><strong>Consistency:</strong> Dùng cùng pattern với reactive API (ref, computed, watch)</li></ul><pre><code>// ✅ GOOD - Vue 3 modern way\nimport { ref, nextTick } from 'vue'\n\nconst data = ref(0)\n\nconst update = async () => {\n  data.value++\n  await nextTick()\n  // DOM updated\n}\n\n// ❌ AVOID - Mixing old and new\nconst update2 = function() {\n  this.data++\n  this.$nextTick(() => {\n    // Mixes this context with Composition API\n  })\n}</code></pre>",
      "level": "senior"
    },
    {
      "question": "Làm thế nào để hủy API request khi component bị unmount trong Vue?",
      "answer": "<p><strong>Tại sao cần cancel API requests?</strong></p><p>Khi component bị unmount trước khi API request hoàn thành, việc update state sau khi unmount sẽ gây ra:</p><ul><li>Memory leaks</li><li>Warning: \"Can't perform a React state update on an unmounted component\"</li><li>Unnecessary network traffic</li><li>Potential bugs nếu callback vẫn chạy</li></ul><p><strong>Method 1: AbortController (Modern, Recommended):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nconst data = ref(null)\nconst loading = ref(false)\nconst error = ref(null)\n\n// Tạo AbortController\nconst abortController = new AbortController()\n\nconst fetchData = async () => {\n  loading.value = true\n  error.value = null\n  \n  try {\n    const response = await fetch('/api/data', {\n      signal: abortController.signal // Pass signal vào fetch\n    })\n    \n    if (!response.ok) throw new Error('Failed')\n    \n    data.value = await response.json()\n  } catch (err) {\n    // Kiểm tra nếu error là do abort\n    if (err.name === 'AbortError') {\n      console.log('Request was cancelled')\n    } else {\n      error.value = err.message\n    }\n  } finally {\n    loading.value = false\n  }\n}\n\nonMounted(() => {\n  fetchData()\n})\n\n// Cancel khi unmount\nonUnmounted(() => {\n  abortController.abort()\n  console.log('API request cancelled')\n})\n&lt;/script&gt;</code></pre><p><strong>Method 2: Axios với CancelToken:</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\nimport axios from 'axios'\n\nconst data = ref(null)\nconst source = axios.CancelToken.source()\n\nconst fetchData = async () => {\n  try {\n    const response = await axios.get('/api/data', {\n      cancelToken: source.token\n    })\n    data.value = response.data\n  } catch (err) {\n    if (axios.isCancel(err)) {\n      console.log('Request cancelled:', err.message)\n    } else {\n      console.error('Error:', err)\n    }\n  }\n}\n\nonMounted(() => {\n  fetchData()\n})\n\nonUnmounted(() => {\n  source.cancel('Component unmounted')\n})\n&lt;/script&gt;</code></pre><p><strong>Method 3: Axios với AbortController (Axios 0.22+):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\nimport axios from 'axios'\n\nconst data = ref(null)\nconst abortController = new AbortController()\n\nconst fetchData = async () => {\n  try {\n    const response = await axios.get('/api/data', {\n      signal: abortController.signal\n    })\n    data.value = response.data\n  } catch (err) {\n    if (err.name === 'CanceledError') {\n      console.log('Request cancelled')\n    }\n  }\n}\n\nonMounted(() => {\n  fetchData()\n})\n\nonUnmounted(() => {\n  abortController.abort()\n})\n&lt;/script&gt;</code></pre><p><strong>Method 4: Flag-based approach (Simple fallback):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nconst data = ref(null)\nlet isMounted = true\n\nconst fetchData = async () => {\n  const response = await fetch('/api/data')\n  const result = await response.json()\n  \n  // Chỉ update state nếu component vẫn mounted\n  if (isMounted) {\n    data.value = result\n  }\n}\n\nonMounted(() => {\n  isMounted = true\n  fetchData()\n})\n\nonUnmounted(() => {\n  isMounted = false\n})\n&lt;/script&gt;</code></pre><p><strong>Method 5: Composable để reuse logic:</strong></p><pre><code>// composables/useFetch.js\nimport { ref, onUnmounted } from 'vue'\n\nexport function useFetch(url) {\n  const data = ref(null)\n  const error = ref(null)\n  const loading = ref(false)\n  \n  const abortController = new AbortController()\n  \n  const fetchData = async () => {\n    loading.value = true\n    error.value = null\n    \n    try {\n      const response = await fetch(url, {\n        signal: abortController.signal\n      })\n      \n      if (!response.ok) throw new Error(`HTTP ${response.status}`)\n      \n      data.value = await response.json()\n    } catch (err) {\n      if (err.name !== 'AbortError') {\n        error.value = err.message\n      }\n    } finally {\n      loading.value = false\n    }\n  }\n  \n  const abort = () => {\n    abortController.abort()\n  }\n  \n  // Auto cleanup on unmount\n  onUnmounted(() => {\n    abort()\n  })\n  \n  return { data, error, loading, fetchData, abort }\n}\n\n// Sử dụng trong component\nimport { useFetch } from '@/composables/useFetch'\n\nconst { data, error, loading, fetchData } = useFetch('/api/users')\n\nonMounted(() => {\n  fetchData()\n})</code></pre><p><strong>Method 6: Multiple requests với Promise.race:</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nconst data = ref(null)\nlet cancelPromise\nlet resolveCancelPromise\n\nconst fetchData = async () => {\n  // Tạo cancel promise\n  cancelPromise = new Promise((resolve) => {\n    resolveCancelPromise = resolve\n  })\n  \n  try {\n    const dataPromise = fetch('/api/data').then(r => r.json())\n    \n    // Race giữa data và cancel\n    const result = await Promise.race([\n      dataPromise,\n      cancelPromise\n    ])\n    \n    if (result) {\n      data.value = result\n    }\n  } catch (err) {\n    console.error(err)\n  }\n}\n\nonMounted(() => {\n  fetchData()\n})\n\nonUnmounted(() => {\n  // Resolve cancel promise để win the race\n  resolveCancelPromise(null)\n})\n&lt;/script&gt;</code></pre><p><strong>Advanced: Handle multiple concurrent requests:</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nconst data = ref(null)\nconst controllers = new Set()\n\nconst fetchData = async (endpoint) => {\n  const controller = new AbortController()\n  controllers.add(controller)\n  \n  try {\n    const response = await fetch(endpoint, {\n      signal: controller.signal\n    })\n    data.value = await response.json()\n  } catch (err) {\n    if (err.name !== 'AbortError') {\n      console.error(err)\n    }\n  } finally {\n    controllers.delete(controller)\n  }\n}\n\nconst cancelAll = () => {\n  controllers.forEach(controller => controller.abort())\n  controllers.clear()\n}\n\nonMounted(() => {\n  // Multiple requests\n  fetchData('/api/users')\n  fetchData('/api/posts')\n  fetchData('/api/comments')\n})\n\nonUnmounted(() => {\n  cancelAll()\n})\n&lt;/script&gt;</code></pre><p><strong>Browser compatibility:</strong></p><table><tr><th>Method</th><th>Browser Support</th><th>Pros</th><th>Cons</th></tr><tr><td>AbortController</td><td>Modern browsers (IE ❌)</td><td>Native, standard, clean API</td><td>Polyfill cần cho old browsers</td></tr><tr><td>Axios CancelToken</td><td>All (library handles)</td><td>Works everywhere, easy</td><td>Axios-specific, deprecated</td></tr><tr><td>Axios AbortController</td><td>Modern browsers</td><td>Standard + Axios benefits</td><td>Requires Axios 0.22+</td></tr><tr><td>Flag-based</td><td>All browsers</td><td>Simple, no dependencies</td><td>Request vẫn chạy, waste bandwidth</td></tr></table><p><strong>Best practices:</strong></p><ul><li>✅ Dùng AbortController cho fetch API (modern, standard)</li><li>✅ Dùng Axios với AbortController (Axios 0.22+)</li><li>✅ Cleanup trong onUnmounted hook</li><li>✅ Handle AbortError/CanceledError riêng, không log error</li><li>✅ Tạo composable để reuse logic</li><li>❌ KHÔNG ignore cleanup - gây memory leaks</li><li>❌ KHÔNG dùng flag-based nếu có AbortController</li></ul><p><strong>Testing:</strong></p><pre><code>// Test với Vue Test Utils\nimport { mount } from '@vue/test-utils'\nimport { nextTick } from 'vue'\n\ntest('cancels request on unmount', async () => {\n  const wrapper = mount(MyComponent)\n  \n  // Component mounted, request started\n  \n  wrapper.unmount()\n  \n  // Verify abort was called\n  await nextTick()\n  \n  // Request should be cancelled\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "v-for hoạt động như thế nào? Tại sao không nên dùng v-if và v-for cùng element?",
      "answer": "<p><strong>v-for hoạt động như thế nào?</strong></p><p>v-for render list bằng cách iterate qua array/object và tạo VNode (Virtual DOM node) cho mỗi item. Vue sử dụng <strong>in-place patch strategy</strong> để update efficiently.</p><p><strong>Cú pháp v-for:</strong></p><pre><code>&lt;!-- Array --&gt;\n&lt;li v-for=\"(item, index) in items\" :key=\"item.id\"&gt;\n  {{ index }}: {{ item.name }}\n&lt;/li&gt;\n\n&lt;!-- Object --&gt;\n&lt;div v-for=\"(value, key, index) in object\" :key=\"key\"&gt;\n  {{ key }}: {{ value }}\n&lt;/div&gt;\n\n&lt;!-- Range --&gt;\n&lt;span v-for=\"n in 10\" :key=\"n\"&gt;{{ n }}&lt;/span&gt;\n\n&lt;!-- Component --&gt;\n&lt;MyComponent \n  v-for=\"item in items\" \n  :key=\"item.id\"\n  :data=\"item\" \n/&gt;</code></pre><p><strong>Virtual DOM diffing algorithm:</strong></p><p>Khi list thay đổi, Vue compare old VNodes với new VNodes:</p><ol><li><strong>Với :key:</strong> Vue track từng node bằng key, reuse & reorder elements efficiently</li><li><strong>Không có :key:</strong> Vue dùng \"in-place patch\" - update content của existing elements theo thứ tự, không move DOM nodes</li></ol><pre><code>// Có :key - Vue track và reorder\n&lt;div v-for=\"item in items\" :key=\"item.id\"&gt;\n  {{ item.name }}\n&lt;/div&gt;\n\n// items = [{ id: 1, name: 'A' }, { id: 2, name: 'B' }]\n// → [{ id: 2, name: 'B' }, { id: 1, name: 'A' }]\n// Vue sẽ MOVE DOM nodes\n\n// Không có :key - in-place patch\n&lt;div v-for=\"item in items\"&gt;\n  {{ item.name }}\n&lt;/div&gt;\n// Vue sẽ UPDATE content của existing divs, không move</code></pre><p><strong>Tại sao cần :key unique và stable?</strong></p><ul><li><strong>Identity tracking:</strong> Vue phân biệt được element nào tương ứng với data item nào trong array</li><li><strong>State preservation:</strong> Component state, form input values được preserve đúng khi list reorder</li><li><strong>Transition animations:</strong> Vue track chính xác element nào move/add/remove để animate</li><li><strong>Performance:</strong> Reuse existing DOM nodes thay vì destroy/create mới</li></ul><pre><code>// ❌ BAD - Dùng index làm key\n&lt;div v-for=\"(item, index) in items\" :key=\"index\"&gt;\n  &lt;input v-model=\"item.value\" /&gt;\n&lt;/div&gt;\n// Khi xóa item, index thay đổi → Vue nhầm lẫn identity\n\n// ✅ GOOD - Dùng unique ID\n&lt;div v-for=\"item in items\" :key=\"item.id\"&gt;\n  &lt;input v-model=\"item.value\" /&gt;\n&lt;/div&gt;</code></pre><p><strong>Tại sao KHÔNG nên dùng v-if và v-for cùng element?</strong></p><p><strong>Lý do 1: Priority conflict</strong></p><p>Vue 2 và Vue 3 có priority khác nhau:</p><ul><li><strong>Vue 2:</strong> v-for có priority cao hơn v-if</li><li><strong>Vue 3:</strong> v-if có priority cao hơn v-for</li></ul><pre><code>&lt;!-- Vue 2 --&gt;\n&lt;div v-for=\"item in items\" v-if=\"item.isActive\"&gt;\n  {{ item.name }}\n&lt;/div&gt;\n// v-for chạy trước → v-if check từng item (WORK nhưng không tối ưu)\n\n&lt;!-- Vue 3 --&gt;\n&lt;div v-for=\"item in items\" v-if=\"item.isActive\"&gt;\n  {{ item.name }}\n&lt;/div&gt;\n// v-if chạy trước → 'item' chưa defined → ERROR!</code></pre><p><strong>Lý do 2: Performance issue</strong></p><p>Khi v-for và v-if cùng element, Vue phải evaluate cả hai mỗi lần render:</p><pre><code>&lt;!-- ❌ BAD - Check condition cho MỌI item mỗi render --&gt;\n&lt;li v-for=\"user in users\" v-if=\"user.isActive\" :key=\"user.id\"&gt;\n  {{ user.name }}\n&lt;/li&gt;\n// Nếu users = 1000 items → 1000 checks mỗi render!</code></pre><p><strong>Lý do 3: Code clarity</strong></p><p>Mixing v-for và v-if làm code khó đọc và maintain.</p><p><strong>Solutions - Cách đúng để combine filtering với v-for:</strong></p><p><strong>Solution 1: Computed property (RECOMMENDED):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, computed } from 'vue'\n\nconst users = ref([\n  { id: 1, name: 'John', isActive: true },\n  { id: 2, name: 'Jane', isActive: false },\n  { id: 3, name: 'Bob', isActive: true }\n])\n\n// Filter một lần, cache result\nconst activeUsers = computed(() =&gt; \n  users.value.filter(user =&gt; user.isActive)\n)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;!-- ✅ GOOD - Chỉ loop qua filtered items --&gt;\n  &lt;li v-for=\"user in activeUsers\" :key=\"user.id\"&gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/template&gt;\n\n&lt;!-- Benefits:\n  - Filter chỉ chạy khi users thay đổi (cached)\n  - v-for chỉ loop qua items cần thiết\n  - Code clear và maintainable\n--&gt;</code></pre><p><strong>Solution 2: Wrapper template với v-if bên ngoài:</strong></p><pre><code>&lt;!-- ✅ GOOD - v-if wrapper --&gt;\n&lt;template v-for=\"user in users\" :key=\"user.id\"&gt;\n  &lt;li v-if=\"user.isActive\"&gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/template&gt;\n\n&lt;!-- hoặc --&gt;\n&lt;div v-for=\"user in users\" :key=\"user.id\"&gt;\n  &lt;div v-if=\"user.isActive\"&gt;\n    {{ user.name }}\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!-- Dùng khi:\n  - Không thể/không muốn dùng computed\n  - Condition phức tạp, depends on multiple factors\n  - Cần preserve DOM structure\n--&gt;</code></pre><p><strong>Solution 3: v-show cho toggle visibility:</strong></p><pre><code>&lt;!-- Nếu cần toggle thường xuyên --&gt;\n&lt;li \n  v-for=\"user in users\" \n  v-show=\"user.isActive\"\n  :key=\"user.id\"\n&gt;\n  {{ user.name }}\n&lt;/li&gt;\n\n&lt;!-- v-show chỉ toggle CSS display\n  - Tốt khi toggle frequently\n  - Elements vẫn render, chỉ ẩn/hiện\n  - Không có performance benefit cho filtering\n--&gt;</code></pre><p><strong>Solution 4: v-if bên ngoài v-for (show/hide entire list):</strong></p><pre><code>&lt;!-- ✅ GOOD - Conditional rendering của entire list --&gt;\n&lt;div v-if=\"hasUsers\"&gt;\n  &lt;li v-for=\"user in users\" :key=\"user.id\"&gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/div&gt;\n&lt;div v-else&gt;\n  &lt;p&gt;No users found&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;!-- Dùng khi cần show/hide toàn bộ list --&gt;</code></pre><p><strong>Performance comparison:</strong></p><pre><code>// Scenario: 1000 users, 100 active\n\n// ❌ BAD - v-if trên v-for\n&lt;div v-for=\"user in users\" v-if=\"user.isActive\"&gt;\n// → 1000 iterations mỗi render\n// → 1000 condition checks\n\n// ✅ GOOD - Computed\nconst activeUsers = computed(() =&gt; \n  users.value.filter(u =&gt; u.isActive)\n)\n&lt;div v-for=\"user in activeUsers\"&gt;\n// → Filter 1 lần khi users change (cached)\n// → 100 iterations mỗi render\n// → 10x faster!</code></pre><p><strong>Vue 3 specific - Template v-for:</strong></p><pre><code>&lt;!-- Vue 3 allows v-for on template without wrapper --&gt;\n&lt;template v-for=\"item in items\" :key=\"item.id\"&gt;\n  &lt;div&gt;{{ item.title }}&lt;/div&gt;\n  &lt;div&gt;{{ item.description }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;!-- Key phải ở template, không phải child elements --&gt;</code></pre><p><strong>ESLint rule:</strong></p><pre><code>// .eslintrc.js\nrules: {\n  'vue/no-use-v-if-with-v-for': 'error'\n}\n\n// Sẽ warning khi dùng v-if và v-for cùng element</code></pre><p><strong>Best practices summary:</strong></p><ul><li>✅ Luôn dùng :key với unique, stable ID</li><li>✅ KHÔNG dùng index làm key (trừ static list)</li><li>✅ Filter bằng computed property thay vì v-if trên v-for</li><li>✅ Dùng template wrapper nếu cần v-if cho từng item</li><li>✅ v-if bên ngoài v-for để show/hide entire list</li><li>✅ Enable ESLint rule để catch mistakes</li><li>❌ KHÔNG dùng v-if và v-for cùng element</li><li>❌ KHÔNG dùng random/unstable keys</li></ul>",
      "level": "senior"
    }
  ]
}
