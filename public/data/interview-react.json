{
  "id": "react",
  "name": "Câu hỏi phỏng vấn React",
  "description": "",
  "questions": [
    {
      "question": "React là gì?",
      "answer": "<p>React là một thư viện JavaScript mã nguồn mở và giao diện người dùng, rất hữu ích trong việc phát triển giao diện người dùng dành riêng cho các ứng dụng SPA. Nó hữu ích trong việc xây dựng các thành phần giao diện người dùng (UI) phức tạp và có thể tái sử dụng của các ứng dụng web và di động vì nó tuân theo mô hình dựa trên component.\r\n\r\nTính năng của React:\r<ul><li>Tăng hiệu suất của ứng dụng với Virtual DOM.</li></ul>\r<ul><li>JSX làm cho code dễ đọc và viết.</li></ul>\r<ul><li>Nó kết xuất cả phía máy khách và máy chủ.</li></ul>\r<ul><li>Dễ dàng tích hợp với các frameworks khác (Angular, BackboneJS) vì nó chỉ là một thư viện giao diện.</li></ul>\r<ul><li>Dễ dàng viết các trường hợp kiểm thử UI và tích hợp với các công cụ như JEST.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Lợi ích khi dùng React?",
      "answer": "<p><ul><li>ReactJS giúp cho việc viết các đoạn code Javascript sẽ trở nên dễ dàng hơn vì nó sử dụng một cú pháp đặc biệt đó chính là cú pháp JSX. Thông qua JSX cho phép nhúng code HTML và Javascript.</li></ul>\r<ul><li>ReactJS cho phép nhà phát triển phá vỡ những cấu trúc UI phức tạp thành những component độc lập. Các nhà phát triển sẽ không phải lo lắng về tổng thể ứng dụng web, giờ đây có thể dễ dàng chia nhỏ các cấu trúc UI/UX phức tạp thành từng component đơn giản hơn. </li></ul>\r<ul><li>Đi kèm với ReactJS là rất nhiều các công cụ phát triển giúp cho việc debug code một cách dễ dàng hơn.</li></ul>\r<ul><li>Một trong những ưu điểm nữa của ReactJS đó là sự thân thiện với SEO. Hầu như các JS Frameworks không thân thiện với các tìm kiếm mặc dù đã được cải thiện nhiều nhưng dưới sự hỗ trợ của các render dữ liệu trả về dưới dạng web page giúp cho SEO chuẩn hơn.</li></ul>\r<ul><li>React cùng với React Native, Redux, Electro cùng với nhiều công cụ hữu ích khác giúp nhà phát triển xây dựng được đa dạng loại ứng dụng phù hợp với nhiều yêu cầu.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Hạn chế của React?",
      "answer": "<p><ul><li>React không phải một framework hoàn chỉnh mà chỉ là thư viện.</li></ul>\r<ul><li>Component trong React sẽ rất nhiều và mất nhiều thời gian để hiểu với các trang web phức tạp.</li></ul>\r<ul><li>Code sẽ trở nên phức tạp khi dùng template với JSX.</li></ul>\r<ul><li>Khá khó cho người mới bắt đầu.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "useState() trong React là gì?",
      "answer": "<p>useState() là một hooks có sẵn trong React, cho phép bạn quản lý biến state của các function component. Nó được dùng khi DOM có thứ gì đó cần được điều khiển/quản lý.\r\n\r\nTrong code bên dưới, <code>useState(0)</code> sẽ trả về một mảng trong đó tham số đầu tiên là state hiện tại của <code>counter</code> và tham số thứ hai là phương thức <code>setCounter</code> cho phép cập nhật state của counter.\r\n\r\n``<code>jsx\r\n...\r\nconst [count, setCounter] = useState(0);\r\nconst [otherStuffs, setOtherStuffs] = useState(...);\r\n...\r\nconst setCount = () =&gt; {\r\n   setCounter(count + 1);\r\n   setOtherStuffs(...);\r\n   ...\r\n};\r\n</code>`<code>\r\n\r\nTa có thể sử dụng phương thức </code>setCounter()<code> cho cập nhật state của count ở bất cứ đâu. Trong ví dụ này, ta sử dụng </code>setCounter()<code> trong hàm </code>setCount` . Đây là một ý tưởng tuyệt với để quản lý state trong các function component, tránh sử dụng class component khi không cần thiết.</p>",
      "level": "fresher"
    },
    {
      "question": "Keys trong React?",
      "answer": "<p>Key là một thuộc tính chuỗi đặc biệt dùng khi sử dụng danh sách phần tử.\r\n\r\n<img src=\"/interview-assets/What_are_keys_in_React.png\" alt=\"\" />\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nconst ids = [1,2,3,4,5];\r\nconst listElements = ids.map((id)=&gt;{\r\n    return(\r\n        &lt;li key={id.toString()}&gt;\r\n            {id}\r\n        &lt;/li&gt;\r\n    )\r\n})\r\n</code>``\r\n\r\n#</p>",
      "level": "fresher"
    },
    {
      "question": "JSX là gì?",
      "answer": "<p>JSX là viết tắt của JavaScript XML. Nó cho phép ta viết HTML trong JavaScript và đặt nó vào DOM mà không cần dùng <code>appendChild()</code> hay <code>createElement()</code>.\r\n\r\nTheo trang chủ của React, JSX cung cấp cú pháp tuyệt vời hơn cho <code>React.createElement()</code>. Ví dụ\r<ul><li>Không dùng JSX:</li></ul>\r\n\r\n``<code>js\r\nconst text = React.createElement(&#39;p&#39;, {}, &#39;This is a text&#39;);\r\nconst container = React.createElement(&#39;div&#39;,&#39;{}&#39;,text );\r\nReactDOM.render(container,rootElement);\r\n</code>`<code>\r<ul><li>Dùng JSX:</li></ul>\r\n\r\n</code>`<code>jsx\r\nconst container = (\r\n&lt;div&gt;\r\n    &lt;p&gt;This is a text&lt;/p&gt;\r\n&lt;/div&gt;\r\n);\r\nReactDOM.render(container,rootElement);\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa class component và function component?",
      "answer": "<p>Trước khi giới thiệu hooks ở phiên bản 16, các function component được gọi là stateless component và ít khi được dùng trong React. Sau khi hook ra đời, các function component giờ đã ngang hàng với class component.\r\n\r\nDù function component đang là trend hiện tại, nhưng class component vẫn còn rất quan trọng. Dưới đây là một vài so sánh cơ bản:\r<ul><li><strong>Khai báo</strong></li></ul>\r\n\r\nFunction component giống như một hàm thông thường trong JS, ta có thể tạo kiểu arrow function hoặc function:\r\n\r\n``<code>jsx\r\nfunction card(props){\r\n    return(\r\n        &lt;div className=&quot;main-container&quot;&gt;\r\n            &lt;h2&gt;Title of the card&lt;/h2&gt;\r\n        &lt;/div&gt;\r\n    )\r\n}\r\n\r\nconst card = (props) =&gt; {\r\n    return(\r\n        &lt;div className=&quot;main-container&quot;&gt;\r\n            &lt;h2&gt;Title of the card&lt;/h2&gt;\r\n        &lt;/div&gt;\r\n    )\r\n}\r\n</code>`<code>\r\n\r\nClass component sử dụng cú pháp tạo lớp của ES6\r\n\r\n</code>`<code>jsx\r\nclass Card extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n    }\r\n    render(){\r\n        return(\r\n            &lt;div className=&quot;main-container&quot;&gt;\r\n                &lt;h2&gt;Title of the card&lt;/h2&gt;\r\n            &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Xử lý props</strong></li></ul>\r\n\r\nTa thử render component dưới đây theo cả hai cách:\r\n\r\n</code>`<code>jsx\r\n&lt;Student Info name=&quot;Vivek&quot; rollNumber=&quot;23&quot; /&gt;\r\n</code>`<code>\r\n\r\nTrong function component, xử lý props rất thẳng thắn. Bất ký props nào cũng được xem như tham số của function component có thể xử lý trực tiếp:\r\n\r\n</code>`<code>jsx\r\nfunction StudentInfo(props){\r\n    return(\r\n        &lt;div className=&quot;main&quot;&gt;\r\n            &lt;h2&gt;{props.name}&lt;/h2&gt;\r\n            &lt;h4&gt;{props.rollNumber}&lt;/h4&gt;\r\n        &lt;/div&gt;\r\n    )\r\n}\r\n</code>`<code>\r\n\r\nVới class component, props được xử lý bằng </code>this<code>:\r\n\r\n</code>`<code>jsx\r\nclass StudentInfo extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n    }\r\n    \r\n    render(){\r\n        return(\r\n            &lt;div className=&quot;main&quot;&gt;\r\n                &lt;h2&gt;{this.props.name}&lt;/h2&gt;\r\n                &lt;h4&gt;{this.props.rollNumber}&lt;/h4&gt; \r\n            &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Xử lý state</strong></li></ul>\r\n\r\nFunction component sử dụng hook để quản lý state. Hook hữu ích nhất là </code>useState<code> cho thiết lập state trong component.\r\n\r\n</code>`<code>jsx\r\nfunction ClassRoom(props){\r\n    let [studentsCount,setStudentsCount] = useState(0);\r\n    \r\n    const addStudent = () =&gt; {\r\n        setStudentsCount(++studentsCount);\r\n    }\r\n        \r\n    return(\r\n        &lt;div&gt;\r\n            &lt;p&gt;Number of students in class room: {studentsCount}&lt;/p&gt;\r\n            &lt;button onClick={addStudent}&gt;Add Student&lt;/button&gt;\r\n        &lt;/div&gt;\r\n    )\r\n}\r\n</code>`<code>\r\n\r\nTa không thể sử dụng hook bên trong class component, thế nên ta vẫn phải xử lý state bằng </code>this<code> trong class component.\r\n\r\n</code>`<code>jsx\r\nclass ClassRoom extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n\r\n        this.state = {studentsCount : 0};\r\n        this.addStudent = this.addStudent.bind(this);\r\n    }\r\n    \r\n    addStudent(){\r\n        this.setState((prevState)=&gt;{\r\n            return {studentsCount: prevState.studentsCount++}\r\n        });\r\n    }\r\n    \r\n    render(){\r\n        return(\r\n            &lt;div&gt;\r\n                &lt;p&gt;Number of students in class room: {this.state.studentsCount}&lt;/p&gt;\r\n                &lt;button onClick={this.addStudent}&gt;Add Student&lt;/button&gt;\r\n            &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Virtual DOM là gì?",
      "answer": "<p>Virtual DOM là một khái niệm trong đó biểu diễn ảo của DOM thực được lưu giữ bên trong bộ nhớ và được đồng bộ hóa với DOM thực bởi một thư viện như ReactDOM.\r\n\r\n<img src=\"/interview-assets/virtual_DOM.png\" alt=\"\" />\r\n\r\n#</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa controlled component và uncontrolled component?",
      "answer": "<p>| Tính năng | Uncontrolled | Controlled \r\n|-|-|-|\r\n| Truy xuất giá trị một lần (như khi submit) | Yes | Yes |\r\n| Xác thực submit | Yes | Yes |\r\n| Xác thực trường | No | Yes |\r\n| Điều kiện cho kích hoạt nút submit | No | Yes |\r\n| Định dạng đầu vào | No | Yes |\r\n| Cung cấp nhiều input cho một mẫu dữ liệu | No | Yes |\r\n| Input động | No | Yes |\r\n\r\n<strong>Controlled component</strong>\r\n\r\nTrong controlled component, giá trị của phần tử input được điều khiển bởi React. Ta lưu trữ trạng thái của phần tử input trong code, và sử dụng callback, với bất kỳ thay đổi nào đến input sẽ được phản ánh tương tự trong code.\r\n\r\nKhi người dùng nhập dữ liệu vào phần tử input trong controlled component, hàm <code>onChange</code> kích hoạt và trong code, ta kiểm tra giá trị nhập vào là hợp lệ hay không. Nếu hợp lệ, ta thay đổi trạng thái và re-render phần tử input với giá trị mới.\r\n\r\n``<code>jsx\r\nfunction FormValidation(props) {\r\n    let [inputValue, setInputValue] = useState(&quot;&quot;);\r\n    let updateInput = e =&gt; {\r\n        setInputValue(e.target.value);\r\n    };\r\n    return (\r\n        &lt;div&gt;\r\n            &lt;form&gt;\r\n            &lt;input type=&quot;text&quot; value={inputValue} onChange={updateInput} /&gt;\r\n            &lt;/form&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nNhư đoạn code trên, giá trị của phần tử input được xác định bởi biến </code>inputValue<code>. Bất kỳ thay đổi nào đến phần tử input sẽ được xử lý bởi hàm </code>updateInput<code>.\r\n\r\n<strong>Uncontrolled component</strong>\r\n\r\nTrong uncontrolled component, giá trị của phần tử input được xử lý bởi chính DOM. Các phần tử input này hoạt động giống như phần tử input HTML.\r\n\r\nTrạng thái của phần tử input được xử lý bởi DOM. Nên khi giá trị input thay đổi, callback sẽ không được gọi. Hoặc có thể nói là React không thực hiện bất cứ hàng động nào khi xảy ra thay đổi.\r\n\r\nKhi người dùng nhập dữ liệu vào trường input, dữ liệu cập nhật được hiển thị trực tiếp. Để truy cập giá trị phần tử input, ta có thể dùng <strong>ref</strong>.\r\n\r\n</code>`<code>jsx\r\nfunction FormValidation(props) {\r\n    let inputValue = React.createRef();\r\n    let handleSubmit = e =&gt; {\r\n        alert(</code>Input value: ${inputValue.current.value}<code>);\r\n        e.preventDefault();\r\n    };\r\n    return (\r\n        &lt;div&gt;\r\n            &lt;form onSubmit={handleSubmit}&gt;\r\n            &lt;input type=&quot;text&quot; ref={inputValue} /&gt;\r\n            &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;\r\n            &lt;/form&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Props trong React là gì?",
      "answer": "<p>Props trong React là dữ liệu được truyền cho các component. Nó có thể là giá trị đơn hoặc đối tượng có tập giá trị được truyền cho component trong suốt quá trình bằng cách thực hiện truyền tham số (tương tự với cú pháp thuộc tính trong HTML). Ta có thể nói props là dữ liệu kế thừa được truyền từ component cha sang component con.\r\n\r\nCác chức năng của props:\r<ul><li>Truyền dữ liệu tuỳ chỉnh đến component.</li></ul>\r<ul><li>Kích hoạt thay đổi trạng thái</li></ul>\r<ul><li>Sử dụng cho render dữ liệu.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích state và props?",
      "answer": "<p>| Props | State |\r\n|-|-|\r\n| Bất biến | Có thể thay đổi |\r\n| Hiệu suất tốt hơn | Phạm vi cục bộ |\r\n| Truyền được cho component khác | Truyền được giống như props |\r\n| | Có phương thức setState để đổi giá trị |\r\n| | Đổi trạng bất đồng bộ |\r\n\r\n<strong>React State</strong>\r\n\r\nTất cả component đều có sẵn đối tượng state, bao gồm tất cả giá trị thuộc tính cùng với component đó. Nói cách khác, đối tượng state điều khiển hành vi của component. Bất kỳ thay đổi giá trị thuộc tính nào của đối tượng state sẽ dẫn đến re-render component.\r\n\r\n<em>Khai báo đối tượng state</em>\r\n\r\n``<code>jsx\r\nclass Car extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            brand: &quot;BMW&quot;,\r\n            color: &quot;black&quot;\r\n        }\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<em>Dùng và cập nhật đối tượng state</em>\r\n\r\n</code>`<code>jsx\r\nclass Car extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            brand: &quot;BMW&quot;,\r\n            color: &quot;Black&quot;\r\n        };\r\n    }\r\n    changeColor() {\r\n        this.setState(prevState =&gt; {\r\n            return { color: &quot;Red&quot; };\r\n        });\r\n    }\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;button onClick={() =&gt; this.changeColor()}&gt;Change Color&lt;/button&gt;\r\n                &lt;p&gt;{this.state.color}&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>React Props</strong>\r\n\r\nTất cả component đều nhận vào một đối thượng tham số gọi là props (viết tắt của properties). Props có thể được truyền đi component khác và các component này nhận props như một đối số.\r\n\r\n<em>Truyền props cho component</em>\r\n\r\n</code>`<code>jsx\r\n&lt;Car brand=&quot;Mercedes&quot;/&gt;\r\n</code>`<code>\r\n\r\n<em>Nhận props từ component khác</em>\r\n\r\nTrong class:\r\n\r\n</code>`<code>jsx\r\nclass Car extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            brand: this.props.brand,\r\n            color: &quot;Black&quot;\r\n        };\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong function:\r\n\r\n</code>`<code>jsx\r\nfunction Car(props) {\r\n    let [brand, setBrand] = useState(props.brand);\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Các kiểu side effect trong React component?",
      "answer": "<p>Có hai kiểu side effect trong React.\r<ul><li><strong>Effect không có cleanup:</strong> Side effect này sẽ được sử dụng trong <code>useEffect</code> không hạn chế trình duyệt cập nhật màn hình. Nó cũng cải thiện khả năng phản hồi của một ứng dụng. Một vài ví dụ phổ biến là yêu cầu mạng, logging, chỉnh sửa DOM thủ công, v.v.</li></ul>\r<ul><li><strong>Effect có cleanup:</strong> Một số Hook effect sẽ yêu cầu cleanup sau khi cập nhật xong DOM. Ví dụ: nếu bạn muốn thiết lập đăng ký nguồn dữ liệu bên ngoài, nó yêu cầu dọn dẹp bộ nhớ, nếu không có thể xảy ra sự cố rò rỉ bộ nhớ. Có một thực tế là React sẽ thực hiện dọn dẹp bộ nhớ khi các component unmounting. Nhưng các effect sẽ chạy mỗi phương thức <code>render()</code> hơn là cho bất kỳ phương thức cụ thể nào. Do đó, chúng ta có thể nói rằng, trước khi thực thi các hiệu ứng thời gian, React cũng sẽ dọn dẹp các hiệu ứng từ lần hiển thị trước đó.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Prop drilling trong React?",
      "answer": "<p>Đôi khi trong việc phát triển các ứng dụng React, cần phải truyền dữ liệu từ một thành phần cao hơn trong hệ thống phân cấp đến một thành phần được lồng sâu vào nhau. Để truyền dữ liệu giữa các thành phần như vậy, ta chuyển các props từ một thành phần nguồn và tiếp tục truyền phần hỗ trợ cho thành phần tiếp theo trong hệ thống phân cấp cho đến khi chúng ta tiếp cận thành phần được lồng sâu.\r\n\r\nHạn chế của sử dụng prop drilling là việc truy cập dữ liệu sẽ vô cùng phức tạp trong các ứng dụng lớn.</p>",
      "level": "fresher"
    },
    {
      "question": "Error boundary là gì?",
      "answer": "<p>Được giới thiệu ở React v16, error boundary cung cấp một cách để xử lý lỗi xảy ra trong giai đoạn render.\r\n\r\nBất kỳ component nào sử dụng các phương thức lifecycle cũng được xem là một error boundary. Các vị trí mà error boundary có thể được phát hiện:\r\n\r\n1. Giai đoạn Render\r\n2. Trong một phương thức lifecycle\r\n3. Trong constructor\r\n\r\n<strong>Không dùng error boundary</strong>\r\n\r\n``<code>jsx\r\nclass CounterComponent extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            counterValue: 0\r\n        }\r\n        this.incrementCounter = this.incrementCounter.bind(this);\r\n    }\r\n\r\n    incrementCounter(){\r\n        this.setState(prevState =&gt; counterValue = prevState+1);\r\n    }\r\n    render(){\r\n        if(this.state.counter === 2){\r\n            throw new Error(&#39;Crashed&#39;);\r\n        }\r\n        return(\r\n            &lt;div&gt;\r\n                &lt;button onClick={this.incrementCounter}&gt;Increment Value&lt;/button&gt;\r\n                &lt;p&gt;Value of counter: {this.state.counterValue}&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, khi </code>counterValue<code> bằng 2, ta có lỗi bên trong phương thức render.\r\n\r\nKhi không dùng error boundary, ta sẽ thấy một trang trống thay vì lỗi. Bất cứ lỗi nào trong phương thức render đều dẫn đến unmounting component. Để hiển thị lỗi khi đó, ta sử dụng error boundary.\r\n\r\n<strong>Sử dụng error boundary</strong>: error bounary là một component sử dụng một hoặc cả hai phương thức sau:\r<ul><li></code>getDerivedStateFromError<code></li></ul>\r<ul><li></code>componentDidCatch<code></li></ul>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>jsx\r\nclass ErrorBoundary extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { hasError: false };\r\n    }\r\n    static getDerivedStateFromError(error) {     \r\n        return { hasError: true }; \r\n    }\r\n    componentDidCatch(error, errorInfo) {       \r\n        logErrorToMyService(error, errorInfo); \r\n    }\r\n    render() {\r\n        if (this.state.hasError) {     \r\n            return &lt;h4&gt;Something went wrong&lt;/h4&gt;     \r\n        }\r\n        return this.props.children;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, hàm </code>getDerivedStateFromError<code> render một fallback UI interface khi phương thực render có lỗi.\r\n\r\n</code>componentDidCatch<code> ghi lại thông tin lỗi vào một dịch vụ theo dõi lỗi.\r\n\r\nBây giờ với error boundary ta có thể render CounterComponent như sau:\r\n\r\n</code>`<code>jsx\r\n&lt;ErrorBoundary&gt;\r\n    &lt;CounterComponent /&gt;\r\n&lt;/ErrorBoundary&gt;\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "React Hooks là gì?",
      "answer": "<p>React Hooks là các hàm có sẵn cho phép các nhà phát triển sử dụng các phương thức trạng thái (state) và vòng đời (lifecycle) trong các component React. Đây là những tính năng mới được bổ sung có sẵn trong phiên bản React 16.8. Mỗi lifecycle của một component có 3 giai đoạn bao gồm mount, unmount và update. Cùng với đó, các component có state và props. Hooks sẽ cho phép các nhà phát triển sử dụng các phương pháp này để cải thiện việc tái sử dụng code với tính linh hoạt cao hơn trong việc điều hướng cây component.\r\n\r\nSử dụng Hook, tất cả các tính năng của React có thể được sử dụng mà không cần viết các class component. Ví dụ, trước phiên bản React 16.8, nó yêu cầu một class component để quản lý trạng thái của một component. Nhưng bây giờ bằng cách sử dụng hook useState, chúng ta có thể giữ trạng thái trong một function component.</p>",
      "level": "fresher"
    },
    {
      "question": "Tại sao lại cần React Hook?",
      "answer": "<p>React hooks đã được giới thiệu trong phiên bản 16.8 của React. Trước đây, các function component được gọi là stateless component. Chỉ các class component mới được sử dụng cho các phương thức quản lý trạng thái và vòng đời. Nhưng vì class component quá nặng nếu như chỉ cần thay đổi một vài state hay phương thức trong lifecycle. Điều đó dẫn đến sự ra đời của React Hooks.\r\n\r\nVí dụ: sử dụng hook useState\r\n\r\n``<code>jsx\r\nfunction Person(props) {\r\n// We are declaring a state variable called name.\r\n// setName is a function to update/change the value of name\r\nlet [name, setName] = useState(&#39;&#39;);\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Các quy tắc sử dụng React Hooks?",
      "answer": "<p><ul><li>Chỉ có thể gọi hooks trong function component (không thể dùng trong class).</li></ul>\r<ul><li>Chỉ có thể gọi ở cấp cao, không thể gọi trong hàm, vòng lặp hay điều kiện.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Cách dùng useEffect?",
      "answer": "<p>React Hook useEffect được dùng cho thực hiện side effect trong function component. Với useEffect, ta sẽ thông báo cho React biết các component của bạn yêu cầu phải thực hiện điều gì đó sau khi render component hoặc sau khi thay đổi trạng thái. Function đã được truyền sẽ được React nhớ và gọi sau khi quá trình cập nhật DOM kết thúc. Nhừo điều này ta có thể thực hiện các thao tác khác nhau như tìm nạp dữ liệu, thiệt lập tiêu đều, quản lý DOM trực tiếp,... mà không nhắm đến giá trị output. Hook useEffect sẽ chạy theo mặc định sau lần render đầu tiên và mỗi lần cập nhật component. React đảm bảo tằng DOM sẽ  được cập nhật vào thời điểm effect chạy bởi nó.\r\n\r\nuseEffect nhận vào hai thám số: <code>useEffect(callback[, dependencies]);</code>\r\n\r\nTrong đó tham số calback đầu tiên biểu diễn hàm chứa logic side-effect và sẽ thực thi ngay lập tức khi ta thực hiện thay đổi lên DOM. Tham số dependencies thứ hai biểu diễn mảng các dependencies. useEffect chỉ thực thi nếu các dependencies có thay đổi khi render.\r\n\r\nVí dụ:\r\n\r\n``<code>jsx\r\nimport { useEffect } from &#39;react&#39;;\r\n\r\nfunction WelcomeGreetings({ name }) {\r\n    const msg = </code>Hi, ${name}!<code>;     // Calculates output\r\n\r\n    useEffect(() =&gt; {\r\n        document.title = </code>Welcome to you ${name}<code>;    // Side-effect!\r\n    }, [name]);\r\n\r\n    return &lt;div&gt;{msg}&lt;/div&gt;;         // Calculates output\r\n}\r\n</code>`<code>\r\n\r\nĐoạn code trên sẽ cập nhật tiêu đề document nó được xem như một side-effect vì nó không tính toán output trực tiếp. Đó là lý do tại sao cập nhật tiêu đề document  được đặt trong callback và cung cấp cho </code>useEffect()<code>.\r\n\r\nHãy cân nhắc rằng bạn không muốn thực hiện cập nhật tiêu đề document mỗi lần render component </code>WelcomeGreetings<code> và bạn muốn nó chỉ được thực thi khi prop </code>name<code> thay đổi thì bạn cần cung cấp </code>name<code> làm phụ thuộc đến </code>useEffect(callback, [name])`.</p>",
      "level": "fresher"
    },
    {
      "question": "Sử dụng refs với React Hooks?",
      "answer": "<p>Trước đây, các ref chỉ giới hạn trong các class component nhưng giờ đây nó cũng có thể được truy cập trong các function component thông qua <code>useRef</code> trong React Hook.\r\n\r\nCác refs được sử dụng cho:\r<ul><li>Quản lý tiêu điểm, phát lại phương tiện hoặc lựa chọn văn bản.</li></ul>\r<ul><li>Tích hợp với các thư viện DOM của bên thứ ba.</li></ul>\r<ul><li>Kích hoạt các ảnh động bắt buộc.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Hook tuỳ chỉnh là gì?",
      "answer": "<p>Một hook tùy chỉnh(custom hooks) là một hàm trong Javascript có tên bắt đầu bằng <strong>use</strong> và gọi các hook khác. Nó là một phần của bản cập nhật hook React v16.8 và cho phép bạn sử dụng lại logic trạng thái mà không cần phải cấu trúc lại cấu trúc phân cấp component.\r\n\r\nTrong hầu hết các trường hợp, hook tùy chỉnh được coi là đủ để thay thế render props và HoC (High-Order components) và giảm số lượng lồng ghép cần thiết. Hooks  tuỳ chỉnh sẽ cho phép bạn tránh nhiều lớp trừu tượng hoặc wrapper hell có thể đi kèm với render props và HoC.\r\n\r\nNhược điểm của Hooks tuỳ chỉnh là nó không thể được sử dụng bên trong các lớp.\r\n\r\n## Câu hỏi phỏng vấn React cho Experienced</p>",
      "level": "fresher"
    },
    {
      "question": "Strict mode trong React là gì?",
      "answer": "<p>StrictMode là công cụ được thêm vào ở React v16.3 để highlight các vấn đề tiềm ẩn trong React. Nó thực hiện kiểm tra bổ sung lên ứng dụng.\r\n\r\n``<code>jsx\r\nfunction App() {\r\n    return (\r\n        &lt;React.StrictMode&gt;\r\n            &lt;div classname=&quot;App&quot;&gt;\r\n                &lt;Header/&gt;\r\n                &lt;div&gt;\r\n                    Page Content\r\n                &lt;/div&gt;\r\n                &lt;Footer/&gt;\r\n            &lt;/div&gt;\r\n        &lt;/React.StrictMode&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nĐể khởi động StrictMode, thẻ </code><React.StrictMode><code> được thêm vào ứng dụng:\r\n\r\n</code>`<code>js\r\nimport React from &quot;react&quot;;\r\nimport ReactDOM from &quot;react-dom&quot;;\r\nimport App from &quot;./App&quot;;\r\nconst rootElement = document.getElementById(&quot;root&quot;);\r\nReactDOM.render(\r\n&lt;React.StrictMode&gt;\r\n  &lt;App /&gt;\r\n&lt;/React.StrictMode&gt;,\r\nrootElement\r\n);\r\n</code>`<code>\r\n\r\nStrictMode giúp giải quyết các vấn đề sau:\r<ul><li><strong>Xác định các component với phương thức lifecycle</strong></li></ul>\r<ul><li>Một số phương thức lifecycle không an toàn khi dùng bất đồng bộ trong ứng dụng react. Với thư viện bên thứ 3, thật khó để đảm bảo một số phương thức lifecycle nhất định không được dùng.</li></ul>\r<ul><li>StrictMode giúp ta bằng cách cung cấp cảnh báo với bất kỳ class component nào sử dụng phương thức lifecycle không an toàn.</li></ul>\r<ul><li><strong>Cảnh báo sử dụng chuỗi API kế thừa</strong></li></ul>\r<ul><li>Nếu sử dụng phiên bản cũ của React, <strong>callback ref</strong> được đề nghị là cách để quản lý <strong>refs</strong> thay vì dùng <strong>chuỗi refs</strong>. StringMode đưa ra cảnh báo nếu bản sử dụng chuỗi ref để quản lý refs.</li></ul>\r<ul><li><strong>Cảnh báo sử dụng findDOMNode</strong></li></ul>\r<ul><li>Phương thức </code>findDOMNode()` dùng để tìm cây của node DOM. Phương thức này đã không còn hỗ trợ trogn React. Do đó, StrictMode đưa ra cảnh báo khi ta dùng phương thức này.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Ngăn chặn re-render trong React?",
      "answer": "<p>Nguyên nhân cho re-render:\r<ul><li>Re-render một component và con của nó xảy ra khi props hoặc state của component thay đổi</li></ul>\r<ul><li>Re-render component không có cập nhật, sẽ ảnh hưởng đến hiệu suất của ứng dụng</li></ul>\r\n\r\nCách để chặn re-render:\r\n\r\n``<code>jsx\r\nclass Parent extends React.Component {\r\n    state = { messageDisplayed: false };\r\n    \r\n    componentDidMount() {\r\n        this.setState({ messageDisplayed: true });\r\n    }\r\n    \r\n    render() {\r\n        console.log(&quot;Parent is getting rendered&quot;);\r\n        return (\r\n            &lt;div className=&quot;App&quot;&gt;\r\n                &lt;Message /&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n    \r\nclass Message extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { message: &quot;Hello, this is vivek&quot; };\r\n    }  \r\n    \r\n    render() {\r\n        console.log(&quot;Message is getting rendered&quot;);\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;p&gt;{this.state.message}&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nComponent </code>Parent<code> là cha của component </code>Message<code>. Bất kỳ thay đổi nào đến </code>Parent<code> sẽ dẫn đến re-render ở cả </code>Message<code>. Để ngăn chặn điều này, ta sử dụng phương thức </code>shouldComponentUpdate()<code>:\r\n\r\n</code>`<code>jsx\r\nclass Message extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { message: &quot;Hello, this is vivek&quot; };\r\n    }\r\n\r\n    shouldComponentUpdate() {\r\n        console.log(&quot;Does not get rendered&quot;);\r\n        return false;\r\n    }\r\n\r\n    render() {\r\n        console.log(&quot;Message is getting rendered&quot;);\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;p&gt;{this.state.message}&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nNhư đã thấy, ta trả về false cho phương thức </code>shouldComponentUpdate()` ngăn chặn component con bị re-render.</p>",
      "level": "fresher"
    },
    {
      "question": "Các cách khác nhau để chỉnh style component?",
      "answer": "<p><strong>Inline Styling:</strong> ta có thể chỉnh style trực tiếp lên phần tử bằng cách dùng thuộc tính <code>style</code>. Nhớ giá trị của <code>style</code> luôn là đối tượng JavaScript:\r\n\r\n``<code>jsx\r\nclass RandomComponent extends React.Component {\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n            &lt;h3 style={{ color: &quot;Yellow&quot; }}&gt;This is a heading&lt;/h3&gt;\r\n            &lt;p style={{ fontSize: &quot;32px&quot; }}&gt;This is a paragraph&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>Javascript Object:</strong> ta có thể tạo đối tượng JavaScript và tập mô tả thuộc tính style. Các đối tượng có thể dùng như giá trị của thuộc tính style.\r\n\r\n</code>`<code>jsx\r\nclass RandomComponent extends React.Component {\r\n    paragraphStyles = {\r\n        color: &quot;Red&quot;,\r\n        fontSize: &quot;32px&quot;\r\n    };\r\n\r\n    headingStyles = {\r\n        color: &quot;blue&quot;,\r\n        fontSize: &quot;48px&quot;\r\n    };\r\n\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n            &lt;h3 style={this.headingStyles}&gt;This is a heading&lt;/h3&gt;\r\n            &lt;p style={this.paragraphStyles}&gt;This is a paragraph&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>CSS Stylesheet:</strong> Ta sẽ tạo một file CSS riêng và viết tất cả style cho component trong file đó. Sau đó import nó vào file React.\r\n\r\n</code>`<code>jsx\r\nimport &#39;./RandomComponent.css&#39;;\r\n\r\nclass RandomComponent extends React.Component {\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;h3 className=&quot;heading&quot;&gt;This is a heading&lt;/h3&gt;\r\n                &lt;p className=&quot;paragraph&quot;&gt;This is a paragraph&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>CSS Module:</strong> Tương tự như file CSS, nhưng ta sửa thành </code>.module.css<code>, với cách này tên lớp sẽ được mã hoá, đồng thời nó hỗ trợ kiểu viết tương tự sass.\r\n\r\n</code>`<code>css\r\n.paragraph{\r\n    color:&quot;red&quot;;\r\n    border:1px solid black;\r\n}\r\n</code>`<code>\r\n\r\nTa có thể import file vào component như sau:\r\n\r\n</code>`<code>jsx\r\nimport styles from  &#39;./styles.module.css&#39;;\r\n\r\nclass RandomComponent extends React.Component {\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;h3 className=&quot;heading&quot;&gt;This is a heading&lt;/h3&gt;\r\n                &lt;p className={styles.paragraph} &gt;This is a paragraph&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Các kỹ thuật tối ưu hiệu suất ứng dụng React?",
      "answer": "<p><ul><li><strong>useMemo()</strong></li></ul>\r<ul><li>Là hook dùng cho caching CPU.</li></ul>\r<ul><li>Đôi khi trong các ứng dụng web, các hàm đắt (tính toán nhiều, tốn bộ nhớ) được gọi liên túc do re-render đẫn đến tốc độ render chậm, hiệu suất kém.</li></ul>\r<ul><li>useMemo() có thể sử dụng cho cache cám hàm như vậy. Bằng cách dùng useMemo() các hàm đó chỉ được gọi khi cần thiết.</li></ul>\r<ul><li><strong>React.PureComponent</strong></li></ul>\r<ul><li>Là class component cơ sở để kiểm tra state và props của một component để biết khi nào nó nên được cập nhật.</li></ul>\r<ul><li>Thay vì dùng React.Component, ta có sử dụng React.PureComponent để giảm việc re-render không cần thiết.</li></ul>\r<ul><li><strong>Duy trì vị trí state</strong></li></ul>\r<ul><li>Đây là quá trình chuyển state đến nơi bạn nhất có thể.</li></ul>\r<ul><li>Thỉnh thoảng ta có các state không cần thiết nằm trong component cha để gây khó đọc và bảo trì hơn, thậm chí là dẫn đến re-render không cần thiết.</li></ul>\r<ul><li>Để tốt hơn, ta chuyển các state vô nghĩa ở component cha sang một component riêng biệt.</li></ul>\r<ul><li><strong>Lazy Loading</strong></li></ul>\r<ul><li>Đây là kỹ thuật dùng để giảm thời gian tải của ứng dụng React. Lazy loading giúp tối ưu hiệu suất ứng dụng web bằng cách chỉ tải khi cần thiết.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Truyền dữ liệu giữa các component?",
      "answer": "<p><img src=\"/interview-assets/How_to_pass_data_between_react_components.png\" alt=\"\" />\r\n\r\n<strong>Từ component cha sang component con (dùng props)</strong>\r\n\r\nTa có thể làm như sau:\r\n\r\n``<code>jsx\r\nimport ChildComponent from &quot;./Child&quot;;\r\n\r\nfunction ParentComponent(props) {\r\n    let [counter, setCounter] = useState(0);\r\n    let increment = () =&gt; setCounter(++counter);\r\n   \r\n    return (\r\n        &lt;div&gt;\r\n            &lt;button onClick={increment}&gt;Increment Counter&lt;/button&gt;\r\n            &lt;ChildComponent counterValue={counter} /&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nNhư ta có thể thấy trong đoạn code trên, ta đang hiển thị component con bên trong component cha, bằng cách cung cấp một prop tên là </code>counterValue<code>. Giá trị của </code>counter<code> được chuyển từ component cha sang con.\r\n\r\nTa có thể sử dụng dữ liệu được chuyển đến component con như sau:\r\n\r\n</code>`<code>jsx\r\nfunction ChildComponent(props) {\r\n    return (\r\n        &lt;div&gt;\r\n            &lt;p&gt;Value of counter: {props.counterValue}&lt;/p&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\n<strong>Từ component con sang cha (dùng callback)</strong>\r\n\r\nTa có các bước sau:\r<ul><li>Tạo một callback trong component cha nhận dữ liệu cần thiết như tham số.</li></ul>\r<ul><li>Truyền callback này như props cho component con.</li></ul>\r<ul><li>Gửi dữ liệu từ component con bằng cách dùng callback.</li></ul>\r\n\r\nVí dụ:\r\n\r\nTạo callback và gửi nó như prop đến component con:\r\n\r\n</code>`<code>jsx\r\nfunction ParentComponent(props) {\r\n    let [counter, setCounter] = useState(0);\r\n    let callback = valueFromChild =&gt; setCounter(valueFromChild);\r\n\r\n    return (\r\n        &lt;div&gt;\r\n            &lt;p&gt;Value of counter: {counter}&lt;/p&gt;\r\n            &lt;ChildComponent callbackFunc={callback} counterValue={counter} /&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nSau đó ta truyền dữ liệu từ component con đến component cha:\r\n\r\n</code>`<code>jsx\r\nfunction ChildComponent(props) {\r\n    let childCounterValue = props.counterValue;\r\n    \r\n    return (\r\n        &lt;div&gt;\r\n            &lt;button onClick={() =&gt; props.callbackFunc(++childCounterValue)}&gt;\r\n                Increment Counter\r\n            &lt;/button&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nBây giờ khi ta click vào button, ta sẽ tăng giá trị </code>childCounterValue<code> đến </code>props.callbackFunc`.</p>",
      "level": "fresher"
    },
    {
      "question": "High-Order Component là gì?",
      "answer": "<p>High-Order Component (HOC) là một hàm nhận một component làm tham số và trả về một component mới.\r\n\r\n<img src=\"/interview-assets/Higher_Order_Components.png\" alt=\"\" />\r\n\r\n<em>Tại sao lại cần HOC</em>\r\n\r\nTrong phát triển ứng dụng React, ta có thể phát triển component khá giống nhau với vài sự khác biệt nhỏ. Trong hầu hết trường hợp, việc phát triển các component tương tự không phải là vấn đề, nhưng khi ứng dụng lớn hơn, chúng ta cần giữ cho code mình DRY. Do đó, chúng ta muốn một sự trừu tượng cho phép chúng ta xác định logic này ở một nơi duy nhất và chia sẻ nó trên các component. HOC cho phép chúng ta tạo ra sự trừu tượng đó.\r\n\r\nVí dụ:\r\n\r\nComponent sau dùng để hiển thị danh sách bài viết:\r\n\r\n``<code>jsx\r\n// &quot;GlobalDataSource&quot; is some global data source\r\nclass ArticlesList extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.handleChange = this.handleChange.bind(this);\r\n        this.state = {\r\n            articles: GlobalDataSource.getArticles(),\r\n        };\r\n    }\r\n    componentDidMount() {\r\n        // Listens to the changes added\r\n        GlobalDataSource.addChangeListener(this.handleChange);\r\n    }\r\n    componentWillUnmount() {\r\n        // Listens to the changes removed\r\n        GlobalDataSource.removeChangeListener(this.handleChange);\r\n    }\r\n    handleChange() {\r\n        // States gets Update whenver data source changes\r\n        this.setState({\r\n            articles: GlobalDataSource.getArticles(),\r\n        });\r\n    }\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n                {this.state.articles.map((article) =&gt; (\r\n                    &lt;ArticleData article={article} key={article.id} /&gt;\r\n                ))}\r\n            &lt;/div&gt;\r\n        );  \r\n    }\r\n}\r\n</code>`<code>\r\n\r\nComponent sau dùng để hiển thị danh sách người dùng:\r\n\r\n</code>`<code>jsx\r\n// &quot;GlobalDataSource&quot; is some global data source\r\nclass UsersList extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.handleChange = this.handleChange.bind(this);\r\n        this.state = {\r\n            users: GlobalDataSource.getUsers(),\r\n        };\r\n    }\r\n    componentDidMount() {\r\n        // Listens to the changes added\r\n        GlobalDataSource.addChangeListener(this.handleChange);\r\n    }\r\n    componentWillUnmount() {\r\n        // Listens to the changes removed\r\n        GlobalDataSource.removeChangeListener(this.handleChange);\r\n    }\r\n    handleChange() {\r\n        // States gets Update whenver data source changes\r\n        this.setState({\r\n            users: GlobalDataSource.getUsers(),\r\n        });\r\n    }\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n            {this.state.users.map((user) =&gt; (\r\n                &lt;UserData user={user} key={user.id} /&gt;\r\n            ))}\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nBây giờ ta có hai component có chức năng giống nhau chỉ khác về API được gọi. Ta sẽ tạo một HOC dùng chung cho cả hai:\r\n\r\n</code>`<code>jsx\r\n// Higher Order Component which takes a component\r\n// as input and returns another component\r\n// &quot;GlobalDataSource&quot; is some global data source\r\nfunction HOC(WrappedComponent, selectData) {\r\n    return class extends React.Component {\r\n        constructor(props) {\r\n            super(props);\r\n            this.handleChange = this.handleChange.bind(this);\r\n            this.state = {\r\n                data: selectData(GlobalDataSource, props),\r\n            };\r\n        }\r\n        componentDidMount() {\r\n            // Listens to the changes added\r\n            GlobalDataSource.addChangeListener(this.handleChange);\r\n        }\r\n        componentWillUnmount() {\r\n            // Listens to the changes removed\r\n            GlobalDataSource.removeChangeListener(this.handleChange);\r\n        }\r\n        handleChange() {\r\n            this.setState({\r\n            data: selectData(GlobalDataSource, this.props),\r\n            });\r\n        }\r\n        render() {\r\n            // Rendering the wrapped component with the latest data data\r\n            return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt;;\r\n        }\r\n    };\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên ta tạo HOC trả về một component và thực hiện vài hành động có thể dùng chung trên cả component </code>ArticleList<code> và </code>UsersList<code>.\r\n\r\nTham số thứ hai là hàm gọi cho phương thức trên API.\r\n\r\nTa đã giảm code trùng lặp giữa </code>componentDidUpdate<code> và </code>componentDidMount<code>. Bây giờ ta có component </code>ArticleList<code> và </code>UsersList<code> như sau:\r\n\r\n</code>`<code>jsx\r\nconst ArticlesListWithHOC = HOC(ArticlesList, (GlobalDataSource) =&gt; GlobalDataSource.getArticles());\r\nconst UsersListWithHOC = HOC(UsersList, (GlobalDataSource) =&gt; GlobalDataSource.getUsers());\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Các giai đoạn trong vòng đời component?",
      "answer": "<p>Có 3 giai đoạn trong vòng đời component React.\r<ul><li><strong>Mounting</strong>: đề cập đến việc đưa phần tử vào DOM của trình duyệt. Vì React dùng virtual DOM, toàn bộ DOM của trình duyệt đã render sẽ không được làm mới. Bao gồm các phương thức trong giai đoạn này bao gồm: <code>constructor</code> và <code>componentDidMount</code>.</li></ul>\r<ul><li><strong>Updating</strong>: Trong giai đoạn này, component sẽ được cập nhật khi có thay đổi state hoặc props của component. Các phương thức trong giai đoạn này: <code>getDerivedStateFromProps</code>, <code>shouldComponentUpdate</code>, <code>render</code>, và <code>componentDidUpdate</code>.</li></ul>\r<ul><li><strong>Unmounting</strong>: Ở giai đoạn cuối, component sẽ bị xoá khỏi DOM. Giai đoạn này  sẽ có phương thức là <code>componentWillUnmount</code>.</li></ul>\r\n\r\n<img src=\"/interview-assets/different_phases_of_the_component_lifecycle.png\" alt=\"\" /></p>",
      "level": "fresher"
    },
    {
      "question": "Các phương thức trong vòng đời component?",
      "answer": "<p>Trong vòng đời của React sẽ có các phương thức sẽ được gọi tự động ở các giai đoạn khác nhau trong vòng đời của component và do đó nó cung cấp khả năng kiểm soát tốt những gì xảy ra tại điểm được gọi. Nó cung cấp năng lực để kiểm soát và thao tác hiệu quả những gì diễn ra trong suốt vòng đời của component.\r\n\r\nVí dụ: nếu bạn đang phát triển ứng dụng YouTube, thì ứng dụng sẽ sử dụng mạng để đệm video và nó tiêu tốn pin (giả sử chỉ có hai mạng này). Sau khi phát video, nếu người dùng chuyển sang bất kỳ ứng dụng nào khác, thì bạn nên đảm bảo rằng các tài nguyên như mạng và pin đang được sử dụng hiệu quả nhất. Bạn có thể dừng hoặc tạm dừng tải video vào bộ đệm, do đó sẽ ngừng sử dụng pin và mạng khi người dùng chuyển sang ứng dụng khác sau khi phát video.\r\n\r\nVì vậy, chúng ta có thể nói rằng nhà phát triển sẽ có thể tạo ra một ứng dụng chất lượng với sự trợ giúp của các phương pháp vòng đời và nó cũng giúp các nhà phát triển đảm bảo lập kế hoạch những gì và làm như thế nào tại các thời điểm sinh, phát triển hoặc chết của giao diện người dùng.\r\n\r\nCác phương thức trong vòng đời:\r<ul><li><code>constructor()</code>: phương thức được gọi khi component được tạo trước khi thực hiện bất kỳ hành động gì. Nó giúp tạo state và props.</li></ul>\r<ul><li><code>getDerivedStateFromProps()</code>: nó sẽ gọi trước khi phần tử được render vào DOM. Nó giúp thiết lập đối tượng state dựa trên props khởi tạo. Phương thức <code>getDerivedStateFromProps</code> sẽ có một state như đối số và trả về một đối tượng để thay đổi state. Nó sẽ là phương thức đầu tiên được gọi khi thực hiện cập nhật.</li></ul>\r<ul><li><code>render()</code>: phương thức này sẽ render HTML từ DOM với thay đổi mới nhất. Phương thức <code>render</code> sẽ được gọi mỗi khi có thay đổi đến component.</li></ul>\r<ul><li><code>componentDidMount()</code>: phương thức sẽ được gọi sau khi render component. Ta có thể chạy lệnh cần component đã được lưu trong DOM.</li></ul>\r<ul><li><code>shouldComponentUpdate()</code>: trả về giá trị boolean để quyết định xem có render hay không. Mặc định sẽ là True.</li></ul>\r<ul><li><code>getSnapshotBeforeUpdate()</code>: cung cáp truy cập cho props cung như state trước khi cập nhật. Nó dùng cho kiểm tra giá trị trước khi cập nhật.</li></ul>\r<ul><li><code>componentDidUpdate()</code>: được gọi sau khi cập nhật component trong DOM.</li></ul>\r<ul><li><code>componentWillUnmount()</code>: phương thức được gọi khi component bị xoá khỏi DOM.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "React hook có làm việc với static typing?",
      "answer": "<p>Static typing đề cập đến quá trình kiểm tra code trong suốt thời gian biên dịch để đảm bảo mọi biến đề sẽ được nhập. React Hook là hàm được thiết kế để đảm bảo mọi thuộc tính sẽ được nhập tĩnh. Để thực thi nhập tĩnh chặt chẽ hơn trong code, ta có thể sử dụng API React với các Hook tùy chỉnh.</p>",
      "level": "fresher"
    },
    {
      "question": "Các kiểu Hooks trong React?",
      "answer": "<p><strong>Hook có sẵn</strong>: là các hooks được hỗ trợ sẵn trong React:\r<ul><li><strong>Hook cơ bản</strong>:</li></ul>\r<ul><li><code>useState()</code>: là component dùng cho thiết lập và chỉnh sửa state.</li></ul>\r<ul><li><code>useEffect()</code>: cho phép thực hiện side effect trên function component.</li></ul>\r<ul><li><code>useContext()</code>: dùng cho tạo dữ liệu chung có thể truy cập trong hệ phân cấp component mà không cần truyền dữ liệu theo props từ trên xuống.</li></ul>\r<ul><li><strong>Hook nâng cao</strong>:</li></ul>\r<ul><li><code>useReducer()</code>: dùng cho các logic state phức tạp có nhiều giá trị con khi cập nhật state phụ thuộc vào state trước đó. Nó sẽ giúp tối ưu hoá hiệu suất component khi kích hoạt các bản cập nhật sâu hơn vì nó được truyền xuống thay vì callback.</li></ul>\r<ul><li><code>useMemo()</code>: điều này sẽ được sử dụng để tính toán lại giá trị đã ghi nhớ khi có sự thay đổi trong một trong các phần phụ thuộc. Việc tối ưu hóa này sẽ giúp tránh các tính toán tốn kém trên mỗi lần render.</li></ul>\r<ul><li><code>useCallback()</code>: hữu ích khi truyền callback vào component con đã tối ưu hoá và phụ thuộc vào tham chiếu để ngăn chặn các render không cần thiết.</li></ul>\r<ul><li><code>useImperativeHandle()</code>: cho phép chỉnh sửa thực thể sẽ được truyền cho đối tượng ref.</li></ul>\r<ul><li><code>useDebugValue()</code>: dùng cho hiển thị nhãn hoặc hook tuỳ chỉnh trong React DevTools.</li></ul>\r<ul><li><code>useRef()</code>: Nó sẽ cho phép tạo một tham chiếu đến phần tử DOM trực tiếp trong function component.</li></ul>\r<ul><li><code>useLayoutEffect()</code>: dùng cho đọc bố cục từ DOM và re-render bất đồng bộ.</li></ul>\r\n\r\n<strong>Hook tuỳ chỉnh</strong>: là một hàm JavaScript. Hoạt động giống như một hàm thông thường với \"use\" phía trước để React hiểu đó là một hook tuỳ chỉnh và sẽ mô tả các hàm đặc biệt theo quy tắc của Hook. Hơn thế nữa, việc phát triển hook tuỳ chỉnh cho phép bạn trích xuất logic component trong các hàm có thể tái sử dụng\r\n\r\n<img src=\"/interview-assets/types_of_Hooks_in_React.png\" alt=\"\" /></p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa lớp và React Hook?",
      "answer": "<p>| React Hook | Lớp |\r\n|-|-|\r\n| Được dùng cho function component | Được dùng cho class component |\r\n| Không yêu cầu khai báo constructor | Cần constructor trong các class component |\r\n| Không yêu cầu con trỏ this cho khai báo hay chỉnh sửa | Cần dùng this cho khai báo state (this.state) và chỉnh sửa (this.setState()) |\r\n| Dễ sử dụng với useState | Không có hàm cụ thể giúp ta truy cập state với setState tương ứng |\r\n| Hữu dụng khi triển khai Redux và Context API | Quá trình thiết lập state lâu, nên class state sẽ không được ưu tiên |</p>",
      "level": "fresher"
    },
    {
      "question": "Hiệu suất của React Hook so với lớp?",
      "answer": "<p><ul><li>React Hooks sẽ tránh được rất nhiều chi phí như tạo thực thể, liên kết các sự kiện, .., có trong các lớp.</li></ul>\r<ul><li>Các hook trong React sẽ dẫn đến các cây component nhỏ hơn vì chúng sẽ tránh được việc lồng nhau tồn tại trong HOC và sẽ render props dẫn đến việc React phải thực hiện ít công việc hơn.r</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Các hook có thay thế được lớp hoàn toàn?",
      "answer": "<p>Mục đích của Hook là thay thế các chức năng được cung cấp bởi lớp. Nhưng có các phương thức mà Hook vẫn chưa thay thế được lớp:\r<ul><li><code>getSnapshotBeforeUpdate()</code></li></ul>\r<ul><li><code>getDerivedStateFromError()</code></li></ul>\r<ul><li><code>componentDidCatch()</code></li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "React Router là gì?",
      "answer": "<p>React Router đề cập đến thư viện tiêu chuẩn được sử dụng để định tuyến trong React. Nó cho phép chúng tôi xây dựng một ứng dụng web trong React với điều hướng mà không cần làm mới trang khi người dùng điều hướng. Nó cũng cho phép thay đổi URL của trình duyệt và sẽ giữ cho giao diện người dùng đồng bộ với URL. React Router sẽ sử dụng cấu trúc component để gọi các component, sử dụng thông tin thích hợp có thể được hiển thị.\r\n\r\nCài đặt với npm:\r\n\r\n``<code>\r\nnpm install react-router-dom\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "React Hook có thể thay thế Redux?",
      "answer": "<p>React Hook không thể được coi là sự thay thế cho Redux (Nó là một thư viện JavaScript mã nguồn mở, hữu ích trong việc quản lý trạng thái ứng dụng) khi nói đến việc quản lý toàn bộ state trong các ứng dụng phức tạp lớn, mặc dù React sẽ cung cấp một hook <code>useReducer</code> quản lý các chuyển đổi trạng thái tương tự như Redux. Nhưng Redux hữu ích ở cấp độ thấp hơn của hệ thống phân cấp component để xử lý các phần của state phụ thuộc vào nhau, thay vì khai báo nhiều hook <code>useState</code>.\r\n\r\nTrong các ứng dụng web thương mại lớn hơn, độ phức tạp sẽ cao, vì vậy chỉ sử dụng React Hook có thể không đủ. Một số nhà phát triển sẽ cố gắng giải quyết thách thức với sự trợ giúp của React Hooks và những người khác sẽ kết hợp React Hooks với Redux.</p>",
      "level": "fresher"
    },
    {
      "question": "Render có điều kiện trong React?",
      "answer": "<p>Render có điều kiện đề cập kết quả động của giao diện người dùng dựa trên điều kiện state. Nó hoạt động tương tự điều kiện JavaScript. Sử dụng render có điều kiện, nó có thể chuyển đổi các hàm ứng dụng cụ thể, API dữ liệu, ẩn hoặc hiện các phần tử, phân quyền, xử lý xác thức,...\r\n\r\nCác cách khác nhau cho triển khai render có điều kiện trong React:\r<ul><li>Sử dụng if-else phù hợp với các ứng dụng vừa và nhỏ.</li></ul>\r<ul><li>Sử dụng toán tử ba ngôi (<code>?:</code>) giúp giảm bớt câu lệnh if-else phức tạp.</li></ul>\r<ul><li>Sử dụng biến phần tử, phù hợp cho viết code sạch.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa NavLink và Link?",
      "answer": "<p><code>&lt;Link&gt;</code> dùng cho điều hướng các trang khác nhau trong ứng dụng web. Còn <code>&lt;NavLink&gt;</code> được dùng để thêm thuộc tính cho hoạt động chuyển hướng.\r\n\r\n<strong>Cú pháp</strong>\r<ul><li>Link:</li></ul>\r\n\r\n``<code>jsx\r\n&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;\r\n</code>`<code>\r<ul><li>NavLink:</li></ul>\r\n\r\n</code>`<code>jsx\r\n&lt;NavLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;Home&lt;/NavLink&gt;\r\n</code>`<code>\r\n\r\n<strong>Ví dụ</strong>\r\n\r\nindex.css\r\n\r\n</code>`<code>css\r\n.active {\r\n  color: blue;\r\n}\r\n</code>`<code>\r\n\r\nRoutes.js\r\n\r\n</code>`<code>jsx\r\nimport ReactDOM from &#39;react-dom&#39;\r\nimport &#39;./index.css&#39;\r\nimport { Route, NavLink, BrowserRouter as Router, Switch } from &#39;react-router-dom&#39;\r\nimport App from &#39;./App&#39;\r\nimport Users from &#39;./users&#39;\r\nimport Contact from &#39;./contact&#39;\r\nimport Notfound from &#39;./notfound&#39;\r\n\r\nconst Routes = (\r\n    &lt;Router&gt;\r\n        &lt;div&gt;\r\n            &lt;ul&gt;\r\n                &lt;li&gt;\r\n                &lt;NavLink exact activeClassName=&quot;active&quot; to=&quot;/&quot;&gt;\r\n                    Home\r\n                &lt;/NavLink&gt;\r\n                &lt;/li&gt;\r\n                &lt;li&gt;\r\n                &lt;NavLink activeClassName=&quot;active&quot; to=&quot;/users&quot;&gt;\r\n                    Users\r\n                &lt;/NavLink&gt;\r\n                &lt;/li&gt;\r\n                &lt;li&gt;\r\n                &lt;NavLink activeClassName=&quot;active&quot; to=&quot;/contact&quot;&gt;\r\n                    Contact\r\n                &lt;/NavLink&gt;\r\n                &lt;/li&gt;\r\n            &lt;/ul&gt;\r\n            &lt;hr /&gt;\r\n            &lt;Switch&gt;\r\n                &lt;Route exact path=&quot;/&quot; component={App} /&gt;\r\n                &lt;Route path=&quot;/users&quot; component={Users} /&gt;\r\n                &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;\r\n                &lt;Route component={Notfound} /&gt;\r\n            &lt;/Switch&gt;\r\n        &lt;/div&gt;\r\n    &lt;/Router&gt;\r\n)\r\n\r\nReactDOM.render(Routes, document.getElementById(&#39;root&#39;))\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "withRouter trong react-router-dom là gì?",
      "answer": "<p><code>withRouter()</code> là một HOC cho phép truy cập thuộc tính đối tượng <code>history</code> ứng với <code>&lt;Route&gt;</code> gần nhất. Nó sẽ truyền <code>match</code>, <code>location</code> và <code>history</code> như props đến component được bọc bất cứ khi nào nó render.\r\n\r\nVí dụ:\r\n\r\n``<code>jsx\r\nimport React from &quot;react&quot;\r\nimport PropTypes from &quot;prop-types&quot;\r\nimport { withRouter } from &quot;react-router&quot;\r\n\r\n// A simple component that shows the pathname of the current location\r\nclass ShowTheLocation extends React.Component {\r\n    static propTypes = {\r\n        match: PropTypes.object.isRequired,\r\n        location: PropTypes.object.isRequired,\r\n        history: PropTypes.object.isRequired\r\n    }\r\n\r\n    render() {\r\n        const { match, location, history } = this.props\r\n\r\n        return &lt;div&gt;You are now at {location.pathname}&lt;/div&gt;\r\n    }\r\n}\r\n\r\nconst ShowTheLocationWithRouter = withRouter(ShowTheLocation)\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Cách hiển thị dữ liệu API với Axios?",
      "answer": "<p>Axios là một promise dựa trên HTTP để tạo yêu cầu HTTP đến trình duyệt hay web server.\r\n\r\n<strong>Tính năng</strong>\r<ul><li><strong>Interceptors</strong>: Truy cập cấu hình yêu cầu hoặc phản hồi (header, dữ liệu, v.v.) khi chúng gửi đến hoặc đi. Các hàm này có thể hoạt động như các cổng để kiểm tra cấu hình hoặc thêm dữ liệu.</li></ul>\r<ul><li><strong>Instances</strong>: Tạo thực thể có thể tái sử dụng như baseUrl, headers, và cấu hình khác đã thiết lập.</li></ul>\r<ul><li><strong>Defaults</strong>: Thiết lập giá trị chung cho header chung (như Authorization) với các yêu cầu. Nó hữu ích khi bạn cần xác thực đến server trên mọi yêu cầu.</li></ul>\r\n\r\n<strong>Cài đặt</strong>\r\n\r\n``<code>\r\nnpm install axios -- save\r\n</code>`<code>\r\n\r\nCác phương thức thường dùng:\r<ul><li></code>axios.request(config)<code></li></ul>\r<ul><li></code>axios.get(url[, config])<code></li></ul>\r<ul><li></code>axios.delete(url[, config])<code></li></ul>\r<ul><li></code>axios.head(url[, config])<code></li></ul>\r<ul><li></code>axios.options(url[, config])<code></li></ul>\r<ul><li></code>axios.post(url[, data[, config]])<code></li></ul>\r<ul><li></code>axios.put(url[, data[, config]])<code></li></ul>\r<ul><li></code>axios.patch(url[, data[, config]])<code></li></ul>\r\n\r\nVí dụ POST:\r\n\r\n</code>`<code>js\r\n\r\naxios.post(&#39;/url&#39;,{data: &#39;data&#39;})\r\n    .then((res)=&gt;{\r\n        //on success\r\n    })\r\n    .catch((error)=&gt;{\r\n        //on error\r\n    })\r\n</code>`<code>\r\n\r\nVí dụ GET:\r\n\r\n</code>`<code>js\r\naxios.get(&#39;/url&#39;)\r\n    .then((res)=&gt;{\r\n        //on success\r\n    })\r\n    .catch((error)=&gt;{\r\n        //on error\r\n    })\r\n</code>`<code>\r\n\r\nXử lý nhiều yêu cầu đồng thời:\r\n\r\n</code>`<code>js\r\nfunction getUserAccount() {\r\n    return axios.get(&#39;/user/12345&#39;)\r\n}\r\n\r\nfunction getUserPermissions() {\r\n    return axios.get(&#39;/user/12345/permissions&#39;)\r\n}\r\n\r\naxios.all([getUserAccount(), getUserPermissions()])\r\n    .then(axios.spread(function (acct, perms) {\r\n        // Both requests are now complete\r\n    }))\r\n</code>`<code>\r\n\r\nPOST trong Component:\r\n\r\n</code>`<code>jsx\r\nimport React from &#39;react&#39;\r\nimport axios from &#39;axios&#39;\r\n\r\nexport default class PersonList extends React.Component {\r\n    state = {\r\n        name: &#39;&#39;,\r\n    }\r\n\r\n    handleChange = event =&gt; {\r\n        this.setState({ name: event.target.value })\r\n    }\r\n\r\n    handleSubmit = event =&gt; {\r\n        event.preventDefault()\r\n\r\n        const user = {\r\n        name: this.state.name\r\n        }\r\n\r\n        axios.post(</code>https://jsonplaceholder.typicode.com/users<code>, { user })\r\n        .then(res =&gt; {\r\n            console.log(res)\r\n            console.log(res.data)\r\n        })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n        &lt;div&gt;\r\n            &lt;form onSubmit={this.handleSubmit}&gt;\r\n            &lt;label&gt;\r\n                Person Name:\r\n                &lt;input type=&quot;text&quot; name=&quot;name&quot; onChange={this.handleChange} /&gt;\r\n            &lt;/label&gt;\r\n            &lt;button type=&quot;submit&quot;&gt;Add&lt;/button&gt;\r\n            &lt;/form&gt;\r\n        &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Caching trong React?",
      "answer": "<p>Ta có thể caching dữ liệu trong React bằng nhiều cách như:\r<ul><li>Local Storage</li></ul>\r<ul><li>Redux Store</li></ul>\r<ul><li>Giữa dữ liệu giữa mounting và unmounting</li></ul>\r\n\r\nMemoization là một kỹ thuật mà chúng ta sẽ sử dụng để đảm bảo rằng chúng ta không gặp phải API nếu chúng tôi đã thực hiện một số loại yêu cầu tìm nạp nó ở một số giai đoạn đầu tiên. Việc lưu trữ kết quả của các cuộc gọi tốn kém sẽ tiết kiệm thời gian tải cho người dùng, nhờ đó tăng hiệu suất tổng thể.\r\n\r\nVí dụ:\r\n\r\n``<code>jsx\r\nconst cache = {}\r\n\r\nconst useFetch = (url) =&gt; {\r\n    const [status, setStatus] = useState(&#39;idle&#39;)\r\n    const [data, setData] = useState([])\r\n\r\n    useEffect(() =&gt; {\r\n        if (!url) return\r\n\r\n        const fetchData = async () =&gt; {\r\n            setStatus(&#39;fetching&#39;)\r\n\r\n            if (cache[url]) {\r\n                const data = cache[url]\r\n                setData(data)\r\n                setStatus(&#39;fetched&#39;)\r\n            } else {\r\n                const response = await fetch(url)\r\n                const data = await response.json()\r\n                cache[url] = data // set response in cache\r\n                setData(data)\r\n                setStatus(&#39;fetched&#39;)\r\n            }\r\n        }\r\n\r\n        fetchData()\r\n    }, [url])\r\n\r\n    return { status, data }\r\n}\r\n</code>``\r\n\r\nỞ đây ta ánh xạ URL tới dữ liệu của ta. Nếu ta thực hiện yêu cầu nạp dữ liệu hiện có, chúng ta sẽ lấy dữ liệu từ cache cục bộ của mình. Nếu không, ta tiếp tục thực hiện yêu cầu và đặt kết quả vào cache. Điều này đảm bảo tằng ta không gọi lại API khi đã có dữ liệu cục bộ.\r\n\r\n#</p>",
      "level": "fresher"
    }
  ]
}