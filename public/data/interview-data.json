{
  "categories": [
    {
      "id": "frontend",
      "name": "Frontend Development",
      "icon": "web",
      "color": "#36e27b",
      "subcategories": [
        {
          "id": "vuejs",
          "name": "Câu hỏi phỏng vấn Vue.js 3",
          "description": "Tổng hợp câu hỏi phỏng vấn Vue.js 3 từ Fresher đến Senior",
          "questions": []
        },
        {
          "id": "css",
          "name": "Câu hỏi phỏng vấn CSS",
          "description": "",
          "questions": [
            {
              "question": "Mô hình hộp trong CSS là gì? Thuộc tính CSS nào là một phần của nó?",
              "answer": "<p>Các phần tử trong HTML có thể được coi là những chiếc hộp. Trong CSS, thuật ngữ \"mô hình hộp\" được dùng để nói về việc thiết kế, xây dựng bố cục.\r\n\r\nVề cơ bản mô hình hộp CSS là một chiếc hộp bao xung quanh phần tử HTML, gồm margin, border, padding và nội dung bên trong. Hình ảnh dưới đây cho thấy vị trí và mối liên hệ giữa các thành phần này.\r\n\r\n<img src=\"/interview-assets/Box_Model_in_CSS.jpg\" alt=\"\" />\r\n\r\n<em> <strong>Content</strong> - nội dung trong hộp, nơi hiển thị văn bản và hình ảnh.\r\n</em> <strong>Padding</strong> - phần khoảng trắng xung quanh nội dung.\r\n<em> <strong>Border</strong> - đường viền xung quanh nội dung và padding.\r\n</em> <strong>Margin</strong> - phần lề bên ngoài đường viền.</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của CSS?",
              "answer": "<p><ul><li>Tiết kiệm thời gian, công sức trong việc code web/xây dựng giao diện; kiểm soát dễ dàng các lỗi không đáng có trên web</li></ul>\r<ul><li>CSS cung cấp nhiều thuộc tính cụ thể hơn HTML giúp tạo ra nhiều style khác nhau và có thể áp dụng được cho nhiều loại web.</li></ul>\r<ul><li>CSS giúp tốc độ tải trang web nhanh chóng hơn, dễ dàng bảo trì, tương thích với các thiết bị di động.</li></ul>\r<ul><li>CSS thiết lập nhiều kiểu chữ khác nhau giúp website của bạn trở nên khác biệt hơn; tự động sắp xếp chữ khi chèn hình ảnh (thuộc tính shape-outsite); đặt nội dung theo các chiều khác nhau/ thay đổi chế độ viết theo mong muốn của mình (thuộc tính write-mode); có thể tạo chữ lớn ở đầu dòng (thuộc tính first-letter)…</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hạn chế của CSS?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để đưa CSS vào trang web?",
              "answer": "<p>Có nhiều cách để thêm CSS vào trang web.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Các loại selector khác nhau trong CSS?",
              "answer": "<p>CSS Selector giống như là đường đẫn, chỉ định để cho CSS biết bạn đang muốn điều chỉnh, tạo kiểu cho phần tử HTML nào vậy.\r\n\r\n<strong>Universal Selector:</strong> hoạt động như một ký tự đại diện cho tất cả phần tử trong trang. Trong ví dụ này, các style được cung cấp sẽ được áp dụng cho tất cả các phần tử trên trang.\r\n\r\n``<code>css\r<ul><li>{</li></ul>\r\n    color: &quot;green&quot;;\r\n    font-size: 20px;\r\n    line-height: 25px;\r\n}\r\n</code>`<code>\r\n\r\n<strong>Element Type Selector:</strong> selector loại này ứng với một hoặc nhiều phần tử HTML cùng tên. Trong ví dụ này, các style được cung cấp sẽ được áp dụng cho tất cả các phần tử ul trên trang.\r\n\r\n</code>`<code>css\r\nul {\r\n    line-style: none;\r\n    border: solid 1px #ccc;\r\n}\r\n</code>`<code>\r\n\r\n<strong>ID Selector:</strong> selector này ứng với bất kỳ phần tử HTML nào có thuộc tính ID có cùng giá trị với giá trị của selector. Trong ví dụ này, các style được cung cấp sẽ được áp dụng cho tất cả các phần tử có ID trùng trên trang.\r\n\r\n</code>`<code>css\r\n#container {\r\n    width: 960px;\r\n    margin: 0 auto;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;\r\n</code>`<code>\r\n\r\n<strong>Class Selector:</strong> tương tự như ID Selector nhưng thay vì ứng với ID thì nó ứng với thuộc tính class. Trong ví dụ này, các style được cung cấp sẽ áp dụng cho tất cả phần tử có cùng tên lớp.\r\n\r\n</code>`<code>css\r\n.box {\r\n    padding: 10px;\r\n    margin: 10px;\r\n    width: 240px;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n</code>`<code>\r\n\r\n<strong>Descendant Combinator:</strong> giúp bạn kết hợp hai hoặc nhiều selector để có thể chỉ định phần tử cụ thể.\r\n\r\n</code>`<code>css\r\n#container .box {\r\n\tfloat: left;\r\n\tpadding-bottom: 15px;\r\n} \r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div id=&quot;container&quot;&gt;\r\n\t&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n\t\r\n\t&lt;div class=&quot;box-2&quot;&gt;&lt;/div&gt;\r\n&lt;/div&gt;\r\n\r\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n</code>`<code>\r\n\r\nKhối khai báo này sẽ áp dụng cho tất cả các phần tử có lớp </code>box<code> nằm bên trong phần tử có ID là </code>container<code>. Cần lưu ý rằng phần tử </code>.box<code> không nhất thiết phải là phần tử con, nó có thể có một phần tử khác bao bọc </code>.box<code> và các style vẫn sẽ áp dụng.\r\n\r\n<strong>Child Combinator:</strong> selector sử dụng bộ child combinator tương tự như descendant combinator, ngoại trừ việc nó chỉ nhắm đến các phần tử con.\r\n\r\n</code>`<code>css\r\n#container&gt; .box {\r\n\tfloat: left;\r\n\tpadding-bottom: 15px;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div id=&quot;container&quot;&gt;\r\n\t&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n\t\r\n\t&lt;div&gt;\r\n\t\t&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n\t&lt;/div&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\nSelector sẽ ứng với tất cả phần tử có lớp </code>box<code> và là phần tử con của phần tử có id là </code>container<code>. Điều đó có nghĩa là các phần tử lớp </code>box<code> không phải là phần tử con của </code>container<code> sẽ không được áp dụng.\r\n\r\n<strong>General Sibling Combinator:</strong> selector này so với các phần tử có quan hệ anh chị em với phần tử tương ứng.\r\n\r\n</code>`<code>css\r\nh2 ~ p {\r\n\tmargin-bottom: 20px;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;h2&gt;Title&lt;/h2&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;div class=&quot;box&quot;&gt;\r\n\t&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\nTrong ví dụ này, tất cả các phần tử văn bản (</code><p><code>) sẽ được áp dụng style với các quy tắc đã chỉ định, nhưng chỉ khi chúng là anh chị em của các phần tử </code><h2><code>. Có thể có các phần tử khác ở giữa </code><h2><code> và </code><p><code> và các style sẽ vẫn áp dụng.\r\n\r\n<strong>Adjacent Sibling Combinator:</strong>: selector sử dụng ký tự </code>+<code> và gần giống với General Sibling Combinator. Sự khác biệt là phần tử được nhắm phải là anh chị ruột thịt chứ không phải enh chị em chung chung.\r\n\r\n</code>`<code>css\r\np + p {\r\n\ttext-indent: 1.Sem;\r\n\tmargin-bottom: 0;\r\n}\r\n</code>`<code>\r\n</code>`<code>html\r\n&lt;h2&gt;Title&lt;/h2&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n\r\n&lt;div class=”box”&gt;\r\n\t&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n\t&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\nVí dụ trên sẽ chỉ áp dụng các style được chỉ định cho các phần tử văn bản ngay sau các phần tử văn bản khác. Điều này có nghĩa là phần tử văn bản đầu tiên trên một trang sẽ không nhận được các style này. Ngoài ra, nếu một phần tử khác xuất hiện giữa hai đoạn văn, thì đoạn thứ hai của cả hai sẽ không được áp dụng style.\r\n\r\n<strong>Attribute Selector:</strong> nhắm đến các phần tử dựa trên sự xuất hiện và giá trị của thuộc tính HTML. Được khai báo bằng dấu ngoặc vuông.\r\n\r\n</code>`<code>css\r\ninput [type=”text”] {\r\n\tbackground-color: #444;\r\n\twidth: 200px;\r\n}\r\n</code>`<code>\r\n</code>`<code>html\r\n&lt;input type=&quot;text&quot;&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "So sánh CSS Preprocessors: SASS vs SCSS vs LESS vs Stylus vs PostCSS?",
              "answer": "<p><strong>CSS Preprocessors là gì?</strong></p><p>CSS Preprocessors là ngôn ngữ mở rộng của CSS, cho phép sử dụng variables, functions, mixins, nesting và nhiều tính năng lập trình khác. Code được viết bằng preprocessor syntax sau đó compile ra CSS thuần.</p><p><strong>1. SASS (Indented Syntax) - Phiên bản gốc:</strong></p><p>Sử dụng indentation thay vì dấu ngoặc nhọn, không có dấu chấm phẩy.</p><pre><code>// SASS Syntax (.sass)\r\n$primary-color: #3498db\r\n$padding: 15px\r\n\r\n.container\r\n  padding: $padding\r\n  background: $primary-color\r\n  \r\n  .header\r\n    font-size: 24px\r\n    color: white\r\n    \r\n  &:hover\r\n    background: darken($primary-color, 10%)</code></pre><p><strong>Đặc điểm SASS:</strong></p><ul><li>Cú pháp ngắn gọn, clean</li><li>Không dùng { } và ;</li><li>Dựa vào indentation (như Python)</li><li>File extension: .sass</li><li>Ít phổ biến hơn SCSS</li></ul><p><strong>2. SCSS (Sassy CSS) - Phiên bản mới của SASS:</strong></p><p>Sử dụng cú pháp giống CSS truyền thống với { } và ;.</p><pre><code>// SCSS Syntax (.scss)\r\n$primary-color: #3498db;\r\n$padding: 15px;\r\n\r\n.container {\r\n  padding: $padding;\r\n  background: $primary-color;\r\n  \r\n  .header {\r\n    font-size: 24px;\r\n    color: white;\r\n  }\r\n  \r\n  &:hover {\r\n    background: darken($primary-color, 10%);\r\n  }\r\n}\r\n\r\n// Mixins\r\n@mixin flex-center {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.box {\r\n  @include flex-center;\r\n}</code></pre><p><strong>Đặc điểm SCSS:</strong></p><ul><li>Cú pháp giống CSS, dễ học</li><li>CSS hợp lệ cũng là SCSS hợp lệ</li><li>File extension: .scss</li><li>PHỔ BIẾN NHẤT hiện nay</li><li>Ecosystem lớn, nhiều framework dùng (Bootstrap, Foundation)</li></ul><p><strong>3. LESS (Leaner Style Sheets):</strong></p><p>Preprocessor sử dụng JavaScript, cú pháp gần với CSS.</p><pre><code>// LESS Syntax (.less)\r\n@primary-color: #3498db;\r\n@padding: 15px;\r\n\r\n.container {\r\n  padding: @padding;\r\n  background: @primary-color;\r\n  \r\n  .header {\r\n    font-size: 24px;\r\n    color: white;\r\n  }\r\n  \r\n  &:hover {\r\n    background: darken(@primary-color, 10%);\r\n  }\r\n}\r\n\r\n// Mixins\r\n.flex-center() {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.box {\r\n  .flex-center();\r\n}</code></pre><p><strong>Đặc điểm LESS:</strong></p><ul><li>Variables dùng @ thay vì $</li><li>Có thể chạy trên browser (less.js)</li><li>Cú pháp đơn giản, dễ học</li><li>Bootstrap 3 sử dụng LESS (Bootstrap 4+ chuyển sang SCSS)</li><li>File extension: .less</li></ul><p><strong>4. Stylus - Flexible nhất:</strong></p><p>Cú pháp cực kỳ linh hoạt, có thể viết theo nhiều style.</p><pre><code>// Stylus Syntax (.styl)\r\n// Style 1: Không dấu ngoặc, chấm phẩy\r\nprimary-color = #3498db\r\npadding = 15px\r\n\r\n.container\r\n  padding padding\r\n  background primary-color\r\n  \r\n  .header\r\n    font-size 24px\r\n    color white\r\n    \r\n// Style 2: Giống CSS\r\n.container {\r\n  padding: 15px;\r\n  background: #3498db;\r\n}\r\n\r\n// Mixins\r\nflex-center()\r\n  display flex\r\n  justify-content center\r\n  align-items center\r\n\r\n.box\r\n  flex-center()</code></pre><p><strong>Đặc điểm Stylus:</strong></p><ul><li>Cú pháp cực kỳ linh hoạt (với/không { } ; :)</li><li>Không cần $ hay @ cho variables</li><li>Powerful built-in functions</li><li>File extension: .styl</li><li>Ít phổ biến hơn SCSS/LESS</li></ul><p><strong>5. PostCSS - Post-processor (Khác biệt):</strong></p><p>Không phải preprocessor thuần, là tool để transform CSS với JavaScript plugins.</p><pre><code>/* PostCSS với plugins */\r\n/* Input CSS */\r\n:root {\r\n  --primary-color: #3498db;\r\n}\r\n\r\n.container {\r\n  display: flex;\r\n  background: var(--primary-color);\r\n}\r\n\r\n/* Với Autoprefixer plugin */\r\n.container {\r\n  display: -webkit-box;\r\n  display: -ms-flexbox;\r\n  display: flex;\r\n  background: #3498db;\r\n  background: var(--primary-color);\r\n}</code></pre><p><strong>Đặc điểm PostCSS:</strong></p><ul><li>Plugin-based architecture</li><li>Có thể dùng CSS variables native</li><li>Autoprefixer (thêm vendor prefixes tự động)</li><li>CSSnano (minify CSS)</li><li>Tailwind CSS build trên PostCSS</li><li>Có thể kết hợp với SCSS/LESS</li></ul><p><strong>Bảng so sánh tổng quan:</strong></p><table><tr><th>Feature</th><th>SASS</th><th>SCSS</th><th>LESS</th><th>Stylus</th><th>PostCSS</th></tr><tr><td>Syntax</td><td>Indented</td><td>CSS-like</td><td>CSS-like</td><td>Flexible</td><td>Pure CSS</td></tr><tr><td>Variables</td><td>$var</td><td>$var</td><td>@var</td><td>var</td><td>--var</td></tr><tr><td>Learning Curve</td><td>Medium</td><td>Easy</td><td>Easy</td><td>Easy</td><td>Easy</td></tr><tr><td>Community</td><td>Large</td><td>Largest</td><td>Large</td><td>Medium</td><td>Large</td></tr><tr><td>Performance</td><td>Fast</td><td>Fast</td><td>Medium</td><td>Fast</td><td>Very Fast</td></tr><tr><td>Popularity 2024</td><td>Low</td><td>Very High</td><td>Medium</td><td>Low</td><td>High</td></tr></table><p><strong>So sánh cú pháp Variables & Nesting:</strong></p><pre><code>/* SCSS */\r\n$primary: #3498db;\r\n.nav { background: $primary; }\r\n\r\n/* LESS */\r\n@primary: #3498db;\r\n.nav { background: @primary; }\r\n\r\n/* Stylus */\r\nprimary = #3498db\r\n.nav\r\n  background primary\r\n\r\n/* PostCSS (CSS Variables) */\r\n:root { --primary: #3498db; }\r\n.nav { background: var(--primary); }</code></pre><p><strong>Mixins so sánh:</strong></p><pre><code>/* SCSS */\r\n@mixin button($bg) {\r\n  background: $bg;\r\n  padding: 10px;\r\n}\r\n.btn { @include button(blue); }\r\n\r\n/* LESS */\r\n.button(@bg) {\r\n  background: @bg;\r\n  padding: 10px;\r\n}\r\n.btn { .button(blue); }\r\n\r\n/* Stylus */\r\nbutton(bg)\r\n  background bg\r\n  padding 10px\r\n.btn\r\n  button(blue)</code></pre><p><strong>Khi nào dùng cái nào?</strong></p><ul><li><strong>SCSS:</strong> Dự án mới, team lớn, ecosystem rộng - RECOMMENDED</li><li><strong>LESS:</strong> Dự án legacy Bootstrap 3, hoặc ưa thích @ syntax</li><li><strong>Stylus:</strong> Thích cú pháp linh hoạt, dự án Node.js</li><li><strong>PostCSS:</strong> Modern tooling, kết hợp với Tailwind, cần autoprefixer</li><li><strong>SASS (indented):</strong> Ít dùng, chỉ khi maintain code cũ</li></ul><p><strong>Xu hướng hiện tại (2024):</strong></p><ol><li>SCSS - Vẫn là standard trong industry</li><li>PostCSS - Tăng mạnh với Tailwind CSS</li><li>CSS Native Variables - Browser hỗ trợ tốt</li><li>LESS - Giảm dần</li><li>Stylus - Ít dùng</li></ol>",
              "level": "middle"
            },
            {
              "question": "VH/VM trong CSS là gì?",
              "answer": "<p>Đây là một đơn vị CSS được sử dụng để đo chiều cao và chiều rộng theo tỷ lệ phần trăm đối với viewport. Nó được sử dụng chủ yếu trong các kỹ thuật thiết kế reponsive. Số đo VH bằng 1/100 chiều cao của viewport. Nếu chiều cao của trình duyệt là 1000px, thì 1vh bằng 10px. Tương tự, nếu chiều rộng là 1000px, thì 1 vw bằng 10px.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa reset và normalize CSS?",
              "answer": "<p><strong>Reset CSS:</strong> nhằm mục đích xoá tất cả thiết lập style mặc định từ trình duyệt. Ví dụ như margin, padding, font-size của tất cả phần tử đó được reset lại giống nhau.\r\n\r\n<strong>Normalize CSS:</strong> nhằm mục đích làm cho các style mặc định nhất quán trên trình duyệt. Nó cũng sửa các lỗi phổ biến trên trình duyệt.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa inline, block và inline-block?",
              "answer": "<p><strong>Block</strong>: Các phần tử block luôn bắt đầu trên một dòng mới. Chúng cũng sẽ chiếm không gian trên toàn bộ hàng hay chiều rộng. Danh sách các phần tử block là <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>.\r\n\r\n<strong>Inline</strong>: Các phần tử inline không bắt đầu trên dòng mới, mà nó xuất hiện cùng dòng với các thẻ bên cạnh chúng. Ví dụ các phần tử inline là <code>&lt;span&gt;</code>, <code>&lt;strong&gt;</code> và <code>&lt;img&gt;</code>.\r\n\r\n<strong>Inline Block</strong>: Các phần tử inline-block tương tự inline, ngoại trừ chúng có thể có phần padding và margin và đặt các giá trị height và width.</p>",
              "level": "fresher"
            },
            {
              "question": "Việc kiểm tra trang web trên các trình duyệt khác nhau có quan trọng không?",
              "answer": "<p>Điều quan trọng nhất là kiểm tra một trang web trong các trình duyệt khác nhau khi bạn thiết kế lần đầu tiên hoặc khi thực hiện các thay đổi lớn. Tuy nhiên, điều quan trọng là phải lặp lại các kiểm tra này theo định kỳ, vì các trình duyệt thường xuyên có các bản cập nhật và thay đổi.</p>",
              "level": "fresher"
            },
            {
              "question": "Phần tử Pseudo và các lớp Pseudo là gì?",
              "answer": "<p><strong>Phần tử pseudo</strong> cho phép ta tạo các mục thường không tồn tại trong DOM.\r<ul><li>::before</li></ul>\r<ul><li>::after</li></ul>\r<ul><li>::first-letter</li></ul>\r<ul><li>::first-line</li></ul>\r<ul><li>::selection</li></ul>\r\n\r\nTrong ví dụ bên dưới, màu sẽ xuất hiện ở dòng đầu tiên trong đoạn văn\r\n\r\n``<code>css\r\np::first-line {\r\n\tcolor: #ffOOOO;\r\n\tfont-variant: small-caps;\r\n}\r\n</code>`<code>\r\n\r\n<strong>Lớp pseudo</strong>  chọn các phần tử thông thường nhưng trong các điều kiện nhất định như khi người dùng di chuột qua liên kết.\r<ul><li>:link</li></ul>\r<ul><li>:visited</li></ul>\r<ul><li>:hover</li></ul>\r<ul><li>:active</li></ul>\r<ul><li>:focus</li></ul>\r\n\r\nTrong ví dụ này, màu xuất hiện khi bạn di chuyển chuột qua thẻ liên kết.\r\n\r\n</code>`<code>css\r\n/<em> mouse over link </em>/\r\na:hover {\r\n\tcolor: #FFOOFF;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để chỉ định các đơn vị trong CSS? Những cách khác nhau để làm điều đó là gì?",
              "answer": "<p>Có nhiều cách khác nhau để chỉ định các đơn vị trong CSS như <code>px</code>, <code>em</code>, <code>pt</code>, phần trăm (<code>%</code>). \r<ul><li>Pixel (px) cung cấp khả năng kiểm soát chi tiết và duy trì căn chỉnh vì 1 hoặc nhiều px được đảm bảo sự sắc nét. px không phân tầng.</li></ul>\r<ul><li>em duy trì kích thước tương đối. Bạn có thể có phông chữ reponse. Em, sẽ xếp tầng 1em bằng kích thước phông chữ hiện tại của phần tử hoặc mặc định của trình duyệt. Nếu bạn để font-size thành 16px thì 1em = 16px. Thực tế phổ biến là đặt kích thước phông chữ nội dung mặc định thành 62,5% (bằng 10px).</li></ul>\r<ul><li>pt (điểm) thường được sử dụng trong in ấn. 1pt = 1/72 inch và nó là một đơn vị có kích thước cố định.</li></ul>\r<ul><li>% (phần trăm) đặt kích thước phông chữ so với kích thước phông của nội dung. Do đó, bạn phải đặt kích thước phông chữ của phần nội dung thành kích thước hợp lý.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Liệu margin-top hoặc margin-bottom có ảnh hưởng đến các phần tử inline không?",
              "answer": "<p>Không, nó không ảnh hưởng đến các phần tử inline. Các phần tử inline ở cùng dòng với nội dung của trang.</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính nào được sử dụng để thay đổi dạng phông chữ?",
              "answer": "<p>Chúng ta có thể sử dụng thuộc tính <code>font-family</code> để thực hiện được điều này. Thuộc tính font-family được sử dụng để chỉ định phông chữ nào cần được áp dụng trên phần tử DOM. Nó có thể chứa một số tên phông chữ như một phần của cơ chế “dự phòng” trong trường hợp trình duyệt không hỗ trợ phông chữ. Ví dụ, chúng ta có thể sử dụng:\r\n\r\n``<code>css\r\np {\r\n    font-family: &quot;Times New Roman&quot;, Times, serif;\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta đang áp dụng thuộc tính font-family cho phần tử đoạn văn.\r<ul><li>Nó yêu cầu trình duyệt tìm kiếm phông chữ &quot;Times New Roman&quot; và áp dụng nó.</li></ul>\r<ul><li>Nếu phông chữ &quot;Times New Roman&quot; không được cài đặt hoặc hỗ trợ, thì nó sẽ yêu cầu trình duyệt sử dụng phông chữ Times.</li></ul>\r<ul><li>Nếu cả &quot;Times New Roman&quot; và &quot;Times&quot; đều không được hỗ trợ, thì nó sẽ yêu cầu trình duyệt sử dụng bất kỳ phông chữ chung nào được hỗ trợ thuộc serif.</li></ul>\r\n\r\nNếu bạn không muốn </code>font-face<code> của phần tử văn bản là phông chữ Times New Roman/ Times/serif và bạn muốn sử dụng phông chữ Arial/Helvetica/sans-serif, thì ta có thể cập nhật thuộc tính CSS của phần tử văn bản như:\r\n\r\n</code>`<code>css\r\np {\r\n    font-family: Arial, Helvetica, sans-serif;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa adaptive design và responsive design?",
              "answer": "<p>| Adaptive Design | Responsive Design |\r\n|-----------------|-------------------|\r\n| Tập trung vào thiết kế trang web dựa trên nhiều kích thước bố cục cố định | Tập trung vào việc hiển trị nội dung trên cơ sở không gian trình duyệt có sẵn |\r\n| Khi một trang web được phát triển bằng cách sử dụng thiết kế adaptive được mở trên trình duyệt máy tính để bàn, trước tiên không gian có sẵn sẽ được phát hiện và sau đó bố cục có kích thước phù hợp nhất sẽ được chọn và sử dụng để hiển thị nội dung. Thay đổi kích thước của cửa sổ trình duyệt không ảnh hưởng đến thiết kế | Khi một trang web được phát triển bằng cách sử dụng thiết kế responsive được mở trên trình duyệt trên máy tính để bàn và khi ta thay đổi kích thước cửa sổ trình duyệt, nội dung của trang web được sắp xếp động và tối ưu để phù hợp với cửa sổ |\r\n| Thông thường, các thiết kế adaptive sử dụng sáu chiều rộng màn hình tiêu chuẩn - 320px, 480px, 760px, 960px, 1200px, 1600 . Các kích thước này được phát hiện và các bố cục thích hợp được tải | Thiết kế này sử dụng các truy vấn CSS để thay đổi kiểu tùy thuộc vào thuộc tính thiết bị mục tiêu để thích ứng với các màn hình khác nhau |\r\n| Đầu tiên phải mất rất nhiều thời gian và nỗ lực để xem xét các lựa chọn và thực tế của người dùng cuối, sau đó thiết kế các giải pháp thích ứng tốt nhất có thể cho họ | Nói chung, thiết kế responsive cần ít công việc hơn để xây dựng và thiết kế các trang web linh hoạt có thể chứa nội dung từ màn hình tùy thuộc vào kích thước màn hình |\r\n| Cung cấp nhiều quyền kiểm soát thiết kế để phát triển các trang web cho các màn hình cụ thể | Không có nhiều quyền kiểm soát thiết kế được cung cấp ở đây |</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để các CSS Selector ứng với các phần tử của trình duyệt?",
              "answer": "<p>Thứ tự của các selector phù hợp đi từ phải sang trái của biểu thức selector. Các phần tử trong DOM được trình duyệt lọc dựa trên các khóa selector và sau đó được chuyển đến các phần tử mẹ để xác định các kết quả phù hợp. Tốc độ xác định các phần tử phụ thuộc vào độ dài của chuỗi các selector. Hãy xem xét một ví dụ:\r\n\r\n``<code>css\r\np span{ \r\n    color: black;\r\n}\r\n</code>`<code>\r\n\r\n<img src=\"/interview-assets/CSS_selectors_matched_against_the_elements_by_the_browser.png\" alt=\"\" />\r\n\r\nỞ đây, trước tiên trình duyệt tìm tất cả các phần tử </code>span<code> trong DOM và sau đó nó chuyển đến từng phần tử cha của nó để kiểm tra xem chúng có phải là phần tử của đoạn </code>p<code> hay không.\r\n\r\nSau khi trình duyệt tìm thấy tất cả các thẻ </code>span<code> phù hợp có các phần tử </code>p` là cha và áp dụng màu đen cho nội dung, quá trình so sánh sẽ bị dừng lại.</p>",
              "level": "fresher"
            },
            {
              "question": "Border-box khác với content-box như thế nào?",
              "answer": "<p><code>content-box</code> là thuộc tính xác định giá trị mặc định cho kích thước hộp. Thuộc tính width và height chỉ bao gồm nội dung bằng cách loại trừ border và padding. Hãy xem xét một ví dụ như sau:\r\n\r\n``<code>css\r\ndiv{\r\n    width:300px;\r\n    height:200px;\r\n    padding:15px;\r\n    border: 5px solid grey;\r\n    margin:30px;\r\n    -moz-box-sizing:content-box;\r\n    -webkit-box-sizing:content-box;\r\n    box-sizing:content-box;\r\n}\r\n</code>`<code>\r\n\r\nỞ đây, kích thước hộp cho phần tử div được cung cấp dưới dạng </code>content-box<code>. Điều đó có nghĩa là height và width được xem xét cho nội dung div sẽ loại trừ padding và border. Chúng ta sẽ nhận được đầy đủ các thông số chiều cao và chiều rộng được chỉ định cho nội dung như trong hình bên dưới.\r\n\r\n<img src=\"/interview-assets/content_box.png\" alt=\"\" />\r\n\r\n</code>border-box<code> là thuộc tính bao gồm nội dung và padding, border trong thuộc tính height và width. Hãy xem ví dụ sau:\r\n\r\n</code>`<code>css\r\ndiv{\r\n    width:300px;\r\n    height:200px;\r\n    padding:15px;\r\n    border: 5px solid grey;\r\n    margin:30px;\r\n    -moz-box-sizing:border-box;\r\n    -webkit-box-sizing:border-box;\r\n    box-sizing:border-box;\r\n}\r\n</code>`<code>\r\n\r\nỞ đây, kích thước hộp cho phần tử div được cung cấp dưới dạng </code>border-box`. Điều đó có nghĩa là height và width được xem xét cho nội dung div cũng sẽ bao gồm phần border và padding. Điều này có nghĩa là chiều cao thực của nội dung div sẽ là:\r\n\r\n<img src=\"/interview-assets/border_box.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Opacity được quy định như thế nào trong CSS3?",
              "answer": "<p>Opacity ám chỉ mức độ nội dung trong suốt hoặc không trong suốt. Chúng ta có thể sử dụng thuộc tính có tên opacity nhận các giá trị từ 0 đến 1. 0 chỉ định rằng phần tử là hoàn toàn trong suốt, trong khi 1 có nghĩa là phần tử hoàn toàn không trong suốt. Chúng ta có thể sử dụng thuộc tính opacity như sau:\r\n\r\n``<code>css\r\ndiv { \r\n    opacity: 0.6;\r\n}\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, độ mờ 60% được áp dụng cho phần div. Thuộc tính opacity không được trình duyệt internet explorer hỗ trợ. Để làm cho nó hoạt động ở đó, chúng ta cần sử dụng thuộc tính filter là polyfill như ví dụ bên dưới.\r\n\r\n</code>`<code>css\r\ndiv { \r\n    opacity: 0.6;\r\n    filter: alpha(opacity=60);\r\n}\r\n</code>``\r\n\r\n<img src=\"/interview-assets/opacity_in_css3.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao chúng ta nên sử dụng thuộc tính float trong CSS?",
              "answer": "<p>Thuộc tính float được sử dụng để định vị các phần tử HTML theo chiều ngang về phía bên trái hoặc bên phải của container. Ví dụ,\r\n\r\n``<code>css\r\nfloat-demo {\r\n\tfloat: right;\r\n}\r\n</code>``\r\n\r\nỞ đây, phần tử mà lớp được áp dụng đảm bảo rằng phần tử được định vị ở bên phải của container. Nếu bạn chỉ định giá trị của float ở bên trái, thì phần tử sẽ được đặt ở bên trái của container.</p>",
              "level": "fresher"
            },
            {
              "question": "z-index là gì? Nó hoạt động như thế nào?",
              "answer": "<p>z-index được sử dụng để chỉ định cách xếp chồng theo chiều sâu của các phần tử chồng lên nhau xảy ra tại thời điểm định vị nó. Nó chỉ định thứ tự ngăn xếp theo chiều sâu của các phần tử được định vị giúp xác định cách hiển thị các phần tử diễn ra như thế nào trong trường hợp chồng chéo.\r\n\r\nGiá trị mặc định của thuộc tính này là 0 và có thể là số dương hoặc số âm. Ngoài 0, các giá trị của z-index có thể là:\r<ul><li>Auto: Thứ tự ngăn xếp bằng với phần tử cha.</li></ul>\r<ul><li>Number: Có thể là dương hoặc âm. Nó xác định thứ tự ngăn xếp.</li></ul>\r<ul><li>Initial: Giá trị mặc định là 0.</li></ul>\r<ul><li>Inherit: Kế thừa giá trị từ phần tử cha.</li></ul>\r\n\r\nCác phần tử có giá trị z-index nhỏ hơn được xếp chồng thấp hơn các phần tử có z-index cao hơn.\r\n\r\n<img src=\"/interview-assets/z-index.png\" alt=\"\" />\r\n\r\nTừ hình trên, chúng ta có thể thấy rằng khi giá trị của z-index tăng dọc theo trục z, thứ tự xếp chồng sẽ hướng về phía trên cùng của các phần tử khác dọc theo trục tung.</p>",
              "level": "fresher"
            },
            {
              "question": "Các CSS selector sau đây có nghĩa là gì?",
              "answer": "<p><em> div, p\r\n</em> div p\r\n<em> div ~ p\r\n</em> div + p\r\n<em> div > p\r\n\r\nÝ nghĩa của chúng như sau:\r\n\r\n</em> <code>div, p</code>: Selector này ngụ ý chọn tất cả các phần tử div và tất cả các phần tử p.\r\n\r\n``<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n\tDivision 1\r\n\t&lt;p&gt; paragraph 1&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt; \r\n&lt;p&gt; paragraph 3&lt;/p&gt; \r\n&lt;div&gt;\r\n\tDivision 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nỞ đây, tất cả các phần tử div và phần tử p sẽ được trình duyệt chọn bất kể cha mẹ của chúng hay chúng được đặt ở đâu. Các thẻ còn lại như h1 và span bị bỏ qua.\r\n\r\n<em> </code>div p<code>: Selector cho biết chọn tất cả các phần tử p nằm bên trong các phần tử div. Hãy xem xét một ví dụ dưới đây:\r\n\r\n</code>`<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n    Division 1\r\n    &lt;p&gt; paragraph 1&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n    &lt;div&gt;\r\n        &lt;p&gt; Inner Div Paragraph &lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n    &lt;/div&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt;\r\n&lt;p&gt; paragraph 3&lt;/p&gt;\r\n&lt;div&gt;\r\n    Division 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nỞ dây, </code><p> paragraph 1</p><code> và </code><p> Inner Div Paragraph </p><code> sẽ được chọn bởi trình duyệt và thuộc tính được áp dụng. Phần còn lại sẽ không được chọn.\r\n\r\n</em> </code>div ~ p<code>: Selector này chọn tất cả các phần tử p có phần tử div đứng trước ở bất kỳ đâu.\r\n\r\n</code>`<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n   Division 1\r\n   &lt;p&gt; paragraph 1&lt;/p&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;p&gt; paragraph 3&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;div&gt;\r\n   Division 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nỞ đây, các phần tử của paragraph 2 và paragraph 3 sẽ được chọn như được đánh dấu trong đoạn code trên.\r\n\r\n<em> </code>div + p<code>: Selector nàychọn tất cả các phần tử p được đặt ngay sau phần tử div.\r\n\r\n</code>`<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n\tDivision 1\r\n\t&lt;p&gt; paragraph 1&lt;/p&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;p&gt; paragraph 3&lt;/p&gt; \r\n&lt;div&gt;\r\n\tDivision 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nTrong trường hợp này, chúng ta có phần tử paragraph 2 ngay sau thẻ div. Do đó, chỉ phần tử đó sẽ được chọn.\r\n\r\n</em> </code>div > p<code>: Selector này chọn tất cả các phần tử p có div là cha trực tiếp. Trong cùng một ví dụ dưới đây:\r\n\r\n</code>`<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n\tDivision 1\r\n\t&lt;p&gt; paragraph 1&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt; \r\n&lt;p&gt; paragraph 3&lt;/p&gt; \r\n&lt;div&gt;\r\n\tDivision 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nChỉ </code><p> paragraph 1</p>` được chọn trong trường hợp này vì nó có div là cha trực tiếp.</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính flexbox là gì?",
              "answer": "<p>Flexbox Layout (hay còn gọi là Flexible Box) là một kiểu bố cục trang có khả năng tự cân đối kích thước, thay đổi chiều rộng/chiều cao và thứ tự phần tử bên trong để phù hợp với tất cả các loại thiết bị hiển thị và kích thước màn hình.\r\n\r\nVới bố cục thông thường, bạn cần phải thiết lập kích thước của phần tử, thiết lập hiển thị dạng block hay inline, cho nó float, còn với Flexbox bạn chỉ cần thiết lập phần hiển thị theo chiều ngang hay chiều dọc, lúc đó các phần tử bên trong có thể hiển thị theo ý muốn.\r\n\r\n<img src=\"/interview-assets/flex-terminology.png\" alt=\"\" />\r\n\r\nCác thuộc tính flexbox:\r<ul><li><strong>flex-direction</strong>: Thuộc tính này giúp xác định hướng container sẽ xếp chồng các mục cho linh hoạt. Các giá trị của thuộc tính này có thể là:</li></ul>\r<ul><li>row: xếp các mục theo chiều ngang từ trái sang phải trong flex container.</li></ul>\r<ul><li>column: xếp các mục theo chiều dọc từ trước ra sau trong flex container.</li></ul>\r<ul><li>row-reverse: xếp các mục theo chiều ngang từ phải sang trái trong flex container.</li></ul>\r<ul><li>column-reverse: xếp các mục theo chiều dọc từ sau ra trước trong flex container.</li></ul>\r<ul><li><strong>flex-wrap</strong>: Thuộc tính này chỉ định các mục flex nên được bọc hay không. Giá trị có thể là:</li></ul>\r<ul><li>wrap: mục flex nên được bọc.</li></ul>\r<ul><li>nowrap: giá trị mặc định này là mục không được bọc.</li></ul>\r<ul><li>wrap-reverse: chỉ định này cho biết mục sẽ được bọc nếu cần nhưng theo thứ tự ngược.</li></ul>\r<ul><li><strong>flex-flow</strong>: thuộc tính này thiết lập cả flex-direction và flex-wrap trong một dòng.</li></ul>\r<ul><li><strong>justify-content</strong>: dùng cho căn chỉnh mục. Các giá trị có thể:</li></ul>\r<ul><li>center: có nghĩa là các mục hiện ở trung tâm của container.</li></ul>\r<ul><li>flex-start: đây là giá trị mặc định, sẽ được căn chỉnh từ điểm bắt đầu container.</li></ul>\r<ul><li>flex-end: các mục sẽ được căn chỉnh từ điểm cuối của container.</li></ul>\r<ul><li>space-around: các mục sẽ được căn chỉnh với khoảng trắng giữa, trước và xung quanh các mục.</li></ul>\r<ul><li>space-between: các mục sẽ được căn chỉnh với khoảng trắng giữa các mục.</li></ul>\r<ul><li><strong>align-items</strong>: sử dụng cho căn chỉnh mục flex.</li></ul>\r<ul><li><strong>align-content</strong>: sử dụng cho căn chỉnh dòng flex.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Xếp tầng trong CSS là gì?",
              "answer": "<p>Cascanding hay xếp tầng, đề cập đến quá trình xem xét các khai báo kiểu và xác định trọng lượng hoặc tầm quan trọng của các quy tắc tạo kiểu giúp trình duyệt chọn quy tắc nào phải được áp dụng trong thời gian xung đột. Xung đột ở đây đề cập đến nhiều quy tắc có thể áp dụng cho một phần tử HTML cụ thể. Trong những trường hợp như vậy, chúng ta cần cho trình duyệt biết phong cách nào cần được áp dụng cho phần tử. Điều này được thực hiện bằng cách xếp tầng danh sách các phần tử khai báo kiểu.\r\n\r\nVí dụ:\r\n\r\n``<code>css\r\np {\r\n    color:white;\r\n}\r\n</code>`<code>\r\n\r\nvà chúng ta cũng có khai báo sau bên dưới nó hoặc trong một biểu định kiểu khác đã được liên kết với trang:\r\n\r\n</code>`<code>css\r\np {\r\n    color:black;\r\n}\r\n</code>`<code>\r\n\r\nỎ đây, chúng ta có xung đột về thuộc tính màu cho các phần tử của đoạn văn. Trình duyệt chỉ cần phân tầng để xác định đâu là kiểu mới nhất và cụ thể nhất và áp dụng kiểu đó. Vì ta có </code>color:black;<code> như một khai báo cụ thể nhất, màu đen được áp dụng cho các phần tử của đoạn văn. Bây giờ nếu bạn muốn đảm bảo màu trắng được áp dụng cho đoạn văn, chúng ta có thể xác định trọng số cho kiểu đó bằng cách thêm </code>!important<code> như hình dưới đây:\r\n\r\n</code>`<code>css\r\np {\r\n    color:white !important;\r\n}\r\n</code>`<code>\r\n\r\n</code>!important` đảm bảo rằng thuộc tính có trọng lượng tối đa khi có các thuộc tính xung đột khác.\r\n\r\n## Câu hỏi phỏng vấn CSS cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích thuộc tính position CSS?",
              "answer": "<p><ul><li><strong>static</strong>: vị trí mặc định/tĩnh của phần tử và bạn đặt đâu phần tử sẽ nằm ở đó.</li></ul>\r<ul><li><strong>relative</strong>: vị trí của phần tử sẽ tương đối so với vị trí tĩnh bạn đặt và khoản không gian xung quanh phần tử sẽ được giữ nguyên.</li></ul>\r<ul><li><strong>fixed</strong>: vị trí sẽ nằm cố định một chỗ, dù bạn có làm gì, phần tử vẫn nằm cố định 1 vị trí trên màn hình.</li></ul>\r<ul><li><strong>absolute</strong>: vị trí của phần tử sẽ được xác định từ padding của phần tử cha.</li></ul>\r<ul><li><strong>sticky</strong>: vị trí của phần tử sẽ được định vị khi người dùng sử dụng thanh scroll.</li></ul>\r\n\r\n<img src=\"/interview-assets/CSS_Position_Property.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Khi nào thì xảy ra DOM reflow?",
              "answer": "<p>Reflow là tên của quá trình mà trình duyệt web tính toán lại vị trí và hình dạng của các phần tử trong document, nhằm mục đích hiển thị lại một phần hoặc toàn bộ document.\r\n\r\nReflow xảy ra khi:\r<ul><li>Chèn, xóa hoặc cập nhật một phần tử trong DOM.</li></ul>\r<ul><li>Sửa đổi nội dung trên trang, ví dụ: văn bản trong hộp nhập liệu.</li></ul>\r<ul><li>Di chuyển một phần tử DOM.</li></ul>\r<ul><li>Tạo hoạt ảnh cho một phần tử DOM.</li></ul>\r<ul><li>Thực hiện các phép đo một phần tử như <code>offsetHeight</code> hoặc <code>getComputedStyle</code>.</li></ul>\r<ul><li>Thay đổi kiểu CSS.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa các thuộc tính Box Sizing?",
              "answer": "<p>Thuộc tính CSS box-sizing quy định cách tính tổng chiều rộng và chiều cao của một phần tử.\r<ul><li><strong>Context-box:</strong> Giá trị chiều rộng và chiều cao mặc định chỉ áp dụng cho nội dung của phần tử. Padding và border nằm ở bên ngoài hộp.</li></ul>\r<ul><li><strong>Padding-box:</strong> Giá trị chiều rộng và chiều cao mặc định chỉ áp dụng cho nội dung của phần tử và padding của nó. Border nằm ở bên ngoài hộp. Hiện tại chỉ có Firefox hỗ trợ padding-box.</li></ul>\r<ul><li><strong>Border-box:</strong>  Giá trị chiều rộng và chiều cao áp dụng cho nội dung, padding và border.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Làm sao để căn giữa một div trong một div khác?",
              "answer": "<p>Ta có :\r\n\r\n``<code>html\r\n&lt;div class=&quot;cn&quot;&gt;&lt;div class=&quot;inner&quot;&gt;your content&lt;/div&gt;&lt;/div&gt;\r\n</code>`<code>\r<ul><li>Căn giữa với Table</li></ul>\r\n\r\n</code>`<code>css\r\n.cn {\r\n\tdisplay: table-cell;\r\n\twidth: 500px;\r\n\theight: 500px;\r\n\tvertical-align: middle;\r\n\ttext-align: center;\r\n}\r\n\r\n.inner {\r\n\tdisplay: inline-block;\r\n\twidth: 200px; height: 200px;\r\n}\r\n</code>`<code>\r<ul><li>Căn giữa với Transform</li></ul>\r\n\r\n</code>`<code>css\r\n.cn {\r\n\tposition: relative;\r\n\twidth: 500px;\r\n\theight: 500px;\r\n}\r\n\r\n.inner {\r\n\tposition: absolute;\r\n\ttop: 50%; left: 50%;\r\n\ttransform: translate(-50%,-50%);\r\n\twidth: 200px;\r\n\theight: 200px;\r\n}\r\n</code>`<code>\r<ul><li>Căn giữa với Flexbox</li></ul>\r\n\r\n</code>`<code>css\r\n.cn {\r\n\tdisplay: flex;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n}\r\n</code>`<code>\r<ul><li>Căn giữa với Grid</li></ul>\r\n\r\n</code>`<code>html\r\n&lt;div class=&quot;wrap_grid&quot;&gt;\r\n\t&lt;div id=&quot;container&quot;&gt;vertical aligned text&lt;br /&gt;some more text here\r\n\t&lt;/div&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\n</code>`<code>css\r\n.wrap-grid {\r\n\tdisplay: grid;\r\n\tplace-content: center;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kể tên bốn loại thuộc tính @media?",
              "answer": "<p>1. All -> Thuộc tính mặc định dùng cho tất cả thiết bị.\r\n2. Screen -> sử dụng màn hình máy tính, điện thoại.\r\n3. Print -> Sử dụng cho máy in.\r\n4. Speech -> Sử dụng cho màn hình người đọc.</p>",
              "level": "fresher"
            },
            {
              "question": "Hệ thống grid là gì?",
              "answer": "<p>CSS Grid layout là một hệ thống layout 2 chiều (x,y) được dùng trong thiết kế UI. Theo định nghĩa từ Mozilla, grid (lưới) là một tổ hợp của những đường ngang và dọc cắt nhau – một nhóm xác định các cột và nhóm kia xác định các hàng. Các phần tử có thể được đặt lên grid, dựa vào các đường hàng và cột này.\r\n\r\n<img src=\"/interview-assets/grid-term.jpg\" alt=\"\" />\r<ul><li>Grid Item: Phần container bao gồm các grid items.</li></ul>\r<ul><li>Grid Line: Đường thẳng theo chiều dọc và ngang để xây dựng cấu trúc grid.</li></ul>\r<ul><li>Grid Cell: Đơn vị nhỏ nhất trong grid. Nó là không gian giữa các hàng và cột.</li></ul>\r<ul><li>Rows: Là đường nằm ngang trong grid.</li></ul>\r<ul><li>Columns: Là đường nằm dọc trong grid.</li></ul>\r<ul><li>Gutter: Là độ rộng không gian của hàng hay cột trong grid.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các cách để ẩn phần tử với CSS?",
              "answer": "<p><ul><li>Sử dụng thuộc tính <code>display: none</code>. Phần tử sẽ không xuất hiện trong DOM. </li></ul>\r<ul><li>Sử dụng thuộc tính <code>visibility: hidden</code>, phần tử có xuất hiện trong DOM, nhưng không hiển thị trên màn hình cho người dùng.</li></ul>\r<ul><li>Sử dụng thuộc tính <code>position: absolute</code>. Khả dụng bên ngoài màn hình.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": ":root pseudo-class đề cập tới cái gì?",
              "answer": "<p>:root selector cho phép bạn chỉ đến phần tử \"cha\" cao nhất trong DOM, hoặc cây document. Nó được xác định trong tài liệu đặc tả CSS Selectors Level 3.</p>",
              "level": "fresher"
            },
            {
              "question": "Chiến lược mobile-first là gì?",
              "answer": "<p>Để reponsive một trang web có nghĩa là các phần tử sẽ thay đổi kích thước hoặc chức năng tuỳ theo kích thước màn hình của thiết bị, thường là thay đổi chiều rộng (width), thông qua các truy vấn media CSS, chẳng hạn như làm nhỏ kích thước phông chữ trên các thiết bị nhỏ hơn.\r\n\r\n``<code>css\r\n@media (min-width: 601px) {\r\n  .my-class {\r\n    font-size: 24px;\r\n  }\r\n}\r\n@media (max-width: 600px) {\r\n  .my-class {\r\n    font-size: 12px;\r\n  }\r\n}\r\n</code>`<code>\r\n\r\nChiến lược mobile-first là một reponsive mà ta nên xác định các style trên thiết bị di động và chỉ thay đổi quy tắc cho các thiết bị khác sau. Ví dụ như:\r\n\r\n</code>`<code>css\r\n.my-class {\r\n  font-size: 12px;\r\n}\r\n\r\n@media (min-width: 600px) {\r\n  .my-class {\r\n    font-size: 24px;\r\n  }\r\n}\r\n</code>`<code>\r\n\r\nChiến lược mobile-first có hai ưu điểm:\r<ul><li>Nó hoạt động hiệu quả hơn trên thiết bị di động, vì tất cả các quy tắc áp dụng cho chúng không cần phải được xác thực dựa trên bất kỳ truy vấn </code>media<code> nào.</li></ul>\r<ul><li>Nó buộc phải viết code rõ ràng hơn liên quan đến các quy tắc CSS reponsive.</li></ul>\r\n\r\nVí dụ\r\n\r\n</code>`<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n  &lt;head&gt;\r\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\r\n  &lt;title&gt;CSS Media Query&lt;/title&gt;\r\n  &lt;style&gt;\r\n    body {\r\n        background-color: lightgreen;\r\n    }\r\n\r\n    @media only screen and (max-width: 800px) {\r\n        body {\r\n            background-color: rgb(233, 50, 18);\r\n        }\r\n    }\r\n  &lt;/style&gt;\r\n  &lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;h1&gt;Resize the browser window&lt;/h1&gt;\r\n    &lt;h2&gt;When the width of this document is 800px or less, the background-color is &quot;green&quot;, \r\n      otherwise it is &quot;Red&quot;.&lt;/h2&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để khôi phục giá trị mặc định của thuộc tính?",
              "answer": "<p>Từ khoá <code>initial</code> có thể được dùng để khôi phục giá trị mặc định.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa CSS grid và flexbox?",
              "answer": "<p>1. CSS Grid là hệ thống dựng layout 2 chiều, có nghĩa là chúng ta có thể xử lý theo cột và hàng, không giống như Flexbox là hệ thống layout 1 chiều. ( xử lý theo 1 cột hoặc 1 hàng ).\r\n\r\n2. Điểm khác biệt cốt lõi giữa CSS Grid và Flexbox đó là: CSS Grid tiếp cận theo hướng bố cục (layout) dung còn Flexbox tiếp cận theo hướng nội dung. Nếu bạn biết được rõ trước nội dung mình cần trình bày hãy dùng CSS Flexbox ngược lại thì chọn CSS Grid.\r\n\r\n3. Flexbox phù hợp với các website có bố cục đơn giản, CSS Grid phù hợp với website có bố cục phức tạp hơn.\r\n\r\n4. Nếu bạn chỉ cần dựng layout theo 1 hàng hoặc 1 cột thì Flexbox sẽ phù hợp hơn. Ngược lại, nếu bạn muốn xác định grid và điều chỉnh nội dung theo 2 chiều - CSS Grid sẽ là lựa chọn của bạn.\r\n\r\n<img src=\"/interview-assets/flex.png\" alt=\"\" />\r\n\r\n<img src=\"/interview-assets/grid.png\" alt=\"\" />\r\n\r\nVí dụ\r\n\r\n``<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n  &lt;head&gt;\r\n    &lt;title&gt;Grid vs Flexbox Layout&lt;/title&gt;\r\n  &lt;/head&gt;\r\n  &lt;style&gt;\r\n    /<em> Grid layout </em>/\r\n    .row {\r\n        display: grid;\r\n        grid-template-columns: auto auto auto;\r\n        background-color: #2196f3;\r\n        padding: 5px;\r\n    }\r\n\r\n    .col-item {\r\n        background-color: rgba(255, 255, 255, 0.8);\r\n        border: 1px solid rgba(0, 0, 0, 0.8);\r\n        padding: 10px;\r\n        font-size: 30px;\r\n        text-align: center;\r\n    }\r\n\r\n    /<em> Flexbox layout </em>/\r\n    .wrapper {\r\n        border: 2px solid #f76707;\r\n        border-radius: 5px;\r\n        background-color: #fff4e6;\r\n    }\r\n\r\n    .wrapper &gt; div {\r\n        border: 2px solid #ffa94d;\r\n        border-radius: 5px;\r\n        background-color: #ffd8a8;\r\n        padding: 1em;\r\n        color: #d9480f;\r\n    }\r\n\r\n    .wrapper {\r\n        display: flex;\r\n        width: 500px;\r\n        flex-wrap: wrap;\r\n    }\r\n\r\n    .wrapper &gt; div {\r\n        flex: 1 1 150px;\r\n    }\r\n  &lt;/style&gt;\r\n  &lt;body&gt;\r\n    &lt;p&gt;&lt;h1&gt;Grid Layout Example&lt;hr/&gt;&lt;/h1&gt;&lt;/p&gt;\r\n    &lt;div class=&quot;row&quot;&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 1&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 2&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 3&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 1&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 2&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 3&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 1&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 2&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 3&lt;/div&gt;\r\n    &lt;/div&gt;\r\n\r\n    &lt;p&gt;&lt;h1&gt;&lt;br/&gt;Flexbox Layout Example&lt;hr/&gt;&lt;/h1&gt;&lt;/p&gt;\r\n    &lt;div class=&quot;wrapper&quot;&gt;\r\n        &lt;div&gt;One&lt;/div&gt;\r\n        &lt;div&gt;Two&lt;/div&gt;\r\n        &lt;div&gt;Three&lt;/div&gt;\r\n        &lt;div&gt;Four&lt;/div&gt;\r\n        &lt;div&gt;Five&lt;/div&gt;\r\n    &lt;/div&gt;\r\n  &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Calc dùng để làm gì?",
              "answer": "<p>Trong CSS3, hàm <code>calc()</code> cho phép ta thực hiện các phép tiến trên giá trị thuộc tính. Thay vì khai báo trực tiếp, với <strong>width</strong> là giá trị tĩnh ta có thể dùng <code>calc()</code> để chỉ định giá trị <strong>width</strong> bằng các phép tính trên các giá trị số.\r\n\r\n``<code>css\r\n.foo {\r\n\twidth: calc(100px + 50px)\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tuỳ chỉnh thuộc tính biến trong CSS?",
              "answer": "<p>Tuỳ chỉnh thuộc tính (thỉnh thoảng đề cập đến biến CSS) được định nghĩa bởi người dùng bao gồm giá trị cụ thể để sử dụng nhiều lần trong document. Giá trị là một tập hợp sử dụng ký hiệu <strong>--</strong>. Và giá trị được truy cập bằng hàm <code>var()</code>.\r\n\r\n``<code>css\r\n:root {\r\n\t--main-bg-color: brown\r\n}\r\n\r\n.one {\r\n\tcolor: white;\r\n\tbackground-color· var (--main-bg-color);\r\n\tmargin: l0px,\r\n\twidth: 50px,\r\n\theight: 5Opx;\r\n\tdisplay: inline-block;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt của biến CSS và biến preprocessor (SASS, LESS, Stylus)?",
              "answer": "<p><ul><li>Biến CSS có thể dùng mà không cần preprocessor. Đồng thời, tất cả trình duyệt đều hỗ trợ biến CSS.</li></ul>\r<ul><li>Biến CSS có tác động nối tiếp. Còn preprocessor không cần.</li></ul>\r<ul><li>Biến CSS có thể truy cập và quản lý trong JavaScript</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "`* { box-sizing: border-box }` là gì?",
              "answer": "<p><ul><li>Nó điều chỉnh tất cả phần tử có bao gồm padding, border trong không gian phần tử cho tính toàn chiều dài và chiều rộng.</li></ul>\r<ul><li>Trong <code>box-sizing: border-box</code>, chiều cao phần tử được tính toán với: height + padding dọc + độ dài border dọc. Còn chiều dài là width + padding ngang + độ dài border ngang.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "!important trong CSS là gì?",
              "answer": "<p>Các style có từ khoá important sẽ được ưu tiên cao nhất và ghi đè lên các thuộc tính bị trùng.\r\n\r\n``<code>css\r\np {\r\n \tcolor: red !important;\r\n}\r\n#thing {\r\n \tcolor: green;\r\n} \r\n&lt;p id=&quot;thing&quot;&gt;Will be RED.&lt;/p&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tính đặc hiệu trong CSS?",
              "answer": "<p>Tính đặc hiệu hay độ ưu tiên (specificity) là cách mà trình duyệt quyết định sẽ áp dụng thuộc tính css nào với một phần tử khi có nhiều quy tắc css cùng trỏ đến phần tử đó. \r\n\r\nInline style sẽ được ưu tiên so với ID rồi đến giá trị lớp (pseudo-class hoặc attribute selector), universal selector *<em>(</em>)** sẽ không có độ ưu tiên. ID Selector có độ ưu tiên cao hơn attribute selector.</p>",
              "level": "fresher"
            },
            {
              "question": "Progressive rendering là gì?",
              "answer": "<p>Progressive rendering là một kỹ thuật sử dụng để cải thiện hiệu suất trang web (cụ thể là cải thiện thời gian tải web) để render nội dung cho hiển thị nhanh nhất có thể.\r\n\r\nTa có thể triển khai progressive rendering bằng cách lazy loading với hình ảnh. Ta sử dụng Intersection Observer API cho lazy load ảnh. API giúp đơn giản hoá việc phát hiện một phần tử đi vào viewport và thực hiện hành động khi phần tử đó thực hiện hành động. Khi image vào viewport, ta mới bắt đầu tải ảnh. \r\n\r\nVí dụ:\r\n\r\n``<code>html\r\n&lt;img class=&quot;lazy&quot;\r\nsrc=&quot;placeholder-image.jpg&quot;\r\ndata-src=&quot;image-to-lazy-load-1x.jpg&quot;\r\ndata-srcset=&quot;image-to-lazy-load-2x.jpg 2x, image-to-lazy-load-1x.jpg 1x&quot;\r\nalt=&quot;I&#39;m an image!&quot;&gt;\r\n</code>`<code>\r\n\r\n</code>`<code>js\r\ndocument.addEventListener(&quot;DOMContentLoaded&quot;, function() {\r\n\tvar lazyImages = [].slice.call(document.querySelectorAll(&quot;img.lazy&quot;));\r\n\r\n\tif (&quot;IntersectionObserver&quot; in window) {\r\n\t\tlet lazyImageObserver = new IntersectionObserver(function(entries, observer) {\r\n\t\t\tentries.forEach(function(entry) {\r\n\t\t\t\tif (entry.isIntersecting) {\r\n\t\t\t\tlet lazyImage = entry.target;\r\n\t\t\t\tlazyImage.src = lazyImage.dataset.src;\r\n\t\t\t\tlazyImage.srcset = lazyImage.dataset.srcset;\r\n\t\t\t\tlazyImage.classList.remove(&quot;lazy&quot;);\r\n\t\t\t\tlazyImageObserver.unobserve(lazyImage);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tlazyImages.forEach(function(lazyImage) {\r\n\t\t\tlazyImageObserver.observe(lazyImage);\r\n\t\t});\r\n\t} else {\r\n\t\t// Possibly fall back to event handlers here\r\n\t}\r\n});\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Lợi thế của dùng translate() thay vì position absolute?",
              "answer": "<p>Translate() không làm cho trình duyệt kích hoạt vẽ lại layout, mà chỉ thực hiện soạn thảo. Còn position: absolute làm trình duyệt phải vẽ lại các luồng DOM. Thế nền <code>translate()</code> đem về hiệu suất tốt hơn.</p>",
              "level": "fresher"
            },
            {
              "question": "Style nào sẽ được tải và áp dụng trước trong code sau?",
              "answer": "<p>``<code>html\r\n&lt;head&gt;\r\n\t&lt;link href=&quot;style1.css&quot; rel=&quot; stylesheet&quot;&gt;\r\n\t&lt;link href=&quot;style2.css&quot; rel=&quot;stylesheet&quot;&gt;\r\n&lt;/head&gt;\r\n</code>``\r\n\r\nStyle1.css sẽ được áp dụng trước vì CSS thực hiện theo thứ tự xuất hiện trong HTML.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm sao để biết trình duyệt có hỗ trợ một tính năng nhất định không?",
              "answer": "<p>Sử dụng <code>@supports</code> trong CSS để biết trình duyệt có hỗ trợ tính năng hay không.\r\n\r\n``<code>css\r\n@supports (display: grid) {\r\n\tdiv {\r\n\t\tdisplay: grid;\r\n\t}\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách position absolute hoạt động?",
              "answer": "<p>Absolute là một cơ chế định vị mạnh mẽ cho phép người dùng đặt bất kỳ phần tử ở đâu vào một vị trí chính xác. Thuộc tính CSS như <code>right</code>, <code>left</code>, <code>top</code>, <code>bottom</code> sẽ xác định vị trí chính xác cần đặt phần tử. Trong absolute cần xem xét các điểm sau:\r<ul><li>Các phần tử được áp dụng absolute sẽ bị xoá khỏi luồng thông thường của HTML document.</li></ul>\r<ul><li>Bố cục HTML sẽ không tạo bất kỳ không gian nào cho các phần tử này trong bố cục trang.</li></ul>\r<ul><li>Các phần tử sẽ được định vị relative với phần tử cha (tổ tiên) gần nhất. Nếu không có phần tử cha nào nó sẽ được đặt tương ứng với container ban đầu.</li></ul>\r<ul><li>Vị trí cuối cùng của phần tử được xác định dựa trên các giá trị <code>top</code>, <code>left</code>, <code>right</code> và <code>bottom</code> được cung cấp.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thuộc tính của overflow trong CSS?",
              "answer": "<p>Thuộc tính overflow trong CSS dùng để xử lý khi kích thước nội dụng vượt qua kích thước container.\r\n\r\nCú pháp:\r\n\r\n``<code>css\r\noverflow: visible|hidden|scroll|auto|initial|inherit;\r\n</code>`<code>\r\n\r\nCác thuộc tính:\r<ul><li>visible: phần nội dung tràn sẽ được hiển thị bên ngoài box phần tử.</li></ul>\r<ul><li>hidden: phần nội dung tràn bị ẩn đi.</li></ul>\r<ul><li>scroll: phần nội dung tràn được cắt, những sẽ được hiển thị khi scroll xuống.</li></ul>\r<ul><li>auto: tương tự như scroll</li></ul>\r<ul><li>initial: thiết lập giá trị mặc định</li></ul>\r<ul><li>inherit: kế thừa thuộc tính của phần tử cha</li></ul>\r<ul><li>overflow-x: chỉ định đỉnh trái/phải của nội dung nếu nội dung tràn khỏi phạm vi của nó.</li></ul>\r<ul><li>overflow-y: chỉ định đỉnh trên/dưới của nội dung nếu nội dung tràn khỏi phạm vi của nó.</li></ul>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n\t&lt;head&gt;\r\n\t\t&lt;title&gt;CSS Overflow Property&lt;/title&gt;\r\n\t\t&lt;style&gt;\r\n\t\tdiv {\r\n\t\t\tbackground-color: #eee;\r\n\t\t\twidth: 200px;\r\n\t\t\theight: 100px;\r\n\t\t\tborder: 1px dotted black;\r\n\t\t\toverflow: scroll;\r\n\t\t\tpadding: 10px;\r\n\t\t}\r\n\t\t&lt;/style&gt;\r\n\t&lt;/head&gt;\r\n\t&lt;body&gt;\r\n\t\t&lt;h2&gt;CSS Overflow Property&lt;/h2&gt;\r\n\t\t&lt;p&gt;Setting the overflow value to scroll, the overflow is clipped and a scrollbar\r\n\t\t\tis added to scroll inside the box.\r\n\t\t&lt;/p&gt;\r\n\r\n\t\t&lt;div&gt;You can use the overflow property when you want to have better control of \r\n\t\t\tthe layout. The overflow property specifies what happens if content overflows \r\n\t\t\tan element&#39;s box.\r\n\t\t&lt;/div&gt;\r\n\t&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn có thể căn chỉnh nội dung của thẻ `<p>` nằm ngay trung tâm của thẻ `<div>`?",
              "answer": "<p>Ta có thể dùng thuộc tính <code>text-align: center</code> bên trong div cha, để căn chỉnh nội dung nằm ngay trung tâm theo chiều ngang. Nhưng không ngay trung tâm chiều dọc. Để chỉnh nó theo chiều dọc ta cần làm gán position của phần tử cha là <code>relative</code> và ở phần tử con là <code>absolute</code>. Các phần tử con có giá trị <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code> là 0 để nó nằm ở giữa theo chiều dọc. Sau đó ta thiết lập margin là auto. Nó giả sử cả phần tử con và cha sẽ có giá trị height và width.\r\n\r\nXem như ta có height và width của phần tử div là 20% kích cỡ màn hình. Ta có height văn bản là 1.2em và width là 20%. Nếu muốn chỉnh văn bản nằm ở trung tâm div ta làm như sau:\r\n\r\n``<code>css\r\ndiv {\r\n    position : relative;  // Make position relative\r\n    height : 20%;\r\n    width : 20%;\r\n    text-align : center; //Align to center horizontally\r\n}\r\np {\r\n    position : absolute; // Make position absolute\r\n    top:0;                // Give values of top, bottom,left, right to 0\r\n    bottom:0;\r\n    left:0;\r\n    right:0;\r\n    margin : auto;        // Set margin as auto\r\n    height : 1.2 em;\r\n    width : 20%;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Margin khác Padding như thế nào?",
              "answer": "<p>Thuộc tính margin được dùng để tạo không gian xung quanh phần tử. Ta có thể tạo không gian được xác định ở bên ngoài border. Ta có các thuộc tính sau cho margin:\r\n\r\n<em> margin-top\r\n</em> margin-right\r\n<em> margin-bottom\r\n</em> margin-left\r\n\r\nCác giá trị mà thuộc tính có thể có:\r\n\r\n<em> auto – Trình duyệt tự động tính toán margin khi ta sử dụng.\r\n</em> length – Giá trị có thể là <code>px</code>, <code>pt</code>, <code>cm</code>, <code>em</code>,... các giá trị có thể âm hoặc dương.\r\n<em> % - Ta cũng có thể cung cấp giá trị phần trăm cho margin\r\n</em> inherit - sử dụng giá trị từ phần tử cha.\r\n\r\nThuộc tính padding dùng cho tạo không gian xung quanh nội dung phần tử và bên trong border. Padding có các thuộc tính con sau:\r\n\r\n<em> padding-top\r\n</em> padding-right\r\n<em> padding-bottom\r\n</em> padding-left\r\n\r\nLưu ý: padding không có giá trị âm.\r\n\r\n<img src=\"/interview-assets/CSS_Margin_vs._Padding.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Cách để tự động đánh số giá trị heading của section và category?",
              "answer": "<p>Ta có thể dùng khái niệm CSS counter (bộ đếm). Điều này cho phép chúng ta điều chỉnh hình thức của nội dung dựa trên vị trí trong document. Để sử dụng nó, trước tiên chúng ta cần khởi tạo giá trị của thuộc tính <code>counter-reset</code>, giá trị này là 0 theo mặc định. Thuộc tính tương tự cũng được sử dụng để thay đổi giá trị thành bất kỳ số nào mà chúng ta cần. Sau khi khởi tạo, giá trị của bộ đếm có thể tăng hoặc giảm bằng cách sử dụng thuộc tính <code>counter-increment</code>. Tên của bộ đếm không được là các từ khóa CSS như <code>none</code>, <code>initial</code>, <code>inherit</code>, v.v. Nếu các từ khóa CSS được sử dụng, thì khai báo sẽ bị bỏ qua.\r\n\r\nVí dụ:\r\n\r\n``<code>css\r\nbody {\r\n  \tcounter-reset: header;   /<em> define counter named &#39;header&#39; whose initial value is 0 by default </em>/\r\n}\r\n\r\nh2::before {\r\n\tcounter-increment: header;   /<em> The value of header counter by 1.</em>/\r\n\tcontent: &quot;Header &quot; counter(header) &quot;: &quot;;  /<em> To display word Header and the value of the counter with colon before it.</em>/\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa nth-child() và nth-of-type()?",
              "answer": "<p>Cả hai đều là pseudo-classes.\r\n\r\n<code>nth-child()</code> được dùng để so khớp các phần tử dựa trên số đại diện cho vị trí của một phần tử dựa trên các phần tử anh chị em.\r\n\r\nVí dụ, trong đoạn code dưới đây, ta cung cấp <code>nth-child(4)</code> thì phần tử con thứ 4 sẽ được chọn bất kể loại. \r\n\r\n``<code>css\r\n.example:nth-child(4) {   \r\n    background: black; \r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div class=&quot;example&quot;&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt; &lt;!-- 4th Element to select and apply style--&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt; \r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\n</code>nth-of-type()<code> cũng tương tự nhưng chỉ so khớp với các phần tử anh chị em cùng loại. Số để xác định trong </code>nth-of-type()<code> có thể là một hàm hoặc từ khoá như odd hay even.\r\n\r\nVí dụ: nếu ta cấp </code>p:nth-of-type(even)<code> thì các thẻ </code><p><code> và số thứ tự chẵn được áp dụng. \r\n\r\n</code>`<code>css\r\n.example p:nth-of-type(even) { \r\n    background: black; \r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div class=&quot;example&quot;&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; \r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;!-- Select this and apply style--&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; \r\n\t&lt;div&gt;This is a div.&lt;/div&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt; \r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;!-- Select this and apply style--&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; \r\n\t&lt;div&gt;This is a div.&lt;/div&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;!-- Select this and apply style--&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt;\r\n&lt;/div&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "CSS Sprite là gì?",
              "answer": "<p>CSS Sprite dùng cho kết hợp nhiều hình ảnh thành một hình ảnh lớn. Nó thường dùng cho biểu diễn icons. Các ưu điểm của nó là:\r<ul><li>Giảm số lượng yêu cầu HTTP để lấy nhiều ảnh vì nó cho phép chỉ gửi một yêu cầu.</li></ul>\r<ul><li>Nó giúp tải trước các nội dung giúp hiển thị các icon hoặc hình ảnh khi di chuột và các pseudo-state khác.</li></ul>\r<ul><li>Khi có nhiều hình ảnh, trình duyệt sẽ thực hiện các lệnh gọi riêng biệt để lấy hình ảnh cho từng hình ảnh đó.</li></ul>\r\n\r\nSử dụng sprites, các hình ảnh được kết hợp thành một và chúng ta chỉ cần gọi hình ảnh đó bằng một lệnh gọi.\r\n\r\nHãy xem xét một ví dụ trong đó ứng dụng của chúng ta yêu cầu 3 hình ảnh như hình dưới đây (Không có Section Sprites). Nếu chúng ta đang cố gắng tải các hình ảnh một cách độc lập, chúng ta cần 3 yêu cầu HTTP khác nhau để lấy dữ liệu. Nhưng nếu chúng ta có CSS Sprites trong đó cả 3 hình ảnh được kết hợp thành 1 được phân tách bằng một số khoảng trắng, thì chúng ta chỉ yêu cầu 1 HTTP Request.\r\n\r\n<img src=\"/interview-assets/CSS_Sprites.png\" alt=\"\" />\r\n\r\n``<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n\t&lt;head&gt;\r\n\t\t&lt;style&gt;\r\n\t\t\t#home-icon {\r\n\t\t\t\tleft: 0px;\r\n\t\t\t\twidth: 46px;\r\n\t\t\t\tbackground: url(&#39;spriteFile.gif&#39;) 0 0;\r\n\t\t\t}\r\n\r\n\t\t\t#prev-icon {\r\n\t\t\t\tleft: 63px;\r\n\t\t\t\twidth: 43px;\r\n\t\t\t\tbackground: url(&#39;spriteFile.gif&#39;) -47px 0;\r\n\t\t\t}\r\n\r\n\t\t\t#next-icon {\r\n\t\t\t\tleft: 129px;\r\n\t\t\t\twidth: 43px;\r\n\t\t\t\tbackground: url(&#39;spriteFile.gif&#39;) -91px 0;\r\n\t\t\t}\r\n\t\t&lt;/style&gt;\r\n\t&lt;/head&gt;\r\n\t&lt;body&gt;\r\n\r\n\t\t&lt;img id=&quot;home-icon&quot; src=&quot;spriteFile.gif&quot; width=&quot;1&quot; height=&quot;1&quot;&gt;    &lt;!-- To display home icon here --&gt;\r\n\t\t&lt;img id=&quot;next-icon&quot; src=&quot;spriteFile.gif&quot; width=&quot;1&quot; height=&quot;1&quot;&gt;    &lt;!-- To display next icon icon here --&gt;\r\n\t\t&lt;img id=&quot;prev-icon&quot; src=&quot;spriteFile.gif&quot; width=&quot;1&quot; height=&quot;1&quot;&gt;    &lt;!-- To display previous icon icon here --&gt;\r\n\r\n\t&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, chúng ta đang cố gắng truy cập từng phần tử - </code>home<code>, </code>previous<code> và </code>next<code> - từ file sprite bằng cách sử dụng thuộc tính left, width. Hình ảnh được hiển thị trong phần img nhờ thuộc tính </code>background<code>. Lưu ý rằng nguồn của hình ảnh (thuộc tính </code>src<code> của thẻ img) chỉ là một file là </code>spriteFile.gif` và tùy thuộc vào các quy tắc được chỉ định trong id selector, hình ảnh được tải tương ứng.</p>",
              "level": "fresher"
            },
            {
              "question": "Tweening trong CSS?",
              "answer": "<p>Tweening là quá trình lấp đầy khoảng trống giữa các chuỗi khóa, tức là giữa các keyframes đã được tạo. Keyframes là những frame đại diện cho điểm bắt đầu và điểm kết thúc của hành động hoạt ảnh. Tweening liên quan đến việc tạo keyframe giữa hai hình ảnh để tạo ấn tượng rằng hình ảnh đầu tiên đã di chuyển mượt mà sang hình ảnh thứ hai. Với mục đích này, chúng ta sử dụng các thuộc tính như transforms - matrix, translate, scale, rotate,...\r\n\r\nTrong đoạn code bên dưới, ta tạo frame trung gian của các phần tử <code>&lt;p&gt;</code> để chuyển từ đầu đến phía bên trái của trình duyệt.\r\n\r\n``<code>css\r\np {\r\n\tanimation-duration: 2s;\r\n\tanimation-name: slidethrough;\r\n}\r\n\r\n@keyframes slidethrough {\r\n\tfrom {\r\n\t\tmargin-left: 100%;\r\n\t\twidth: 300%; \r\n\t}\r\n\r\n\tto {\r\n\t\tmargin-left: 0%;\r\n\t\twidth: 100%;\r\n\t}\r\n}\r\n</code>`<code>\r\n\r\nỞ đây, phần tử đoạn văn chỉ định rằng quá trình hoạt ảnh sẽ mất 2 giây để thực hiện từ đầu đến cuối. Điều này được thực hiện bằng cách sử dụng thuộc tính </code>animation-duration<code>. Tên hoạt ảnh của </code>@keyframes<code> được xác định bằng cách sử dụng thuộc tính </code>animation-name<code>. Keyframe trung gian được xác định bằng cách sử dụng quy tắc </code>@keyframes<code>. \r\n\r\nTrong ví dụ, chúng ta chỉ có 2 keyframe. Keyframe đầu tiên bắt đầu ở </code>0%<code> và chạy cho đến lề trái </code>100%<code>, là cạnh ngoài cùng bên phải của phần tử container. Keyframe thứ hai bắt đầu ở </code>100%<code> trong đó lề trái được đặt là </code>0%<code> và chiều rộng được đặt là </code>100%`, kết quả là kết thúc hoạt ảnh nghiêng về phía bên trái của container.</p>",
              "level": "fresher"
            },
            {
              "question": "DOM là gì và cách nó liên kết với CSS?",
              "answer": "<p>DOM (Document Object Model) là một interface lập trình cho HTML và XML. Nó xác định cấu trsuc của document và cách mà document được hiển thị và quản lý. Document này cho phép javascript truy cập và quản lý phần tử và style của web. Mô hình được xây dựng theo cấu trúc cây đối tượng và xác định:\r<ul><li>Các phần tử HTML là đối tượng</li></ul>\r<ul><li>Thuộc tính của tất cả phần tử HTML</li></ul>\r<ul><li>Phương thức truy cập đến tất cả phần tử HTML</li></ul>\r<ul><li>Sự kiện với tất cả phần tử HTML</li></ul>\r\n\r\n<img src=\"/interview-assets/DOM.png\" alt=\"\" />\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Chi tiết cách CSS hoạt động?",
              "answer": "<p>Ngôn ngữ CSS được thiết kế để sử dụng cùng với ngôn ngữ \"đánh dấu\" như HTML. CSS xác định cách các phần tử HTML được định dạng - kiểm soát bố cục, màu sắc, phông chữ của chúng, ... Khi trình duyệt hiển thị một document, nó phải kết hợp nội dung của document với thông tin style của nó. Nó xử lý document theo một số giai đoạn, mà chúng ta đã liệt kê bên dưới.\r\n\r\n1. Trình duyệt tải HTML (ví dụ: nhận nó từ mạng).\r\n2. Nó chuyển đổi HTML thành DOM.\r\n3. Sau đó, trình duyệt sẽ tìm nạp hầu hết các tài nguyên được liên kết với tài liệu HTML, chẳng hạn như hình ảnh và video được nhúng và CSS được liên kết.\r\n4. Trình duyệt phân tích cú pháp CSS đã nạp và sắp xếp các quy tắc khác nhau theo kiểu selector của chúng thành các \"nhóm\" khác nhau, ví dụ: phần tử, lớp, ID, ... Dựa trên các selector mà nó tìm thấy, nó sẽ tìm ra các quy tắc nên được áp dụng cho các nút nào trong DOM và đính kèm kiểu cho chúng theo yêu cầu (bước trung gian này được gọi là cây render).\r\n5. Cây render được bố trí trong cấu trúc mà nó sẽ xuất hiện sau khi các quy tắc đã được áp dụng cho nó.\r\n6. Hiển thị trực quan của trang được hiển thị trên màn hình.\r\n\r\nSơ đồ sau đây cũng cung cấp một cái nhìn đơn giản về quy trình:\r\n\r\n<img src=\"/interview-assets/css-dom.png\" alt=\"\" />\r\n\r\n#</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "es6",
          "name": "Câu hỏi phỏng vấn ES6",
          "description": "",
          "questions": [
            {
              "question": "Các tính năng nổi bật của ES6",
              "answer": "<p><em> Hỗ trợ các biến hằng\r\n</em> Block scope hỗ trợ cho tất cả biến, hằng, và hàm\r\n<em> Giới thiệu hàm arrow\r\n</em> Xử lý tham số mở rộng\r\n<em> Tham số mặc định\r\n</em> Các ký tự mở rộng và mẫu\r\n<em> Promise\r\n</em> Class\r\n<em> Module\r\n</em> Tập hợp\r<ul><li>Hỗ trợ map/set</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hỗ trợ hướng đối tượng trong ES6 như thế nào?",
              "answer": "<p><ul><li><strong>Classes</strong> có thể tạo lớp trong ES6. Về cơ bản, hàm lớp xây dựng một khuôn mẫu mà từ đó ta có thể tạo các đối tượng. Khi tạo một thực thế mới của lớp, phương thức constructor sẽ được gọi.</li></ul>\r<ul><li><strong>Methods</strong> phương thức tĩnh có thể được tìm thấy trong các lớp. Một phương thức tĩnh không giống như một đối tượng mà nó là một hàm được liên kết với lớp. Một phương thức tĩnh không thể được gọi từ một thực thể của lớp.</li></ul>\r\n\r\nTa hãy xem qua getter và setter nhé.\r\nĐóng gói là một khái niệm căn bản trong OOP. Dữ liệu (thuộc tính) sẽ không được truy cập trực tiếp từ bên ngoài, đây là một khía cạnh quan trọng của đóng gói. Một getter (truy cập) hay setter (chỉnh sửa) là những phương thức của thực thể đã xác định để truy cập hay chỉnh sửa một thuộc tính.\r<ul><li><strong>Tính kế thừa</strong>, các lớp cũng có thể kế thừa từ nhau. Lớp cha là lớp kế thừa và con là lớp được kế thừa từ lớp cha.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa ES5 và ES6",
              "answer": "<p>| ES5 | ES6 |\r\n|-----|-----|\r\n| Là chuẩn thứ 5 của ECMAScript được giới thiệu năm 2009 | Là chuẩn thứ 6 của ECMAScript được giới thiệu năm 2015 |\r\n| Kiểu dữ liệu nguyên thuỷ là string, boolean, number, null và undefined | Giới thiệu thêm kiểu symbol |\r\n| Chỉ có thể khai báo biến với var | Có thể dùng var, và hai cách khai báo biến mới là let và const |\r\n| Sử dụng function để khai báo hàm | Giới thiệu thêm hàm arrow |\r\n| for cho vòng lặp | Giới thiệu thêm for...of |</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa let và const?",
              "answer": "<p>Cả let và const đều có block scope. Nếu bạn sử dụng các từ khóa này để khai báo một biến, biến đó sẽ chỉ tồn tại trong block trong cùng bao quanh chúng. Nếu bạn khai báo một biến với let bên trong một block (ví dụ: nếu một điều kiện hoặc một vòng lặp for), thì nó chỉ có thể được truy cập trong block đó.\r\n\r\nCác biến được khai báo với từ khóa let có thể thay đổi, có nghĩa là giá trị của chúng có thể được thay đổi. Nó tương tự như từ khóa var, nhưng với lợi ích bổ sung là block scope. Các biến được khai báo với từ khóa const là block scope và bất biến. Khi các biến được khai báo với từ khóa const, giá trị của chúng không thể được sửa đổi hoặc gán lại.</p>",
              "level": "fresher"
            },
            {
              "question": "Thảo luận về hàm arrow",
              "answer": "<p>Trong ES6, hàm arrow là một cú pháp mới cho khai báo hàm. hàm arrow bao gồm tham số theo sau mũi tên (=>) và thân hàm.\r\n\r\n``<code>js\r\nconst function<em>name = (arg</em>1, arg<em>2, arg</em>3, ...) =&gt; {  \r\n    //body of the function  \r\n}\r\n</code>`<code>\r\n\r\nCác điều cần nhớ:\r<ul><li>Nó tiết kiệm kích cỡ code.</li></ul>\r<ul><li>Với hàm một dòng, lênh return là không bắt buộc.</li></ul>\r<ul><li>Ràng buộc ngữ cảnh.</li></ul>\r<ul><li>Với hàm một tham số, dấu ngoặc đơn là không bắt buộc.</li></ul>\r<ul><li>Không hoạt động với </code>new`.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Khi nào không nên dùng hàm arrow?",
              "answer": "<p>Không nên sử dụng hàm arrow cho các trường hợp dưới đây:\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm generator là gì?",
              "answer": "<p>Là tính năng mới được giới thiệu trong ES6. Hàm Generator trả về một đối tượng sau khi tạo nhiều giá trị theo thời gian. Ta có thể lặp qua đối tượng và trích xuất từng giá trị từ hàm một. Một hàm trả về một đối tượng được lặp đi lặp lại gọi là hàm generator. Trong ES6, cú pháp cho nó là <code>fuction<em></code> cùng từ khoá <code>yield</code> bên trong nó.\r\n\r\n``<code>js\r\nfunction </em>Numbers() {\r\n    let num = 1;\r\n    while(true) {\r\n        yield num++;\r\n    }\r\n}\r\n  \r\nvar gen = Numbers();\r\n \r\n// Loop to print the first\r\n// 5 Generated numbers\r\nfor (var i = 0; i &lt; 5; i++) {\r\n \r\n    // Generate the next number\r\n    document.write(gen.next().value);\r\n \r\n    // New Line\r\n    document.write(&quot;&lt;br&gt;&quot;);\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\n1\r\n2\r\n3\r\n4\r\n5\r\n</code>``\r\n\r\nGiá trị yield trở thành giá trị kế tiếp trong chuỗi tuần tự mỗi lần yield được gọi. Ngoài ra, hàm generator tính toán kết quả output của chúng theo yêu cầu, cho phép chúng biểu diễn một cách hiệu quả các chuỗi tuần tự dài hơn thậm chí là vô hạn.</p>",
              "level": "fresher"
            },
            {
              "question": "Toán tử spread trong ES6?",
              "answer": "<p>Toán tử spread có cú pháp giống với rest parameters tuy nhiên cả hai có ý nghĩa khác nhau. Rest parameters được sử dụng khi khai báo hàm, ngược lại toán tử spread được sử dụng trong các câu lệnh, biểu thức hoặc khi gọi hàm.\r\n\r\nES6 cung cấp một toán tử mới gọi là toán tử spread bao gồm ba dấu chấm (...). Spread cho phép bạn trải ra các phần tử của một đối tượng có thể lặp lại chẳng hạn như một array, map hoặc set.\r\n\r\n``<code>js\r\nlet arr1 = [4, 5, 6];  \r\n    \r\nlet arr2 = [1, 2, 3, ...arr1, 7, 8, 9, 10];  \r\n    \r\nconsole.log(arr2);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\n[ 1 2 3 4 5 6 7 8 9 10 ]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về destructuring trong ES6?",
              "answer": "<p>Destructuring được giới thiệu trong ES6 là một cách để trích xuất dữ liệu từ mảng hay đối tượng thành các biến duy nhất. Ta có thể tạo các đoạn nhỏ hơn từ đối tượng hay mảng bằng phương thức này. Ví dụ:\r\n\r\n``<code>js\r\nlet greeting = [&quot;Good&quot;, &quot;Morning&quot;];\r\nlet [g1, g2] = greeting;\r\nconsole.log(g1, g2);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nGood Morning\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Promise trong ES6 là gì?",
              "answer": "<p>Lập trình bất đồng bộ là khái niệm quan trọng trong JavaScript. Các tiến trình chạy độc lập với luồng chính trong lập trình bất đồng bộ. Promise là cách tiếp cận tiện lợi để xử lý lập trình bất đồng bộ trong ES6. Callback được dùng để chủ yếu trong bất đồng bộ trước khi ES6 giới thiệu về Promise.\r\n\r\nTuy nhiên, vì callback dễ gây ra callback hell, nên hướng giải quyết cho nó là dùng promise thay thế.\r\n\r\n<strong>Callback hell</strong>\r\n\r\n``<code>js\r\nf1(function(x){\r\n    f2(x, function(y){\r\n        f3(y, function(z){ \r\n            ...\r\n        });\r\n    });\r\n}); \r\n</code>`<code>\r\n\r\n<strong>Cú pháp Promise</strong>\r\n\r\n</code>`<code>js\r\nconst promise = new Promise((resolve,reject) =&gt; {....}); \r\n</code>`<code>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nconst myPromise = new Promise((resolve, reject) =&gt; {\r\n    if (Math.random() &gt; 0) {\r\n        resolve(&#39;Hello, I am positive number!&#39;);\r\n    }\r\n    reject(new Error(&#39;I failed some times&#39;));\r\n})\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Rest parameter trong ES6?",
              "answer": "<p>Rest Parameters dịch theo tiếng Anh chuyên ngành công nghệ thông tin có nghĩa là tham số còn lại, điều này có nghĩa là bạn có thể khai báo một hàm với số lượng tham số không xác định, đây là một tính năng mới trong ES6 khiến Javascript ngày càng trở nên mạnh mẽ hơn.\r\n\r\n``<code>js\r\nfunction display(...args) {  \r\n    let ans = 0;  \r\n    for (let i of args) {  \r\n        ans *= i;  \r\n    }  \r\n    console.log(&quot;Product = &quot;+ans);  \r\n}  \r\n    \r\ndisplay(4, 2, 3);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nProduct = 24\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thảo luận về template literal trong ES6?",
              "answer": "<p>Temaplate Literals là một cú pháp mới dùng để khai báo biến, được thêm vào trong phiên bản ES6. Khi sử dụng cú pháp này các bạn có thể:\r<ul><li>Khai báo biến nhiều dòng một cách hết sức đơn giản. (Nếu bạn sử dụng cách truyền thống thì sẽ không thể nào khai báo được một biến mà có sử dụng ký tự xuống dòng, nhưng với template thì có thể).</li></ul>\r<ul><li>Binding biến vào trong template một cách dễ dàng.</li></ul>\r\n\r\nKý tự `<code> dùng để mở và đóng template literal. Ký hiệu dollar và dấu ngoặc nhọn &quot;${}&quot; được dùng để đặt một biến vào template literal.\r\n\r\n</code>`<code>js\r\nlet s1 = &quot;Good&quot;;  \r\n  \r\nlet s2 = &quot;Day&quot;;  \r\n   \r\nlet s = </code>${s1} ${s2}<code>;  \r\nconsole.log(s);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nGood Day\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của class trong ES6?",
              "answer": "<p>Các ưu điểm của class ở ES6:\r<ul><li>Cú pháp đơn giản và ít lỗi hơn.</li></ul>\r<ul><li>Khi xây dựng một hệ phân cấp kế thừa, ES6 kết hợp cú pháp cũ và mới, làm giảm lỗi và đơn giản hoá các quy trình.</li></ul>\r<ul><li>Class trong ES6 ngăn chặn lỗi do toán tử <code>new</code>. Nếu một đối tượng không hợp lệ khởi tạo, class sẽ loại trừ vấn đề này bằng cách để constructor trả về lỗi.</li></ul>\r<ul><li>Class còn gọi một phương thức từ prototype. Với cú pháp ES6, nó dễ dùng hơn các phiên bản trước.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách tạo class trong ES6?",
              "answer": "<p>Từ khoá <code>class</code> dùng cho tạo lớp trong ES6. Ta có thể dùng biểu thức lớp hoặc khai báo lớp để tạo. Chỉ có hàm và contrustor là được cho phép trong lớp. Các thành phần này gọi chung là thuộc tính dữ liệu của lớp.\r\n\r\nConstructor trong lớp có trách nhiệm cấp phát bộ nhớ cho đối tượng của lớp. Hàm của lớp chịu trách nhiệm thực hiện các hành động trên đối tượng.\r\n\r\nCú pháp ở ES5\r\n\r\n``<code>js\r\nvar varName = new className {\r\n    // something\r\n}\r\n</code>`<code>\r\n\r\nCú pháp ở ES6\r\n\r\n</code>`<code>js\r\nclass className {\r\n    // Something\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Biểu thức lớp là gì?",
              "answer": "<p>Trong ES6, một cách khác để khai báo lớp là dùng biểu thức lớp. Giống như một biểu thức hàm, có thể có tên hoặc không. Nếu có tên, tên đó là duy nhất trong thân lớp. \r\n\r\n``<code>js\r\nvar Product = class {\r\n    constructor (num1, num2) {\r\n    this.num1 = num1;\r\n    this.num2 = num2;\r\n    }\r\n    multiplication() {\r\n    return this.num1 * this.num2;\r\n    }\r\n}\r\nconsole.log(new Product(5,8).multiplication());\r\n// expected output: 40\r\n</code>``\r\n\r\nCú pháp của một biểu thức lớp tương tự như cú pháp của một câu lệnh lớp (khai báo). Mặt khác, các biểu thức lớp cho phép bạn bỏ qua tên lớp (\"định danh ràng buộc\"), điều này không thể thực hiện được với các câu lệnh lớp. Ngoài ra, không giống như khai báo lớp, biểu thức lớp cho phép bạn khai báo lại các lớp mà không gây ra bất kỳ lỗi kiểu nào. Nó không bắt buộc phải sử dụng thuộc tính constructor. Loại lớp được tạo bằng từ khóa này sẽ luôn là \"function\".</p>",
              "level": "fresher"
            },
            {
              "question": "Tham số mặc định là gì?",
              "answer": "<p>Nếu không có giá trị nào được truyền cho tham số, ta có thể dùng tham số mặc định để thiết lập giá trị mặc định cho tham số.\r\n\r\n``<code>js\r\nvar display = (x , y = 2) =&gt; {  \r\n    console.log(x + &quot; &quot; + y);  \r\n}  \r\ndisplay(1);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\n1 2\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về IIFE?",
              "answer": "<p>IIFE là hàm JavaScript chạy ngay khi được khai báo. Nó được chia thành hai phần chính là:\r<ul><li>Phần đầu tiên là một hàm ẩn danh lexical scope, được bao bọc bởi <code>()</code>.</li></ul>\r<ul><li>Phần thứ hai là dấu ngoặc <code>()</code> dùng để chạy hàm ngay sau khi khai báo.</li></ul>\r\n\r\n``<code>js\r\n(function () {    \r\n   console.log(&quot;Good Day&quot;);     \r\n})();\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các trạng thái của Promise trong ES6?",
              "answer": "<p>Khi được khởi tạo thì Promise có một trong ba trạng thái sau:\r<ul><li><strong>Fulfilled</strong>: hành động xử lý xong và thành công</li></ul>\r<ul><li><strong>Rejected</strong>: hành động xử lý xong và thất bại</li></ul>\r<ul><li><strong>Pending</strong>: hành động đang chờ xử lý hoặc bị từ chối</li></ul>\r\n\r\nTrong đó hai trạng thái <strong>Reject</strong> và <strong>Fulfilled</strong> ta gọi là <strong>Settled</strong>, tức là đã xử lý xong.</p>",
              "level": "fresher"
            },
            {
              "question": "Export Default và Name Export trong ES6?",
              "answer": "<p>Với sự hỗ trợ của lệnh import, export bây giờ khi ta cần xuất các hàm, đối tượng, và biến đến module JavaScript khác ta có hai cách sau:\r<ul><li><strong>Named Export</strong> dùng khi export nhiều giá trị cùng lúc. Tên của module được import phải trùng với tên module export.</li></ul>\r\n\r\n``<code>js\r\n //file rectangle.js\r\nfunction perimeter(x, y) {\r\n    return 2 <em> (x + y);\r\n}\r\nfunction area(x, y) {\r\n    return x </em> y;\r\n}\r\nexport { perimeter, area };\r\n  \r\n   \r\n//while importing the functions in test.js\r\nimport { perimeter, area } from &#39;./rectangle;\r\nconsole.log(perimeter(4, 6)) //20\r\nconsole.log(area(4, 6)) //24\r\n</code>`<code>\r<ul><li><strong>Default Export</strong> dùng khi export một module thành export mặc định. Một hàm, lớp, đối tượng hay bất cứ thứ gì cũng có thể dùng cho default export. Trong default export, tên có thể tuỳ ý miễn sao đúng file.</li></ul>\r\n\r\n</code>`<code>js\r\n// file module.js\r\nvar a = 6; \r\nexport default a;\r\n  \r\n// test.js\r\n// while importing a in test.js\r\nimport b from &#39;./module&#39;; \r\nconsole.log(b);        \r\n// output will be 6\r\n</code>`<code>\r<ul><li><strong>Dùng cả hai</strong>, trong cùng một file ta có thể dùng cả hai cách.</li></ul>\r\n\r\n</code>`<code>js\r\n //index.js\r\nvar a = 3;\r\nconst b = 8;\r\nfunction show() {\r\n    return &quot;This is a default export.&quot;\r\n}\r\nfunction product(a , b) {\r\n    return a * b;\r\n}\r\nexport { show as default, a, b, product };\r\n</code>`<code>\r\n\r\n</code>`<code>js\r\n//test.js file\r\nimport any<em>other</em>name, { a, b, product} from &#39;./index.js&#39;;\r\nconsole.log(any<em>other</em>name()); //This is a default export.\r\nconsole.log(a); //3\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Từ khoá nào dùng cho kế thừa trong ES6?",
              "answer": "<p>Từ khoá <code>extends</code> dùng cho triển khai kế thừa trong ES6.\r\n\r\n``<code>js\r\nclass Classroom {\r\n    constructor(students) {\r\n        this.students = students;\r\n    }\r\n    room() {\r\n        console.log(&#39;This class has  &#39; + this.students + &#39; students&#39;);\r\n    }\r\n}\r\n \r\nclass sectionA extends Classroom {\r\n    constructor(students) {\r\n        super(students);\r\n    }\r\n    sec() {\r\n        console.log(&#39;section A&#39;);\r\n    }\r\n}\r\n  \r\nlet secA = new sectionA(40);\r\n \r\nsecA.room();\r\nsecA.sec();\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Bubbling và Capturing là gì?",
              "answer": "<p>Khi một sự kiện xảy ra trong DOM, nó sẽ diễn ra hoàn toàn trên một phần tử. Sự kiện nổi lên (bubble) phần tử cha, hay tổ tiên của nó cho đến khi nó tới giai đoạn Bubbling. Trong khi đó, sự kiện bắt đầu từ ngoài window đến khi phần tử nhận sự kiện thì là giai đoạn Capturing.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa for...of và for..in?",
              "answer": "<p><ul><li><strong>for in</strong> chạy trên các tên thuộc tính có thể liệt kê của một đối tượng.</li></ul>\r<ul><li><strong>for of</strong> lấy một đối tượng cụ thể và lặp qua dữ liệu mà nó tạo ra.</li></ul>\r\n\r\nCả lệnh <code>for..of</code> và <code>for..in</code> đều lặp lại qua các danh sách, nhưng kết quả chúng trả về là khác nhau: <code>for..in</code> trả về danh sách các khóa trên đối tượng đang được lặp lại, trong khi <code>for..of</code> trả về danh sách các giá trị của thuộc tính của đối tượng.\r\n\r\n``<code>js\r\nlet arr = [3, 4, 5];\r\n\r\nfor (let i in arr) {\r\n   console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;,\r\n}\r\n\r\nfor (let i of arr) {\r\n   console.log(i); // &quot;3&quot;, &quot;4&quot;, &quot;5&quot;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Symbol trong ES6 là gì?",
              "answer": "<p>Trong ES6 xuất hiện thêm một kiểu dữ liệu đó là Symbol, đây là kiểu dữ liệu nguyên thuỷ, nó sẽ tạo ra các ký tự duy nhất (unique) và không trả về một chuỗi mà nó chỉ là một dạng đối tượng, vì vậy bạn sẽ không thể thấy được giá trị thực của nó.\r\n\r\nSymbol được sinh ra dùng để xử lý cho bài toán mang tính duy nhất (unique), mỗi khi bạn tạo một đối tượng Symboy thì đối tượng đó sẽ không bao giờ trùng lặp với một đối tượng khác. Cú pháp khởi tạo của Symbol.\r\n\r\n``<code>js\r\nlet symbol = Symbol();\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Babel là gì?",
              "answer": "<p>Babel là một công cụ chuyển đổi mã lệnh JavaScript hay JavaScript transpiler, được dùng với mục đích chuyển đổi mã lệnh JavaScript được viết dựa trên tiêu chuẩn ECMAScript phiên bản mới về phiên bản cũ hơn trước đó.\r\n\r\nBabel đảm bảo code của các lập trình viên luôn được biên dịch thành phiên bản tương thích các trình duyệt khác nhau mà không lo bị lỗi.\r\n\r\n\"Chuẩn ECMAScript được ra đời để hạn chế sự khác biệt giữa các \"ngôn ngữ\" JavaScript khác nhau được định nghĩa bởi các trình duyệt khác nhau\".\r\n\r\nVí dụ, arrow function được giới thiệu ở ES6 sẽ được chuyển đổi về các function truyền thống. Nó cũng có thể chuyển đổi các cú pháp JS không chuẩn như JSX. Babel có thể tự động chèn các core-js cho các môi trường javascript không khả dụng. Ví dụ như phương thức <code>Array.from</code> hay Promise chỉ khả dụng trong ES6+, nhưng nó vẫn có thể sử dụng ở các phiên bản trước nhờ core-js.</p>",
              "level": "fresher"
            },
            {
              "question": "Tên các phương thức mảng có trong ES6?",
              "answer": "<p>| Phương thức | Mô tả |\r\n|-------------|-------|\r\n| Array.from() | Tạo một đối tượng <code>Array</code> mới, được sao chép từ một đối tượng giống mảng hoặc có thể lặp lại |\r\n| Array.of() | Tạo một đối tượng <code>Array</code> mới từ một lượng biến đối số, bất kể số lượng hoặc kiểu của đối số |\r\n| Array.prototype.copyWithin() | Sao chép một chuỗi tuần tự phần tử mảng bên trong mảng |\r\n| Array.prototype.find() | Trả về phần tử trong mảng, nếu một phần tử trong mảng hàm kiểm trả hoặc trả về <code>undefined</code> nếu ngược lại |\r\n| Array.prototype.findIndex() | Trả về chỉ mục trong mảng, nếu một phần tử trong mảng thoả mãn hàm kiểm tra hoặc <code>-1</code> nếu ngược lại |\r\n| Array.prototype.entries() | Trả về một lần lặp mảng bao gồm cặp key/value cho từng chỉ mục trong mảng |\r\n| Array.prototype.keys() | Trả về lần lặp mảng mới bao gồm khoá cho từng chỉ mục trong mảng |\r\n| Array.prototype.values() | Trả về đối tượng lặp bao gồm giá trị cho từng chỉ mục trong mảng |\r\n| Array.prototype.fill() | Thay đổi tất cả phần tử với giá trị tĩnh, mặc định bắt đầu từ <code>0</code> và kết thúc ở cuối mảng.</p>",
              "level": "fresher"
            },
            {
              "question": "Tên các hàm chuỗi có trong ES6?",
              "answer": "<p>| Phương thức | Mô tả |\r\n|-------------|-------|\r\n| startsWith | Nó xác định xem một chuỗi có bắt đầu bằng các ký tự của một chuỗi đã cho hay không |\r\n| endsWith | Nó xác định xem một chuỗi có kết thúc bằng các ký tự của một chuỗi đã cho hay không |\r\n| includes | Nó sẽ trả về true nếu đối số có trong chuỗi |\r\n| repeat | Nó tạo và trả về một chuỗi mới chứa số lượng bản sao nhất định của chuỗi mà phương thức này được gọi, được nối với nhau |</p>",
              "level": "fresher"
            },
            {
              "question": "So sánh code ES5 và ES6 cho tạo và tách đối tượng?",
              "answer": "<p><strong>Tạo đối tượng</strong> \r<ul><li>ES5</li></ul>\r\n\r\n``<code>js\r\n// ES5 code\r\nvar\r\n    x = 1, y = 2, z = 3;\r\n    ob = {\r\n        x : a,\r\n        y : b,\r\n        z : z\r\n    };\r\n\r\n// ob.x = 1, ob.y = 2, ob.z = 3\r\n</code>`<code>\r<ul><li>ES6</li></ul>\r\n\r\n</code>`<code>js\r\n// ES6 code\r\nconst\r\n    x = 1, y = 2, z = 3;\r\n    ob = {\r\n        x\r\n        y\r\n        z\r\n    };\r\n\r\n// ob.x = 1, ob.y = 2, ob.z = 3\r\n</code>`<code>\r\n\r\n<strong>Phân tích đối tượng</strong>\r<ul><li>ES5</li></ul>\r\n\r\n</code>`<code>js\r\n// ES5 code\r\nvar\r\n    ob = getObject(),\r\n    a = ob.a,\r\n    b = ob.b,\r\n    c = ob.c;\r\n</code>`<code>\r<ul><li>ES6</li></ul>\r\n\r\n</code>`<code>js\r\n// ES6 code\r\nconst { a , b , c } = getObject();\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hoán vị với Destrucuring Assignment?",
              "answer": "<p>``<code>js\r\nvar a = 1, b = 2;\r\n\r\n[a, b] = [b, a];\r\nconsole.log(a); // 2\r\nconsole.log(b); // 1\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kết quả của toán tử spread ở code bên dưới?",
              "answer": "<p>``<code>js\r\n[...&#39;apple&#39;]\r\n</code>`<code>\r\n\r\nKết quả: [</code>a<code>, </code>p<code>, </code>p<code>, </code>l<code>, </code>e`]\r\n\r\nGiải thích: Một chuỗi là một kiểu có thể lặp, và như mảng toán tử spread chuyển đổi từng ký tự thành một phần tử. Kết quả mỗi ký tự của chuỗi trở thành một phần tử mảng.\r\n\r\n## Câu hỏi phỏng vấn ES6 dành cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Prototype Design Pattern với ES6?",
              "answer": "<p>Prototype Pattern tạo ra các đối tượng mới, nhưng thay vì trả về các đối tượng chưa được khởi tạo, nó trả về các đối tượng có giá trị được sao chép từ một đối tượng prototype - hoặc sample. Nó còn được gọi là Properties Pattern.\r\n\r\nViệc khởi tạo các đối tượng nghiệp vụ với các giá trị phù hợp với cài đặt mặc định của cơ sở dữ liệu là một ví dụ về công dụng của Prototype Pattern. Các giá trị mặc định từ đối tượng prototype được sao chép thành một đối tượng nghiệp vụ mới được tạo.\r\n\r\nMẫu Prototype hiếm khi được sử dụng trong các ngôn ngữ truyền thống, nhưng JavaScript, sử dụng nó trong việc tạo ra các đối tượng và prototype mới.</p>",
              "level": "fresher"
            },
            {
              "question": "WeakMap trong ES6 là gì? Nó khác Map như thế nào?",
              "answer": "<p>WeakMap là một tập hợp các key/value, gần giống như Map. Key của WeakMap phải là đối tượng, trong khi value có thể là bất kỳ thứ gì. Các tham chiếu đối tượng đến key được tổ chức rất yếu, có nghĩa là nếu không có tham chiếu nào khác đến đối tượng, nó sẽ bị bộ dọn rác dọn dẹp. WeakMap, không giống như Map, cho phép bộ gọn rác hoàn thành nhiệm vụ của nó. Mảng key sẽ bảo toàn các tham chiếu đến đối tượng key trong map được xây dựng thủ công, cấm chúng bị dọn dẹp. Các tham chiếu đến đối tượng key trong WeakMap được tổ chức \"yếu\", có nghĩa là chúng không cản trở việc dọn rác nếu không có tham chiếu nào khác đến đối tượng. API Map và API WeakMap là giống nhau.</p>",
              "level": "fresher"
            },
            {
              "question": "Lợi thế của hàm khởi tạo với cú pháp arrow?",
              "answer": "<p>Lợi ích của việc dùng hàm arrow như phương thức trong constructor là giá trị của <strong>this</strong> là tập hợp ở thời điểm hàm tạo và không thể thay đổi trong tương lai. Kết quả, bất cứ khi nào constructor dùng cho tạo đối tượng mới, <strong>this</strong> đề cập đến đối tượng này.\r\n\r\n``<code>js\r\nconst Shape = function(shapeName) {\r\n    this.shapeName = shapeName;\r\n    this.showName1 = function() { console.log(this.shapeName); };\r\n    this.showName2 = () =&gt; { console.log(this.shapeName); };\r\n};\r\n\r\nconst circle = new Shape(&#39;Circle&#39;);\r\nconst square = new Shape(&#39;Square&#39;);\r\n\r\ncircle.showName1(); // Circle\r\ncircle.showName2(); // Square\r\n\r\n// The regular function can have its &#39;this&#39; value changed, but the arrow function cannot\r\ncircle.showName1.call(square); // Square (because &quot;this&quot; is now the square object)\r\ncircle.showName2.call(square); // Circle\r\n\r\ncircle.showName1.apply(square); // Square (because &#39;this&#39; is now the square object)\r\ncircle.showName2.apply(square); // Circle\r\n\r\ncircle.showName1.bind(square)(); // Square (because &#39;this&#39; is now the square object)\r\ncircle.showName2.bind(square)(); // Circle\r\n\r\nvar showNameFromPic1 = circle.showName1;\r\nsayNameFromPic1(); // undefined (because &#39;this&#39; is now the pic object)\r\n\r\nvar showNameFromPic2 = circle.showName2;\r\nshowNameFromPic2(); // Circle\r\n</code>``\r\n\r\nĐiểm chính ở đây là đối với một hàm bình thường, <strong>this</strong> có thể được sửa đổi, nhưng đối với một hàm arrow, ngữ cảnh luôn giống nhau. Bạn sẽ không phải lo lắng về việc thay đổi ngữ cảnh nếu bạn chuyển hàm arrow sang các khu vực khác trong ứng dụng của mình.</p>",
              "level": "fresher"
            },
            {
              "question": "Temporal Dead Zone là gì?",
              "answer": "<p>Variable Hoisting không áp dụng cho phép ràng buộc trong ES6, do đó, cho phép các khai báo không đưa lên đầu ngữ cảnh thực thi hiện tại. Một ReferenceError được ném ra nếu biến trong block được tham chiếu trước khi nó được khởi tạo (không giống như một biến được khai báo bằng var, sẽ chỉ sở hữu giá trị không xác định). Từ đầu block cho đến khi quá trình khởi tạo được thực hiện, biến nằm trong \"Temporal Dead Zone\".\r\n\r\n``<code>js\r\nconsole.log(a); // undefined\r\nconsole.log(b); // causes ReferenceError: aLet is not defined\r\nvar a = 1;\r\nlet b = 2;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Set và WeakSet trong ES6?",
              "answer": "<p><strong>Set:</strong> bằng cách dùng lớp <code>Set()</code>, người dùng có thể định nghĩa một đối tượng có thể lặp lai không đồng nhất giống như mảng. Đối tượng này sẽ bao gồm các giá trị riêng biệt, các phần tử không nên chỉ khác biệt theo giá trị mà còn theo kiểu. tức là \"2\" và 2 sẽ được coi là khác nhau.\r\n\r\n``<code>js\r\nvar set1= new Set([0, 1, 2]);\r\n\r\nset1.add(3); // 0, 1, 2, 3\r\nset1.add(2); // 0, 1, 2, 3\r\nset1.add({x:1, y:2}); // 0, 1, 2, {x:1, y:2}\r\nset1.add(&quot;Good&quot;); // 0, 1, 2, {x:1, y:2}, &#39;Good&#39;\r\n \r\nset1.has(&quot;Hello&quot;); // false\r\nset1.has(&quot;Good&quot;);  // true\r\nset1.delete(&quot;Good&quot;); // &#39;Good&#39; deleted\r\nset1.has(&quot;Good&quot;); // false\r\n \r\nset1.size; // 4\r\nset1.clear(); // Set Cleared\r\n</code>`<code>\r\n\r\n<strong>WeakSet():</strong> là một tập hợp tương tự Set vì nó giữ lại các giá trị duy nhất, nhưng nó chỉ có thể chứa các đối tượng. Nếu một đối tượng trong WeakSet của bạn không còn biến tham chiếu nào khác, nó sẽ tự động bị xóa\r\n\r\n</code>`<code>js\r\nvar weakSet1 = new WeakSet([{x:1}]);\r\nvar ob1 = {o:1};\r\nvar ob2 = {o:2};\r\n\r\nweakSet1.has(ob1); //false\r\nweakSet1.add(ob1); \r\nweakSet1.add(ob2); \r\nweakSet1.has(ob2); // true\r\ndelete ob1; // you can&#39;t delete objects in this way. Use scope to execute this.\r\nmyWeakSet.has(ob1); // false, because you deleted ob1, so WeakSet releases it automatically\r\nmyWeakSet.delete(ob2); // ob2 deleted from the set\r\nmyWeakSet.add(1); // ERROR, no primitive value\r\n</code>`<code>\r\n\r\n| Set | WeakSet |\r\n|-----|---------|\r\n| Bao gồm nhiều kiểu giá trị | Chỉ chứa kiểu đối tượng |\r\n| Dùng </code>.size<code> để tìm số lượng phần tử | Dùng </code>.length<code> để tìm số lượng phần tử |\r\n| </code>.forEach()<code> khả dụng cho vòng lặp | </code>.forEach` không khả dụng cho vòng lặp |\r\n| Không tự huỷ | Một đối tượng phần tử sẽ được bị bộ thu gom rác dọn dẹp nếu nó không còn tham chiếu nào khác |</p>",
              "level": "fresher"
            },
            {
              "question": "Proxy trong ES6 là gì?",
              "answer": "<p>Các đối tượng proxy được sử dụng để tùy chỉnh hành vi cho các hoạt động cơ bản như tra cứu thuộc tính, gán, liệt kê, gọi hàm, ...\r\n\r\nChúng ta cần xác định ba thuật ngữ quan trọng:\r<ul><li><strong>handler</strong> - đối tượng giữ cho cho trap</li></ul>\r<ul><li><strong>trap</strong> - phương thức cho phép bạn truy cập một thuộc tính</li></ul>\r<ul><li><strong>target</strong> - đối tượng được ảo hoá bởi proxy</li></ul>\r\n\r\n``<code>js\r\nconst handle = {\r\n    get: function(ob, prp) {\r\n        return prp in ob ?\r\n        ob[prp] :\r\n        37;\r\n    }\r\n};\r\n\r\nconst x = new Proxy({}, handle);\r\nx.a = 2;\r\nx.b = undefined;\r\n\r\nconsole.log(x.a, x.b); \r\n//  2, undefined\r\n\r\nconsole.log(&#39;c&#39; in x, x.c); \r\n//  false, 37\r\n</code>``\r\n\r\nProxy có rất nhiều ứng dụng trong thế giới thực.\r<ul><li>Xác thực.</li></ul>\r<ul><li>Sửa chữa giá trị.</li></ul>\r<ul><li>Tiện ích mở rộng cho tra cứu thuộc tính.</li></ul>\r<ul><li>Truy cập thuộc tính đang được theo dõi.</li></ul>\r<ul><li>Tham chiếu có thể được gọi.</li></ul>\r<ul><li>Triển khai DOM trong javascript.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa const và Object.freeze()?",
              "answer": "<p>Const là một thuộc tính áp dụng cho các ràng buộc (\"biến\"). Nó tạo ra một ràng buộc bất biến, có nghĩa là bạn không thể thay đổi giá trị của nó.\r\n\r\n``<code>js\r\nconst a = {\r\n    b: &quot;apple&quot;\r\n};\r\n\r\nlet c = {\r\n    d: &quot;mango&quot;\r\n};\r\n\r\na = c; // ERROR &quot;a&quot; is read-only\r\n</code>`<code>\r\n\r\n<strong>Object.freeze()</strong> là một hàm hoạt động với các giá trị, chủ yếu là các giá trị đối tượng. Nó làm cho một đối tượng trở nên bất biến, nghĩa là không thể thay đổi các thuộc tính của nó.\r\n\r\n<strong>freeze()</strong> trả về cùng một đối tượng đã được cung cấp cho nó dưới dạng một tham số. Nó không tạo ra một bản sao freeze. Nếu tham số của phương thức này không phải là một đối tượng (một nguyên thủy) trong ES5, một TypeError sẽ xảy ra. Một đối số không phải đối tượng trong ES6 sẽ được xử lý như thể nó là một đối tượng thông thường được đóng băng và sẽ được trả về.\r\n\r\n</code>`<code>js\r\nlet a = {\r\n    b: &quot;apple&quot;\r\n};\r\nlet c = {\r\n    d: &quot;mango&quot;\r\n};\r\nObject.freeze(a);\r\na.b = &quot;kiwi&quot;; //TypeError: Cannot assign to read only property &#39;name&#39; of object\r\nconsole.log(a);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao đoạn code này không hoạt động như một IIFE? Điều gì cần được sửa đổi để nó được phân loại là IIFE?",
              "answer": "<p>``<code>js\r\nfunction f(){ }();\r\n</code>`<code>\r\n\r\nTrình phân tích cú pháp JavaScript thông dịch hàm </code>f(){}();<code> như hàm </code>f(){}<code> và </code>();<code> trong đó cái trước là khai báo hàm trong khi cái sau (một cặp dấu ngoặc đơn) là nỗ lực thực thi một hàm mà không chỉ định tên, dẫn đến <strong>Uncaught SyntaxError: Unexpected token</strong>\r\n\r\n</code>(function f(){})()<code> và </code>(function f(){}())<code> là hai cách để sửa lỗi liên quan đến việc thêm nhiều dấu ngoặc hơn. Các hàm này không khả dụng trong phạm vi toàn cục và bạn thậm chí có thể bỏ qua tên của chúng nếu bạn không cần tham chiếu đến chúng trong nội dung.\r\n\r\nBạn cũng có thể sử dụng toán tử void: </code>void function f(){}();<code> Tuy nhiên, có một điểm hạn chế trong chiến lược này. Bởi vì đánh giá của một biểu thức nhất định luôn không được xác định, bạn không thể sử dụng hàm IIFE nếu nó trả về bất kỳ thứ gì. Hãy xem xét tình huống sau:\r\n\r\n</code>`<code>js\r\n // Don&#39;t add JS syntax to this code block to prevent Prettier from formatting it.\r\nconst f = void\r\nfunction b() {\r\n    return &#39;f&#39;;\r\n}();\r\n\r\nconsole.log(f); // undefined\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Internationalization và Localization?",
              "answer": "<p>Đây là các API chuẩn JavaScript hỗ trợ các hoạt động như đối chiếu, định dạng số, định dạng tiền tệ và định dạng ngày và giờ.\r\n\r\n<em> <strong>Đối chiếu:</strong> Đây là một phương pháp để tìm kiếm và sắp xếp các chuỗi trong một tập hợp. Nó có một đối số ngôn ngữ và nhận biết được Unicode.\r\n</em> <strong>Định dạng số:</strong> Các dấu phân cách được bản địa hóa và nhóm chữ số có thể được sử dụng để định dạng số. Định dạng kiểu, hệ thống số, phần trăm và độ chính xác nằm trong số các mục khác.\r\n<em> <strong>Định dạng tiền tệ:</strong> Các ký hiệu tiền tệ, dấu phân tách bản địa hóa và nhóm chữ số là những cách phổ biến nhất để định dạng số.\r\n</em> <strong>Định dạng ngày và giờ:</strong> Các dấu phân cách và thứ tự được bản địa hóa được sử dụng để định dạng. Định dạng có thể ngắn hoặc dài và có thể bao gồm các đặc điểm khác như vị trí và múi giờ.</p>",
              "level": "fresher"
            },
            {
              "question": "Webpack là gì?",
              "answer": "<p>Webpack là một công cụ để gói các file javascript để sử dụng trong các trình duyệt. Webpack phân tích ứng dụng và tạo các gói bằng cách tạo một biểu đồ phụ thuộc ánh xạ từng module của dự án được yêu cầu. Nó cho phép bạn thực thi môi trường được host bởi Babel. Webpack có lợi thế là kết hợp nhiều module và gói vào một file JavaScript duy nhất. Nó bao gồm một máy chủ nhà dev, hỗ trợ cập nhật code và quản lý assets.\r\n\r\nVí dụ\r\n\r\nfolder<em>name/index.js\r\n\r\n``<code>js\r\nimport bar from &#39;./func.js&quot;;\r\nfunc();\r\n</code>`<code>\r\n\r\nfolder</em>name/func.js\r\n</code>`<code>js\r\nexport default function func() {\r\n    // body of the function\r\n}\r\n</code>`<code>\r\n\r\nwebpack.config.js\r\n\r\n</code>`<code>js\r\nconst path = require(&#39;path&#39;);\r\n\r\nmodule.exports = {\r\n    entry: &#39;./folder<em>name/index.js&#39;,\r\n    output: {\r\n        path: path.resolve(</em>_dirname, &#39;dict&#39;),\r\n        filename: &#39;bundle.js&#39;,\r\n    },\r\n};\r\n</code>`<code>\r\n\r\npage.html\r\n\r\n</code>`<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n    &lt;head&gt;\r\n        &lt;meta charset=&quot;utf-8&quot; /&gt;\r\n        ...\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n        ...\r\n        &lt;script src=&quot;dict/bundle.js&quot;&gt;&lt;/script&gt;\r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "html",
          "name": "Câu hỏi phỏng vấn HTML",
          "description": "",
          "questions": [
            {
              "question": "Thẻ HTML và phần tử là một?",
              "answer": "<p>Không. Phần tử (element) HTML được xác định bằng cách bắt đầu thẻ, bao gồm tất cả nội dung cho đến khi đóng thẻ. Ví dụ, <code>&lt;h1&gt;Heading&lt;/h1&gt;</code> là một phần tử HTML, còn tag chỉ là <code>&lt;h1&gt;</code> và <code>&lt;/h1&gt;</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Thẻ và thuộc tính trong HTML là gì?",
              "answer": "<p>Thẻ là thành phần quan trọng trong HTML xác định cách nội dung sẽ được định dạng, trong khi thuộc tính đi cùng với thẻ HTML để xác định đặc trưng của phần tử HTML. Ví dụ: <code>&lt;p align=&quot;center&quot;&gt;HTML Question&lt;/p&gt;</code>, thì <code>algin</code> là thuộc tính để xác định đoạn văn bản sẽ hiển thị ở giữa.</p>",
              "level": "fresher"
            },
            {
              "question": "Phần tử void trong HTML là gì?",
              "answer": "<p>Trong HTML sẽ có các phần tử không cần thẻ đóng. Ví dụ: <code>&lt;br /&gt;</code>, <code>&lt;img /&gt;</code>, <code>&lt;hr /&gt;</code>,...</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của khoảng trắng?",
              "answer": "<p>Trong HTML, một chuỗi ký tự khoảng trắng được coi là một ký tự khoảng trắng. Vì trình duyệt thu gọn nhiều khoảng trắng thành một ký tự khoảng trắng duy nhất và điều này giúp dev thụt lề các dòng văn bản mà không phải lo lắng về nhiều khoảng trắng và duy trì tính dễ đọc và dễ hiểu của code HTML.</p>",
              "level": "fresher"
            },
            {
              "question": "HTML Entities là gì?",
              "answer": "<p>Trong HTML một vài ký tự dành riêng như <code>&lt;</code>, <code>&gt;</code>, <code>/</code>,... Để sử dụng các ký tự trong trang web, ta cần dùng các ký tự đặc biệt gọi là HTML entities. Dưới đây là một số ánh xạ giữa ký tự dành riêng và ký tự entities tương ứng sẽ được sử dụng. \r\n\r\n| Character | Entity Name | Entity Number |\r\n|-----------|-------------|---------------|\r\n| <         | <code>&amp;lt;</code>        | <code>&amp;#60;</code>         |\r\n| >         | <code>&amp;gt;</code>        | <code>&amp;#62;</code>         |\r\n| &         | <code>&amp;amp;</code>        | <code>&amp;#38;</code>         |</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu danh sách trong HTML?",
              "answer": "<p><img src=\"/interview-assets/Image_List.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính `class` trong HTML là gì?",
              "answer": "<p>Thuộc tính class được sử dụng để chỉ định tên lớp cho một phần tử HTML. Nhiều phần tử trong HTML có thể có cùng giá trị lớp. Ngoài ra, nó chủ yếu được sử dụng để liên kết các style được viết trong CSS.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác nhau của thuộc tính `id` và `class` trong phần tử HTML?",
              "answer": "<p>Nhiều phần tử trong HTML có thể có cùng giá trị lớp, trong khi giá trị thuộc tính id của một phần tử này không thể được liên kết với phần tử HTML khác.</p>",
              "level": "fresher"
            },
            {
              "question": "multipart/form-data là gì?",
              "answer": "<p><code>multipart/form-data</code> là một trong những giá trị của thuộc tính <code>enctype</code>. Nó được sử dụng để gửi dữ liệu file cho phía server xử lý. Các giá trị hợp lệ khác của thuộc tính <code>enctype</code> là <code>text/plain</code> and <code>application/x-www-form-urlencoded</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả cấu trúc của HTML",
              "answer": "<p>Mỗi trang web đều có các thành phần khác nhau để hiển thị nội dung dự định và một giao diện người dùng cụ thể. Tuy nhiên, có một số kiểu mẫu được chấp nhận trên toàn cầu để cấu trúc trang web, chẳng hạn như:\r<ul><li><strong><code>&lt;header&gt;</code></strong>: Lưu trữ thông tin bắt đầu về trang web.</li></ul>\r<ul><li><strong><code>&lt;footer&gt;</code></strong>: Biểu diễn phần cuối cùng của trang.</li></ul>\r<ul><li><strong><code>&lt;nav&gt;</code></strong>: Menu điều hướng của trang HTML.</li></ul>\r<ul><li><strong><code>&lt;article&gt;</code></strong>: Nó là một tập hợp thông tin.</li></ul>\r<ul><li><strong><code>&lt;section&gt;</code></strong>: Nó được sử dụng bên trong <code>article</code> để xác định cấu trúc cơ bản của một trang.</li></ul>\r<ul><li><strong><code>&lt;aside&gt;</code></strong>: Nội dung menu dọc của trang.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách để tối ưu tải tài nguyên website?",
              "answer": "<p>Để tối ưu thời gian tải web ta cần tối ưu việc tải các tài nguyên:\r<ul><li><strong>CDN hosting</strong> - CDN hoặc mạng phân phối nội dung là các server được phân phối theo địa lý để giúp giảm độ trễ.</li></ul>\r<ul><li><strong>File compression</strong> - Đây là một phương pháp giúp giảm kích thước của nội dung để giảm việc truyền dữ liệu.</li></ul>\r<ul><li><strong>File concatenation</strong> - làm giảm số lượng cuộc gọi HTTP.</li></ul>\r<ul><li><strong>Minify scripts</strong> - làm giảm kích thước tổng thể của file js và CSS</li></ul>\r<ul><li><strong>Parallel downloads</strong> - Lưu trữ nội dung trong nhiều miền phụ để vượt qua giới hạn tải xuống là 6 nội dung trên mỗi miền của tất cả các trình duyệt hiện nay. Điều này có thể được cấu hình nhưng hầu hết người dùng thông thường không bao giờ sửa đổi các cài đặt này.</li></ul>\r<ul><li><strong>Lazy Loading</strong> - Thay vì tải tất cả các nội dung cùng một lúc, các nội dung không quan trọng chỉ được tải trên khi cần thiết.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Thẻ định dạng khác nhau trong HTML",
              "answer": "<p>HTML có các thẻ định dạng khác nhau:\r\n\r\n<em> <code>&lt;b&gt;</code> - in đậm văn bản\r\n</em> <code>&lt;i&gt;</code> - in nghiêng văn bản\r\n<em> <code>&lt;em&gt;</code> - làm cho văn bản nghiêng nhưng có thêm tầm quan trọng về ngữ nghĩa\r\n</em> <code>&lt;big&gt;</code> - tăng kích cỡ chữ lên một đơn vị \r\n<em> <code>&lt;small&gt;</code>- giảm kích cỡ chữ lên một đơn vị \r\n</em> <code>&lt;sub&gt;</code> - biến văn bản thành chỉ số dưới\r\n<em> <code>&lt;sup&gt;</code> - biến văn bản thành chỉ số trên\r\n</em> <code>&lt;del&gt;</code> - hiển thị dưới dạng văn bản gạch bỏ\r\n<em> <code>&lt;strong&gt;</code> - đánh dấu văn bản là quan trọng\r\n</em> <code>&lt;mark&gt;</code> - highlights văn bản\r<ul><li><code>&lt;ins&gt;</code> - hiển thị dưới dạng văn bản đã thêm</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thể loại Doctypes khả dụng",
              "answer": "<p>Có ba thể loại Doctypes khả dung:\r<ul><li>Strict Doctype </li></ul>\r<ul><li>Transitional Doctype</li></ul>\r<ul><li>Frameset Doctype</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hãy giải thích cách hiển thị tập ký tự đang được sử dụng trong HTML?",
              "answer": "<p>Tập ký tự được xác định bởi thẻ <code>&lt;meta&gt;</code> trong phần tử <code>&lt;head&gt;</code>\r\n\r\n``<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n    &lt;head&gt;\r\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\r\n        ...\r\n        ...\r\n    &lt;/head&gt;\r\n    ...\r\n&lt;/html&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác nhau giữa thẻ `<strong>` và `<b>`, thẻ `<em>` và `<i>`?",
              "answer": "<p>Hiệu ứng trên trang web bình thường của các thẻ <code>&lt;strong&gt;</code>, <code>&lt;b&gt;</code> và <code>&lt;em&gt;</code>, <code>&lt;i&gt;</code> là như nhau. Thẻ <code>&lt;b&gt;</code> và <code>&lt;i&gt;</code> là viết tắt của chữ in đậm và chữ nghiêng. Hai thẻ này chỉ áp dụng font chữ và thẻ in đậm <code>&lt;b&gt;</code>, chỉ thêm mực vào chữ, các thẻ này không nói lên điều gì về văn bản.\r\n\r\nTrong khi đó, các thẻ <code>&lt;strong&gt;</code> và <code>&lt;em&gt;</code> thể hiện rằng đoạn văn bản có tầm quan trọng cao và nhấn mạnh hơn so với phần còn lại của văn bản. Các thẻ này có ý nghĩa ngữ nghĩa.</p>",
              "level": "fresher"
            },
            {
              "question": "Đặc trưng của thẻ `<head>` và `<body>` trong HTML?",
              "answer": "<p>Thẻ <code>&lt;head&gt;</code> cung cấp thông tin về tài liệu. Nó phải luôn được đặt trong thẻ <code>&lt;html&gt;</code>. Thẻ này chứa siêu dữ liệu (metadata) về trang web và các thẻ nằm trong thẻ head như<code> &lt;link&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;script&gt;</code> v.v. không được hiển thị trên trang web. Ngoài ra, chỉ có thể có 1 thẻ <code>&lt;head&gt;</code> trong toàn bộ tài liệu html và sẽ luôn ở trước thẻ <code>&lt;body&gt;</code>.\r\n\r\nThẻ <code>&lt;body&gt;</code> xác định phần nội dung của tài liệu HTML. Nó phải luôn được đặt trong thẻ <code>&lt;html&gt;</code>. Tất cả nội dung cần được hiển thị trên trang web như hình ảnh, văn bản, âm thanh, video, nội dung, sử dụng các phần tử như <code>&lt;p&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;audio&gt;</code>, <code>&lt;heading&gt;</code>, <code>&lt;video&gt;</code>, <code>&lt;div&gt;</code>, v.v ... sẽ luôn nằm trong thẻ <code>&lt;body&gt;</code>. Ngoài ra, chỉ có 1 phần tử body trong tài liệu HTML và sẽ luôn ở sau thẻ <code>&lt;head&gt;</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Chúng ta có thể hiển thị một trang bên trong một trang web hoặc lồng các trang web vào nhau có được không?",
              "answer": "<p>Có, chúng tôi có thể hiển thị một trang web bên trong một trang web HTML khác. HTML cung cấp thẻ <code>&lt;iframe&gt;</code> để có thể thực hiện chức năng này.\r\n\r\n``<code>html\r\n&lt;iframe src=&quot;url of the web page to embed&quot; /&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cell Padding khác với Cell Spacing như thế nào?",
              "answer": "<p>Cell Spacing là khoảng trống giữa hai ô liên tiếp. Trong khi, Cell Padding là khoảng trống giữa văn bản/nội dung của ô và cạnh/đường viền của ô. Xem hình bên dưới.\r\n\r\n<img src=\"/interview-assets/cell-padding-vs-cell-spacing.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào chúng ta có thể ghép hai hoặc nhiều hàng hoặc nhiều cột thành một hàng hoặc cột duy nhất trong một bảng HTML?",
              "answer": "<p>HTML cung cấp hai thuộc tính cho bảng là <code>rowspan</code> và <code>colspan</code> để tạo một ô kéo dài tới nhiều hàng và cột tương ứng.</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể thay đổi một phần tử inline thành một phần tử block không?",
              "answer": "<p>Có, có thể sử dụng thuộc tính <code>display</code> với giá trị của nó là <code>block</code>, để thay đổi phần tử inline thành phần tử block.</p>",
              "level": "fresher"
            },
            {
              "question": "Chúng ta có thể định vị một phần tử HTML bằng bao nhiêu cách?",
              "answer": "<p>Có 6 giá trị thuộc tính có thể dùng cho định vị phần tử HTML\r<ul><li><strong>static</strong>: phần tử sẽ xuất hiện ở vị trí mặc định dựa theo thứ tự khai báo, ta không thể sử dụng các thuộc tính <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> để thiết lập lại vị trí cho phần tử.</li></ul>\r<ul><li><strong>absolute</strong>: dùng để thiết lập vị trí cho một phần tử dựa theo vị trí của phần tử cha nằm gần với nó nhất, nếu không có phần tử cha nào được thiết lập thuộc tính <code>position</code> với một trong ba giá trị (relative, fixed, absolute) thì vị trí của phần tử sẽ được xác định dựa theo khung trang web.</li></ul>\r<ul><li><strong>fixed</strong>: dùng để thiết lập phần tử nằm tại một vị trí cố định trên màn hình trình duyệt mặc cho người dùng có scroll trang lên xuống hay trái phải.</li></ul>\r<ul><li><strong>relative</strong>: cũng gần giống với phương thức định vị static, đó chính là phần tử sẽ xuất hiện ở vị trí mặc định dựa theo thứ tự khai báo. Tuy nhiên, đối với phương thức định vị relative thì chúng ta có thể sử dụng các thuộc tính top, right, bottom, left để thiết lập lại vị trí cho phần tử.</li></ul>\r<ul><li><strong>initial</strong>: Reset giá trị thuộc tính về giá trị mặc định.</li></ul>\r<ul><li><strong>inherit</strong>: Kế thừa giá trị từ phần tử cha.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Có bao nhiêu cách để hiển thị phần tử HTML?",
              "answer": "<p>1. <strong>inline</strong>: ta có thể hiển thị bất kỳ phần tử dạng block nào thành dạng inline. Giá trị thuộc tính <code>height</code> và <code>width</code> sẽ không ảnh hưởng.\r\n2. <strong>block</strong>: ta có thể hiển thị bất kỳ phần tử dạng inline nào thành dạng block.\r\n3. <strong>inline-block</strong>: Thuộc tính này tương tự như inline, ngoại trừ việc hiển thị dưới dạng inline-block, chúng ta có thể định dạng phần tử bằng cách sử dụng các giá trị <code>height</code> và <code>width</code>.\r\n4. <strong>flex</strong>: hiển thị phần tử container một cách linh hoạt. Nó theo sau thuộc tính <code>flexbox</code>.\r\n5. <strong>inline-flex</strong>: hiển thị container như một phần tử inline trong khi nội dung của nó vẫn tuân theo thuộc tính <code>flexbox</code>.\r\n6. <strong>grid</strong>: hiển thị nội dung phần tử như một grid container.\r\n7. <strong>none</strong>: Using this property we can hide the HTML element.\r\n\r\nMột vài kiểu hiển thị khác nhưng ít khi dùng là:\r\n\r\n<em> table\r\n</em> inline-table\r\n<em> table-cell\r\n</em> table-column\r\n<em> table-row\r\n</em> inline-grid\r\n<em> list-item\r\n</em> inherit\r\n<em> initial\r\n</em> table-caption</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa `dislay: none` và `visibility: hidden`?",
              "answer": "<p>Khi sử dụng thuộc tính <code>visibility: hidden</code> cho một phần tử HTML thì phần tử đó sẽ bị ẩn khỏi trang web nhưng vẫn chiếm không gian. Trong khi đó, nếu sử dụng thuộc tính <code>display: none</code> cho một phần tử HTML thì phần tử đó sẽ bị ẩn và không chiếm bất kỳ không gian nào trên trang web.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm sao để chỉ định liên kết trong HTML và giải thích thuộc tính `target`?",
              "answer": "<p>HTML cung cấp thẻ <code>&lt;a&gt;</code> để chỉ định liên kết trên web. Thuộc tính <code>href</code> được dùng để chỉ định liên kết và thuộc tính <code>target</code> được dùng để chỉ định cách mở liên kết. Thuộc tính <code>target</code> có các giá trị sau:\r\n\r\n<em> <strong><em>self</strong>: là giá trị mặc định. Mở liên kết cùng tab hay cửa sổ với trang web.\r\n</em> <strong></em>blank</strong>: mở ở tab mới.\r\n<em> <strong><em>parent</strong>: mở ở frame cha.\r\n</em> <strong></em>top</strong>: mở ở toàn cửa sổ.</p>",
              "level": "fresher"
            },
            {
              "question": "Có bao nhiêu cách để dùng CSS cùng với HTML?",
              "answer": "<p>Có 3 cách là:\r<ul><li><strong>Inline:</strong> sử dụng thuộc tính <code>style</code> trong phần tử HTML.</li></ul>\r<ul><li><strong>Internal:</strong> sử dụng thẻ <code>&lt;style&gt;</code> trong thẻ <code>&lt;head&gt;</code>. </li></ul>\r<ul><li><strong>External:</strong> sử dụng thẻ <code>&lt;link&gt;</code> trong thẻ <code>&lt;head&gt;</code> để liên kết đến file CSS vào code HTML. </li></ul>\r\n\r\n<img src=\"/interview-assets/css-styles-for-html5-element.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa thẻ `<link>` và thẻ `<a>`?",
              "answer": "<p>Thẻ <code>&lt;a&gt;</code> được dùng để mở liên kết đến trang web khác hay một phần nào đó ở web hiện tại nên nó có thể click vào. Trong khi thẻ <code>&lt;link&gt;</code> xác định một liên kết đến một nguồn tài nguyên bên ngoài, nó không thể click.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách để thêm code javascript vào HTML?",
              "answer": "<p>HTML cung cấp thẻ <code>&lt;script&gt;</code> để chạy code javascript cho trang web thêm sinh động.\r\n\r\n``<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n    &lt;body&gt;\r\n        &lt;h1&gt;\r\n            &lt;span&gt;This is a demo for &lt;/span&gt;\r\n            &lt;u&gt;&lt;span id=&quot;demo&quot;&gt;&lt;/span&gt;&lt;/u&gt;\r\n        &lt;/h1&gt;\r\n    &lt;script&gt;\r\n        document.getElementById(&quot;demo&quot;).innerHTML = &quot;script Tag&quot;\r\n    &lt;/script&gt;\r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thẻ script dùng ở head hay body?",
              "answer": "<p>Nếu các script chứa các hàm event-trigger hoặc thư viện jquery thì nên đặt ở head. Nếu script viết nội dung hoặc không nằm trong hàm thì nên đặt ở cuối body. Nói tóm lại có 3 điểm cần nhớ sau:\r<ul><li>Đặt thư viện hoặc sự kiện script ở head.</li></ul>\r<ul><li>Đặt script thông thường ở head cho đến khi có vấn đề gì đó về hiệu suất.</li></ul>\r<ul><li>Đặt script hiển thị nội dung ở cuối body.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Form là gì và cách tạo form trong HTML?",
              "answer": "<p>Form được dùng cho người dùng nhập thông tin. HTML cung cấp thẻ <code>&lt;form&gt;</code> cho tạo form. Để lấy thông tin từ người dùng ta có thể dùng thẻ <code>&lt;input&gt;</code> trong form để lưu lại dữ liệu người dùng và gửi về server xử lý. Thẻ input hỗ trợ các kiểu khác nhau như button, checkbox, number, text, password,...\r\n\r\n``<code>html\r\n&lt;form action=&quot;/submit<em>data.php&quot;&gt;\r\n   &lt;label&gt;Enter your name: &lt;/label&gt;\r\n   &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; \r\n   &lt;label&gt;Enter Mobile number &lt;/label&gt;\r\n   &lt;input type=&quot;number&quot; name=&quot;mobile</em>no&quot;/&gt;\r\n   &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\r\n&lt;/form&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Xử lý sự kiện trong HTML?",
              "answer": "<p>HTML cho phép thực hiện kích hoạt sự kiện trong trình duyệt sử dụng javascript hoặc JQuery. Có rất nhiều sự kiện như <code>onClick</code>, <code>onDrag</code>, <code>onChange</code>, v.v. \r\n\r\n``<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n    &lt;body style=&quot;padding-top:50px&quot;&gt;\r\n        &lt;h3 id=&quot;event<em>demo&quot;&gt;0&lt;/h3&gt;\r\n        &lt;input type=&quot;button&quot; onclick=&quot;myFunction()&quot; value=&quot;Click Me&quot; /&gt;\r\n        &lt;input type=&quot;reset&quot; onclick=&quot;reset()&quot; value=&quot;Reset&quot; /&gt;\r\n    &lt;/body&gt;\r\n    \r\n    &lt;script&gt;\r\n        function myFunction() {\r\n            var value = document.getElementById(&quot;event</em>demo&quot;).innerHTML\r\n            value = parseInt(value) + 1;\r\n            document.getElementById(&quot;event<em>demo&quot;).innerHTML = value;\r\n        }\r\n        function reset() {\r\n            document.getElementById(&quot;event</em>demo&quot;).innerHTML = 0;\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các ưu điểm của HTML5 so với các phiên bản trước?",
              "answer": "<p><ul><li>Hỗ trợ đa phương tiện.</li></ul>\r<ul><li>Nó có khả năng lưu trữ dữ liệu ngoại tuyến bằng cách sử dụng cơ sở dữ liệu SQL và bộ đệm ứng dụng.</li></ul>\r<ul><li>Javascript có thể được chạy ở chế độ nền.</li></ul>\r<ul><li>HTML5 cũng cho phép người dùng vẽ nhiều hình dạng khác nhau như hình chữ nhật, hình tròn, hình tam giác, v.v.</li></ul>\r<ul><li>Bao gồm các thẻ Sematic mới và các thẻ điều khiển biểu form.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách để thêm nhạc và video vào web?",
              "answer": "<p>HTML5 cung cấp hai thẻ là <code>&lt;audio&gt;</code> và <code>&lt;video&gt;</code> để ta thêm nhạc và video trực tiếp vào web.</p>",
              "level": "fresher"
            },
            {
              "question": "Phần tử inline và block trong HTML5?",
              "answer": "<p>| Inline | Block |\r\n|--------|-------|\r\n| Các phần tử inline chỉ chiếm không gian cần thiết cho nội dung và không bắt đầu một dòng mới | Các phần tử block bắt đầu trên một dòng mới và chiếm toàn bộ chiều rộng của trang có sẵn |\r\n| <code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;em&gt;</code>, <code>&lt;select&gt;</code>, <code>&lt;abbr&gt;</code>, <code>&lt;label&gt;</code>, <code>&lt;sub&gt;</code>, <code>&lt;cite&gt;</code>, <code>&lt;abbr&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;label&gt;</code>, <code>&lt;i&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;output&gt;</code>, <code>&lt;q&gt;,</code> ... | <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;h1&gt;</code>...<code>&lt;h6&gt;</code>, <code>&lt;form&gt;</code>, <code>&lt;table&gt;</code>, <code>&lt;canvas&gt;</code>, <code>&lt;video&gt;</code>, <code>&lt;blockquote&gt;</code>, <code>&lt;pre&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;figcaption&gt;</code>, <code>&lt;figure&gt;</code>, <code>&lt;hr&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code> ... |\r\n\r\n<img src=\"/interview-assets/Inline_and_block_elements_in_HTML5.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa thẻ img và thẻ figure?",
              "answer": "<p>Thẻ <code>&lt;figure&gt;</code> chỉ định nội dung như ảnh, sơ đồ, code snippets,... Thẻ <code>&lt;figure&gt;</code> được dùng để tổ chức các nội dung như ảnh, tiêu đề ảnh trong khi thẻ <code>&lt;img&gt;</code> dùng để nhúng một ảnh vào tài liệu HTML5.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để chỉ định metadata trong HTML5?",
              "answer": "<p>Để chỉ định, ta có thể sử dụng thẻ <code>&lt;meta&gt;</code> (là một thẻ void, tức là nó không có thẻ đóng). Một số thuộc tính được sử dụng với thẻ meta là name, content, http-equiv, v.v. Hình ảnh dưới đây cho biết cách chỉ định metadata.\r\n\r\n<img src=\"/interview-assets/How_to_specify_the_metadata_in_HTML5.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Thẻ `<datalist>` và thẻ `<select>` là giống nhau?",
              "answer": "<p>Không. Thẻ <code>&lt;datalist&gt;</code> và thẻ <code>&lt;select&gt;</code> là khác nhau. Trong thẻ <code>&lt;select&gt;</code>, người dùng sẽ chọn từ một danh sách tuỳ chọn (options), trong khi <code>&lt;datalist&gt;</code> được sử dụng để cung cấp chức năng \"autocomplete\" cho các phần tử <code>&lt;input&gt;</code>, người dùng sẽ thấy một danh sách thả xuống các tùy chọn trước khi họ nhập dữ liệu.\r\n\r\n<img src=\"/interview-assets/is-datalist-and-select-tag-same.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Image Map là gì?",
              "answer": "<p>Bản đồ ảnh (image map) có thể tạm hiểu là một loại hình ảnh đặc biệt, trên tấm hình sẽ có các vùng được xác định, mỗi vùng đó được gán với một cái liên kết.\r\n\r\n``<code>html\r\n&lt;img  src=”image_url” ,  usemap=”#workspace” /&gt;\r\n&lt;map  name=”workspace”&gt;\r\n    &lt;area shape=”rect”  coords=”34, 44, 270, 350” ,  href=”xyz.html” /&gt;\r\n    &lt;area shape=”rect”  coords=”10, 120, 250, 360” ,  href=”xyz.html” /&gt;\r\n&lt;/map&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Phần tử Sematic là gì?",
              "answer": "<p>Phần tử semantic mô tả ý nghĩa cụ thể đối với trình duyệt và nhà phát triển. Các phần tử như <code>&lt;form&gt;</code>, <code>&lt;table&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;figure&gt;</code>, ... là phần tử semantic.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa thẻ `<meter>` và thẻ `<process>`?",
              "answer": "<p>Thẻ <code>&lt;progress&gt;</code> được sử dụng khi ta muốn hiển thị tiến độ hoàn thành của một nhiệm vụ, trong khi thẻ <code>&lt;meter&gt;</code> xác định một phép đo vô hướng trong một phạm vi biết trước hoặc một giá trị phân số.</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể kéo và thả trong HTML5 không?",
              "answer": "<p>Có, trong HTML5, chúng ta có thể kéo và thả một phần tử. Điều này có thể thực hiện bằng cách sử dụng các sự kiện liên quan đến kéo và thả được sử dụng với phần tử mà chúng ta muốn kéo và thả.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa phần tử SVG và Canvas trong HTML5?",
              "answer": "<p>| SVG | Canvas |\r\n|-----|--------|\r\n| SVG là dựa trên vector, để tạo hình dạng | Dựa trên Raster, tức là bao gồm pixel |\r\n| Hoạt động tốt hơn với surface lớn | Hoạt động tốt hơn với surface nhỏ |\r\n| Có thể chỉnh sửa với script và css | Chỉ có thể chỉnh sửa với script |\r\n| Khả năng mở rộng cao. Có thể in ở độ phân giải cao. | Khả năng mở rộng thấp |</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu file audio có thể dùng trong HTML5?",
              "answer": "<p>HTML5 hỗ trợ các định dạng audio như sau:\r\n1. Mp3\r\n2. Wav\r\n3. Ogg</p>",
              "level": "fresher"
            },
            {
              "question": "Thông số kỹ thuật trong HTML5 là gì?",
              "answer": "<p>Thông số kỹ thuật trong HTML5 nhằm mục đích là:\r<ul><li>Giới thiệu thẻ phần tử mới để cấu trúc trang tốt hơn.</li></ul>\r<ul><li>Hình thành một tiêu chuẩn hành vi trên nhiều trình duyệt và hỗ trợ cho các thiết bị và nền tảng khác nhau.</li></ul>\r<ul><li>Tương thích ngược với các trang web HTML phiên bản cũ hơn.</li></ul>\r<ul><li>Giới thiệu các phần tử tương tác cơ bản mà không phụ thuộc vào các plugin, chẳng hạn như thẻ <code>&lt;video&gt;</code> thay vì plugin flash.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các khái niệm về web storage trong HTML5?",
              "answer": "<p>Web storage này giúp lưu trữ một số dữ liệu tĩnh trong bộ local storage của trình duyệt để hạn chế việc tìm nạp dữ liệu từ máy chủ quá thường xuyên. Có giới hạn kích thước dựa trên các trình duyệt khác nhau. Điều này giúp giảm thời gian tải và trải nghiệm người dùng mượt mà. Có hai loại web storage được sử dụng để lưu trữ dữ liệu cục bộ trong HTML5:\r\n<em> <strong>Local Storage</strong> - giúp dữ liệu được lưu trữ ngay cả khi người dùng đóng trình duyệt. Nó được lưu trữ cho từng ứng dựng web trên các trình duyệt khác nhau.\r\n</em> <strong>Session Storage</strong> - chỉ lưu trữ trong phiên làm việc. Nếu người dùng đóng trình duyệt nó sẽ bị xoá.</p>",
              "level": "fresher"
            },
            {
              "question": "Microdata là gì?",
              "answer": "<p>Microdata là một phương thức đơn giản để phân loại các nội dung trong website. Microdata hiểu một cách đơn giản là để thêm dữ liệu có cấu trúc vào website. Microdata nó định nghĩa thuộc tính, có thể đặt vào trong HTML để cho biết trang web đó viết về mục đích gì.\r\n\r\n``<code>html\r\n&lt;div itemscope itemtype=&quot;http://schema.org/SoftwareApplication&quot;&gt;\r\n    &lt;span itemprop=&quot;name&quot;&gt;Interviewbit Games&lt;/span&gt; -\r\n    REQUIRES &lt;span itemprop=&quot;operatingSystem&quot;&gt;ANDROID&lt;/span&gt;&lt;br&gt;\r\n    &lt;link itemprop=&quot;applicationCategory&quot; href=&quot;http://schema.org/GameApplication&quot;/&gt;\r\n    &lt;div itemprop=&quot;aggregateRating&quot; itemscope itemtype=&quot;http://schema.org/AggregateRating&quot;&gt;\r\n        RATING:\r\n        &lt;span itemprop=&quot;ratingValue&quot;&gt;4.6&lt;/span&gt; (\r\n        &lt;span itemprop=&quot;ratingCount&quot;&gt;8864&lt;/span&gt; ratings )\r\n    &lt;/div&gt;\r\n    &lt;div itemprop=&quot;offers&quot; itemscope itemtype=&quot;http://schema.org/Offer&quot;&gt;\r\n    Price: Rs.&lt;span itemprop=&quot;price&quot;&gt;1.00&lt;/span&gt;\r\n        &lt;meta itemprop=&quot;priceCurrency&quot; content=&quot;INR&quot; /&gt;\r\n    &lt;/div&gt;\r\n&lt;/div&gt;\r\n</code>``\r\n\r\n<em> <strong>itemid</strong> – Thuộc tính này là bộ nhận diện global cho item\r\n</em> <strong>itemprop</strong> – Thuộc tính này định nghĩa một thuộc tính của item\r\n<em> <strong>itemref</strong> – Thuộc tính này cung cấp một danh sách các phần tử bổ sung để tìm các cặp tên-giá trị của item.\r\n</em> <strong>itemscope</strong> – Được sử dụng để tạo một item. Thuộc tính này là một thuộc tính logic mà nói rằng có Microdata trên trang này, và đây là nơi nó bắt đầu.\r<ul><li><strong>itemtype</strong> – Thuộc tính này là một URL hợp lệ mà định nghĩa item và cung cấp ngữ cảnh cho các thuộc tính.</li></ul>\r\n\r\nVí dụ về microdata bởi Google:\r\n\r\n<img src=\"/interview-assets/Microdata_in_HTML5.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Thẻ nào được dùng để biểu diễn kết quả tính toán?",
              "answer": "<p>Thẻ <code>&lt;output&gt;</code> được dùng để biểu diễn kết quả tính toán. Nó có các thuộc tính sau:\r<ul><li><strong>for</strong> - Nó xác định mối quan hệ giữa các phần tử được sử dụng trong tính toán và kết quả.</li></ul>\r<ul><li><strong>form</strong> - được sử dụng để xác định hình thức mà phần tử đầu ra thuộc về.</li></ul>\r<ul><li><strong>name</strong> - Tên của phần tử output</li></ul>\r\n\r\n``<code>html\r\n&lt;form oninput = &quot;result.value=parseInt(n1.value)+parseInt(n2.value)&quot;&gt;\r\n    &lt;input type = &quot;number&quot; name = &quot;n1&quot; value = &quot;1&quot; /&gt; +\r\n    &lt;input type = &quot;number&quot; name = &quot;n2&quot; value = &quot;2&quot; /&gt;&lt;br /&gt;\r\n    The output is: &lt;output name = &quot;result&quot;&gt;&lt;/output&gt;\r\n&lt;/form&gt;\r\n</code>``\r\n\r\nKết quả trông như:\r\n\r\n<img src=\"/interview-assets/html-output-tag.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Mối quan hệ giữa thẻ `<h1>` và `<header>` trong HTML5?",
              "answer": "<p>Trong HTML5 thẻ <code>&lt;header&gt;</code> chỉ định phần tiêu đề của trang web. Không giống như các phiên bản trước có một phần tử <code>&lt;h1&gt;</code> cho toàn bộ trang web, bây giờ đây chỉ có header cho một phần như <code>&lt;article&gt;</code> hoặc <code>&lt;section&gt;</code>. Theo đặc tả HTML5, mỗi phần tử <code>&lt;header&gt;</code> phải có ít nhất một thẻ <code>&lt;h1&gt;</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về đồ hoạ trong HTML5?",
              "answer": "<p>HTML 5 hỗ trợ hai loại đồ hoạ:\r<ul><li><strong>Canvas:</strong> Nó giống như vẽ trên một tờ giấy trắng hoặc một trang web trống. Ta có thể thêm các thiết kế đồ họa khác nhau trên các trang web với các phương pháp có sẵn để vẽ các hình dạng hình học khác nhau.</li></ul>\r\n\r\n``<code>html\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n    &lt;head&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n        &lt;canvas width=&quot;300&quot; height=&quot;100&quot; style=&quot;border:2px solid;&quot;&gt;&lt;/canvas&gt;  \r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>`<code>\r<ul><li><strong>SVG:</strong> Scalable Vector Graphics được sử dụng hầu hết cho các sơ đồ hoặc biểu tượng. Nó tuân theo định dạng XML.</li></ul>\r\n\r\n</code>`<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n    &lt;body&gt;\r\n    &lt;svg width=&quot;400&quot; height=&quot;110&quot;&gt;\r\n        &lt;rect width=&quot;300&quot; height=&quot;100&quot; style=&quot;fill:#FFF;stroke-width:2;stroke:#000&quot; /&gt;\r\n    &lt;/svg&gt;\r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``\r\n\r\nCả hai ví dụ trên đều tạo output này, chúng là hai cách tiếp cận khác nhau do HTML5 cung cấp để triển khai đồ hoạ trên trang web.\r\n\r\n<img src=\"/interview-assets/Explain_HTML5_Graphics.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu input mới trong HTML5 trong form?",
              "answer": "<p><ul><li>Date - Chọn ngày bằng cách dùng <code>type=&quot;date&quot;</code></li></ul>\r<ul><li>Week - Chọn tuần bằng cách dùng <code>type=&quot;week&quot;</code></li></ul>\r<ul><li>Time - Chọn thời gian bằng cách dùng <code>type=&quot;time&quot;</code></li></ul>\r<ul><li>Month - Chọn tháng bằng cách dùng <code>type=&quot;month&quot;</code></li></ul>\r<ul><li>Datetime - Kết hợp ngày và thời gian dùng <code>type=&quot;datetime&quot;</code></li></ul>\r<ul><li>Datetime-local - Kết hợp ngày và thời gian và chặn timezone,dùng <code>type=&quot;datetime&quot;</code></li></ul>\r<ul><li>Color - Chấp nhận nhiều màu dùng <code>type=&quot;color&quot;</code></li></ul>\r<ul><li>Email - Chấp nhận một hay nhiều email dùng <code>type=&quot;email&quot;</code> </li></ul>\r<ul><li>Number - Chấp nhận một giá trị số với các kiểm tra bổ sung như min và max, sử dụng <code>type=&quot;number&quot;</code></li></ul>\r<ul><li>Search - Cho phép truy vấn tìm kiếm văn bản dùng <code>type=&quot;search&quot;</code></li></ul>\r<ul><li>Tel - Cho phép các số điện thoại khác nhau dùng <code>type=&quot;tel&quot;</code></li></ul>\r<ul><li>Placeholder - Để hiển thị một gợi ý ngắn trước khi nhập giá trị bằng cách sử dụng <code>type=&quot;placeholder&quot;</code></li></ul>\r<ul><li>Range - Chấp nhận giá trị số trong một phạm vi cụ thể dùng <code>type=&quot;range&quot;</code></li></ul>\r<ul><li>Url - Chập nhận địa chỉ trang web dùng <code>type=&quot;url&quot;</code></li></ul>\r\n\r\n``<code>html\r\n&lt;form&gt;  \r\n    &lt;div&gt;\r\n        &lt;label&gt;Date:&lt;/label&gt;\r\n        &lt;input type=&quot;date&quot; id=&quot;date&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Week:&lt;/label&gt;\r\n        &lt;input type=&quot;week&quot; id=&quot;week&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Month:&lt;/label&gt;\r\n        &lt;input type=&quot;month&quot; id=&quot;month&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Time:&lt;/label&gt;\r\n        &lt;input type=&quot;time&quot; id=&quot;time&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Datetime:&lt;/label&gt;\r\n        &lt;input type=&quot;datetime&quot; id=&quot;datetime&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Datetime Local:&lt;/label&gt;\r\n        &lt;input type=&quot;datetime-local&quot; id=&quot;datetime-local&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Color:&lt;/label&gt;\r\n        &lt;input type=&quot;color&quot; id=&quot;color&quot;/&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Email:&lt;/label&gt;\r\n        &lt;input type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;email address&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Number:&lt;/label&gt;\r\n        &lt;input type=&quot;number&quot; id=&quot;number&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Search:&lt;/label&gt;\r\n        &lt;input type=&quot;search&quot; id=&quot;search&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Phone:&lt;/label&gt;\r\n        &lt;input type=&quot;tel&quot; id=&quot;phone&quot; placeholder=&quot;Phone Number&quot; pattern=&quot;\\d{10}$&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;Range:&lt;/label&gt;\r\n        &lt;input type=&quot;range&quot; id=&quot;range&quot; /&gt;\r\n        &lt;br&gt;\r\n        &lt;label&gt;URL:&lt;/label&gt;\r\n        &lt;input type=&quot;url&quot; id=&quot;url&quot;/&gt;\r\n    &lt;/div&gt;  \r\n&lt;/form&gt;\r\n</code>``\r\n\r\n<img src=\"/interview-assets/Artboard_1_2x.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các thẻ mới cho phần tử media trong HTML5?",
              "answer": "<p><em> <code>&lt;audio&gt;</code>: dùng cho các file âm thanh, nhạc, nhúng nội dung audio mà không cần plugin.\r\n</em> <code>&lt;video&gt;</code>: dùng cho nhúng nội dung video.\r\n<em> <code>&lt;source&gt;</code>: dùng cho nhiều tài nguyên media như video, audio,...\r\n</em> <code>&lt;embed&gt;</code>: dùng cho nội dung nhúng hay ứng dụng mở rộng.\r<ul><li><code>track</code>: tiêu đề con cho video hay audio</li></ul>\r\n\r\n``<code>html\r\n&lt;label&gt;\r\n       Video:\r\n&lt;/label&gt;\r\n&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt;\r\n    &lt;source src=&quot;video.mp4&quot; type=&quot;video/mp4&quot;&gt;\r\n    &lt;track src=&quot;subtitles.vtt&quot; kind=&quot;subtitles&quot; srclang=&quot;en&quot; label=&quot;English&quot;&gt;\r\n&lt;/video&gt;\r\n&lt;br&gt;\r\n&lt;label&gt;\r\n    Embed:\r\n&lt;/label&gt;\r\n&lt;embed type=&quot;video/webm&quot; src=&quot;https://www.youtube.com/embed/MpoE6s2psCw&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;\r\n&lt;br&gt;\r\n&lt;label&gt;\r\n    Audio:\r\n&lt;/label&gt;\r\n&lt;audio controls&gt;\r\n    &lt;source src=&quot;audio.mp3&quot; type=&quot;audio/mpeg&quot;&gt;\r\n&lt;/audio&gt;\r\n</code>``\r\n\r\n<img src=\"/interview-assets/html5-new-tags-in-media-elements.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao bạn nghĩ rằng việc bổ sung chức năng kéo và thả trong HTML5 là quan trọng? Bạn sẽ làm thế nào để tạo một hình ảnh có thể kéo được trong HTML5?",
              "answer": "<p>Chức năng kéo và thả là một cách rất trực quan để chọn các file cục bộ. Điều này tương tự như việc hầu hết các hệ điều hành có chức năng sao chép, nó giúp cho người dùng làm việc dễ dàng. Trước khi có API kéo và thả, điều này chỉ có thể thực được bằng cách viết lập trình Javascript phức tạp hoặc các thư viện bên ngoài như jQuery.\r\n\r\nĐể bật chức năng này, có một thuộc tính có thể kéo trong thẻ <code>&lt;img&gt;</code> và cần đặt thuộc tính <strong>ondrop</strong> và <strong>ondragover</strong> thành một event-handler có sẵn trong script.\r\n\r\n``<code>html\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n    &lt;head&gt;\r\n    &lt;script&gt;\r\n        function allowDrop(ev) {\r\n            ev.preventDefault();\r\n        }\r\n        function drop(ev) {\r\n            ...\r\n        }\r\n    &lt;/script&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n        ...\r\n        &lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot; style=&quot;border: 1px solid #aaaaaa; width:350px; height: 70px;&quot;&gt;&lt;/div&gt;\r\n        &lt;br&gt;\r\n        &lt;img id=&quot;drag1&quot; src=&quot;img_logo.gif&quot; draggable=&quot;true&quot; width=&quot;336&quot; height=&quot;69&quot;&gt;\r\n            ...\r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao ta cần phần tử MathML trong HTML5?",
              "answer": "<p>MathML là viết tắt của Mathematical Markup Language. Nó dùng cho hiển thị các biểu thức hàm số toán học trên web. Với thẻ <code>&lt;math&gt;</code>:\r\n\r\n``<code>html\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n    &lt;head&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n        &lt;math&gt;\r\n            &lt;mrow&gt;\r\n                &lt;mrow&gt;\r\n                &lt;msup&gt;\r\n                    &lt;mi&gt; a &lt;/mi&gt;\r\n                    &lt;mn&gt; 2 &lt;/mn&gt;\r\n                &lt;/msup&gt;\r\n                &lt;mo&gt; + &lt;/mo&gt;\r\n                &lt;msup&gt;\r\n                    &lt;mi&gt; b &lt;/mi&gt;\r\n                    &lt;mn&gt; 2 &lt;/mn&gt;\r\n                &lt;/msup&gt;\r\n                &lt;mo&gt; + &lt;/mo&gt;\r\n                &lt;mn&gt; 2 &lt;/mn&gt;\r\n                &lt;mn&gt; a &lt;/mn&gt;\r\n                &lt;mn&gt; b &lt;/mn&gt;\r\n                &lt;/mrow&gt;\r\n                &lt;mo&gt; = &lt;/mo&gt;\r\n                &lt;mn&gt; 0 &lt;/mn&gt;\r\n            &lt;/mrow&gt;\r\n        &lt;/math&gt;\r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``\r\n\r\nKết quả là phương trình a2 + b2 +2ab = 0</p>",
              "level": "fresher"
            },
            {
              "question": "Server-sent events trong HTML5 là gì?",
              "answer": "<p>Server-Sent Events (SSE) hay còn được biết đến với tên gọi Event Source là một Web Api cho phép kết nối thời gian thực giữa server và client (browser). SSE tạo ra kết nối một chiều từ server đến client sử dụng giao thức HTTP truyền thống với định nghĩa dữ liệu đơn giản cho phía server (event stream format) và API gọn nhẹ phía client.\r\n\r\nSo với phương pháp polling từ client lên server để kiểm tra dữ liệu thì SSE hiệu quả hơn rất nhiều do client chỉ cần tạo kết nối HTTP lên server một lần, và server giữ kết nối đó để liên tục gửi data cho client.\r\n\r\nWebSockets thì phức tạp và hoành tráng hơn hẳn SSE. Tuy nhiên WebSockets là kết nối hai chiều mà đôi khi ta lại không cần chiều từ client lên server. Ngoài ra WebSockets là một giao thức hoàn toàn khác và đòi hỏi server phải hỗ trợ.\r\n\r\nĐể dùng SSE, phần tử <code>&lt;eventsource&gt;</code> được dùng. Thuộc tính <code>src</code> dùng để chỉ định URL của server gửi luồng dữ liệu cho các sự kiện.\r\n\r\n``<code>html\r\n&lt;eventsource src = &quot;/cgi-bin/myfile.cgi&quot; /&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Web workers là gì?",
              "answer": "<p>Được thêm vào để mang lại khả năng thực thi song song và bất đồng bộ. Nó chạy nền để thực hiện các tác vụ tính toán tốn kém mà trang web không có khả năng đáp ứng. Nó thực hiện bằng cách tạo một luồng riêng cho các tác vụ như vậy. \r\nCó 3 loại worker chính:\r<ul><li><strong>Dedicated Workers</strong>: là worker được dùng bởi một script duy nhất</li></ul>\r<ul><li><strong>Shared Workers</strong> là những worker được dùng bởi nhiều script chạy trong các cửa sổ, iframe khác nhau,...</li></ul>\r<ul><li><strong>Service workers</strong> những worker này hoạt động như một proxy server giữa ứng dụng web, trình duyệt và mạng. Chủ yếu được dùng để thông báo và đồng bộ hoá API.</li></ul>\r\n\r\n``<code>html\r\n&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;\r\n&lt;button onclick=&quot;startWorker()&quot;&gt;Start Worker&lt;/button&gt;\r\n&lt;button onclick=&quot;stopWorker()&quot;&gt;Stop Worker&lt;/button&gt;\r\n&lt;script&gt;\r\nvar w;\r\nfunction startWorker() {\r\n    if(typeof(Worker) !== &quot;undefined&quot;) {\r\n        if(typeof(w) == &quot;undefined&quot;) {\r\n            w = new Worker(&quot;demo_workers.js&quot;);\r\n        }\r\n        w.onmessage = function(event) {\r\n            document.getElementById(&quot;result&quot;).innerHTML = event.data;\r\n        };\r\n    }\r\n}\r\nfunction stopWorker() {\r\n    w.terminate();\r\n    w = undefined;\r\n}\r\n&lt;/script&gt;\r\n</code>``\r\n\r\n<img src=\"/interview-assets/Artboard_2_2x.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Việc sử dụng thuộc tính novalidate cho thẻ form trong HTML5 để làm gì?",
              "answer": "<p>Giá trị của nó là kiểu boolean cho biết liệu dữ liệu đang được form gửi có được xác thực trước hay không. Nếu nó là false, các form có thể được gửi mà không cần xác thực.\r\n\r\n``<code>html\r\n&lt;form action = &quot;&quot; method = &quot;get&quot; novalidate&gt;\r\n        Name:&lt;br&gt;&lt;input type=&quot;name&quot; name=&quot;sname&quot;&gt;&lt;br&gt;\r\n       Doubt:&lt;br&gt;&lt;input type=&quot;number&quot; name=&quot;doubt&quot;&gt;&lt;br&gt;\r\n        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\r\n&lt;/form&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Vector và Raster trong ảnh là gì?",
              "answer": "<p><strong>Rasters</strong>: xác định thứ tự của pixel trong grid với màu sắc chính xác của pixel đó. File định dạng raster như png, jpg, ...\r\n\r\n<strong>Vector</strong>: xác định thuật toán với hình dạng và đường đi xác định để kết xuất ảnh trên màn hình. Vd như svg</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để hỗ trợ SVG trên trình duyệt cũ?",
              "answer": "<p>Để hỗ trợ các trình duyệt cũ thay vì xác định tài nguyên của svg trong thuộc tính <em>src</em> của thẻ <code>&lt;img&gt;</code>, thì nên xác định nó trong thuộc tính <em>srcset</em> và trong <em>src</em>, file png dự phòng phải được xác định.\r\n\r\n``<code>html\r\n&lt;img src=&quot;circle.png&quot; alt=&quot;circle&quot; srcset=&quot;circle.svg&quot;&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Progressive rendering là gì?",
              "answer": "<p>Progressive Rendering là một kỹ thuật render tuần tự các phần của trang web trong server và streaming đến client từng phần thay vì đợi render toàn bộ trang.\r\n\r\nNó ngụ ý rằng một tài quan trọng được tạo trên server, bạn có thể stream đến client mà không cần đợi những thứ không quan trọng hiển thị. Nó kết hợp cả SSR và CSR.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "File manifest trong HTML5 là gì?",
              "answer": "<p>File manifest được sử dụng để liệt kê các tài nguyên có thể được lưu vào bộ nhớ đệm. Trình duyệt sử dụng thông tin này để làm cho trang web tải nhanh hơn lần đầu tiên. Có 3 phần trong mainfest:\r\n\r\n<em> CACHE Manifest - File cần lưu vào bộ đệm\r\n</em> Network - File không bao giờ lưu vào bộ đệm, cần kết nối mạng.\r<ul><li>Fallback - File dự phòng trong trường hợp trang không tiếp cận được.</li></ul>\r\n\r\n``<code>text\r\nCACHE MANIFEST\r\n# 2012-06-16 v1.0.0\r\n/style.css\r\n/logo.gif\r\n/main.js\r\nNETWORK:\r\nlogin.php\r\nFALLBACK:\r\n/html/ /offline.html\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html manifest=&quot;tutorial.appcache&quot;&gt;\r\n...\r\n...\r\n&lt;/html&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "API định vị địa lý trong HTML5?",
              "answer": "<p>API định vị địa lý được sử dụng để chia sẻ vị trí thực của máy khách với các trang web. Điều này giúp cung cấp nội dung dựa trên ngôn ngữ và trải nghiệm độc đáo cho người dùng, dựa trên vị trí của họ. Nó hoạt động với một thuộc tính mới của đối tượng điều hướng toàn cầu và hầu hết các trình duyệt hiện đại đều hỗ trợ điều này.\r\n\r\n``<code>js\r\nvar geolocation = navigator.geolocation;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Viết code minh hoạ API định vị địa lý?",
              "answer": "<p>``<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n    &lt;body&gt;\r\n        &lt;p&gt;Click &quot;try it&quot; button to get your coordinates.&lt;/p&gt;\r\n        &lt;button onclick=&quot;getLocation()&quot;&gt;Try It&lt;/button&gt;\r\n        &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;\r\n        &lt;script&gt;\r\n            var x = document.getElementById(&quot;demo&quot;);\r\n            \r\n            function getLocation() {\r\n                if (navigator.geolocation) {\r\n                    navigator.geolocation.getCurrentPosition(showPosition);\r\n                } else { \r\n                    x.innerHTML = &quot;Geolocation functionality is not supported by this browser.&quot;;\r\n                }\r\n            }\r\n                \r\n            function showPosition(position) {\r\n                x.innerHTML = &quot;Latitude: &quot; + position.coords.latitude + \r\n                &quot;&lt;br&gt;Longitude: &quot; + position.coords.longitude;\r\n            }\r\n        &lt;/script&gt;\r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``\r\n\r\nVí dụ trên yêu cầu người dùng cho phép truy cập dữ liệu vị trí thông qua API định vị địa lý và sau khi nhấp vào nút, tọa độ của vị trí thực của client sẽ được hiển thị.\r\n\r\n<img src=\"/interview-assets/Geolocation_API.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Web Component?",
              "answer": "<p>Chúng được sử dụng để tạo các phần tử tùy chỉnh có thể sử dụng lại, nó rất khó thực hiện trong HTML truyền thống. Nó bao gồm ba công nghệ:\r\n\r\n<strong>Custom elements</strong> - Đây là các API JavaScript giúp xác định các phần tử tùy chỉnh và hành vi của chúng.\r\nShadow DOM -Đây là các API JavaScript gắn cây shadow DOM được đóng gói vào một phần tử để giữ các tính năng của phần tử đó riêng tư và không bị ảnh hưởng bởi các phần khác.\r\n\r\n``<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n    &lt;head&gt;\r\n        &lt;meta charset=&quot;utf-8&quot;&gt;\r\n        &lt;title&gt;composed and composedPath demo&lt;/title&gt;\r\n        &lt;script src=&quot;main.js&quot; defer&gt;&lt;/script&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n        &lt;h1&gt;&lt;code&gt;composed&lt;/code&gt; and &lt;code&gt;composedPath&lt;/code&gt; demo&lt;/h1&gt;\r\n        &lt;open-shadow text=&quot;I have an open shadow root&quot;&gt;&lt;/open-shadow&gt;\r\n        &lt;closed-shadow text=&quot;I have a closed shadow root&quot;&gt;&lt;/closed-shadow&gt;\r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>`<code>\r\n\r\n</code>`<code>js\r\ncustomElements.define(&#39;open-shadow&#39;,\r\n    class extends HTMLElement {\r\n        constructor() {\r\n            super();\r\n            const pElem = document.createElement(&#39;p&#39;);\r\n            pElem.textContent = this.getAttribute(&#39;text&#39;);\r\n            const shadowRoot = this.attachShadow({mode: &#39;open&#39;});\r\n            shadowRoot.appendChild(pElem);\r\n        }\r\n    }\r\n);\r\ncustomElements.define(&#39;closed-shadow&#39;,\r\n    class extends HTMLElement {\r\n        constructor() {\r\n            super();\r\n            const pElem = document.createElement(&#39;p&#39;);\r\n            pElem.textContent = this.getAttribute(&#39;text&#39;);\r\n            const shadowRoot = this.attachShadow({mode: &#39;closed&#39;});\r\n            shadowRoot.appendChild(pElem);\r\n        }\r\n    }\r\n);\r\ndocument.querySelector(&#39;html&#39;).addEventListener(&#39;click&#39;, e =&gt; {\r\n    console.log(e.composed);\r\n    console.log(e.composedPath());\r\n});\r\n</code>`<code>\r\n\r\n<img src=\"/interview-assets/Explain_Web_Components_and_it’s_usage..png\" alt=\"\" />\r\n\r\nỞ đây 2 phần tử tùy chỉnh được xác định là </code><open-shadow><code> và </code><closed-shadow><code> lấy nội dung văn bản của chúng và chèn chúng vào DOM bóng như nội dung của phần tử </code><p><code>.\r<ul><li><strong>HTML Template</strong> Các template đánh dấu được viết bằng các phần tử </code><template><code> và </code><slot><code> có thể được sử dụng lại nhiều lần làm cơ sở cho cấu trúc của phần tử tùy chỉnh. </li></ul>\r\n\r\n</code>`<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n    &lt;head&gt;\r\n        &lt;meta charset=&quot;utf-8&quot;&gt;\r\n        &lt;title&gt;Simple template&lt;/title&gt;\r\n        &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n        &lt;h1&gt;Simple template&lt;/h1&gt;\r\n        &lt;template id=&quot;my-paragraph&quot;&gt;\r\n            &lt;style&gt;\r\n            p {\r\n                color: white;\r\n                background-color: #666;\r\n                padding: 5px;\r\n            }\r\n            &lt;/style&gt;\r\n            &lt;p&gt;&lt;slot name=&quot;my-text&quot;&gt;My default text&lt;/slot&gt;&lt;/p&gt;\r\n        &lt;/template&gt;\r\n        &lt;my-paragraph&gt;\r\n            &lt;span slot=&quot;my-text&quot;&gt;Let&#39;s have some different text!&lt;/span&gt;\r\n        &lt;/my-paragraph&gt;\r\n        &lt;my-paragraph&gt;\r\n            &lt;ul slot=&quot;my-text&quot;&gt;\r\n                &lt;li&gt;Let&#39;s have some different text!&lt;/li&gt;\r\n                &lt;li&gt;In a list!&lt;/li&gt;\r\n            &lt;/ul&gt;\r\n        &lt;/my-paragraph&gt;\r\n    &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>`<code>\r\n\r\n</code>`<code>js\r\ncustomElements.define(&#39;my-paragraph&#39;,\r\n    class extends HTMLElement {\r\n        constructor() {\r\n            super();\r\n            const template = document.getElementById(&#39;my-paragraph&#39;);\r\n            const templateContent = template.content;\r\n            this.attachShadow({mode: &#39;open&#39;}).appendChild(\r\n                templateContent.cloneNode(true)\r\n            );\r\n        }\r\n    }\r\n);\r\nconst slottedSpan = document.querySelector(&#39;my-paragraph span&#39;);\r\nconsole.log(slottedSpan.assignedSlot);\r\nconsole.log(slottedSpan.slot);\r\n</code>``\r\n\r\n<img src=\"/interview-assets/explain-web-components-and-its-usage.png\" alt=\"\" /></p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "javascript",
          "name": "Câu hỏi phỏng vấn JavaScript",
          "description": "",
          "questions": [
            {
              "question": "Sự khác biệt giữa các kiểu dữ liệu trong JavaScript?",
              "answer": "<p>Trong JavaScript các kiểu dữ liệu được chia làm hai loại là kiểu nguyên thuỷ và đối tượng. Để biết kiểu dữ liệu của các biến JavaScript, ta có thể sử dụng <strong>typeof</strong>.\r\n\r\n<strong>Kiểu nguyên thuỷ</strong>\r\n\r\n<em><strong>String</strong></em> - biểu diễn một mảng ký tự hay một chuỗi. Kiểu chuỗi trong javascript có thể sử dụng một cặp dấu ngoặc kép hoặc dấu ngoặc kép đơn.\r\n\r\n``<code>js\r\n var str = &quot;Vivek Singh Bisht&quot;; //sử dụng dấu ngoặc kép\r\n var str2 = &#39;John Doe&#39;; // sử dụng dấu ngoặc đơn\r\n</code>`<code>\r\n\r\n<em><strong>Number</strong></em> - biểu diễn cả số nguyên và số thực.\r\n\r\n</code>`<code>js\r\nvar x = 3; // số nguyên\r\nvar y = 3.6; // số thực\r\n</code>`<code>\r\n\r\n<em><strong>BigInt</strong></em> - kiểu dữ liệu này được sử dụng để lưu trữ các số vượt quá giới hạn của kiểu dữ liệu Number. Nó có thể lưu trữ các số nguyên lớn và được biểu diễn bằng cách thêm “n” vào một chữ số nguyên.\r\n\r\n</code>`<code>js\r\nvar bigInteger =  234567890123456789012345678901234567890;\r\n</code>`<code>\r\n\r\n<em><strong>Boolean</strong></em> - kiểu luận lý, có hai giá trị là <em>true</em> và <em>false</em>. Thường được dùng với điều kiện.\r\n\r\n</code>`<code>js\r\nvar a = 2;\r\nvar b =  3;\r\nvar c =  2;\r\n(a == b) // trả về false\r\n(a == c) // trả về true\r\n</code>`<code>\r\n\r\n<em><strong>undefined</strong></em> - khi giá trị của một biến là không xác định.\r\n\r\n</code>`<code>js\r\nvar x; // giá trị của x là undefined\r\nvar y = undefined; // ta cũng có thể gán một biến là undefined\r\n</code>`<code>\r\n\r\n<em><strong>null</strong></em> - biểu diễn giá trị null. Vì JavaScript là case-sensitive, null sẽ không giống với</code> Null<code>, </code>NULL<code>, hoặc bất kỳ biến thể khác.\r\n\r\n</code>`<code>js\r\nvar z = null;\r\n</code>`<code>\r\n\r\n<em><strong>Symbol</strong></em> - mới được giới thiệu trong ES6. Nó lưu trữ các giá trị duy nhất và ẩn danh.\r\n\r\n</code>`<code>js\r\nvar symbol1 = Symbol(&#39;symbol&#39;);\r\n</code>`<code>\r\n\r\nSử dụng </code>typeof<code> để tìm kiểu nguyên thuỷ:\r\n\r\n</code>`<code>js\r\ntypeof &quot;John Doe&quot; // Returns &quot;string&quot;\r\ntypeof 3.14 // Returns &quot;number&quot;\r\ntypeof true // Returns &quot;boolean&quot;\r\ntypeof 234567890123456789012345678901234567890n // Returns bigint\r\ntypeof undefined // Returns &quot;undefined&quot;\r\ntypeof null // Returns &quot;object&quot; (đặc trưng của JavaScript)\r\ntypeof Symbol(&#39;symbol&#39;) // Returns Symbol\r\n</code>`<code>\r\n\r\nTrong JavaScript nếu dữ liệu không phải là kiểu nguyên thuỷ thì tất cả đều là object.\r\n\r\n<strong>Object</strong> dùng để lưu trữ tập hợp dữ liệu\r\n\r\n</code>`<code>js\r\n// Tập hợp dữ liệu dạng key-value \r\n\r\nvar obj1 = {\r\n   x:  43,\r\n   y:  &quot;Hello world!&quot;,\r\n   z: function(){\r\n      return this.x;\r\n   }\r\n}\r\n      \r\n// Tập hợp dữ liệu dạng danh sách\r\n      \r\nvar array1 = [5, &quot;Hello&quot;, true, 4.1];  \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Hoisting trong Javascript?",
              "answer": "<p>Hoisting là một hành vi mặc định trong Javascript, nó sẽ chuyển tất cả khai báo biến và hàm lên trên cùng.\r\n\r\n<img src=\"/interview-assets/hoisting-in-js.png\" alt=\"hoisting\" />\r\n\r\nĐiều này có nghĩa là bất kể hàm và biến được khai báo ở đâu, chúng cũng sẽ đuọc chuyển lên đầu scope. Scope có thể là toàn cục hoặc cục bộ.\r\n\r\nVí dụ 1:\r\n\r\n``<code>js\r\nhoistedVariable = 3;\r\nconsole.log(hoistedVariable);\r\n// output là 3 vì biến được khởi tạo trước khi khai báo.\r\nvar hoistedVariable;\r\n</code>`<code>\r\n\r\nVí dụ 2:\r\n\r\n</code>`<code>js\r\nhoistedFunction();  \r\n// Outputs &quot; Hello world! &quot; kể cả khi hàm được khai báo sau khi gọi.\r\n\r\nfunction hoistedFunction(){ \r\n  console.log(&quot; Hello world! &quot;);\r\n}\r\n</code>`<code>\r\n\r\nVí dụ 3:\r\n\r\n</code>`<code>js\r\n// Hoisting takes place in the local scope as well\r\nfunction doSomething(){\r\n  x = 33;\r\n  console.log(x);\r\n  var x;\r\n}\r\n</code>`<code>\r\n\r\n<em>Lưu ý</em>: Khai báo biến được hoisting chứ phép gán biến thì không.\r\n\r\n</code>`<code>js\r\nvar x;\r\nconsole.log(x); // Output sẽ trả về &quot;undefined&quot; vì phép gán không được hoisting\r\nx = 23;\r\n</code>`<code>\r\n\r\n<em>Lưu ý</em>: Để tránh hoisting bạn có thể dùng &quot;use strict&quot;\r\n\r\n</code>`<code>js\r\n&quot;use strict&quot;;\r\nx = 23; // Báo lỗi x  chưa được khai báo\r\nvar x; \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa toán tử \"==\" và \"===\" là như thế nào?",
              "answer": "<p>Cả hai đều dùng để so sánh, nhưng \"==\" có thể dùng với bất kỳ kiểu dữ liệu nào còn \"===\" chỉ dành cho cùng kiểu.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nvar x = 2;\r\nvar y = &quot;2&quot;;\r\n(x == y)  // Trả về true vì cả hai cùng giá trị\r\n\r\n(x === y) // Trả về false vì typeof x là &quot;number&quot; còn typeof y là &quot;string\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về ép kiểu ngầm trong JavaScript?",
              "answer": "<p>Ép kiểu ngầm trong javascript là sự chuyển đổi tự động của giá trị từ kiểu dữ liệu này sang kiểu khác. Nó xảy ra khi thực hiện một biểu thức với các kiểu dữ liệu khác nhau.\r\n\r\n<strong>Ép kiểu String</strong>\r\n\r\nÉp kiểu string xảy ra khi dùng toán tử <code>+</code>. Một số cộng với một chuỗi, kiểu số sẽ bị ép thành kiểu chuỗi.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nvar x = 3;\r\nvar y = &quot;3&quot;;\r\nx + y // Returns &quot;33&quot; \r\n</code>`<code>\r\n\r\n</code>`<code>js\r\nvar x = 24;\r\nvar y = &quot;Hello&quot;;\r\nx + y   // Returns &quot;24Hello&quot;;\r\n</code>`<code>\r\n\r\nĐể hiểu về hai ví dụ khi ta cộng một số vào chuỗi, thì khi JavaScript thấy biểu thức </code>x+y<code> với hai kiểu khác nhau (một số và một chuỗi), nó chuyển đổi kiểu số thành chuỗi để thực hiện hành động. Sau khi chuyển đổi, cả hai biến đều là kiểu chuỗi, thao tác </code>+<code> lúc này sẽ thành phép nối chuỗi kết quả là ra chuỗi &quot;33&quot; và &quot;24Hello&quot;.\r\n\r\nNgược lại, khi thực hiện phép toán </code>-<code>, thì chuỗi lại bị ép kiểu ngầm thành số. Ví dụ:\r\n\r\n</code>`<code>js\r\nvar x = 3;\r\nVar y = &quot;3&quot;;\r\nx - y    //Returns 0 since the variable y (string type) is converted to a number type\r\n</code>`<code>\r\n\r\n<strong>Ép kiểu Boolean</strong>\r\n\r\nÉp kiểu boolean xảy ra khi sử dụng các toán tử logic, lệnh if hay kiểm tra vòng lặp. Để hiểu về ép kiểu logic, ta cần hiểu về giá trị <em>truthy</em> và <em>falsy</em>.\r\n\r\nGiá trị <em>truthy</em> là cái sẽ được ép kiểu thành <strong>true</strong>. Còn <em>falsy</em> sẽ được ép kiểu thành <strong>false</strong>.\r\n\r\nTất cả các giá trị ngoại trừ </code>0<code>, </code>0n<code>, </code>-0<code>, </code>\"\"<code>, </code>null<code>, </code>undefined<code>, và </code>NaN<code> thì đều là truthy.\r\n\r\nCâu lệnh If:\r\n\r\n</code>`<code>js\r\nvar x = 0;\r\nvar y = 23;\r\n        \r\nif(x) { console.log(x) }   // The code inside this block will not run since the value of x is 0(Falsy)  \r\n        \r\nif(y) { console.log(y) }    // The code inside this block will run since the value of y is 23 (Truthy)\r\n</code>`<code>\r\n\r\nToán tử Logic:\r\n\r\nToán tử logic trong javascript không giống các ngôn ngữ lập trình khác, <strong>nó không trả về true hay false, mà nó trả về một toán hạng</strong>.\r\n\r\nOR ( || ) - Nếu giá trị đầu tiên là truthy, giá trị đầu tiên sẽ được trả về, ngược lại thì nó trả về giá trị thứ hai.\r\n\r\nAND ( &amp;&amp; ) - Nếu hai giá trị đều là truthy, giá trị thứ hai sẽ được trả về. Nếu giá trị đầu là falsy sẽ trả về giá trị đầu hoặc giá trị hai là falsy sẽ trả về giá trị hai.\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nvar x = 220;\r\nvar y = &quot;Hello&quot;;\r\nvar z = undefined;\r\n        \r\nx | | y    // Returns 220 since the first value is truthy\r\n        \r\nx | | z   // Returns 220 since the first value is truthy\r\n        \r\nx &amp;&amp; y    // Returns &quot;Hello&quot; since both the values are truthy\r\n        \r\ny &amp;&amp; z   // Returns undefined since the second value is falsy\r\n        \r\nif( x &amp;&amp; y ){ \r\n  console.log(&quot;Code runs&quot; ); // This block runs because x &amp;&amp; y returns &quot;Hello&quot; (Truthy)\r\n}   \r\n        \r\nif( x || z ){\r\n  console.log(&quot;Code runs&quot;);  // This block runs because x || y returns 220(Truthy)\r\n}\r\n</code>`<code>\r\n\r\n<strong>Ép kiểu dấu bằng</strong>\r\n\r\nXảy ra khi thực hiện phép &quot;==&quot;. Nhớ lại thì phép <strong>&quot;==&quot; được dùng để so sánh hai giá trị khác kiểu</strong>.\r\n\r\nThực tế khi sử dụng &quot;==&quot; một ép kiểu ngầm đã xảy ra, chuyển đổi tất cả toán hạng về cùng kiểu và so sánh chúng.\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nvar a = 12;\r\nvar b = &quot;12&quot;;\r\na == b // Returns true because both &#39;a&#39; and &#39;b&#39; are converted to the same type and then compared. Hence the operands are equal.\r\n</code>`<code>\r\n\r\nÉp kiểu ngầm không xảy ra khi dùng &quot;===&quot;. \r\n\r\n</code>`<code>js\r\nvar a = 226;\r\nvar b = &quot;226&quot;;\r\n\r\na === b // Returns false because coercion does not take place and the  operands are of different types. Hence they are not equal.\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "JavaScript là ngôn ngữ kiểu tĩnh hay kiểu động?",
              "answer": "<p>JavaScript là ngôn ngữ kiểu động. Trong ngôn ngữ kiểu động, kiểu dữ liệu của biến được kiểm tra trong khi đang chạy chương trình ngược lại với kiểu tĩnh, nơi kiểu dữ liệu của biến được kiểm tra khi biên dịch.\r\n\r\n<img src=\"/interview-assets/static_vs_dynamic_typing.png\" alt=\"\" />\r\n\r\nVì Javascript là ngôn ngữ kiểu động, nên một biến có thể giữ bất kỳ kiểu dữ liệu nào. Ví dụ:\r\n\r\n``<code>js\r\nvar a = 23;\r\nvar a = &quot;Hello World!&quot;;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính NaN trong JavaScript là gì?",
              "answer": "<p>Thuộc tính NaN biểu diễn một giá trị <strong>Not-a-Number</strong>. Nó biểu thị một giá trị không phải là số.\r\n\r\n<code>typeof</code> của NaN trả về <code>Number</code>. Muốn kiểm tra một giá trị có phải NaN không, có thể dùng hàm <code>isNaN()</code>.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nisNaN(&quot;Hello&quot;)  // Returns true\r\nisNaN(345)   // Returns false\r\nisNaN(&#39;1&#39;)  // Returns false, since &#39;1&#39; is converted to Number type which results in 0 ( a number) \r\nisNaN(true) // Returns false, since true converted to Number type results in 1 ( a number)\r\nisNaN(false) // Returns false\r\nisNaN(undefined) // Returns true\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về phép gán quá giá trị và phép gán qua tham chiếu?",
              "answer": "<p>Trong JavaScript, kiểu dữ liệu nguyên thuỷ được gán với giá trị, còn kiểu đối tượng được gán bằng tham chiếu.\r\n\r\nTrước tiên, ta cần hiểu về điều gì xảy ra khi ta tạo một biến và gán giá trị cho nó.\r\n\r\n``<code>js\r\nvar x = 2;\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, ta tạo một biến </code>x<code> và gán nó giá trị là &quot;2&quot;. Phép &quot;=&quot; chỉ định một vài không gian trong bộ nhớ, để lưu trữ giá trị là &quot;2&quot; và trả về vị trí được chỉ định trong bộ nhớ. Do đó, biến </code>x<code> ở trên trỏ đến vị trí trong bộ nhớ thay vì trỏ trực tiếp đến giá trị 2.\r\n\r\nPhép gán thực hiện hành vi khác nhau khi làm việc với kiểu nguyên thuỷ và kiểu đối tượng.\r\n\r\n<strong>Phép gán với kiểu nguyên thuỷ</strong>\r\n\r\n<img src=\"/interview-assets/passed_by_value.png\" alt=\"\" />\r\n\r\n</code>`<code>js\r\nvar y = 234;\r\nvar z = y;\r\n</code>`<code>\r\n\r\nỞ ví dụ này, dòng đầu phép gán giá trị cho </code>y<code> là kiểu nguyên thuỷ, sau đó ở dòng thứ hai, giá trị của </code>y<code> được gán cho </code>z<code>. Phép gán chỉ định một vùng không gian mới trong bộ nhớ và trả về địa chỉ của nó. Do đó, biến </code>z<code> không chỉ đến vị trí của biến </code>y<code> thay vào đó nó chỉ đến vùng không gian mới trong bộ nhớ.\r\n\r\n</code>`<code>js\r\nvar y = #8454; // y pointing to address of the value 234\r\n\r\nvar z = y; \r\n        \r\nvar z = #5411; // z pointing to a completely new address of the value 234\r\n        \r\n// Changing the value of y\r\ny = 23;\r\nconsole.log(z);  // Returns 234, since z points to a new address in the memory so changes in y will not effect z\r\n</code>`<code>\r\n\r\nTừ ví dụ trên, ta có thể thấy rằng các kiểu dữ liệu nguyên thủy khi được truyền cho một biến khác sẽ được truyền theo giá trị. Thay vì chỉ gán cùng một địa chỉ cho một biến khác, giá trị sẽ được gán và không gian bộ nhớ mới được tạo ra.\r\n\r\n<strong>Phép gán với kiểu đối tượng</strong>\r\n\r\n<img src=\"/interview-assets/passed_by_reference.png\" alt=\"\" />\r\n\r\n</code>`<code>js\r\nvar obj = { name: &quot;Vivek&quot;, surname: &quot;Bisht&quot; };\r\n\r\nvar obj2 = obj;\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, phép gán truyền trực tiếp vị trí của biến </code>obj<code> đến biến </code>obj2<code>. Nói cách khác, tham chiếu của biến </code>obj<code> được chuyển cho biến </code>obj2<code>.\r\n\r\n</code>`<code>js\r\nvar obj = #8711;  // obj pointing to address of { name: &quot;Vivek&quot;, surname: &quot;Bisht&quot; }\r\n\r\nvar obj2 = obj;\r\n        \r\nvar obj2 = #8711; // obj2 pointing to the same address \r\n        \r\n        \r\n// changing the value of obj1\r\n        \r\nobj1.name = &quot;Akki&quot;;\r\n        \r\nconsole.log(obj2);\r\n        \r\n// Returns {name:&quot;Akki&quot;, surname:&quot;Bisht&quot;} since both the variables are pointing to the same address.\r\n</code>``\r\n\r\nTừ ví dụ trên, ta có thể thấy rằng trong khi truyền các kiểu dữ liệu đối tượng, phép gán trực tiếp truyền địa chỉ (tham chiếu).\r\n\r\nDo đó, các kiểu dữ liệu đối tượng luôn được truyền bằng tham chiếu.</p>",
              "level": "fresher"
            },
            {
              "question": "IIFE là gì trong JavaScript?",
              "answer": "<p>Immediately Invoked Function (IIFE) là một hàm được chạy ngay sau khi nó được định nghĩa.\r\n\r\nCú pháp của IIFE:\r\n\r\n``<code>js\r\n(function(){ \r\n  // Do something;\r\n})();\r\n</code>`<code>\r\n\r\nĐể hiểu về IIFE, trước hết cần hiểu về hai dấu ngoặc đơn được thêm vào để tạo IIFE.\r\n\r\nDấu ngoặc đơn đầu tiên:\r\n\r\n</code>`<code>js\r\n(function (){\r\n   //Do something;\r\n})\r\n</code>`<code>\r\n\r\nKhi thực thi code javascript, bất cứ khi nào trình biên dịch bắt gặp từ &quot;function&quot; nó cũng sẽ cho rằng ta đang khai báo một function. Do đó, nếu ta không dùng dấu ngoặc đơn, trình biên dịch sẽ báo lỗi vì nó nghĩa ta đang khái báo một function và theo cú pháp thì các function buộc phải có tên.\r\n\r\nĐể tránh lỗi ta thêm dấu ngoặc đơn vào để trình biên dịch biết đây không phải là khai báo function mà là một biểu thức function.\r\n\r\nDấu ngoặc đơn thứ hai:\r\n\r\n</code>`<code>js\r\n(function (){\r\n  //Do something;\r\n})();\r\n</code>``\r\n\r\nTừ định nghĩa IIFE, ta biết rằng code sẽ chạy ngay sai khi khai báo. Một function chỉ chạy khi nó được gọi. Nếu ta không gọi, thì chúng ta chỉ nhận về được khai báo hàm.\r\n\r\nDo đó để gọi function ta sử dụng dấu ngoặc đơn thứ hai.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về HOC(Higher Order Functions) trong JavaScript?",
              "answer": "<p>Các hàm hoạt động trên các hàm khác bằng cách sử dụng chúng làm tham số hoặc kết quả trả về thì được gọi là Higher Order Functions - HOC. Ví dụ:\r\n\r\n``<code>js\r\nfunction higherOrder(fn) {\r\n  fn();\r\n}\r\n     \r\nhigherOrder(function() { console.log(&quot;Hello world&quot;) }); \r\n</code>`<code>\r\n\r\n</code>`<code>js\r\nfunction higherOrder2() {\r\n  return function() {\r\n    return &quot;Do something&quot;;\r\n  }\r\n}\r\n        \r\nvar x = higherOrder2();\r\nx()   // Returns &quot;Do something&quot;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về \"this\"?",
              "answer": "<p>Từ khoá \"this\" trong javascript tham chiếu đến một đối tượng có thuộc tính là một hàm.\r\n\r\nGiá trị của \"this\" phụ thuộc vào đối tượng đang gọi hàm.\r\n\r\nGiả sử ta có code sau:\r\n\r\n``<code>js\r\nfunction doSomething() {\r\n  console.log(this);\r\n}\r\n        \r\ndoSomething();\r\n</code>`<code>\r\n\r\nNhư vậy theo định nghĩa, this tham chiếu đến một đối tượng có hàm là thuộc tính. Vậy trong đoạn code trên hàm là thuộc tính của đối tượng nào?\r\n\r\nVì hàm được gọi từ ngữ cảnh tổng thể, nên <strong>hàm sẽ là thuộc tính của đối tượng toàn cục</strong>. Do đó, nếu ta chạy đoạn code trên trình duyệt kết quả sẽ là <strong>window object</strong>.\r\n\r\nVí dụ 2:\r\n\r\n</code>`<code>js\r\nvar obj = {\r\n    name:  &quot;vivek&quot;,\r\n    getName: function(){\r\n    console.log(this.name);\r\n  }\r\n}\r\n        \r\nobj.getName();\r\n</code>`<code>\r\n\r\nTrong đoạn code này, hàm </code>getName<code> là thuộc tính của </code>obj<code>. Do đó, <strong>this</strong> sẽ tham chiếu đến đối tượng </code>obj<code>, và output sẽ là &quot;vivek&quot;.\r\n\r\nVí dụ 3:\r\n\r\n</code>`<code>js\r\nvar obj = {\r\n    name:  &quot;vivek&quot;,\r\n    getName: function(){\r\n    console.log(this.name);\r\n  }\r\n        \r\n}\r\n        \r\nvar getName = obj.getName;\r\n        \r\nvar obj2 = {name:&quot;akshay&quot;, getName };\r\nobj2.getName();\r\n</code>`<code>\r\n\r\nOutput sẽ là &quot;akshay&quot;. Mặc dù hàm </code>getName<code> được khai báo trong đối tượng </code>obj<code>, nhưng ở thời điểm gọi thì </code>getName()<code> lại là thuộc tính của </code>obj2<code>, do đó &quot;this&quot; sẽ tham chiếu đến </code>obj2<code>. \r\n\r\nCách ngớ ngẩn để hiểu &quot;this&quot; là, bất cứ khi nào hàm được gọi, hãy kiểm tra đối tượng trước dấu chấm. Giá trị của this sẽ luôn là đối tượng trước dấu chấm.\r\n\r\nNếu không có đối tượng nào như ở ví dụ 1, giá trị sẽ là đối tượng toàn cục.\r\n\r\nVí dụ 4:\r\n\r\n</code>`<code>js\r\nvar obj1 = {\r\n    address : &quot;Mumbai,India&quot;,\r\n    getAddress: function(){\r\n    console.log(this.address); \r\n  }\r\n}\r\n       \r\nvar getAddress = obj1.getAddress;\r\nvar obj2 = {name:&quot;akshay&quot;};\r\nobj2.getAddress();   \r\n</code>`<code>\r\n\r\nKết quả sẽ là lỗi, vì từ khóa this tham chiếu đến đối tượng </code>obj2<code>, nhưng </code>obj2<code> không có thuộc tính “address” ‘, do đó hàm </code>getAddress` sẽ xảy ra lỗi.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về phương thức call(), aplly() và bind()?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Currying trong JavaScript là gì?",
              "answer": "<p>Currying là một kỹ thuật nâng cao để biến đổi một hàm với n tham số, thành n hàm với một tham số duy nhất.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nfunction add (a) {\r\n  return function(b){\r\n    return a + b;\r\n  }\r\n}\r\n\r\nadd(3)(4)\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, ta có hàm </code>f(a,b)<code> sau khi currying ta đã biến đổi nó thành </code>f(a)(b)<code>.\r\n\r\nBằng cách sử dụng kỹ thuật currying, chúng ta không thay đổi chức năng của một hàm, mà chỉ thay đổi cách nó được gọi.\r\n\r\n</code>`<code>js\r\nfunction multiply(a,b){\r\n  return a*b;\r\n}\r\n\r\nfunction currying(fn){\r\n  return function(a){\r\n    return function(b){\r\n      return fn(a,b);\r\n    }\r\n  }\r\n}\r\n\r\nvar curriedMultiply = currying(multiply);\r\n\r\nmultiply(4, 3); // Returns 12\r\n\r\ncurriedMultiply(4)(3); // Also returns 12\r\n</code>`<code>\r\n\r\nNhư ta có thể thấy trong đoạn code trên, chúng ta đã chuyển đổi hàm </code>multiply(a, b)<code> thành một hàm </code>curriedMultiply`, nhận một tham số tại một thời điểm.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Scope và Scope Chain?",
              "answer": "<p>Scope trong JS, xác định khả năng truy cập của các biến, hàm ở các phần khác nhau trong một đoạn code.\r\n\r\nNói chung, Scope cho biết phạm vi mà biến và hàm của ta có thể hay không thể truy cập. Có 3 loại scope trong JS:\r<ul><li>Global Scope</li></ul>\r<ul><li>Local hay Function Scope</li></ul>\r<ul><li>Block Scope</li></ul>\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Closures trong JavaScript?",
              "answer": "<p>Closures là khả năng của một hàm ghi nhớ các biến và hàm được khai báo bên ngoài phạm vi của nó.\r\n\r\n``<code>js\r\nvar Person = function(pName){\r\n  var name = pName;\r\n\r\n  this.getName = function(){\r\n    return name;\r\n  }\r\n}\r\n\r\nvar person = new Person(&quot;Neelesh&quot;);\r\nconsole.log(person.getName());\r\n</code>`<code>\r\n\r\nHiểu closure qua ví dụ sau:\r\n\r\n</code>`<code>js\r\nfunction randomFunc(){\r\n  var obj1 = {name:&quot;Vivian&quot;, age:45};\r\n\r\n  return function(){\r\n    console.log(obj1.name + &quot; is &quot;+ &quot;awesome&quot;); // Has access to obj1 even when the randomFunc function is executed\r\n\r\n  }\r\n}\r\n\r\nvar initialiseClosure = randomFunc(); // Returns a function\r\n\r\ninitialiseClosure(); \r\n</code>`<code>\r\n\r\nTrong đoạn code trên:\r\n\r\nHàm </code>randomFunc()<code> được thực thi và trả về một hàm khi ta thực hiện phép gán:\r\n\r\n</code>`<code>js\r\nvar initialiseClosure = randomFunc();\r\n</code>`<code>\r\n\r\nHàm được trả về được thực thi khi ta gọi </code>initialiseClosure<code>:\r\n\r\n</code>`<code>js\r\ninitialiseClosure();\r\n</code>`<code>\r\n\r\nKết quả sẽ là &quot;Vivian is awesome&quot; điều này xảy ra là do closure.\r\n\r\nKhi hàm </code>randomFunc()<code> chạy, nó sẽ thấy rằng hàm trả về đang sử dụng biến </code>obj1<code> bên trong nó: \r\n\r\n</code>`<code>js\r\nconsole.log(obj1.name + &quot; is &quot;+ &quot;awesome&quot;);\r\n</code>`<code>\r\n\r\nDo đó, </code>randomFunc()<code>, thay vì hủy giá trị của </code>obj1` sau khi thực thi, sẽ lưu giá trị lại vào trong bộ nhớ để tham khảo thêm. Đây là lý do tại sao hàm trả về có thể sử dụng biến được khai báo bên ngoài phạm vi ngay cả sau khi hàm đã được thực thi.\r\n\r\n<strong>Khả năng này của một hàm nhằm lưu trữ một biến để tham khảo thêm ngay cả sau khi nó được thực thi, được gọi là Closure.</strong></p>",
              "level": "fresher"
            },
            {
              "question": "Prototype là gì?",
              "answer": "<p>Tất cả các đối tượng javascript đều kế thừa các thuộc tính từ một <strong>prototype</strong>.\r\n\r\nVí dụ:\r\n\r\nĐối tượng Date kế thừa các thuộc tính từ prototype Date.\r\n\r\nĐối tượng Math kế thừa các thuộc tính từ prototype Math.\r\n\r\nĐối tượng Array kế thừa các thuộc tính từ prototype Array.\r\n\r\nTrên đầu chuỗi là <code>Object.prototype</code>. Mọi prototype đều kế thừa các thuộc tính và phương thức từ <code>Object.prototype</code>.\r\n\r\nPrototype là một bản thiết kế của một đối tượng. Prototype cho phép chúng ta sử dụng các thuộc tính và phương thức trên một đối tượng ngay cả khi các thuộc tính và phương thức không tồn tại trên đối tượng hiện tại.\r\n\r\n<img src=\"/interview-assets/object_prototype.png\" alt=\"\" />\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nvar arr = [];\r\narr.push(2);\r\n\r\nconsole.log(arr); // Outputs [2]\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, có thể thấy ta chưa xác định bất kỳ thuộc tính hoặc phương thức nào được gọi là push trên mảng </code>arr<code> nhưng javascript engine không đưa ra lỗi.\r\n\r\nLý do là việc sử dụng các prototype. Như đã thảo luận trước đây, các đối tượng Array kế thừa các thuộc tính từ prototype Array.\r\n\r\nJavascript engine thấy rằng phương thức </code>push` không tồn tại trên đối tượng mảng hiện tại, do đó nó tìm kiếm phương thức push bên trong prototype Array và nó tìm thấy phương thức.\r\n\r\nBất cứ khi nào thuộc tính hoặc phương thức không được tìm thấy trên đối tượng hiện tại, javascript engine sẽ luôn tìm kiếm trong prototype của nó và nếu nó vẫn không tồn tại, nó sẽ tìm bên trong prototype của prototype, v.v.</p>",
              "level": "fresher"
            },
            {
              "question": "Callback là gì?",
              "answer": "<p>Callback là một hàm sẽ được thực thi sau khi một hàm khác được thực thi.\r\n\r\nTrong javascript, các hàm được coi như là <strong>first-class citizens</strong>, chúng có thể được sử dụng như một tham số của một hàm khác, có thể được trả về bởi một hàm khác và có thể được sử dụng như một thuộc tính của một đối tượng.\r\n\r\nCác hàm được sử dụng làm tham số cho một hàm khác được gọi là hàm callback.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nfunction divideByHalf(sum){\r\n  console.log(Math.floor(sum / 2));\r\n}\r\n\r\nfunction multiplyBy2(sum){\r\n  console.log(sum * 2);\r\n}\r\n\r\nfunction operationOnSum(num1,num2,operation){\r\n  var sum = num1 + num2;\r\n  operation(sum);\r\n}\r\n\r\noperationOnSum(3, 3, divideByHalf); // Outputs 3\r\n\r\noperationOnSum(5, 5, multiplyBy2); // Outputs 20\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta đang thực hiện các phép toán cộng hai số.\r\n\r\nHàm </code>operationOnSum<code> nhận 3 tham số, </code>num1<code>, </code>num2<code> và </code>operator<code> sẽ được thực hiện trên tổng của chúng (callback).\r\n\r\nCả hai hàm </code>splitByHalf<code> và </code>MultiBy2<code> đều được sử dụng làm hàm callback trong đoạn code trên.\r\n\r\nCác hàm callback này chỉ được thực thi sau khi thực thi hàm </code>operationOnSum`.\r\n\r\nDo đó, callback là một hàm sẽ được thực thi sau khi một hàm khác được thực thi.</p>",
              "level": "fresher"
            },
            {
              "question": "Memoization là gì?",
              "answer": "<p>Memoization là một dạng bộ nhớ đệm trong đó giá trị trả về của một hàm được lưu vào bộ đệm dựa trên các tham số của nó. Nếu tham số của hàm đó không được thay đổi, phiên bản được lưu trong bộ nhớ cache của hàm sẽ được trả về.\r\n\r\nChúng ta có thể hiểu memoization, bằng cách chuyển đổi một hàm đơn giản thành một hàm được ghi nhớ:\r\n\r\n``<code>js\r\nfunction addTo256(num){\r\n  return num + 256;\r\n}\r\n\r\naddTo256(20); // Returns 276\r\naddTo256(40); // Returns 296\r\naddTo256(20); // Returns 276\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, chúng ta đã viết một hàm thêm tham số vào 256 và trả về nó.\r\n\r\nKhi gọi lại hàm </code>addTo256<code> với cùng một tham số (“20” trong trường hợp trên), ta đang tính toán lại kết quả cho cùng một tham số.\r\n\r\nTính toán kết quả với cùng một tham số không phải là vấn đề lớn trong trường hợp trên, nhưng hãy tưởng tượng nếu hàm thực hiện một số công việc nặng nhọc, thì việc tính toán kết quả lặp đi lặp lại với cùng một tham số sẽ dẫn đến lãng phí thời gian.\r\n\r\nĐây là lúc memoization xuất hiện, bằng cách sử dụng memoization, chúng ta có thể lưu trữ (bộ nhớ đệm) các kết quả được tính toán dựa trên các tham số. Nếu cùng một tham số được sử dụng lại trong khi gọi hàm, thay vì tính toán kết quả, chúng tôi trực tiếp trả về giá trị đã lưu trữ (đã lưu trong bộ nhớ cache).\r\n\r\nHãy chuyển đổi hàm </code>addTo256<code> ở trên, thành một hàm được ghi nhớ:\r\n\r\n</code>`<code>js\r\nfunction memoizedAddTo256(){\r\n  var cache = {};\r\n\r\n  return function(num){\r\n    if(num in cache){\r\n      console.log(&quot;cached value&quot;);\r\n      return cache[num]\r\n\r\n    }\r\n    else{\r\n      cache[num] = num + 256;\r\n      return cache[num];\r\n    }\r\n  }\r\n}\r\n\r\nvar memoizedFunc = memoizedAddTo256();\r\n\r\nmemoizedFunc(20); // Normal return\r\nmemoizedFunc(20); // Cached return\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, nếu ta chạy hàm </code>memoizedFunc` với cùng một tham số, thay vì tính toán lại kết quả, nó sẽ trả về kết quả được lưu trong bộ nhớ cache.\r\n\r\n<em>Lưu ý</em> Mặc dù sử dụng memoization tiết kiệm thời gian, nhưng nó dẫn đến tiêu thụ bộ nhớ lớn hơn vì ta đang lưu trữ tất cả các kết quả được tính toán.</p>",
              "level": "fresher"
            },
            {
              "question": "Đệ quy là gì?",
              "answer": "<p>Đệ quy là một kỹ thuật lặp đi lặp lại một hoạt động bằng cách tự gọi hàm lặp đi lặp lại cho đến khi nó đi đến kết quả.\r\n\r\n``<code>js\r\nfunction add(number) {\r\n  if (number &lt;= 0) {\r\n    return 0;\r\n  } else {\r\n    return number + add(number - 1);\r\n  }\r\n}\r\n\r\nadd(3) =&gt; 3 + add(2)\r\n          3 + 2 + add(1)\r\n          3 + 2 + 1 + add(0)\r\n          3 + 2 + 1 + 0 = 6  \r\n</code>`<code>\r\n\r\nVí dụ về một hàm đệ quy:\r\n\r\nHàm sau đây tính tổng của tất cả các phần tử trong một mảng bằng cách sử dụng đệ quy:\r\n\r\n</code>`<code>js\r\nfunction computeSum(arr){\r\n  if(arr.length === 1){\r\n    return arr[0];\r\n  }\r\n  else{\r\n    return arr.pop() + computeSum(arr);\r\n  }\r\n}\r\n\r\ncomputeSum([7, 8, 9, 99]); // Returns 123\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm khởi tạo trong JavaScript",
              "answer": "<p>Các hàm khởi tạo được sử dụng để tạo các đối tượng trong javascript.\r\n\r\nKhi nào chúng ta sử dụng các hàm khởi tạo?\r\n\r\nNếu chúng ta muốn tạo nhiều đối tượng có các thuộc tính và phương thức giống nhau, các hàm khởi tạo được sử dụng.\r\n\r\n<em>Lưu ý</em> - Tên của một hàm khởi tạo phải luôn được viết bằng Ký hiệu Pascal: mọi từ phải bắt đầu bằng một chữ cái viết hoa.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nfunction Person(name,age,gender){\r\n  this.name = name;\r\n  this.age = age;\r\n  this.gender = gender;\r\n}\r\n\r\n\r\nvar person1 = new Person(&quot;Vivek&quot;, 76, &quot;male&quot;);\r\nconsole.log(person1);\r\n\r\nvar person2 = new Person(&quot;Courtney&quot;, 34, &quot;female&quot;);\r\nconsole.log(person2);\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta đã tạo một hàm khởi tạo có tên là Person.\r\n\r\nBất cứ khi nào chúng ta muốn tạo một đối tượng mới kiểu Person,\r\n\r\nChúng tôi cần tạo nó bằng cách sử dụng từ khóa mới:\r\n\r\n</code>`<code>js\r\nvar person3 = new Person(&quot;Lilly&quot;, 17, &quot;female&quot;);\r\n</code>``\r\n\r\nDòng code trên sẽ tạo một đối tượng mới kiểu Person.\r\n\r\nCác hàm khởi tạo cho phép chúng ta nhóm các đối tượng tương tự nhau.</p>",
              "level": "fresher"
            },
            {
              "question": "DOM là gì?",
              "answer": "<p>DOM là viết tắt của Document Object Model.\r\n\r\nDOM là interface lập trình của tài liệu XML và HTML.\r\n\r\nKhi trình duyệt cố gắng hiển thị một tài liệu HTML, nó sẽ tạo một đối tượng dựa trên tài liệu HTML được gọi là DOM. Sử dụng DOM này, chúng ta có thể thao tác hoặc thay đổi các phần tử khác nhau bên trong tài liệu HTML.\r\n\r\nVí dụ về cách code HTML được chuyển đổi thành DOM:\r\n\r\n<img src=\"/interview-assets/dom.png\" alt=\"\" />\r\n\r\n## Câu hỏi dành cho Experiencer</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm arrow là gì?",
              "answer": "<p>Arrow function được giới thiệu từ phiên bản ES6 của javascript.\r\n\r\nNó cung cấp một cú pháp mới và ngắn hơn cho khai báo hàm. Hàm arrow có thể xử dụng như là một biểu thức hàm. Ta sẽ so sánh khai báo hàm thông thường với hàm arrow.\r\n\r\n``<code>js\r\n// Traditional Function Expression\r\nvar add = function(a,b){\r\n  return a + b;\r\n}\r\n\r\n// Arrow Function Expression\r\nvar arrowAdd = (a,b) =&gt; a + b;\r\n</code>`<code>\r\n\r\nHàm arrow khai báo mà không cần từ khoá </code>function<code>. Nếu nó chỉ trả về một biểu thức hàm thì ta không cần sử dụng từ khoá </code>return<code> như trong ví dụ trên. Ngoài ra, đối với các hàm chỉ có một dòng, có thể bỏ qua dấu ngoặc nhọn </code>{}<code>.\r\n\r\n</code>`<code>js\r\n// Traditional function expression\r\nvar multiplyBy2 = function(num){\r\n  return num <em> 2;\r\n}\r\n// Arrow function expression\r\nvar arrowMultiplyBy2 = num =&gt; num </em> 2;\r\n</code>`<code>\r\n\r\nNếu hàm chỉ nhận một tham số, ta có thể bỏ dấu ngoặc đơn xung quanh nó như ví dụ trên.\r\n\r\n</code>`<code>js\r\nvar obj1 = {\r\n  valueOfThis: function(){\r\n    return this;\r\n  }\r\n}\r\nvar obj2 = {\r\n  valueOfThis: ()=&gt;{\r\n    return this;\r\n  }\r\n}\r\n\r\nobj1.valueOfThis(); // Will return the object obj1\r\nobj2.valueOfThis(); // Will return window/global object\r\n</code>`<code>\r\n\r\nSự khác biệt lớn nhất giữa nhất giữa hàm truyền thống với arrow, là ở từ khoá <strong>this</strong>.\r\n\r\nNhư định nghĩa, từ khoá this tham chiếu đến đối tượng chứa hàm được gọi.\r\n\r\nNhư bạn có thể thấy, </code>obj1.valueOfThis()<code> trả về </code>obj1<code>, vì từ khoá </code>this<code> tham chiếu đến đối tượng chứa hàm đang gọi.\r\n\r\nCòn ở hàm arrow, không có ràng buộc nào của từ khóa this.\r\n\r\nTừ khoá this trong hàm arrow, không tham chiếu đến đối tượng đang gọi nó. Nó kế thừa giá trị của nó từ phạm vi cha là </code>window object<code> trong trường hợp này. \r\n\r\nDo đó, trong đoạn code trên, </code>obj2.valueOfThis()` trả về window object.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biết của biến dùng var, let và const",
              "answer": "<p>Từ phiên bản ES6, từ khoá let và const được thêm vào cho khai báo biến.\r\n\r\n| keyword | const | let | var |\r\n|---------|-------|-----|-----|\r\n|global scope | no | no | yes |\r\n|function scope | yes | yes | yes |\r\n|block scope | yes | yes | no |\r\n|can be reassigned | no | yes | yes | \r\n\r\nTa thử xem các ví dụ:\r\n\r\n``<code>js\r\nvar variable1 = 23;\r\n\r\nlet variable2 = 89;\r\n\r\nfunction catchValues(){\r\n  console.log(variable1);\r\n  console.log(variable2);\r\n\r\n// Both the variables can be accessed anywhere since they are declared in the global scope\r\n}\r\n\r\nwindow.variable1; // Returns the value 23\r\n\r\nwindow.variable2; // Returns undefined   \r\n</code>`<code>\r\n\r\nCác biến được khai báo với từ khóa </code>let<code> trong global scope sẽ hoạt động giống như biến được khai báo với từ khóa </code>var<code> trong global scope.\r\n\r\nCác biến được khai báo trong global scope với từ khóa var và let có thể được truy cập từ bất kỳ đâu trong code.\r\n\r\nNhưng, có một sự khác biệt!\r\n\r\nCác biến được khai báo với từ khóa var trong global scope được thêm vào đối tượng window/global. Do đó, chúng có thể được truy cập bằng </code>window.variableName<code>.\r\n\r\nTrong khi đó, các biến được khai báo với từ khóa let không được thêm vào đối tượng toàn cục, do đó, việc cố gắng truy cập các biến đó bằng cách sử dụng </code>window.variableName<code> sẽ dẫn đến lỗi.\r\n\r\n<strong>var và let ở function scope</strong>\r\n\r\n</code>`<code>js\r\nfunction varVsLetFunction(){\r\n  let awesomeCar1 = &quot;Audi&quot;;\r\n  var awesomeCar2 = &quot;Mercedes&quot;;\r\n}\r\n\r\nconsole.log(awesomeCar1); // Throws an error\r\nconsole.log(awesomeCar2); // Throws an error\r\n</code>`<code>\r\n\r\nCác biến được khai báo trong function scope bằng cách sử dụng </code>var<code> và </code>let<code> hoạt động hoàn toàn giống nhau, nghĩa là chúng không thể được truy cập từ bên ngoài phạm vi.\r\n\r\n</code>`<code>js\r\n{\r\n  var variable3 = [1, 2, 3, 4];\r\n}\r\n\r\nconsole.log(variable3); // Outputs [1,2,3,4]\r\n\r\n{\r\n  let variable4 = [6, 55, -1, 2];\r\n}\r\n\r\nconsole.log(variable4); // Throws error\r\n\r\nfor(let i = 0; i &lt; 2; i++){\r\n  //Do something\r\n}\r\n\r\nconsole.log(i); // Throws error\r\n\r\nfor(var j = 0; j &lt; 2; i++){\r\n  // Do something\r\n}\r\n\r\nconsole.log(j) // Outputs 2\r\n</code>`<code>\r\n\r\nTrong javascript, một khối có nghĩa là code được viết bên trong dấu ngoặc nhọn </code>{}<code>.\r\n\r\nCác biến được khai báo với từ khóa var không có block scope. Nó có nghĩa là một biến được khai báo trong block scope </code>{}` với từ khóa var cũng giống như khai báo biến trong global scope.\r\n\r\nCác biến được khai báo với từ khóa let bên trong block scope không thể được truy cập từ bên ngoài khối.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Tham số còn lại và toán tử spread là gì?",
              "answer": "<p>Cả hai đều được giới thiệu ở phiên bản ES6\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Sử dụng Promise trong JavaScript",
              "answer": "<p><strong>Promise dùng cho xử lý bất đồng bộ trong JavaScript</strong>\r\n\r\nTrước promise, callback được dùng cho các thao tác bất đồng bộ. Nhưng callback có giới hạn của nó, nếu sử dụng quá nhiều callback code sẽ trở nên khó quản lý.\r\n\r\nĐối tượng promise có 4 trạng thái:\r<ul><li><strong>Pending</strong>: trạng thái bắt đầu, biểu diễn promise không phải là fulfilled, cũng không phải là rejected mà đang ở trạng thái pending.</li></ul>\r<ul><li><strong>Fulfilled</strong>: trạng thái này có nghĩa là thao tác bất đồng bộ đã hoàn tất.</li></ul>\r<ul><li><strong>Rejected</strong>: trạng này này có nghĩa là thao tác đã thất bại vì một vài lý do nào đó.</li></ul>\r<ul><li><strong>Settked</strong>: trạng thái này thể hiện promise đã rejected hoặc fulfilled.</li></ul>\r\n\r\nMột promise được tạo bằng cách sử dụng phương thức khởi tạo Promise, hàm này nhận một hàm callback với hai tham số, <code>resolve</code> và <code>reject</code> tương ứng.\r\n\r\n<img src=\"/interview-assets/js_promise_resolve_reject.png\" alt=\"\" />\r<ul><li><strong>resolve</strong> hàm được gọi, khi thao tác bất đồng bộ thực hiện thành công.</li></ul>\r<ul><li><strong>reject</strong> hàm được gọi, khi thao tác thất bại bởi một vài lỗi nào đó.</li></ul>\r\n\r\nVí dụ:\r\n\r\nPromise được dùng cho các thao tác bất đồng bộ như yêu cầu của server, để dễ hiểu ta lấy ví dụ với một phép toán để tính tổng của ba phần tử.\r\n\r\n``<code>js\r\nfunction sumOfThreeElements(...elements){\r\n  return new Promise((resolve,reject)=&gt;{\r\n    if(elements.length &gt; 3 ){\r\n      reject(&quot;Only three elements or less are allowed&quot;);\r\n    }\r\n    else{\r\n      let sum = 0;\r\n      let i = 0;\r\n      while(i &lt; elements.length){\r\n        sum += elements[i];\r\n        i++;\r\n      }\r\n      resolve(&quot;Sum has been calculated: &quot;+sum);\r\n    }\r\n  })\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta đang tính tổng của ba phần tử, nếu độ dài của mảng phần tử lớn hơn 3, thì promise sẽ bị rejected, ngược lại thì promise sẽ được resolved và tổng được trả về.\r\n\r\nChúng ta có thể sử dụng bất kỳ promise nào bằng cách gắn các phương thức </code>then()<code> và </code>catch()<code> vào đối tượng sử dụng.\r\n\r\n<img src=\"/interview-assets/js_promise_then_catch.png\" alt=\"\" />\r<ul><li><strong>then()</strong> phương này được truy cập khi kết quả của promise là <em>fulfilled</em>.</li></ul>\r<ul><li><strong>catch()</strong> phương này được truy cập khi kết quả của promise là <em>rejected</em>.</li></ul>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nsumOfThreeElements(4, 5, 6)\r\n.then(result=&gt; console.log(result))\r\n.catch(error=&gt; console.log(error));\r\n// In the code above, the promise is fulfilled so the then() method gets executed\r\n\r\nsumOfThreeElements(7, 0, 33, 41)\r\n.then(result =&gt; console.log(result))\r\n.catch(error=&gt; console.log(error));\r\n// In the code above, the promise is rejected hence the catch() method gets executed\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Lớp trong JavaScript?",
              "answer": "<p>Được thêm vào ở phiên bản ES6, các lớp không là gì ngoài các cú pháp tuyệt vời cho các hàm khởi tạo.\r\n\r\nChúng cung cấp một cách mới để khai báo các hàm khởi tạo trong javascript.\r\n\r\nDưới đây là các ví dụ về cách các lớp được khai báo và sử dụng:\r\n\r\n``<code>js\r\n// Before ES6 version, using constructor functions\r\nfunction Student(name,rollNumber,grade,section){\r\n  this.name = name;\r\n  this.rollNumber = rollNumber;\r\n  this.grade = grade;\r\n  this.section = section;\r\n}\r\n\r\n// Way to add methods to a constructor function\r\nStudent.prototype.getDetails = function(){\r\n  return &#39;Name: ${this.name}, Roll no: ${this.rollNumber}, Grade: ${this.grade}, Section:${this.section}&#39;;\r\n}\r\n\r\n\r\nlet student1 = new Student(&quot;Vivek&quot;, 354, &quot;6th&quot;, &quot;A&quot;);\r\nstudent1.getDetails();\r\n// Returns Name: Vivek, Roll no:354, Grade: 6th, Section:A\r\n\r\n// ES6 version classes\r\nclass Student{\r\n  constructor(name,rollNumber,grade,section){\r\n    this.name = name;\r\n    this.rollNumber = rollNumber;\r\n    this.grade = grade;\r\n    this.section = section;\r\n  }\r\n\r\n  // Methods can be directly added inside the class\r\n  getDetails(){\r\n    return &#39;Name: ${this.name}, Roll no: ${this.rollNumber}, Grade:${this.grade}, Section:${this.section}&#39;;\r\n  }\r\n}\r\n\r\nlet student2 = new Student(&quot;Garry&quot;, 673, &quot;7th&quot;, &quot;C&quot;);\r\nstudent2.getDetails();\r\n// Returns Name: Garry, Roll no:673, Grade: 7th, Section:C\r\n</code>`<code>\r\n\r\nCác điều cần nhớ về lớp:\r<ul><li>Không như function, các lớp không được hoisting. Chúng cần khai báo trước khi sử dụng.</li></ul>\r<ul><li>Một lớp có thể kế thừa thuộc tính và phương thức từ lớp khác bằng từ khoá </code>extends<code>.</li></ul>\r<ul><li>Tất cả cú pháp trong lớp phải theo tuần thủ chế độ strict (</code>use strict`). Lỗi sẽ xuất hiện nếu các quy tắc trong chế độ strict không được tuân thủ.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hàm generator là gì?",
              "answer": "<p>Được giới thiệu ở phiên bản ES6, generator function là một lớp đặc biệt của hàm.\r\n\r\n<strong>Chúng có thể được dừng lại giữa chừng và sau đó tiếp tục từ nơi nó đã dừng lại.</strong>\r\n\r\nHàm generator được khai báo với từ khoá <strong>function </strong><em>:\r\n\r\n``<code>js\r\nfunction</em> genFunc(){\r\n  // Perform operation\r\n}\r\n</code>`<code>\r\n\r\nTrong các hàm thông thường, ta sử dụng </code>return<code> để trả về giá trị, và ngay sau khi khi lệnh </code>return<code> được thực thi, việc thực thi hàm sẽ dừng lại.\r\n\r\n</code>`<code>js\r\nfunction normalFunc(){\r\n  return 22;\r\n  console.log(2); // This line of code does not get executed\r\n}\r\n</code>`<code>\r\n\r\nCòn với các hàm generator, khi được gọi nó sẽ không thực thi code thay vào đó nó trả về một đối tượng <strong>generator</strong>. Đối tượng generator này xử lý việc thực thi:\r\n\r\n</code>`<code>js\r\nfunction<em> genFunc(){\r\n  yield 3;\r\n  yield 4;\r\n}\r\ngenFunc(); // Returns Object [Generator] {}\r\n</code>`<code>\r\n\r\nĐối tượng generator bao gồm một phương thức được gọi là </code>next()<code>, phương thức này khi được gọi sẽ thực thi code cho đến câu lệnh </code>yield<code> gần nhất và trả về giá trị </code>yield<code>.\r\n\r\nVí dụ: nếu ta chạy phương thức </code>next()<code> trên đoạn code trên:\r\n\r\n</code>`<code>js\r\ngenFunc().next(); // Returns {value: 3, done:false}\r\n</code>`<code>\r\n\r\nNhư ta có thể thấy phương thức </code>next()<code> trả về một đối tượng bao gồm thuộc tính </code>value<code> và </code>done<code>.\r<ul><li>Thuộc tính value đại diện cho giá trị thu được.</li></ul>\r<ul><li>Thuộc tính done cho ta biết code của hàm đã hoàn thành hay chưa. (Trả về true nếu kết thúc).</li></ul>\r\n\r\nCác hàm generator được sử dụng để trả về các vòng lặp. Hãy xem một ví dụ trong đó một vòng lặp được trả về:\r\n\r\n</code>`<code>js\r\nfunction</em> iteratorFunc() {\r\n  let count = 0;\r\n  for (let i = 0; i &lt; 2; i++) {\r\n      count++;\r\n      yield i;\r\n  }\r\n  return count;\r\n}\r\n\r\nlet iterator = iteratorFunc();\r\nconsole.log(iterator.next()); // {value:0,done:false}\r\nconsole.log(iterator.next()); // {value:1,done:false}\r\nconsole.log(iterator.next()); // {value:2,done:true}\r\n</code>`<code>\r\n\r\nNhư bạn có thể thấy trong đoạn code trên, dòng cuối cùng trả về </code>done: true`, vì code này đạt đến cuối hàm.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích WeakSet trong JavaScript",
              "answer": "<p>Trong Javascript, Set là tập hợp các phần tử đơn nhất và có thứ tự.\r\n\r\nGiống như Set, WeakSet cũng là tập hợp các phần tử đơn nhất và có thứ tự. Nhưng có vài điểm khác:\r<ul><li>Weakset chỉ chứa các đối tượng và không có loại nào khác.</li></ul>\r<ul><li>Một đối tượng bên trong weakset có tham chiếu yếu. Điều này có nghĩa là, nếu đối tượng bên trong weakset không có tham chiếu, nó sẽ được bộ dọn dẹp thu gom.</li></ul>\r<ul><li>Không giống như Set, WeakSet chỉ có ba phương thức, add(), delete() và has().</li></ul>\r\n\r\n``<code>js\r\nconst newSet = new Set([4, 5, 6, 7]);\r\nconsole.log(newSet);// Outputs Set {4,5,6,7}\r\n\r\nconst newSet2 = new WeakSet([3, 4, 5]); //Throws an error\r\n\r\n\r\nlet obj1 = {message:&quot;Hello world&quot;};\r\nconst newSet3 = new WeakSet([obj1]);\r\nconsole.log(newSet3.has(obj1)); // true\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về WeakMap trong JavaScript",
              "answer": "<p>Trong JS, Map được dùng để lưu các cặp key-value. Các cặp key-value có thể là kiểu nguyên thuỷ hoặc đối tượng.\r\n\r\nWeakMap gần giống Map với vài điểm khác biệt:\r<ul><li>Key và value trong weakmap phải là kiểu đối tượng.</li></ul>\r<ul><li>Nếu không có tham chiếu đến đối tượng, đối tượng sẽ bị dọn dep.</li></ul>\r\n\r\n``<code>js\r\nconst map1 = new Map();\r\nmap1.set(&#39;Value&#39;, 1);\r\n\r\nconst map2 = new WeakMap();\r\nmap2.set(&#39;Value&#39;, 2.3); // Throws an error\r\n\r\nlet obj = {name:&quot;Vivek&quot;};\r\nconst map3 = new WeakMap();\r\nmap3.set(obj, {age:23});\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cấu trúc đối tượng là gì?",
              "answer": "<p>Cấu trúc đối tượng là một cách mới để trích xuất các phần tử từ một đối tượng hoặc một mảng.\r\n\r\nTrước ES6:\r\n\r\n``<code>js\r\nconst classDetails = {\r\n  strength: 78,\r\n  benches: 39,\r\n  blackBoard:1\r\n}\r\n\r\nconst classStrength = classDetails.strength;\r\nconst classBenches = classDetails.benches;\r\nconst classBlackBoard = classDetails.blackBoard;\r\n</code>`<code>\r\n\r\nVí dụ tương tự sử dụng cấu trúc đối tượng:\r\n\r\n</code>`<code>js\r\nconst classDetails = {\r\n  strength: 78,\r\n  benches: 39,\r\n  blackBoard:1\r\n}\r\n\r\nconst {strength:classStrength, benches:classBenches,blackBoard:classBlackBoard} = classDetails;\r\n\r\nconsole.log(classStrength); // Outputs 78\r\nconsole.log(classBenches); // Outputs 39\r\nconsole.log(classBlackBoard); // Outputs 1\r\n</code>`<code>\r\n\r\nNhư mọi người có thể thấy, bằng cách sử dụng cấu trúc đối tượng, ta đã trích xuất tất cả các phần tử bên trong một đối tượng trong một dòng code.\r\n\r\nNếu chúng ta muốn biến mới của mình có cùng tên với thuộc tính của một đối tượng, chúng ta có thể bỏ dấu hai chấm:\r\n\r\n</code>`<code>js\r\nconst {strength:strength} = classDetails;\r\n// The above line of code can be written as:\r\nconst {strength} = classDetails;\r\n</code>``\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Temporal Dead Zone là gì?",
              "answer": "<p>Temporal Dead Zone là hành vi xảy ra với khai báo biến sử dụng <strong>let</strong> hoặc <strong>const</strong>.\r\n\r\nNó là hành vi xảy ra khi ta truy cập một biến trước khi khởi tạo.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nx = 23; // Gives reference error\r\n\r\nlet x;\r\n\r\n\r\nfunction anotherRandomFunc(){\r\n  message = &quot;Hello&quot;; // Throws a reference error\r\n\r\n  let message;\r\n}\r\nanotherRandomFunc();\r\n</code>``\r\n\r\nTrong đoạn code trên, cả trong global scope và function scope, ta đang cố gắng truy cập các biến chưa được khai báo. Đây được gọi là Temporal Dead Zone.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "react",
          "name": "Câu hỏi phỏng vấn React",
          "description": "",
          "questions": [
            {
              "question": "React là gì?",
              "answer": "<p>React là một thư viện JavaScript mã nguồn mở và giao diện người dùng, rất hữu ích trong việc phát triển giao diện người dùng dành riêng cho các ứng dụng SPA. Nó hữu ích trong việc xây dựng các thành phần giao diện người dùng (UI) phức tạp và có thể tái sử dụng của các ứng dụng web và di động vì nó tuân theo mô hình dựa trên component.\r\n\r\nTính năng của React:\r<ul><li>Tăng hiệu suất của ứng dụng với Virtual DOM.</li></ul>\r<ul><li>JSX làm cho code dễ đọc và viết.</li></ul>\r<ul><li>Nó kết xuất cả phía máy khách và máy chủ.</li></ul>\r<ul><li>Dễ dàng tích hợp với các frameworks khác (Angular, BackboneJS) vì nó chỉ là một thư viện giao diện.</li></ul>\r<ul><li>Dễ dàng viết các trường hợp kiểm thử UI và tích hợp với các công cụ như JEST.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Lợi ích khi dùng React?",
              "answer": "<p><ul><li>ReactJS giúp cho việc viết các đoạn code Javascript sẽ trở nên dễ dàng hơn vì nó sử dụng một cú pháp đặc biệt đó chính là cú pháp JSX. Thông qua JSX cho phép nhúng code HTML và Javascript.</li></ul>\r<ul><li>ReactJS cho phép nhà phát triển phá vỡ những cấu trúc UI phức tạp thành những component độc lập. Các nhà phát triển sẽ không phải lo lắng về tổng thể ứng dụng web, giờ đây có thể dễ dàng chia nhỏ các cấu trúc UI/UX phức tạp thành từng component đơn giản hơn. </li></ul>\r<ul><li>Đi kèm với ReactJS là rất nhiều các công cụ phát triển giúp cho việc debug code một cách dễ dàng hơn.</li></ul>\r<ul><li>Một trong những ưu điểm nữa của ReactJS đó là sự thân thiện với SEO. Hầu như các JS Frameworks không thân thiện với các tìm kiếm mặc dù đã được cải thiện nhiều nhưng dưới sự hỗ trợ của các render dữ liệu trả về dưới dạng web page giúp cho SEO chuẩn hơn.</li></ul>\r<ul><li>React cùng với React Native, Redux, Electro cùng với nhiều công cụ hữu ích khác giúp nhà phát triển xây dựng được đa dạng loại ứng dụng phù hợp với nhiều yêu cầu.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hạn chế của React?",
              "answer": "<p><ul><li>React không phải một framework hoàn chỉnh mà chỉ là thư viện.</li></ul>\r<ul><li>Component trong React sẽ rất nhiều và mất nhiều thời gian để hiểu với các trang web phức tạp.</li></ul>\r<ul><li>Code sẽ trở nên phức tạp khi dùng template với JSX.</li></ul>\r<ul><li>Khá khó cho người mới bắt đầu.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "useState() trong React là gì?",
              "answer": "<p>useState() là một hooks có sẵn trong React, cho phép bạn quản lý biến state của các function component. Nó được dùng khi DOM có thứ gì đó cần được điều khiển/quản lý.\r\n\r\nTrong code bên dưới, <code>useState(0)</code> sẽ trả về một mảng trong đó tham số đầu tiên là state hiện tại của <code>counter</code> và tham số thứ hai là phương thức <code>setCounter</code> cho phép cập nhật state của counter.\r\n\r\n``<code>jsx\r\n...\r\nconst [count, setCounter] = useState(0);\r\nconst [otherStuffs, setOtherStuffs] = useState(...);\r\n...\r\nconst setCount = () =&gt; {\r\n   setCounter(count + 1);\r\n   setOtherStuffs(...);\r\n   ...\r\n};\r\n</code>`<code>\r\n\r\nTa có thể sử dụng phương thức </code>setCounter()<code> cho cập nhật state của count ở bất cứ đâu. Trong ví dụ này, ta sử dụng </code>setCounter()<code> trong hàm </code>setCount` . Đây là một ý tưởng tuyệt với để quản lý state trong các function component, tránh sử dụng class component khi không cần thiết.</p>",
              "level": "fresher"
            },
            {
              "question": "Keys trong React?",
              "answer": "<p>Key là một thuộc tính chuỗi đặc biệt dùng khi sử dụng danh sách phần tử.\r\n\r\n<img src=\"/interview-assets/What_are_keys_in_React.png\" alt=\"\" />\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nconst ids = [1,2,3,4,5];\r\nconst listElements = ids.map((id)=&gt;{\r\n    return(\r\n        &lt;li key={id.toString()}&gt;\r\n            {id}\r\n        &lt;/li&gt;\r\n    )\r\n})\r\n</code>``\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "JSX là gì?",
              "answer": "<p>JSX là viết tắt của JavaScript XML. Nó cho phép ta viết HTML trong JavaScript và đặt nó vào DOM mà không cần dùng <code>appendChild()</code> hay <code>createElement()</code>.\r\n\r\nTheo trang chủ của React, JSX cung cấp cú pháp tuyệt vời hơn cho <code>React.createElement()</code>. Ví dụ\r<ul><li>Không dùng JSX:</li></ul>\r\n\r\n``<code>js\r\nconst text = React.createElement(&#39;p&#39;, {}, &#39;This is a text&#39;);\r\nconst container = React.createElement(&#39;div&#39;,&#39;{}&#39;,text );\r\nReactDOM.render(container,rootElement);\r\n</code>`<code>\r<ul><li>Dùng JSX:</li></ul>\r\n\r\n</code>`<code>jsx\r\nconst container = (\r\n&lt;div&gt;\r\n    &lt;p&gt;This is a text&lt;/p&gt;\r\n&lt;/div&gt;\r\n);\r\nReactDOM.render(container,rootElement);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa class component và function component?",
              "answer": "<p>Trước khi giới thiệu hooks ở phiên bản 16, các function component được gọi là stateless component và ít khi được dùng trong React. Sau khi hook ra đời, các function component giờ đã ngang hàng với class component.\r\n\r\nDù function component đang là trend hiện tại, nhưng class component vẫn còn rất quan trọng. Dưới đây là một vài so sánh cơ bản:\r<ul><li><strong>Khai báo</strong></li></ul>\r\n\r\nFunction component giống như một hàm thông thường trong JS, ta có thể tạo kiểu arrow function hoặc function:\r\n\r\n``<code>jsx\r\nfunction card(props){\r\n    return(\r\n        &lt;div className=&quot;main-container&quot;&gt;\r\n            &lt;h2&gt;Title of the card&lt;/h2&gt;\r\n        &lt;/div&gt;\r\n    )\r\n}\r\n\r\nconst card = (props) =&gt; {\r\n    return(\r\n        &lt;div className=&quot;main-container&quot;&gt;\r\n            &lt;h2&gt;Title of the card&lt;/h2&gt;\r\n        &lt;/div&gt;\r\n    )\r\n}\r\n</code>`<code>\r\n\r\nClass component sử dụng cú pháp tạo lớp của ES6\r\n\r\n</code>`<code>jsx\r\nclass Card extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n    }\r\n    render(){\r\n        return(\r\n            &lt;div className=&quot;main-container&quot;&gt;\r\n                &lt;h2&gt;Title of the card&lt;/h2&gt;\r\n            &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Xử lý props</strong></li></ul>\r\n\r\nTa thử render component dưới đây theo cả hai cách:\r\n\r\n</code>`<code>jsx\r\n&lt;Student Info name=&quot;Vivek&quot; rollNumber=&quot;23&quot; /&gt;\r\n</code>`<code>\r\n\r\nTrong function component, xử lý props rất thẳng thắn. Bất ký props nào cũng được xem như tham số của function component có thể xử lý trực tiếp:\r\n\r\n</code>`<code>jsx\r\nfunction StudentInfo(props){\r\n    return(\r\n        &lt;div className=&quot;main&quot;&gt;\r\n            &lt;h2&gt;{props.name}&lt;/h2&gt;\r\n            &lt;h4&gt;{props.rollNumber}&lt;/h4&gt;\r\n        &lt;/div&gt;\r\n    )\r\n}\r\n</code>`<code>\r\n\r\nVới class component, props được xử lý bằng </code>this<code>:\r\n\r\n</code>`<code>jsx\r\nclass StudentInfo extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n    }\r\n    \r\n    render(){\r\n        return(\r\n            &lt;div className=&quot;main&quot;&gt;\r\n                &lt;h2&gt;{this.props.name}&lt;/h2&gt;\r\n                &lt;h4&gt;{this.props.rollNumber}&lt;/h4&gt; \r\n            &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Xử lý state</strong></li></ul>\r\n\r\nFunction component sử dụng hook để quản lý state. Hook hữu ích nhất là </code>useState<code> cho thiết lập state trong component.\r\n\r\n</code>`<code>jsx\r\nfunction ClassRoom(props){\r\n    let [studentsCount,setStudentsCount] = useState(0);\r\n    \r\n    const addStudent = () =&gt; {\r\n        setStudentsCount(++studentsCount);\r\n    }\r\n        \r\n    return(\r\n        &lt;div&gt;\r\n            &lt;p&gt;Number of students in class room: {studentsCount}&lt;/p&gt;\r\n            &lt;button onClick={addStudent}&gt;Add Student&lt;/button&gt;\r\n        &lt;/div&gt;\r\n    )\r\n}\r\n</code>`<code>\r\n\r\nTa không thể sử dụng hook bên trong class component, thế nên ta vẫn phải xử lý state bằng </code>this<code> trong class component.\r\n\r\n</code>`<code>jsx\r\nclass ClassRoom extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n\r\n        this.state = {studentsCount : 0};\r\n        this.addStudent = this.addStudent.bind(this);\r\n    }\r\n    \r\n    addStudent(){\r\n        this.setState((prevState)=&gt;{\r\n            return {studentsCount: prevState.studentsCount++}\r\n        });\r\n    }\r\n    \r\n    render(){\r\n        return(\r\n            &lt;div&gt;\r\n                &lt;p&gt;Number of students in class room: {this.state.studentsCount}&lt;/p&gt;\r\n                &lt;button onClick={this.addStudent}&gt;Add Student&lt;/button&gt;\r\n            &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Virtual DOM là gì?",
              "answer": "<p>Virtual DOM là một khái niệm trong đó biểu diễn ảo của DOM thực được lưu giữ bên trong bộ nhớ và được đồng bộ hóa với DOM thực bởi một thư viện như ReactDOM.\r\n\r\n<img src=\"/interview-assets/virtual_DOM.png\" alt=\"\" />\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa controlled component và uncontrolled component?",
              "answer": "<p>| Tính năng | Uncontrolled | Controlled \r\n|-|-|-|\r\n| Truy xuất giá trị một lần (như khi submit) | Yes | Yes |\r\n| Xác thực submit | Yes | Yes |\r\n| Xác thực trường | No | Yes |\r\n| Điều kiện cho kích hoạt nút submit | No | Yes |\r\n| Định dạng đầu vào | No | Yes |\r\n| Cung cấp nhiều input cho một mẫu dữ liệu | No | Yes |\r\n| Input động | No | Yes |\r\n\r\n<strong>Controlled component</strong>\r\n\r\nTrong controlled component, giá trị của phần tử input được điều khiển bởi React. Ta lưu trữ trạng thái của phần tử input trong code, và sử dụng callback, với bất kỳ thay đổi nào đến input sẽ được phản ánh tương tự trong code.\r\n\r\nKhi người dùng nhập dữ liệu vào phần tử input trong controlled component, hàm <code>onChange</code> kích hoạt và trong code, ta kiểm tra giá trị nhập vào là hợp lệ hay không. Nếu hợp lệ, ta thay đổi trạng thái và re-render phần tử input với giá trị mới.\r\n\r\n``<code>jsx\r\nfunction FormValidation(props) {\r\n    let [inputValue, setInputValue] = useState(&quot;&quot;);\r\n    let updateInput = e =&gt; {\r\n        setInputValue(e.target.value);\r\n    };\r\n    return (\r\n        &lt;div&gt;\r\n            &lt;form&gt;\r\n            &lt;input type=&quot;text&quot; value={inputValue} onChange={updateInput} /&gt;\r\n            &lt;/form&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nNhư đoạn code trên, giá trị của phần tử input được xác định bởi biến </code>inputValue<code>. Bất kỳ thay đổi nào đến phần tử input sẽ được xử lý bởi hàm </code>updateInput<code>.\r\n\r\n<strong>Uncontrolled component</strong>\r\n\r\nTrong uncontrolled component, giá trị của phần tử input được xử lý bởi chính DOM. Các phần tử input này hoạt động giống như phần tử input HTML.\r\n\r\nTrạng thái của phần tử input được xử lý bởi DOM. Nên khi giá trị input thay đổi, callback sẽ không được gọi. Hoặc có thể nói là React không thực hiện bất cứ hàng động nào khi xảy ra thay đổi.\r\n\r\nKhi người dùng nhập dữ liệu vào trường input, dữ liệu cập nhật được hiển thị trực tiếp. Để truy cập giá trị phần tử input, ta có thể dùng <strong>ref</strong>.\r\n\r\n</code>`<code>jsx\r\nfunction FormValidation(props) {\r\n    let inputValue = React.createRef();\r\n    let handleSubmit = e =&gt; {\r\n        alert(</code>Input value: ${inputValue.current.value}<code>);\r\n        e.preventDefault();\r\n    };\r\n    return (\r\n        &lt;div&gt;\r\n            &lt;form onSubmit={handleSubmit}&gt;\r\n            &lt;input type=&quot;text&quot; ref={inputValue} /&gt;\r\n            &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;\r\n            &lt;/form&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Props trong React là gì?",
              "answer": "<p>Props trong React là dữ liệu được truyền cho các component. Nó có thể là giá trị đơn hoặc đối tượng có tập giá trị được truyền cho component trong suốt quá trình bằng cách thực hiện truyền tham số (tương tự với cú pháp thuộc tính trong HTML). Ta có thể nói props là dữ liệu kế thừa được truyền từ component cha sang component con.\r\n\r\nCác chức năng của props:\r<ul><li>Truyền dữ liệu tuỳ chỉnh đến component.</li></ul>\r<ul><li>Kích hoạt thay đổi trạng thái</li></ul>\r<ul><li>Sử dụng cho render dữ liệu.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích state và props?",
              "answer": "<p>| Props | State |\r\n|-|-|\r\n| Bất biến | Có thể thay đổi |\r\n| Hiệu suất tốt hơn | Phạm vi cục bộ |\r\n| Truyền được cho component khác | Truyền được giống như props |\r\n| | Có phương thức setState để đổi giá trị |\r\n| | Đổi trạng bất đồng bộ |\r\n\r\n<strong>React State</strong>\r\n\r\nTất cả component đều có sẵn đối tượng state, bao gồm tất cả giá trị thuộc tính cùng với component đó. Nói cách khác, đối tượng state điều khiển hành vi của component. Bất kỳ thay đổi giá trị thuộc tính nào của đối tượng state sẽ dẫn đến re-render component.\r\n\r\n<em>Khai báo đối tượng state</em>\r\n\r\n``<code>jsx\r\nclass Car extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            brand: &quot;BMW&quot;,\r\n            color: &quot;black&quot;\r\n        }\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<em>Dùng và cập nhật đối tượng state</em>\r\n\r\n</code>`<code>jsx\r\nclass Car extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            brand: &quot;BMW&quot;,\r\n            color: &quot;Black&quot;\r\n        };\r\n    }\r\n    changeColor() {\r\n        this.setState(prevState =&gt; {\r\n            return { color: &quot;Red&quot; };\r\n        });\r\n    }\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;button onClick={() =&gt; this.changeColor()}&gt;Change Color&lt;/button&gt;\r\n                &lt;p&gt;{this.state.color}&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>React Props</strong>\r\n\r\nTất cả component đều nhận vào một đối thượng tham số gọi là props (viết tắt của properties). Props có thể được truyền đi component khác và các component này nhận props như một đối số.\r\n\r\n<em>Truyền props cho component</em>\r\n\r\n</code>`<code>jsx\r\n&lt;Car brand=&quot;Mercedes&quot;/&gt;\r\n</code>`<code>\r\n\r\n<em>Nhận props từ component khác</em>\r\n\r\nTrong class:\r\n\r\n</code>`<code>jsx\r\nclass Car extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            brand: this.props.brand,\r\n            color: &quot;Black&quot;\r\n        };\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong function:\r\n\r\n</code>`<code>jsx\r\nfunction Car(props) {\r\n    let [brand, setBrand] = useState(props.brand);\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu side effect trong React component?",
              "answer": "<p>Có hai kiểu side effect trong React.\r<ul><li><strong>Effect không có cleanup:</strong> Side effect này sẽ được sử dụng trong <code>useEffect</code> không hạn chế trình duyệt cập nhật màn hình. Nó cũng cải thiện khả năng phản hồi của một ứng dụng. Một vài ví dụ phổ biến là yêu cầu mạng, logging, chỉnh sửa DOM thủ công, v.v.</li></ul>\r<ul><li><strong>Effect có cleanup:</strong> Một số Hook effect sẽ yêu cầu cleanup sau khi cập nhật xong DOM. Ví dụ: nếu bạn muốn thiết lập đăng ký nguồn dữ liệu bên ngoài, nó yêu cầu dọn dẹp bộ nhớ, nếu không có thể xảy ra sự cố rò rỉ bộ nhớ. Có một thực tế là React sẽ thực hiện dọn dẹp bộ nhớ khi các component unmounting. Nhưng các effect sẽ chạy mỗi phương thức <code>render()</code> hơn là cho bất kỳ phương thức cụ thể nào. Do đó, chúng ta có thể nói rằng, trước khi thực thi các hiệu ứng thời gian, React cũng sẽ dọn dẹp các hiệu ứng từ lần hiển thị trước đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Prop drilling trong React?",
              "answer": "<p>Đôi khi trong việc phát triển các ứng dụng React, cần phải truyền dữ liệu từ một thành phần cao hơn trong hệ thống phân cấp đến một thành phần được lồng sâu vào nhau. Để truyền dữ liệu giữa các thành phần như vậy, ta chuyển các props từ một thành phần nguồn và tiếp tục truyền phần hỗ trợ cho thành phần tiếp theo trong hệ thống phân cấp cho đến khi chúng ta tiếp cận thành phần được lồng sâu.\r\n\r\nHạn chế của sử dụng prop drilling là việc truy cập dữ liệu sẽ vô cùng phức tạp trong các ứng dụng lớn.</p>",
              "level": "fresher"
            },
            {
              "question": "Error boundary là gì?",
              "answer": "<p>Được giới thiệu ở React v16, error boundary cung cấp một cách để xử lý lỗi xảy ra trong giai đoạn render.\r\n\r\nBất kỳ component nào sử dụng các phương thức lifecycle cũng được xem là một error boundary. Các vị trí mà error boundary có thể được phát hiện:\r\n\r\n1. Giai đoạn Render\r\n2. Trong một phương thức lifecycle\r\n3. Trong constructor\r\n\r\n<strong>Không dùng error boundary</strong>\r\n\r\n``<code>jsx\r\nclass CounterComponent extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            counterValue: 0\r\n        }\r\n        this.incrementCounter = this.incrementCounter.bind(this);\r\n    }\r\n\r\n    incrementCounter(){\r\n        this.setState(prevState =&gt; counterValue = prevState+1);\r\n    }\r\n    render(){\r\n        if(this.state.counter === 2){\r\n            throw new Error(&#39;Crashed&#39;);\r\n        }\r\n        return(\r\n            &lt;div&gt;\r\n                &lt;button onClick={this.incrementCounter}&gt;Increment Value&lt;/button&gt;\r\n                &lt;p&gt;Value of counter: {this.state.counterValue}&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, khi </code>counterValue<code> bằng 2, ta có lỗi bên trong phương thức render.\r\n\r\nKhi không dùng error boundary, ta sẽ thấy một trang trống thay vì lỗi. Bất cứ lỗi nào trong phương thức render đều dẫn đến unmounting component. Để hiển thị lỗi khi đó, ta sử dụng error boundary.\r\n\r\n<strong>Sử dụng error boundary</strong>: error bounary là một component sử dụng một hoặc cả hai phương thức sau:\r<ul><li></code>getDerivedStateFromError<code></li></ul>\r<ul><li></code>componentDidCatch<code></li></ul>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>jsx\r\nclass ErrorBoundary extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { hasError: false };\r\n    }\r\n    static getDerivedStateFromError(error) {     \r\n        return { hasError: true }; \r\n    }\r\n    componentDidCatch(error, errorInfo) {       \r\n        logErrorToMyService(error, errorInfo); \r\n    }\r\n    render() {\r\n        if (this.state.hasError) {     \r\n            return &lt;h4&gt;Something went wrong&lt;/h4&gt;     \r\n        }\r\n        return this.props.children;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, hàm </code>getDerivedStateFromError<code> render một fallback UI interface khi phương thực render có lỗi.\r\n\r\n</code>componentDidCatch<code> ghi lại thông tin lỗi vào một dịch vụ theo dõi lỗi.\r\n\r\nBây giờ với error boundary ta có thể render CounterComponent như sau:\r\n\r\n</code>`<code>jsx\r\n&lt;ErrorBoundary&gt;\r\n    &lt;CounterComponent /&gt;\r\n&lt;/ErrorBoundary&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "React Hooks là gì?",
              "answer": "<p>React Hooks là các hàm có sẵn cho phép các nhà phát triển sử dụng các phương thức trạng thái (state) và vòng đời (lifecycle) trong các component React. Đây là những tính năng mới được bổ sung có sẵn trong phiên bản React 16.8. Mỗi lifecycle của một component có 3 giai đoạn bao gồm mount, unmount và update. Cùng với đó, các component có state và props. Hooks sẽ cho phép các nhà phát triển sử dụng các phương pháp này để cải thiện việc tái sử dụng code với tính linh hoạt cao hơn trong việc điều hướng cây component.\r\n\r\nSử dụng Hook, tất cả các tính năng của React có thể được sử dụng mà không cần viết các class component. Ví dụ, trước phiên bản React 16.8, nó yêu cầu một class component để quản lý trạng thái của một component. Nhưng bây giờ bằng cách sử dụng hook useState, chúng ta có thể giữ trạng thái trong một function component.</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao lại cần React Hook?",
              "answer": "<p>React hooks đã được giới thiệu trong phiên bản 16.8 của React. Trước đây, các function component được gọi là stateless component. Chỉ các class component mới được sử dụng cho các phương thức quản lý trạng thái và vòng đời. Nhưng vì class component quá nặng nếu như chỉ cần thay đổi một vài state hay phương thức trong lifecycle. Điều đó dẫn đến sự ra đời của React Hooks.\r\n\r\nVí dụ: sử dụng hook useState\r\n\r\n``<code>jsx\r\nfunction Person(props) {\r\n// We are declaring a state variable called name.\r\n// setName is a function to update/change the value of name\r\nlet [name, setName] = useState(&#39;&#39;);\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các quy tắc sử dụng React Hooks?",
              "answer": "<p><ul><li>Chỉ có thể gọi hooks trong function component (không thể dùng trong class).</li></ul>\r<ul><li>Chỉ có thể gọi ở cấp cao, không thể gọi trong hàm, vòng lặp hay điều kiện.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách dùng useEffect?",
              "answer": "<p>React Hook useEffect được dùng cho thực hiện side effect trong function component. Với useEffect, ta sẽ thông báo cho React biết các component của bạn yêu cầu phải thực hiện điều gì đó sau khi render component hoặc sau khi thay đổi trạng thái. Function đã được truyền sẽ được React nhớ và gọi sau khi quá trình cập nhật DOM kết thúc. Nhừo điều này ta có thể thực hiện các thao tác khác nhau như tìm nạp dữ liệu, thiệt lập tiêu đều, quản lý DOM trực tiếp,... mà không nhắm đến giá trị output. Hook useEffect sẽ chạy theo mặc định sau lần render đầu tiên và mỗi lần cập nhật component. React đảm bảo tằng DOM sẽ  được cập nhật vào thời điểm effect chạy bởi nó.\r\n\r\nuseEffect nhận vào hai thám số: <code>useEffect(callback[, dependencies]);</code>\r\n\r\nTrong đó tham số calback đầu tiên biểu diễn hàm chứa logic side-effect và sẽ thực thi ngay lập tức khi ta thực hiện thay đổi lên DOM. Tham số dependencies thứ hai biểu diễn mảng các dependencies. useEffect chỉ thực thi nếu các dependencies có thay đổi khi render.\r\n\r\nVí dụ:\r\n\r\n``<code>jsx\r\nimport { useEffect } from &#39;react&#39;;\r\n\r\nfunction WelcomeGreetings({ name }) {\r\n    const msg = </code>Hi, ${name}!<code>;     // Calculates output\r\n\r\n    useEffect(() =&gt; {\r\n        document.title = </code>Welcome to you ${name}<code>;    // Side-effect!\r\n    }, [name]);\r\n\r\n    return &lt;div&gt;{msg}&lt;/div&gt;;         // Calculates output\r\n}\r\n</code>`<code>\r\n\r\nĐoạn code trên sẽ cập nhật tiêu đề document nó được xem như một side-effect vì nó không tính toán output trực tiếp. Đó là lý do tại sao cập nhật tiêu đề document  được đặt trong callback và cung cấp cho </code>useEffect()<code>.\r\n\r\nHãy cân nhắc rằng bạn không muốn thực hiện cập nhật tiêu đề document mỗi lần render component </code>WelcomeGreetings<code> và bạn muốn nó chỉ được thực thi khi prop </code>name<code> thay đổi thì bạn cần cung cấp </code>name<code> làm phụ thuộc đến </code>useEffect(callback, [name])`.</p>",
              "level": "fresher"
            },
            {
              "question": "Sử dụng refs với React Hooks?",
              "answer": "<p>Trước đây, các ref chỉ giới hạn trong các class component nhưng giờ đây nó cũng có thể được truy cập trong các function component thông qua <code>useRef</code> trong React Hook.\r\n\r\nCác refs được sử dụng cho:\r<ul><li>Quản lý tiêu điểm, phát lại phương tiện hoặc lựa chọn văn bản.</li></ul>\r<ul><li>Tích hợp với các thư viện DOM của bên thứ ba.</li></ul>\r<ul><li>Kích hoạt các ảnh động bắt buộc.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hook tuỳ chỉnh là gì?",
              "answer": "<p>Một hook tùy chỉnh(custom hooks) là một hàm trong Javascript có tên bắt đầu bằng <strong>use</strong> và gọi các hook khác. Nó là một phần của bản cập nhật hook React v16.8 và cho phép bạn sử dụng lại logic trạng thái mà không cần phải cấu trúc lại cấu trúc phân cấp component.\r\n\r\nTrong hầu hết các trường hợp, hook tùy chỉnh được coi là đủ để thay thế render props và HoC (High-Order components) và giảm số lượng lồng ghép cần thiết. Hooks  tuỳ chỉnh sẽ cho phép bạn tránh nhiều lớp trừu tượng hoặc wrapper hell có thể đi kèm với render props và HoC.\r\n\r\nNhược điểm của Hooks tuỳ chỉnh là nó không thể được sử dụng bên trong các lớp.\r\n\r\n## Câu hỏi phỏng vấn React cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Strict mode trong React là gì?",
              "answer": "<p>StrictMode là công cụ được thêm vào ở React v16.3 để highlight các vấn đề tiềm ẩn trong React. Nó thực hiện kiểm tra bổ sung lên ứng dụng.\r\n\r\n``<code>jsx\r\nfunction App() {\r\n    return (\r\n        &lt;React.StrictMode&gt;\r\n            &lt;div classname=&quot;App&quot;&gt;\r\n                &lt;Header/&gt;\r\n                &lt;div&gt;\r\n                    Page Content\r\n                &lt;/div&gt;\r\n                &lt;Footer/&gt;\r\n            &lt;/div&gt;\r\n        &lt;/React.StrictMode&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nĐể khởi động StrictMode, thẻ </code><React.StrictMode><code> được thêm vào ứng dụng:\r\n\r\n</code>`<code>js\r\nimport React from &quot;react&quot;;\r\nimport ReactDOM from &quot;react-dom&quot;;\r\nimport App from &quot;./App&quot;;\r\nconst rootElement = document.getElementById(&quot;root&quot;);\r\nReactDOM.render(\r\n&lt;React.StrictMode&gt;\r\n  &lt;App /&gt;\r\n&lt;/React.StrictMode&gt;,\r\nrootElement\r\n);\r\n</code>`<code>\r\n\r\nStrictMode giúp giải quyết các vấn đề sau:\r<ul><li><strong>Xác định các component với phương thức lifecycle</strong></li></ul>\r<ul><li>Một số phương thức lifecycle không an toàn khi dùng bất đồng bộ trong ứng dụng react. Với thư viện bên thứ 3, thật khó để đảm bảo một số phương thức lifecycle nhất định không được dùng.</li></ul>\r<ul><li>StrictMode giúp ta bằng cách cung cấp cảnh báo với bất kỳ class component nào sử dụng phương thức lifecycle không an toàn.</li></ul>\r<ul><li><strong>Cảnh báo sử dụng chuỗi API kế thừa</strong></li></ul>\r<ul><li>Nếu sử dụng phiên bản cũ của React, <strong>callback ref</strong> được đề nghị là cách để quản lý <strong>refs</strong> thay vì dùng <strong>chuỗi refs</strong>. StringMode đưa ra cảnh báo nếu bản sử dụng chuỗi ref để quản lý refs.</li></ul>\r<ul><li><strong>Cảnh báo sử dụng findDOMNode</strong></li></ul>\r<ul><li>Phương thức </code>findDOMNode()` dùng để tìm cây của node DOM. Phương thức này đã không còn hỗ trợ trogn React. Do đó, StrictMode đưa ra cảnh báo khi ta dùng phương thức này.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Ngăn chặn re-render trong React?",
              "answer": "<p>Nguyên nhân cho re-render:\r<ul><li>Re-render một component và con của nó xảy ra khi props hoặc state của component thay đổi</li></ul>\r<ul><li>Re-render component không có cập nhật, sẽ ảnh hưởng đến hiệu suất của ứng dụng</li></ul>\r\n\r\nCách để chặn re-render:\r\n\r\n``<code>jsx\r\nclass Parent extends React.Component {\r\n    state = { messageDisplayed: false };\r\n    \r\n    componentDidMount() {\r\n        this.setState({ messageDisplayed: true });\r\n    }\r\n    \r\n    render() {\r\n        console.log(&quot;Parent is getting rendered&quot;);\r\n        return (\r\n            &lt;div className=&quot;App&quot;&gt;\r\n                &lt;Message /&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n    \r\nclass Message extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { message: &quot;Hello, this is vivek&quot; };\r\n    }  \r\n    \r\n    render() {\r\n        console.log(&quot;Message is getting rendered&quot;);\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;p&gt;{this.state.message}&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nComponent </code>Parent<code> là cha của component </code>Message<code>. Bất kỳ thay đổi nào đến </code>Parent<code> sẽ dẫn đến re-render ở cả </code>Message<code>. Để ngăn chặn điều này, ta sử dụng phương thức </code>shouldComponentUpdate()<code>:\r\n\r\n</code>`<code>jsx\r\nclass Message extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { message: &quot;Hello, this is vivek&quot; };\r\n    }\r\n\r\n    shouldComponentUpdate() {\r\n        console.log(&quot;Does not get rendered&quot;);\r\n        return false;\r\n    }\r\n\r\n    render() {\r\n        console.log(&quot;Message is getting rendered&quot;);\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;p&gt;{this.state.message}&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nNhư đã thấy, ta trả về false cho phương thức </code>shouldComponentUpdate()` ngăn chặn component con bị re-render.</p>",
              "level": "fresher"
            },
            {
              "question": "Các cách khác nhau để chỉnh style component?",
              "answer": "<p><strong>Inline Styling:</strong> ta có thể chỉnh style trực tiếp lên phần tử bằng cách dùng thuộc tính <code>style</code>. Nhớ giá trị của <code>style</code> luôn là đối tượng JavaScript:\r\n\r\n``<code>jsx\r\nclass RandomComponent extends React.Component {\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n            &lt;h3 style={{ color: &quot;Yellow&quot; }}&gt;This is a heading&lt;/h3&gt;\r\n            &lt;p style={{ fontSize: &quot;32px&quot; }}&gt;This is a paragraph&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>Javascript Object:</strong> ta có thể tạo đối tượng JavaScript và tập mô tả thuộc tính style. Các đối tượng có thể dùng như giá trị của thuộc tính style.\r\n\r\n</code>`<code>jsx\r\nclass RandomComponent extends React.Component {\r\n    paragraphStyles = {\r\n        color: &quot;Red&quot;,\r\n        fontSize: &quot;32px&quot;\r\n    };\r\n\r\n    headingStyles = {\r\n        color: &quot;blue&quot;,\r\n        fontSize: &quot;48px&quot;\r\n    };\r\n\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n            &lt;h3 style={this.headingStyles}&gt;This is a heading&lt;/h3&gt;\r\n            &lt;p style={this.paragraphStyles}&gt;This is a paragraph&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>CSS Stylesheet:</strong> Ta sẽ tạo một file CSS riêng và viết tất cả style cho component trong file đó. Sau đó import nó vào file React.\r\n\r\n</code>`<code>jsx\r\nimport &#39;./RandomComponent.css&#39;;\r\n\r\nclass RandomComponent extends React.Component {\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;h3 className=&quot;heading&quot;&gt;This is a heading&lt;/h3&gt;\r\n                &lt;p className=&quot;paragraph&quot;&gt;This is a paragraph&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>CSS Module:</strong> Tương tự như file CSS, nhưng ta sửa thành </code>.module.css<code>, với cách này tên lớp sẽ được mã hoá, đồng thời nó hỗ trợ kiểu viết tương tự sass.\r\n\r\n</code>`<code>css\r\n.paragraph{\r\n    color:&quot;red&quot;;\r\n    border:1px solid black;\r\n}\r\n</code>`<code>\r\n\r\nTa có thể import file vào component như sau:\r\n\r\n</code>`<code>jsx\r\nimport styles from  &#39;./styles.module.css&#39;;\r\n\r\nclass RandomComponent extends React.Component {\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n                &lt;h3 className=&quot;heading&quot;&gt;This is a heading&lt;/h3&gt;\r\n                &lt;p className={styles.paragraph} &gt;This is a paragraph&lt;/p&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kỹ thuật tối ưu hiệu suất ứng dụng React?",
              "answer": "<p><ul><li><strong>useMemo()</strong></li></ul>\r<ul><li>Là hook dùng cho caching CPU.</li></ul>\r<ul><li>Đôi khi trong các ứng dụng web, các hàm đắt (tính toán nhiều, tốn bộ nhớ) được gọi liên túc do re-render đẫn đến tốc độ render chậm, hiệu suất kém.</li></ul>\r<ul><li>useMemo() có thể sử dụng cho cache cám hàm như vậy. Bằng cách dùng useMemo() các hàm đó chỉ được gọi khi cần thiết.</li></ul>\r<ul><li><strong>React.PureComponent</strong></li></ul>\r<ul><li>Là class component cơ sở để kiểm tra state và props của một component để biết khi nào nó nên được cập nhật.</li></ul>\r<ul><li>Thay vì dùng React.Component, ta có sử dụng React.PureComponent để giảm việc re-render không cần thiết.</li></ul>\r<ul><li><strong>Duy trì vị trí state</strong></li></ul>\r<ul><li>Đây là quá trình chuyển state đến nơi bạn nhất có thể.</li></ul>\r<ul><li>Thỉnh thoảng ta có các state không cần thiết nằm trong component cha để gây khó đọc và bảo trì hơn, thậm chí là dẫn đến re-render không cần thiết.</li></ul>\r<ul><li>Để tốt hơn, ta chuyển các state vô nghĩa ở component cha sang một component riêng biệt.</li></ul>\r<ul><li><strong>Lazy Loading</strong></li></ul>\r<ul><li>Đây là kỹ thuật dùng để giảm thời gian tải của ứng dụng React. Lazy loading giúp tối ưu hiệu suất ứng dụng web bằng cách chỉ tải khi cần thiết.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Truyền dữ liệu giữa các component?",
              "answer": "<p><img src=\"/interview-assets/How_to_pass_data_between_react_components.png\" alt=\"\" />\r\n\r\n<strong>Từ component cha sang component con (dùng props)</strong>\r\n\r\nTa có thể làm như sau:\r\n\r\n``<code>jsx\r\nimport ChildComponent from &quot;./Child&quot;;\r\n\r\nfunction ParentComponent(props) {\r\n    let [counter, setCounter] = useState(0);\r\n    let increment = () =&gt; setCounter(++counter);\r\n   \r\n    return (\r\n        &lt;div&gt;\r\n            &lt;button onClick={increment}&gt;Increment Counter&lt;/button&gt;\r\n            &lt;ChildComponent counterValue={counter} /&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nNhư ta có thể thấy trong đoạn code trên, ta đang hiển thị component con bên trong component cha, bằng cách cung cấp một prop tên là </code>counterValue<code>. Giá trị của </code>counter<code> được chuyển từ component cha sang con.\r\n\r\nTa có thể sử dụng dữ liệu được chuyển đến component con như sau:\r\n\r\n</code>`<code>jsx\r\nfunction ChildComponent(props) {\r\n    return (\r\n        &lt;div&gt;\r\n            &lt;p&gt;Value of counter: {props.counterValue}&lt;/p&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\n<strong>Từ component con sang cha (dùng callback)</strong>\r\n\r\nTa có các bước sau:\r<ul><li>Tạo một callback trong component cha nhận dữ liệu cần thiết như tham số.</li></ul>\r<ul><li>Truyền callback này như props cho component con.</li></ul>\r<ul><li>Gửi dữ liệu từ component con bằng cách dùng callback.</li></ul>\r\n\r\nVí dụ:\r\n\r\nTạo callback và gửi nó như prop đến component con:\r\n\r\n</code>`<code>jsx\r\nfunction ParentComponent(props) {\r\n    let [counter, setCounter] = useState(0);\r\n    let callback = valueFromChild =&gt; setCounter(valueFromChild);\r\n\r\n    return (\r\n        &lt;div&gt;\r\n            &lt;p&gt;Value of counter: {counter}&lt;/p&gt;\r\n            &lt;ChildComponent callbackFunc={callback} counterValue={counter} /&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nSau đó ta truyền dữ liệu từ component con đến component cha:\r\n\r\n</code>`<code>jsx\r\nfunction ChildComponent(props) {\r\n    let childCounterValue = props.counterValue;\r\n    \r\n    return (\r\n        &lt;div&gt;\r\n            &lt;button onClick={() =&gt; props.callbackFunc(++childCounterValue)}&gt;\r\n                Increment Counter\r\n            &lt;/button&gt;\r\n        &lt;/div&gt;\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nBây giờ khi ta click vào button, ta sẽ tăng giá trị </code>childCounterValue<code> đến </code>props.callbackFunc`.</p>",
              "level": "fresher"
            },
            {
              "question": "High-Order Component là gì?",
              "answer": "<p>High-Order Component (HOC) là một hàm nhận một component làm tham số và trả về một component mới.\r\n\r\n<img src=\"/interview-assets/Higher_Order_Components.png\" alt=\"\" />\r\n\r\n<em>Tại sao lại cần HOC</em>\r\n\r\nTrong phát triển ứng dụng React, ta có thể phát triển component khá giống nhau với vài sự khác biệt nhỏ. Trong hầu hết trường hợp, việc phát triển các component tương tự không phải là vấn đề, nhưng khi ứng dụng lớn hơn, chúng ta cần giữ cho code mình DRY. Do đó, chúng ta muốn một sự trừu tượng cho phép chúng ta xác định logic này ở một nơi duy nhất và chia sẻ nó trên các component. HOC cho phép chúng ta tạo ra sự trừu tượng đó.\r\n\r\nVí dụ:\r\n\r\nComponent sau dùng để hiển thị danh sách bài viết:\r\n\r\n``<code>jsx\r\n// &quot;GlobalDataSource&quot; is some global data source\r\nclass ArticlesList extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.handleChange = this.handleChange.bind(this);\r\n        this.state = {\r\n            articles: GlobalDataSource.getArticles(),\r\n        };\r\n    }\r\n    componentDidMount() {\r\n        // Listens to the changes added\r\n        GlobalDataSource.addChangeListener(this.handleChange);\r\n    }\r\n    componentWillUnmount() {\r\n        // Listens to the changes removed\r\n        GlobalDataSource.removeChangeListener(this.handleChange);\r\n    }\r\n    handleChange() {\r\n        // States gets Update whenver data source changes\r\n        this.setState({\r\n            articles: GlobalDataSource.getArticles(),\r\n        });\r\n    }\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n                {this.state.articles.map((article) =&gt; (\r\n                    &lt;ArticleData article={article} key={article.id} /&gt;\r\n                ))}\r\n            &lt;/div&gt;\r\n        );  \r\n    }\r\n}\r\n</code>`<code>\r\n\r\nComponent sau dùng để hiển thị danh sách người dùng:\r\n\r\n</code>`<code>jsx\r\n// &quot;GlobalDataSource&quot; is some global data source\r\nclass UsersList extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.handleChange = this.handleChange.bind(this);\r\n        this.state = {\r\n            users: GlobalDataSource.getUsers(),\r\n        };\r\n    }\r\n    componentDidMount() {\r\n        // Listens to the changes added\r\n        GlobalDataSource.addChangeListener(this.handleChange);\r\n    }\r\n    componentWillUnmount() {\r\n        // Listens to the changes removed\r\n        GlobalDataSource.removeChangeListener(this.handleChange);\r\n    }\r\n    handleChange() {\r\n        // States gets Update whenver data source changes\r\n        this.setState({\r\n            users: GlobalDataSource.getUsers(),\r\n        });\r\n    }\r\n    render() {\r\n        return (\r\n            &lt;div&gt;\r\n            {this.state.users.map((user) =&gt; (\r\n                &lt;UserData user={user} key={user.id} /&gt;\r\n            ))}\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nBây giờ ta có hai component có chức năng giống nhau chỉ khác về API được gọi. Ta sẽ tạo một HOC dùng chung cho cả hai:\r\n\r\n</code>`<code>jsx\r\n// Higher Order Component which takes a component\r\n// as input and returns another component\r\n// &quot;GlobalDataSource&quot; is some global data source\r\nfunction HOC(WrappedComponent, selectData) {\r\n    return class extends React.Component {\r\n        constructor(props) {\r\n            super(props);\r\n            this.handleChange = this.handleChange.bind(this);\r\n            this.state = {\r\n                data: selectData(GlobalDataSource, props),\r\n            };\r\n        }\r\n        componentDidMount() {\r\n            // Listens to the changes added\r\n            GlobalDataSource.addChangeListener(this.handleChange);\r\n        }\r\n        componentWillUnmount() {\r\n            // Listens to the changes removed\r\n            GlobalDataSource.removeChangeListener(this.handleChange);\r\n        }\r\n        handleChange() {\r\n            this.setState({\r\n            data: selectData(GlobalDataSource, this.props),\r\n            });\r\n        }\r\n        render() {\r\n            // Rendering the wrapped component with the latest data data\r\n            return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt;;\r\n        }\r\n    };\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên ta tạo HOC trả về một component và thực hiện vài hành động có thể dùng chung trên cả component </code>ArticleList<code> và </code>UsersList<code>.\r\n\r\nTham số thứ hai là hàm gọi cho phương thức trên API.\r\n\r\nTa đã giảm code trùng lặp giữa </code>componentDidUpdate<code> và </code>componentDidMount<code>. Bây giờ ta có component </code>ArticleList<code> và </code>UsersList<code> như sau:\r\n\r\n</code>`<code>jsx\r\nconst ArticlesListWithHOC = HOC(ArticlesList, (GlobalDataSource) =&gt; GlobalDataSource.getArticles());\r\nconst UsersListWithHOC = HOC(UsersList, (GlobalDataSource) =&gt; GlobalDataSource.getUsers());\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các giai đoạn trong vòng đời component?",
              "answer": "<p>Có 3 giai đoạn trong vòng đời component React.\r<ul><li><strong>Mounting</strong>: đề cập đến việc đưa phần tử vào DOM của trình duyệt. Vì React dùng virtual DOM, toàn bộ DOM của trình duyệt đã render sẽ không được làm mới. Bao gồm các phương thức trong giai đoạn này bao gồm: <code>constructor</code> và <code>componentDidMount</code>.</li></ul>\r<ul><li><strong>Updating</strong>: Trong giai đoạn này, component sẽ được cập nhật khi có thay đổi state hoặc props của component. Các phương thức trong giai đoạn này: <code>getDerivedStateFromProps</code>, <code>shouldComponentUpdate</code>, <code>render</code>, và <code>componentDidUpdate</code>.</li></ul>\r<ul><li><strong>Unmounting</strong>: Ở giai đoạn cuối, component sẽ bị xoá khỏi DOM. Giai đoạn này  sẽ có phương thức là <code>componentWillUnmount</code>.</li></ul>\r\n\r\n<img src=\"/interview-assets/different_phases_of_the_component_lifecycle.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các phương thức trong vòng đời component?",
              "answer": "<p>Trong vòng đời của React sẽ có các phương thức sẽ được gọi tự động ở các giai đoạn khác nhau trong vòng đời của component và do đó nó cung cấp khả năng kiểm soát tốt những gì xảy ra tại điểm được gọi. Nó cung cấp năng lực để kiểm soát và thao tác hiệu quả những gì diễn ra trong suốt vòng đời của component.\r\n\r\nVí dụ: nếu bạn đang phát triển ứng dụng YouTube, thì ứng dụng sẽ sử dụng mạng để đệm video và nó tiêu tốn pin (giả sử chỉ có hai mạng này). Sau khi phát video, nếu người dùng chuyển sang bất kỳ ứng dụng nào khác, thì bạn nên đảm bảo rằng các tài nguyên như mạng và pin đang được sử dụng hiệu quả nhất. Bạn có thể dừng hoặc tạm dừng tải video vào bộ đệm, do đó sẽ ngừng sử dụng pin và mạng khi người dùng chuyển sang ứng dụng khác sau khi phát video.\r\n\r\nVì vậy, chúng ta có thể nói rằng nhà phát triển sẽ có thể tạo ra một ứng dụng chất lượng với sự trợ giúp của các phương pháp vòng đời và nó cũng giúp các nhà phát triển đảm bảo lập kế hoạch những gì và làm như thế nào tại các thời điểm sinh, phát triển hoặc chết của giao diện người dùng.\r\n\r\nCác phương thức trong vòng đời:\r<ul><li><code>constructor()</code>: phương thức được gọi khi component được tạo trước khi thực hiện bất kỳ hành động gì. Nó giúp tạo state và props.</li></ul>\r<ul><li><code>getDerivedStateFromProps()</code>: nó sẽ gọi trước khi phần tử được render vào DOM. Nó giúp thiết lập đối tượng state dựa trên props khởi tạo. Phương thức <code>getDerivedStateFromProps</code> sẽ có một state như đối số và trả về một đối tượng để thay đổi state. Nó sẽ là phương thức đầu tiên được gọi khi thực hiện cập nhật.</li></ul>\r<ul><li><code>render()</code>: phương thức này sẽ render HTML từ DOM với thay đổi mới nhất. Phương thức <code>render</code> sẽ được gọi mỗi khi có thay đổi đến component.</li></ul>\r<ul><li><code>componentDidMount()</code>: phương thức sẽ được gọi sau khi render component. Ta có thể chạy lệnh cần component đã được lưu trong DOM.</li></ul>\r<ul><li><code>shouldComponentUpdate()</code>: trả về giá trị boolean để quyết định xem có render hay không. Mặc định sẽ là True.</li></ul>\r<ul><li><code>getSnapshotBeforeUpdate()</code>: cung cáp truy cập cho props cung như state trước khi cập nhật. Nó dùng cho kiểm tra giá trị trước khi cập nhật.</li></ul>\r<ul><li><code>componentDidUpdate()</code>: được gọi sau khi cập nhật component trong DOM.</li></ul>\r<ul><li><code>componentWillUnmount()</code>: phương thức được gọi khi component bị xoá khỏi DOM.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "React hook có làm việc với static typing?",
              "answer": "<p>Static typing đề cập đến quá trình kiểm tra code trong suốt thời gian biên dịch để đảm bảo mọi biến đề sẽ được nhập. React Hook là hàm được thiết kế để đảm bảo mọi thuộc tính sẽ được nhập tĩnh. Để thực thi nhập tĩnh chặt chẽ hơn trong code, ta có thể sử dụng API React với các Hook tùy chỉnh.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu Hooks trong React?",
              "answer": "<p><strong>Hook có sẵn</strong>: là các hooks được hỗ trợ sẵn trong React:\r<ul><li><strong>Hook cơ bản</strong>:</li></ul>\r<ul><li><code>useState()</code>: là component dùng cho thiết lập và chỉnh sửa state.</li></ul>\r<ul><li><code>useEffect()</code>: cho phép thực hiện side effect trên function component.</li></ul>\r<ul><li><code>useContext()</code>: dùng cho tạo dữ liệu chung có thể truy cập trong hệ phân cấp component mà không cần truyền dữ liệu theo props từ trên xuống.</li></ul>\r<ul><li><strong>Hook nâng cao</strong>:</li></ul>\r<ul><li><code>useReducer()</code>: dùng cho các logic state phức tạp có nhiều giá trị con khi cập nhật state phụ thuộc vào state trước đó. Nó sẽ giúp tối ưu hoá hiệu suất component khi kích hoạt các bản cập nhật sâu hơn vì nó được truyền xuống thay vì callback.</li></ul>\r<ul><li><code>useMemo()</code>: điều này sẽ được sử dụng để tính toán lại giá trị đã ghi nhớ khi có sự thay đổi trong một trong các phần phụ thuộc. Việc tối ưu hóa này sẽ giúp tránh các tính toán tốn kém trên mỗi lần render.</li></ul>\r<ul><li><code>useCallback()</code>: hữu ích khi truyền callback vào component con đã tối ưu hoá và phụ thuộc vào tham chiếu để ngăn chặn các render không cần thiết.</li></ul>\r<ul><li><code>useImperativeHandle()</code>: cho phép chỉnh sửa thực thể sẽ được truyền cho đối tượng ref.</li></ul>\r<ul><li><code>useDebugValue()</code>: dùng cho hiển thị nhãn hoặc hook tuỳ chỉnh trong React DevTools.</li></ul>\r<ul><li><code>useRef()</code>: Nó sẽ cho phép tạo một tham chiếu đến phần tử DOM trực tiếp trong function component.</li></ul>\r<ul><li><code>useLayoutEffect()</code>: dùng cho đọc bố cục từ DOM và re-render bất đồng bộ.</li></ul>\r\n\r\n<strong>Hook tuỳ chỉnh</strong>: là một hàm JavaScript. Hoạt động giống như một hàm thông thường với \"use\" phía trước để React hiểu đó là một hook tuỳ chỉnh và sẽ mô tả các hàm đặc biệt theo quy tắc của Hook. Hơn thế nữa, việc phát triển hook tuỳ chỉnh cho phép bạn trích xuất logic component trong các hàm có thể tái sử dụng\r\n\r\n<img src=\"/interview-assets/types_of_Hooks_in_React.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa lớp và React Hook?",
              "answer": "<p>| React Hook | Lớp |\r\n|-|-|\r\n| Được dùng cho function component | Được dùng cho class component |\r\n| Không yêu cầu khai báo constructor | Cần constructor trong các class component |\r\n| Không yêu cầu con trỏ this cho khai báo hay chỉnh sửa | Cần dùng this cho khai báo state (this.state) và chỉnh sửa (this.setState()) |\r\n| Dễ sử dụng với useState | Không có hàm cụ thể giúp ta truy cập state với setState tương ứng |\r\n| Hữu dụng khi triển khai Redux và Context API | Quá trình thiết lập state lâu, nên class state sẽ không được ưu tiên |</p>",
              "level": "fresher"
            },
            {
              "question": "Hiệu suất của React Hook so với lớp?",
              "answer": "<p><ul><li>React Hooks sẽ tránh được rất nhiều chi phí như tạo thực thể, liên kết các sự kiện, .., có trong các lớp.</li></ul>\r<ul><li>Các hook trong React sẽ dẫn đến các cây component nhỏ hơn vì chúng sẽ tránh được việc lồng nhau tồn tại trong HOC và sẽ render props dẫn đến việc React phải thực hiện ít công việc hơn.r</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các hook có thay thế được lớp hoàn toàn?",
              "answer": "<p>Mục đích của Hook là thay thế các chức năng được cung cấp bởi lớp. Nhưng có các phương thức mà Hook vẫn chưa thay thế được lớp:\r<ul><li><code>getSnapshotBeforeUpdate()</code></li></ul>\r<ul><li><code>getDerivedStateFromError()</code></li></ul>\r<ul><li><code>componentDidCatch()</code></li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "React Router là gì?",
              "answer": "<p>React Router đề cập đến thư viện tiêu chuẩn được sử dụng để định tuyến trong React. Nó cho phép chúng tôi xây dựng một ứng dụng web trong React với điều hướng mà không cần làm mới trang khi người dùng điều hướng. Nó cũng cho phép thay đổi URL của trình duyệt và sẽ giữ cho giao diện người dùng đồng bộ với URL. React Router sẽ sử dụng cấu trúc component để gọi các component, sử dụng thông tin thích hợp có thể được hiển thị.\r\n\r\nCài đặt với npm:\r\n\r\n``<code>\r\nnpm install react-router-dom\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "React Hook có thể thay thế Redux?",
              "answer": "<p>React Hook không thể được coi là sự thay thế cho Redux (Nó là một thư viện JavaScript mã nguồn mở, hữu ích trong việc quản lý trạng thái ứng dụng) khi nói đến việc quản lý toàn bộ state trong các ứng dụng phức tạp lớn, mặc dù React sẽ cung cấp một hook <code>useReducer</code> quản lý các chuyển đổi trạng thái tương tự như Redux. Nhưng Redux hữu ích ở cấp độ thấp hơn của hệ thống phân cấp component để xử lý các phần của state phụ thuộc vào nhau, thay vì khai báo nhiều hook <code>useState</code>.\r\n\r\nTrong các ứng dụng web thương mại lớn hơn, độ phức tạp sẽ cao, vì vậy chỉ sử dụng React Hook có thể không đủ. Một số nhà phát triển sẽ cố gắng giải quyết thách thức với sự trợ giúp của React Hooks và những người khác sẽ kết hợp React Hooks với Redux.</p>",
              "level": "fresher"
            },
            {
              "question": "Render có điều kiện trong React?",
              "answer": "<p>Render có điều kiện đề cập kết quả động của giao diện người dùng dựa trên điều kiện state. Nó hoạt động tương tự điều kiện JavaScript. Sử dụng render có điều kiện, nó có thể chuyển đổi các hàm ứng dụng cụ thể, API dữ liệu, ẩn hoặc hiện các phần tử, phân quyền, xử lý xác thức,...\r\n\r\nCác cách khác nhau cho triển khai render có điều kiện trong React:\r<ul><li>Sử dụng if-else phù hợp với các ứng dụng vừa và nhỏ.</li></ul>\r<ul><li>Sử dụng toán tử ba ngôi (<code>?:</code>) giúp giảm bớt câu lệnh if-else phức tạp.</li></ul>\r<ul><li>Sử dụng biến phần tử, phù hợp cho viết code sạch.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa NavLink và Link?",
              "answer": "<p><code>&lt;Link&gt;</code> dùng cho điều hướng các trang khác nhau trong ứng dụng web. Còn <code>&lt;NavLink&gt;</code> được dùng để thêm thuộc tính cho hoạt động chuyển hướng.\r\n\r\n<strong>Cú pháp</strong>\r<ul><li>Link:</li></ul>\r\n\r\n``<code>jsx\r\n&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;\r\n</code>`<code>\r<ul><li>NavLink:</li></ul>\r\n\r\n</code>`<code>jsx\r\n&lt;NavLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;Home&lt;/NavLink&gt;\r\n</code>`<code>\r\n\r\n<strong>Ví dụ</strong>\r\n\r\nindex.css\r\n\r\n</code>`<code>css\r\n.active {\r\n  color: blue;\r\n}\r\n</code>`<code>\r\n\r\nRoutes.js\r\n\r\n</code>`<code>jsx\r\nimport ReactDOM from &#39;react-dom&#39;\r\nimport &#39;./index.css&#39;\r\nimport { Route, NavLink, BrowserRouter as Router, Switch } from &#39;react-router-dom&#39;\r\nimport App from &#39;./App&#39;\r\nimport Users from &#39;./users&#39;\r\nimport Contact from &#39;./contact&#39;\r\nimport Notfound from &#39;./notfound&#39;\r\n\r\nconst Routes = (\r\n    &lt;Router&gt;\r\n        &lt;div&gt;\r\n            &lt;ul&gt;\r\n                &lt;li&gt;\r\n                &lt;NavLink exact activeClassName=&quot;active&quot; to=&quot;/&quot;&gt;\r\n                    Home\r\n                &lt;/NavLink&gt;\r\n                &lt;/li&gt;\r\n                &lt;li&gt;\r\n                &lt;NavLink activeClassName=&quot;active&quot; to=&quot;/users&quot;&gt;\r\n                    Users\r\n                &lt;/NavLink&gt;\r\n                &lt;/li&gt;\r\n                &lt;li&gt;\r\n                &lt;NavLink activeClassName=&quot;active&quot; to=&quot;/contact&quot;&gt;\r\n                    Contact\r\n                &lt;/NavLink&gt;\r\n                &lt;/li&gt;\r\n            &lt;/ul&gt;\r\n            &lt;hr /&gt;\r\n            &lt;Switch&gt;\r\n                &lt;Route exact path=&quot;/&quot; component={App} /&gt;\r\n                &lt;Route path=&quot;/users&quot; component={Users} /&gt;\r\n                &lt;Route path=&quot;/contact&quot; component={Contact} /&gt;\r\n                &lt;Route component={Notfound} /&gt;\r\n            &lt;/Switch&gt;\r\n        &lt;/div&gt;\r\n    &lt;/Router&gt;\r\n)\r\n\r\nReactDOM.render(Routes, document.getElementById(&#39;root&#39;))\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "withRouter trong react-router-dom là gì?",
              "answer": "<p><code>withRouter()</code> là một HOC cho phép truy cập thuộc tính đối tượng <code>history</code> ứng với <code>&lt;Route&gt;</code> gần nhất. Nó sẽ truyền <code>match</code>, <code>location</code> và <code>history</code> như props đến component được bọc bất cứ khi nào nó render.\r\n\r\nVí dụ:\r\n\r\n``<code>jsx\r\nimport React from &quot;react&quot;\r\nimport PropTypes from &quot;prop-types&quot;\r\nimport { withRouter } from &quot;react-router&quot;\r\n\r\n// A simple component that shows the pathname of the current location\r\nclass ShowTheLocation extends React.Component {\r\n    static propTypes = {\r\n        match: PropTypes.object.isRequired,\r\n        location: PropTypes.object.isRequired,\r\n        history: PropTypes.object.isRequired\r\n    }\r\n\r\n    render() {\r\n        const { match, location, history } = this.props\r\n\r\n        return &lt;div&gt;You are now at {location.pathname}&lt;/div&gt;\r\n    }\r\n}\r\n\r\nconst ShowTheLocationWithRouter = withRouter(ShowTheLocation)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách hiển thị dữ liệu API với Axios?",
              "answer": "<p>Axios là một promise dựa trên HTTP để tạo yêu cầu HTTP đến trình duyệt hay web server.\r\n\r\n<strong>Tính năng</strong>\r<ul><li><strong>Interceptors</strong>: Truy cập cấu hình yêu cầu hoặc phản hồi (header, dữ liệu, v.v.) khi chúng gửi đến hoặc đi. Các hàm này có thể hoạt động như các cổng để kiểm tra cấu hình hoặc thêm dữ liệu.</li></ul>\r<ul><li><strong>Instances</strong>: Tạo thực thể có thể tái sử dụng như baseUrl, headers, và cấu hình khác đã thiết lập.</li></ul>\r<ul><li><strong>Defaults</strong>: Thiết lập giá trị chung cho header chung (như Authorization) với các yêu cầu. Nó hữu ích khi bạn cần xác thực đến server trên mọi yêu cầu.</li></ul>\r\n\r\n<strong>Cài đặt</strong>\r\n\r\n``<code>\r\nnpm install axios -- save\r\n</code>`<code>\r\n\r\nCác phương thức thường dùng:\r<ul><li></code>axios.request(config)<code></li></ul>\r<ul><li></code>axios.get(url[, config])<code></li></ul>\r<ul><li></code>axios.delete(url[, config])<code></li></ul>\r<ul><li></code>axios.head(url[, config])<code></li></ul>\r<ul><li></code>axios.options(url[, config])<code></li></ul>\r<ul><li></code>axios.post(url[, data[, config]])<code></li></ul>\r<ul><li></code>axios.put(url[, data[, config]])<code></li></ul>\r<ul><li></code>axios.patch(url[, data[, config]])<code></li></ul>\r\n\r\nVí dụ POST:\r\n\r\n</code>`<code>js\r\n\r\naxios.post(&#39;/url&#39;,{data: &#39;data&#39;})\r\n    .then((res)=&gt;{\r\n        //on success\r\n    })\r\n    .catch((error)=&gt;{\r\n        //on error\r\n    })\r\n</code>`<code>\r\n\r\nVí dụ GET:\r\n\r\n</code>`<code>js\r\naxios.get(&#39;/url&#39;)\r\n    .then((res)=&gt;{\r\n        //on success\r\n    })\r\n    .catch((error)=&gt;{\r\n        //on error\r\n    })\r\n</code>`<code>\r\n\r\nXử lý nhiều yêu cầu đồng thời:\r\n\r\n</code>`<code>js\r\nfunction getUserAccount() {\r\n    return axios.get(&#39;/user/12345&#39;)\r\n}\r\n\r\nfunction getUserPermissions() {\r\n    return axios.get(&#39;/user/12345/permissions&#39;)\r\n}\r\n\r\naxios.all([getUserAccount(), getUserPermissions()])\r\n    .then(axios.spread(function (acct, perms) {\r\n        // Both requests are now complete\r\n    }))\r\n</code>`<code>\r\n\r\nPOST trong Component:\r\n\r\n</code>`<code>jsx\r\nimport React from &#39;react&#39;\r\nimport axios from &#39;axios&#39;\r\n\r\nexport default class PersonList extends React.Component {\r\n    state = {\r\n        name: &#39;&#39;,\r\n    }\r\n\r\n    handleChange = event =&gt; {\r\n        this.setState({ name: event.target.value })\r\n    }\r\n\r\n    handleSubmit = event =&gt; {\r\n        event.preventDefault()\r\n\r\n        const user = {\r\n        name: this.state.name\r\n        }\r\n\r\n        axios.post(</code>https://jsonplaceholder.typicode.com/users<code>, { user })\r\n        .then(res =&gt; {\r\n            console.log(res)\r\n            console.log(res.data)\r\n        })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n        &lt;div&gt;\r\n            &lt;form onSubmit={this.handleSubmit}&gt;\r\n            &lt;label&gt;\r\n                Person Name:\r\n                &lt;input type=&quot;text&quot; name=&quot;name&quot; onChange={this.handleChange} /&gt;\r\n            &lt;/label&gt;\r\n            &lt;button type=&quot;submit&quot;&gt;Add&lt;/button&gt;\r\n            &lt;/form&gt;\r\n        &lt;/div&gt;\r\n        )\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Caching trong React?",
              "answer": "<p>Ta có thể caching dữ liệu trong React bằng nhiều cách như:\r<ul><li>Local Storage</li></ul>\r<ul><li>Redux Store</li></ul>\r<ul><li>Giữa dữ liệu giữa mounting và unmounting</li></ul>\r\n\r\nMemoization là một kỹ thuật mà chúng ta sẽ sử dụng để đảm bảo rằng chúng ta không gặp phải API nếu chúng tôi đã thực hiện một số loại yêu cầu tìm nạp nó ở một số giai đoạn đầu tiên. Việc lưu trữ kết quả của các cuộc gọi tốn kém sẽ tiết kiệm thời gian tải cho người dùng, nhờ đó tăng hiệu suất tổng thể.\r\n\r\nVí dụ:\r\n\r\n``<code>jsx\r\nconst cache = {}\r\n\r\nconst useFetch = (url) =&gt; {\r\n    const [status, setStatus] = useState(&#39;idle&#39;)\r\n    const [data, setData] = useState([])\r\n\r\n    useEffect(() =&gt; {\r\n        if (!url) return\r\n\r\n        const fetchData = async () =&gt; {\r\n            setStatus(&#39;fetching&#39;)\r\n\r\n            if (cache[url]) {\r\n                const data = cache[url]\r\n                setData(data)\r\n                setStatus(&#39;fetched&#39;)\r\n            } else {\r\n                const response = await fetch(url)\r\n                const data = await response.json()\r\n                cache[url] = data // set response in cache\r\n                setData(data)\r\n                setStatus(&#39;fetched&#39;)\r\n            }\r\n        }\r\n\r\n        fetchData()\r\n    }, [url])\r\n\r\n    return { status, data }\r\n}\r\n</code>``\r\n\r\nỞ đây ta ánh xạ URL tới dữ liệu của ta. Nếu ta thực hiện yêu cầu nạp dữ liệu hiện có, chúng ta sẽ lấy dữ liệu từ cache cục bộ của mình. Nếu không, ta tiếp tục thực hiện yêu cầu và đặt kết quả vào cache. Điều này đảm bảo tằng ta không gọi lại API khi đã có dữ liệu cục bộ.\r\n\r\n#</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "nuxtjs",
          "name": "Câu hỏi phỏng vấn Nuxt.js 3",
          "description": "40 câu hỏi phỏng vấn Nuxt.js 3 cấp độ Senior",
          "questions": []
        },
        {
          "id": "jest",
          "name": "Câu hỏi phỏng vấn Jest Testing",
          "description": "Tổng hợp câu hỏi phỏng vấn về Jest - JavaScript Testing Framework",
          "questions": []
        },
        {
          "id": "typescript",
          "name": "Câu hỏi phỏng vấn TypeScript",
          "description": "",
          "questions": [
            {
              "question": "Các kiểu nguyên thuỷ trong TypeScript?",
              "answer": "<p>Trong TypeScript có loại kiểu dữ liệu là kiểu có sẵn (built-in) và kiểu người dùng định nghĩa (user-defined).\r\n\r\n<em> Built-in:\r<ul><li>string</li></ul>\r<ul><li>number</li></ul>\r<ul><li>boolean</li></ul>\r<ul><li>void</li></ul>\r<ul><li>symbol</li></ul>\r<ul><li>null & undefined</li></ul>\r\n</em> User-defined:\r<ul><li>arrays</li></ul>\r<ul><li>enums</li></ul>\r<ul><li>classes</li></ul>\r<ul><li>interfaces</li></ul>\r\n\r\n<img src=\"/interview-assets/Typescript_Types.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cách mảng làm việc trong TypeScript?",
              "answer": "<p>Ta sử dụng mảng cho lưu trữ các giá trị cùng kiểu. Mảng là tập hợp giá trị có thứ tự và được đánh chỉ mục. Phần tử đầu tiên có chỉ mục là 0, kế tiếp là 1, ....\r\n\r\nCú pháp khai báo và khởi tạo mảng trong TypeScript:\r\n\r\n``<code>ts\r\nlet values: number[] = [];\r\nvalues[0] = 10;\r\nvalues[1] = 20;\r\nvalues[2] = 30;\r\n</code>`<code>\r\n\r\nTa có thể tạo mảng với cú pháp đơn giản hơn:\r\n\r\n</code>`<code>ts\r\nlet values: number[] = [15, 20, 25, 30];\r\n</code>`<code>\r\n\r\nHoặc là dùng từ khoá Array:\r\n\r\n</code>`<code>ts\r\nlet values: Array&lt;number&gt; = [15, 20, 25, 30];\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu any là gì?",
              "answer": "<p>Khi bạn muốn lưu một biến mà không biết trước kiểu của biến đó. Ví dụ, giá trị từ lệnh gọi API hoặc đầu vào người dùng. Kiểu <code>any</code> cho phép gán bất kỳ giá trị nào cho biến.\r\n\r\n``<code>ts\r\nlet person: any = &quot;Foo&quot;;\r\n</code>`<code>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>ts\r\n// json may come from a third-party API\r\nconst employeeData: string = </code>{\"name\": \"John Doe\", \"salary\": 60000}<code>;\r\n\r\n// parse JSON to build employee object\r\nconst employee: any = JSON.parse(employeeData);\r\n\r\nconsole.log(employee.name);\r\nconsole.log(employee.salary);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu void là gì?",
              "answer": "<p>Void cho biết sự vắng mặt của kiểu với biến. Nó hoạt động như đối lập với bất kỳ kiểu nào. Nó hữu ích cho các hàm không trả về giá trị.\r\n\r\n``<code>ts\r\nfunction notify(): void {\r\n    alert(&quot;The user has been notified.&quot;);\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu unknown là gì?",
              "answer": "<p>Kiểu unknown là kiểu đối chứng với kiểu any. Bạn có thể gán cho kiểu unknown với bất cứ thứ gì , nhưng không thể gán bất kỳ thứ gì bằng kiểu unknown (có thể khi ta thu hẹp kiểu dựa trên luồng điều khiển). Bạn không thể thực hiện bất kỳ thao tác nào trên một biến thuộc kiểu unknown mà không xác định trước loại cụ thể của biến đó.\r\n\r\nHãy xem xét ví dụ sau. Chúng ta tạo biến unknown <code>foo</code> và gán giá trị chuỗi cho nó. Nếu chúng ta cố gắng gán biến unknown vào một biến chuỗi <code>bar</code>, trình biên dịch sẽ báo lỗi.\r\n\r\n``<code>ts\r\nlet foo: unknown = &quot;Akshay&quot;;\r\nlet bar: string = foo; // Type &#39;unknown&#39; is not assignable to type &#39;string&#39;.(2322)\r\n</code>`<code>\r\n\r\nBạn có thể thu hẹp một biến của một kiểu unknown thành một kiểu gì đó cụ thể bằng cách thực hiện kiểm tra kiểu hoặc kiểm tra so sánh hoặc sử dụng bảo vệ kiểu. Ví dụ: chúng ta có thể loại bỏ lỗi trên bằng cách\r\n\r\n</code>`<code>ts\r\nlet foo: unknown = &quot;Akshay&quot;;\r\nlet bar: string = foo as string;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các cách khai báo biến trong TypeScript?",
              "answer": "<p><strong>var</strong> khai báo một biến cục bộ hoặc toàn cục. Bạn có thể thiết lập giá trị khi khai báo. Các hành vi và phạm vi của nó tương tự với ở JavaScript. Ví dụ:\r\n\r\n``<code>ts\r\nvar foo = &quot;bar&quot;;\r\n</code>`<code>\r\n\r\n<strong>let</strong> khai báo biến cục bộ. Tương tự var, bạn có thể thiết lập giá trị biến khi khai báo. Ví dụ:\r\n\r\n</code>`<code>ts\r\nlet a = 5;\r\n\r\nif (true) {\r\n    let a = 10;\r\n    console.log(a);  // 10\r\n}\r\nconsole.log(a);  // 5\r\n</code>`<code>\r\n\r\n<strong>const</strong> khai báo hằng cục bộ không thể thay đổi sau khi khởi tạo.\r\n\r\n</code>`<code>ts\r\nconst a = 5;\r\n\r\nif (true) {\r\n    a = 10; // Error: Cannot assign to &#39;a&#39; because it is a constant.(2588)\r\n} \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cung cấp cú pháp cho hàm với chú thích kiểu?",
              "answer": "<p>Hàm là các khối code để thực hiện một code cụ thể. Các hàm có thể tùy ý nhận một hoặc nhiều tham số, xử lý chúng và tùy chọn trả về một giá trị. Trong TypeScript hàm cần có chú thích kiểu là kiểu giá trị trả về của hàm.\r\n\r\n``<code>ts\r\nfunction greet(name: string): string {\r\n  return </code>Hello, ${name}<code>;\r\n}\r\n\r\nlet greeting = greet(&quot;Anders&quot;);\r\nconsole.log(greeting);  // &quot;Hello, Anders&quot;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách tạo đối tượng trong TypeScript?",
              "answer": "<p>Đối tượng là một tập hợp key/value. Key là duy nhất. Nó gần tương đồng với mảng nên còn gọi là mảng liên kết. Tuy nhiên, mảng sử dụng key/chỉ mục là giá trị số, trong khi đối tượng cho phép bất kỳ kiểu dữ liệu nào là key.\r\n\r\nTrong TypeScript, kiểu đối tượng đề cập đến bất kỳ thuộc tính nào. Nó có thể định nghĩa danh sách thuộc tính và kiểu của nó. Ví dụ:\r\n\r\n``<code>ts\r\nlet pt: { x: number; y: number } = {\r\n  x: 10,\r\n  y: 20\r\n};\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tuỳ chọn thuộc tính trong TypeScript?",
              "answer": "<p>Một đối tượng có thể có thuộc tính tuỳ chọn (có hoặc không có) bằng cách thêm <code>?</code> sau tên thuộc tính.\r\n\r\n``<code>ts\r\nlet pt: { x: number; y: number; z?: number } = {\r\n  x: 10,\r\n  y: 20\r\n};\r\nconsole.log(pt);\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, thuộc tính </code>z` là tuỳ chọn, trình biên dịch không bắt buộc ta cung cấp khi khởi tạo đối tượng.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích khái niệm null trong TypeScript?",
              "answer": "<p>Trong lập trình, giá trị null cho biết không có giá trị. Một biến null không trỏ đến bất kỳ đối tượng nào. Do đó, bạn không thể truy cập bất kỳ thuộc tính nào trên biến hoặc gọi một phương thức trên đó.\r\n\r\nTrong TypeScript, giá trị null được chỉ định bằng từ khoá <code>null</code>. Ví dụ\r\n\r\n``<code>ts\r\nfunction greet(name: string | null) {\r\n    if (name === null) {\r\n        console.log(&quot;Name is not provided&quot;);\r\n    } else {\r\n        console.log(&quot;Good morning, &quot; + name.toUpperCase());\r\n    }\r\n}\r\n\r\nvar foo = null;\r\ngreet(foo); // &quot;Name is not provided&quot;\r\n\r\nfoo = &quot;Anders&quot;;\r\ngreet(foo);  // &quot;Good morning, ANDERS&quot;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "undefined trong TypeScript là gì?",
              "answer": "<p>Khi một biến được khai báo mà không tạo giá trị, nó sẽ được gán giá trị undefined. \r\n\r\n``<code>ts\r\nconsole.log(null == null); // true\r\nconsole.log(undefined == undefined); // true\r\nconsole.log(null == undefined); // true, with type-conversion\r\nconsole.log(null === undefined); // false, without type-conversion\r\nconsole.log(0 == undefined); // false\r\nconsole.log(&#39;&#39; == undefined); // false\r\nconsole.log(false == undefined); // false\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích kiểu never trong TypeScript?",
              "answer": "<p>Kiểu never trong TypeScript là một kiểu không chứa giá trị. Do đó, bạn không thể gán bất kỳ giá trị nào cho biến có kiểu never.\r\n\r\n``<code>ts\r\nfunction error(message: string): never {\r\n    throw new Error(message);\r\n}\r\n</code>`<code>\r\n\r\nCâu hỏi đặt ra là tại sao cần kiểu </code>never<code> khi ta đã có </code>void<code>. Vì cả hai khá giống nhau, nhưng thực sự chúng lại là đại diện cho hai khái niệm khác nhau.\r\n\r\nMột hàm không trả về một giá trị nào ngầm hiểu là giá trị undefined trong JavaScript. Do đó, khi ta dùng </code>void<code> với một hàm thực tế nó vẫn nhận về kiểu undefined. Để đảm bảo hàm không nhận bất cứ giá trị nào, kiểu </code>never<code> được dùng cho những trường hợp như vậy.\r\n\r\n</code>`<code>ts\r\nconst test = (arg): void =&gt; {\r\n    console.log(arg)\r\n}\r\n\r\nconsole.log(test(&#39;test&#39;))\r\n\r\n// &quot;test&quot;\r\n// undefined\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách enum hoạt động trong TypeScript?",
              "answer": "<p>Enums cho phép chúng ta tạo các hằng số được đặt tên. Đây là một cách đơn giản để đặt tên thân thiện hơn cho các giá trị hằng số. Một enum được định nghĩa bởi từ khóa enum, theo sau là tên và các thành viên của nó.\r\n\r\nVí dụ:\r\n\r\n``<code>ts\r\nenum Team {\r\n    Alpha,\r\n    Beta,\r\n    Gamma,\r\n    Delta\r\n}\r\n\r\nlet t: Team = Team.Delta;\r\n</code>`<code>\r\n\r\nMặc định, enum bắt đầu đánh số từ 0. Bạn có thể ghi đè lên giá trị mặc định bằng cách gán giá trị cho các thành viên của nó. Ví dụ:\r\n\r\n</code>`<code>ts\r\nenum Author {\r\n  Anders = &quot;Anders&quot;,\r\n  Hejlsberg = &quot;Hejlsberg&quot;\r\n};\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Toán tử typeof trong TypeScript là gì?",
              "answer": "<p>Tương tự JavaScript, đây là toán tử trả về kiểu dữ liệu của toán hạng.\r\n\r\n``<code>ts\r\nconsole.log(typeof 10);  // &quot;number&quot;\r\n\r\nconsole.log(typeof &#39;foo&#39;);  // &quot;string&quot;\r\n\r\nconsole.log(typeof false);  // &quot;boolean&quot;\r\n\r\nconsole.log(typeof bar);  // &quot;undefined&quot;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tham số còn lại trong TypeScript?",
              "answer": "<p>Tham số còn lại (<code>...</code>) cho phép một hàm nhận một lượng không giới hạn tham số như là một mảng. \r\n\r\n``<code>ts\r\nfunction add(...values: number[]) {\r\n    let sum = 0;\r\n    values.forEach(val =&gt; sum += val);\r\n    \r\n    return sum;\r\n}\r\n\r\nconst sum = add(5, 10, 15, 20);\r\nconsole.log(sum);  // 50\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tham số destructuring là gì?",
              "answer": "<p>Tham số destructuring cho phép một hàm tách một đối tượng được cung cấp dưới dạng đối số thành một hoặc nhiều biến cục bộ.\r\n\r\n``<code>ts\r\nfunction multiply({ a, b, c }: { a: number; b: number; c: number }) {\r\n    console.log(a <em> b </em> c);\r\n}\r\n\r\nmultiply({ a: 1, b: 2, c: 3 });\r\n</code>`<code>\r\n\r\nBạn có thể tối ưu code trên bằng cách dùng interface hoặc type:\r\n\r\n</code>`<code>ts\r\ntype ABC = { a: number; b: number; c: number };\r\n\r\nfunction multiply({ a, b, c }: ABC) {\r\n    console.log(a <em> b </em> c);\r\n}\r\n\r\nmultiply({ a: 1, b: 2, c: 3 });\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về cú pháp class trong TypeScript?",
              "answer": "<p>TypeScript hỗ trợ lớp đầy đủ. Cú pháp TypeScript cho khai báo lớp tương tự JavaScript, với hỗ trợ khai báo kiểu cho các thuộc tính của nó.\r\n\r\nVí dụ lớp Employee:\r\n\r\n``<code>ts\r\nclass Employee {\r\n    name: string;\r\n    salary: number;\r\n\r\n    constructor(name: string, salary: number) {\r\n        this.name = name;\r\n        this.salary = salary;\r\n    }\r\n    promote() : void {\r\n        this.salary += 10000;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTa có thể tạo đối tượng cho lớp bằng cách dùng từ khoá </code>new<code>\r\n\r\n</code>`<code>ts\r\n// Create a new employee\r\nlet john = new Employee(&quot;John&quot;, 60000);\r\n\r\nconsole.log(john.salary);  // 60000\r\njohn.promote();\r\nconsole.log(john.salary);  // 70000\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cú pháp arrow function trong TypeScript?",
              "answer": "<p>Arrow function cung cấp cú pháp ngắn và thuận tiện hơn cho khai báo hàm. Nó còn được gọi là lambdas ở một số ngôn ngữ lập trình khác.\r\n\r\nCú pháp khai báo hàm thông thường:\r\n\r\n``<code>ts\r\nfunction add(x: number, y: number): number {\r\n    let sum = x + y;\r\n    return sum;\r\n}\r\n</code>`<code>\r\n\r\nSử dụng arrow function:\r\n\r\n</code>`<code>ts\r\nlet add = (x: number, y: number): number =&gt; {\r\n    let sum = x + y;\r\n    return sum;\r\n}\r\n</code>`<code>\r\n\r\nBạn có thể đơn giản cú pháp hơn nữa bằng cách lược bỏ câu lệnh </code>return<code>. Nó được cho phép khi thân hàm chỉ có duy nhất một câu lệnh, ví dụ:\r\n\r\n</code>`<code>ts\r\nlet add = (x: number, y: number): number =&gt; x + y; \r\n</code>`<code>\r\n\r\nArrow function thường được dùng cho các hàm callback trong TypeScript. Xem đoạn code bên dưới một vòng lặp qua một mảng số để lọc và trả về các bội của 5.\r\n\r\n</code>`<code>ts\r\nlet numbers = [3, 5, 9, 15, 34, 35];\r\n\r\nlet fiveMultiples = numbers.filter(num =&gt; (num % 5) == 0);\r\n\r\nconsole.log(fiveMultiples);  // [5, 15, 35]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tham số tuỳ chọn trong TypeScript?",
              "answer": "<p>Một hàm có thể có một hay nhiều tham số tuỳ chọn bằng cách thêm dấu <code>?</code> sau nó. Ví dụ:\r\n\r\n``<code>ts\r\nfunction greet(name: string, greeting?: string) {\r\n    if (!greeting)\r\n        greeting = &quot;Hello&quot;;\r\n\r\n    console.log(</code>${greeting}, ${name}<code>);\r\n}\r\n\r\ngreet(&quot;John&quot;, &quot;Hi&quot;);  // Hi, John\r\ngreet(&quot;Mary&quot;, &quot;Hola&quot;);  // Hola, Mary\r\ngreet(&quot;Jane&quot;);  // Hello, Jane\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Mục đích của file tsconfig.json?",
              "answer": "<p>Một file tsconfig.json trong một thư mục đánh dấu thư mục đó là thư mục gốc của một dự án TypeScript. Nó cung cấp các tùy chọn trình biên dịch để biên dịch dự án.\r\n\r\n``<code>ts\r\n{\r\n    &quot;compilerOptions&quot;: {\r\n        &quot;module&quot;: &quot;system&quot;,\r\n        &quot;noImplicitAny&quot;: true,\r\n        &quot;removeComments&quot;: true,\r\n        &quot;outFile&quot;: &quot;../../built/local/tsc.js&quot;,\r\n        &quot;sourceMap&quot;: true\r\n    },\r\n    &quot;include&quot;: [&quot;src/*<em>/</em>&quot;],\r\n    &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;*<em>/</em>.spec.ts&quot;]\r\n}\r\n</code>``\r\n\r\n## Câu hỏi phỏng vấn TypeScript cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Liệt kê các kiểu vòng lặp trong TypeScript?",
              "answer": "<p>TypeScript cung cấp 3 cách lặp qua tập hợp như sau:\r<ul><li>Vòng lặp <strong>for</strong></li></ul>\r\n\r\n``<code>ts\r\nlet values = [10, &quot;foo&quot;, true];\r\n\r\nfor(let i=0; i&lt;values.length; i++) {\r\n    console.log(values[i]);  // 10, &quot;foo&quot;, true\r\n}\r\n</code>`<code>\r<ul><li>Hàm <strong>forEach</strong></li></ul>\r\n\r\n</code>`<code>ts\r\nlet values = [10, &quot;foo&quot;, true];\r\nvalues.forEach(val =&gt; {\r\n    console.log(val);  // 10, &quot;foo&quot;, true\r\n})\r\n</code>`<code>\r<ul><li>Câu lệnh <strong>for..of</strong></li></ul>\r\n\r\n</code>`<code>ts\r\nlet values = [10, &quot;foo&quot;, true];\r\nfor (let val of values) {\r\n    console.log(val); // 10, &quot;foo&quot;, true\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về kiểu symbol trong TypeScript?",
              "answer": "<p>Symbol được giới thiệu ở ES6 và được hỗ trợ trong TypeScript. Tương tự như <code>number</code> hay <code>string</code>, <code>symbol</code> là một kiểu nguyên thuỷ. Được sử dụng để tạo thuộc tính duy nhất cho đối tượng.\r\n\r\nBạn có thể tạo giá trị symbol bằng hàm khởi tạo <code>Symbol()</code>, thường dùng một khoá chuỗi:\r\n\r\n``<code>ts\r\nlet foo = Symbol();\r\nlet bar = Symbol(&quot;bar&quot;);\r\n</code>`<code>\r\n\r\nMột khoá ký tự của symbol là duy nhất và bất biến.\r\n\r\n</code>`<code>ts\r\nlet foo = Symbol(&quot;foo&quot;);\r\nlet newFoo = Symbol(&quot;foo&quot;);\r\n\r\nlet areEqual = foo === newFoo;\r\nconsole.log(areEqual);  // false, symbols are unique\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Chuỗi tuỳ chọn trong TypeScript hoạt động thế nào?",
              "answer": "<p>Chuỗi tuỳ chọn cho phép bạn truy cập thuộc tính và gọi phương thức trên một đối tượng dạng chuỗi. \r\n\r\nTypeScript dừng ngay lập tức các biểu thức nếu nó trả về giá trị <code>null</code> hay <code>undefined</code>.\r\n\r\nVí dụ, một biểu thức dài như sau:\r\n\r\n``<code>ts\r\nlet x = foo === null || foo === undefined ? undefined : foo.bar.baz();\r\n</code>`<code>\r\n\r\ncó thể đơn giản thành:\r\n\r\n</code>`<code>ts\r\nlet x = foo?.bar.baz();\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Nạp chồng hàm trong TypeScript?",
              "answer": "<p>Nạp chồng hàm cho phép ta khai báo nhiều hàm cùng tên, nhưng số lượng tham số cho từng hàm phải khác nhau.\r\n\r\nVí dụ bên dưới khai báo hai hàm nạp chồng cho <code>builđate</code>. Hàm nạp chồng đầu tiên nhận về tham số kiểu <em>number</em>, trong khi tham số thứ hai nhận về 3 tham số kiểu <em>number</em>. \r\n\r\n``<code>ts\r\nfunction buildDate(timestamp: number): Date;\r\nfunction buildDate(m: number, d: number, y: number): Date;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tự suy kiểu là gì?",
              "answer": "<p>TypeScript có thể tự suy kiểu của biến nếu bạn không cung cấp kiểu cụ thể. Điều này gọi là tự suy kiểu. Nó thường dùng khi các biến hoặc tham số được khởi tạo khi khai báo.\r\n\r\nVí dụ, đoạn code dưới đây TypeScript sẽ mặc định biến <code>foo</code> là kiểu string\r\n\r\n``<code>ts\r\nlet foo = &quot;this is a string&quot;;\r\nconsole.log(typeof foo);  // &quot;string&quot;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Contextual Typing là gì?",
              "answer": "<p>Khi trình biên dịch TypeScript sử dụng vị trí (hoặc ngữ cảnh) của một biến để suy ra kiểu của nó, nó được gọi là nhập theo ngữ cảnh (Contextual Typing).\r\n\r\nTrong ví dụ sau, TypeScript sử dụng thông tin kiểu hàm <code>window.onmousedown</code> để suy ra kiểu của biểu thức hàm ở phía bên phải của phép gán. Điều này cho phép nó suy ra kiểu của tham số <code>e</code>, tham số này có thuộc tính button nhưng không có thuộc tính có tên <code>foo</code>.\r\n\r\n``<code>ts\r\nwindow.onmousedown = function (e) {\r\n    console.log(e.button); //&lt;- OK\r\n    console.log(e.foo); //&lt;- Error!\r\n};\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "noImplicitAny là gì?",
              "answer": "<p>Thông thường, nếu ta không cung cấp kiểu cho biến, TypeScript sẽ giả sử rằng đó là kiểu any. Ví dụ, đoạn code sau, tham số <code>s</code> sẽ được xem như là kiểu any. Nó hoạt động cùng với chuỗi được truyền:\r\n\r\n``<code>ts\r\nfunction parse(s) {\r\n    console.log(s.split(&#39; &#39;));\r\n}\r\nparse(&quot;Hello world&quot;);  // [&quot;Hello&quot;, &quot;world&quot;]\r\n</code>`<code>\r\n\r\nTuy nhiên, code sẽ sinh lỗi ngay khi ta truyền một số hoặc kiểu khác chuỗi vào phương thức </code>split()<code>. Ví dụ:\r\n\r\n</code>`<code>ts\r\nfunction parse(s) {\r\n    console.log(s.split(&#39; &#39;));  // [ERR]: s.split is not a function\r\n}\r\nparse(10); \r\n</code>`<code>\r\n\r\n<strong>noImplicitAny</strong> là một trình biên dịch tuỳ chọn mà bạn thiết lập trong file tsconfig.json. Nó ép trình biên dịch TypeScript báo lỗi bất cứ khi nào nó đưa ra một biến kiểu any. Điều này ngăn việc vô tình tạo các lỗi tương tự:\r\n\r\n</code>`<code>ts\r\n// Parameter &#39;s&#39; implicitly has an &#39;any&#39; type.(7006)\r\nfunction parse(s) {\r\n    console.log(s.split(&#39; &#39;));  // [ERR]: s.split is not a function\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Interface là gì?",
              "answer": "<p>Interface trong typescript cho phép bạn định nghĩ thuộc tính và phương thức là gì mà đối tượng cần để được triển khai (implement). Nếu đối tượng tuân thủ đúng khuôn mẫu interface thì đối tượng đã triển khai interface ấy sẽ được thi hành đúng. Nếu interface không được thi hành đúng thì typescript sẽ phát sinh lỗi ngay lập tức.\r\n\r\n``<code>ts\r\ninterface Employee {\r\n    name: string;\r\n    salary: number;\r\n}\r\n\r\nfunction process(employee: Employee) {\r\n    console.log(</code>${employee.name}'s salary = ${employee.salary}<code>);\r\n}\r\n\r\nlet john: Employee = {\r\n    name: &quot;John Doe&quot;,\r\n    salary: 150000\r\n}\r\n\r\nprocess(john);  // &quot;John Doe&#39;s salary = 150000&quot;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các quyền truy cập trong TypeScript?",
              "answer": "<p>TypeScript cung cấp ba từ khoá cho điều khiển truy cập thành viên của lớp, như thuộc tính hay phương thức:\r<ul><li><strong>public</strong>: có thể truy cập ở bất cứ đâu kể cả bên ngoài lớp. Tất cả lớp thành viên mặc định là public.</li></ul>\r<ul><li><strong>protected</strong>: là thành viên chỉ có thể truy cập bởi lớp con của lớp chứa thành viện đó. Bên ngoài không thể truy cập vào các thành viên protected.</li></ul>\r<ul><li><strong>private</strong>: chỉ có thể truy cập bên trong lớp đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "TypeScript có hỗ trợ static class không?",
              "answer": "<p>TypeScript không có hỗ trợ static class, không giống như các ngôn ngữ lập trình hướng đối tượng như C# hay Java.\r\n\r\nCác ngôn ngữ này cần các static class vì tất cả code, tức là dữ liệu và các hàm, cần phải nằm trong một lớp và không thể tồn tại độc lập. Các static class cung cấp một cách để cho phép các hàm này mà không cần liên kết chúng với bất kỳ đối tượng nào.\r\n\r\nTrong TypeScript, bạn có thể tạo bất kỳ dữ liệu và nào nào dưới dạng các đối tượng đơn giản mà không cần tạo một lớp chứa. Do đó, TypeScript không cần các static class. Một lớp singleton chỉ là một đối tượng đơn giản trong TypeScript</p>",
              "level": "fresher"
            },
            {
              "question": "Lớp trừu tượng là gì?",
              "answer": "<p>Các lớp trừu tượng tương tự như các interface ở chỗ chúng chỉ định một hợp đồng cho các đối tượng và bạn không thể khởi tạo chúng trực tiếp. Tuy nhiên, không giống như các interface, một lớp trừu tượng có thể cung cấp các chi tiết triển khai cho một hoặc nhiều thành viên của nó.\r\n\r\nMột lớp trừu tượng đánh dấu một hoặc nhiều thành viên của nó là trừu tượng. Bất kỳ lớp nào kế thừa một lớp trừu tượng phải cung cấp một triển khai cho các thành viên trừu tượng của lớp cha.\r\n\r\nĐây là một ví dụ về một lớp trừu tượng <code>Writer</code> với hai hàm thành viên. Phương thức <code>write()</code> được đánh dấu là trừu tượng, trong khi phương thức <code>welcome()</code> là triển khai. Cả hai lớp <code>FictionWriter</code> và <code>RomanceWriter</code> kế thừa từ <code>Writer</code> phải cung cấp triển khai cụ thể của chúng cho phương thức <code>write</code>.\r\n\r\n``<code>ts\r\nabstract class Writer {\r\n    abstract write(): void;\r\n\r\n    greet(): void {\r\n        console.log(&quot;Hello, there. I am a writer.&quot;);\r\n    }\r\n}\r\n\r\nclass FictionWriter extends Writer {\r\n    write(): void {\r\n        console.log(&quot;Writing a fiction.&quot;);\r\n    }\r\n}\r\n\r\nclass RomanceWriter extends Writer {\r\n    write(): void {\r\n        console.log(&quot;Writing a romance novel.&quot;);\r\n    }\r\n}\r\n\r\nconst john = new FictionWriter();\r\njohn.greet();  // &quot;Hello, there. I am a writer.&quot;\r\njohn.write();  // &quot;Writing a fiction.&quot;\r\n\r\nconst mary = new RomanceWriter();\r\nmary.greet();  // &quot;Hello, there. I am a writer.&quot;\r\nmary.write();  // &quot;Writing a romance novel.&quot;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm ẩn danh là gì?",
              "answer": "<p>Một hàm ẩn danh là một hàm không có tên. Các hàm ẩn danh thường được sử dụng như các hàm callback, tức là chúng được chuyển cho các hàm khác, chỉ được gọi bởi hàm khác vào thời điểm sau đó. Ví dụ,\r\n\r\n``<code>ts\r\nsetTimeout(function () {\r\n  console.log(&#39;Run after 2 seconds&#39;)\r\n}, 2000);\r\n</code>`<code>\r\n\r\nBạn có thể gọi một hàm ẩn danh ngay sau khi nó được tạo. Nó được gọi là IIFE, ví dụ:\r\n\r\n</code>`<code>ts\r\n(function() {\r\n  console.log(&#39;Invoked immediately after creation&#39;);\r\n})();\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu union trong TypeScript?",
              "answer": "<p>Kiểu union là một kiểu cấu trúc đặc biệt trong TypeScript biểu thị một giá trị có thể có nhiều kiểu. Phân tách bằng ký hiệu <code>|</code>.\r\n\r\nHãy xem xét ví dụ sau đây trong đó biến <code>value</code> thuộc kiểu union bao gồm chuỗi và số. Value được khởi tạo thành chuỗi \"Foo\". Bởi vì nó chỉ có thể là một chuỗi hoặc một số, ta có thể thay đổi nó thành một số sau đó và trình biên dịch TypeScript không phàn nàn.\r\n\r\n``<code>ts\r\nlet value: string | number = &quot;Foo&quot;;\r\nvalue = 10;  // Okay\r\n</code>`<code>\r\n\r\nTuy nhiên, nếu ta gán cho nó một giá trị thuộc kiểu không được bao gồm trong kiểu union, nó sẽ báo lỗi:\r\n\r\n</code>`<code>ts\r\nvalue = true;  // Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.(2322)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu intersection là gì?",
              "answer": "<p>Kiểu intersection cho phép bạn kết hợp các thành viên của hai hoặc nhiều kiểu bằng cách sử dụng toán tử <code>&amp;</code>. Điều này cho phép bạn kết hợp các kiểu hiện có để có được một kiểu duy nhất với tất cả các tính năng bạn cần.\r\n\r\nVí dụ: Ta tạo kiểu <code>Supervisor</code> mới từ thành viên của kiểu <code>Employee</code> và <code>Manager</code>:\r\n\r\n``<code>ts\r\ninterface Employee {\r\n    work: () =&gt; string;\r\n}\r\n\r\ninterface Manager {\r\n    manage: () =&gt; string;\r\n}\r\n\r\ntype Supervisor = Employee &amp; Manager;\r\n\r\n// john can both work and manage\r\nlet john: Supervisor;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Alias là gì?",
              "answer": "<p>Alias (tên bí danh) cung cấp một tên mới cho kiểu hiện có. Nó không cung cấp kiểu mới mà cung cấp tên mới đề cập đến kiểu đó.\r\n\r\nVí dụ: bạn có đặt bí danh cho kiểu union đế tránh nhập tất cả kiểu ở mọi nơi mà giá trị đó đang sử dụng.\r\n\r\n``<code>ts\r\ntype alphanumeric = string | number;\r\nlet value: alphanumeric = &quot;&quot;;\r\nvalue = 10;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu tuple trong TypeScript?",
              "answer": "<p>Tuple là kiểu đặc biệt trong TypeScript. Chúng tương tự như mảng có một số phần tử cố định với một kiểu đã biết. Tuy nhiên, các kiểu không cần phải giống nhau.\r\n\r\n``<code>ts\r\n// Declare a tuple type and initialize it\r\nlet values: [string, number] = [&quot;Foo&quot;, 15];\r\n\r\n// Type &#39;boolean&#39; is not assignable to type &#39;string&#39;.(2322)\r\n// Type &#39;string&#39; is not assignable to type &#39;number&#39;.(2322)\r\nlet wrongValues: [string, number] = [true, &quot;hello&quot;]; // Error\r\n</code>`<code>\r\n\r\nỞ TypeScript 3.0, một tuple có thể chỉ định một hoặc nhiều kiểu tuỳ chọn sử dụng ? như bên dưới:\r\n\r\n</code>`<code>ts\r\nlet values: [string, number, boolean?] = [&quot;Foo&quot;, 15];\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cách hoạt động tuple destructuring trong TypeScript?",
              "answer": "<p>Bạn có thể destructuring phần tử tuple bằng cách dùng toán tử (=). Các biến destructuring nhận kiểu của phần tử tuple tương ứng.\r\n\r\n``<code>ts\r\nlet employeeRecord: [string, number] = [&quot;John Doe&quot;, 50000];\r\nlet [emp<em>name, emp</em>salary] = employeeRecord;\r\nconsole.log(</code>Name: ${emp<em>name}<code>);  // &quot;Name: John Doe&quot;\r\nconsole.log(</code>Salary: ${emp</em>salary}<code>);  // &quot;Salary: 50000&quot;\r\n</code>`<code>\r\n\r\nSau destructuring, bạn không thể gán giá trị kiểu khác cho biến bị destructuring. Ví dụ:\r\n\r\n</code>`<code>ts\r\nemp_name = true;  // Type &#39;boolean&#39; is not assignable to type &#39;string&#39;.(2322)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Xác nhận kiểu trong TypeScript là gì?",
              "answer": "<p>Đôi khi, bạn với tư cách là một lập trình viên có thể biết nhiều hơn về kiểu của một biến mà TypeScript có thể suy luận. Thông thường, điều này xảy ra khi bạn biết kiểu đối tượng cụ thể hơn kiểu hiện tại của nó. Trong những trường hợp như vậy, bạn có thể yêu cầu trình biên dịch TypeScript không suy ra kiểu của biến bằng cách sử dụng xác nhận kiểu.\r\n\r\nTypeScript cung cấp hai cú pháp cho xác nhận kiểu:\r<ul><li>Dùng <code>as</code></li></ul>\r\n\r\n``<code>ts\r\nlet value: unknown = &quot;Foo&quot;;\r\nlet len: number = (value as string).length;\r\n</code>`<code>\r<ul><li>Dùng </code><><code></li></ul>\r\n\r\n</code>`<code>ts\r\nlet value: unknown = &quot;Foo&quot;;\r\nlet len: number = (&lt;string&gt;value).length;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách để ép kiểm tra null trong TypeScript?",
              "answer": "<p>Con trỏ null là một trong những nguyên nhân phổ biến dẫn đến lỗi \"Error runtime unexpected\" trong lập trình. TypeScript giúp bạn tránh chúng ở một mức độ cao bằng cách thực thị kiểm tra null nghiêm ngặt (strict null checks).\r\n\r\nTa có thể thực hiện theo hai cách:\r<ul><li>cung cấp cờ --strictNullChecks trong trình biên dịch TypeScript.</li></ul>\r<ul><li>thiết lập thuộc tính strictNullChecks là true trong cấu hình tsconfig.json. </li></ul>\r\n\r\nKhi cờ là false, TypeScript bỏ qua các giá trị null và undefined trong code. Khi nó là true, null và undefined có các kiểu riêng biệt. Trình biên dịch throw một lỗi nếu bạn cố gắng sử dụng chúng ở những nơi mà một giá trị cụ thể được mong đợi.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách làm cho thuộc tính đối tượng bất biến trong TypeScript?",
              "answer": "<p>Bạn có thể làm cho thuộc tính đối tượng là bất biến bằng cách dùng từ khoá <code>readonly</code>.\r\n\r\n``<code>ts\r\ninterface Coordinate {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n</code>`<code>\r\n\r\nKhi bạn đánh dấu một thuộc tính là readonly, nó chỉ có thể được đặt khi bạn khởi tạo đối tượng. Khi đối tượng được tạo, bạn không thể thay đổi nó.\r\n\r\n</code>`<code>ts\r\nlet c: Coordinate = { x: 5, y: 15 };\r\nc.x = 20; // Cannot assign to &#39;x&#39; because it is a read-only property.(2540)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "File khai báo kiểu là gì?",
              "answer": "<p>Một dự án TypeScript điển hình tham chiếu đến các thư viện TypeScript của bên thứ ba khác như jQuery để thực hiện các tác vụ thông thường. Có thông tin kiểu cho file thư viện giúp bạn mã hóa bằng cách cung cấp thông tin chi tiết về kiểu, đặc trưng phương thức, ... và cung cấp IntelliSense.\r\n\r\nFile khai báo kiểu là file văn bản kết thúc bằng phần mở rộng <code>.d.ts</code> cung cấp cách khai báo sự tồn tại của một số kiểu hoặc giá trị mà không thực sự cung cấp triển khai cho các giá trị đó. Nó chứa các khai báo kiểu nhưng không có bất kỳ code nguồn nào. Nó không tạo ra file <code>.js</code> sau khi biên dịch.</p>",
              "level": "fresher"
            },
            {
              "question": "Các chỉ thị ba dấu gạch chéo là gì?",
              "answer": "<p>Chỉ thị ba dấu gạch chéo là các chú thích một dòng chứa một thẻ XML. TypeScript sử dụng thẻ XML này làm chỉ thị trình biên dịch.\r\n\r\nBạn chỉ có thể đặt ba dấu gạch chéo ở đầu file. Chỉ các comment đơn hoặc nhiều dòng mới có thể xuất hiện trước ba dấu gạch chéo. TypeScript coi chúng như những comment thông thường nếu nó xuất hiện ở giữa một khối code, sau một câu lệnh.\r\n\r\nCông dụng chính của chỉ thị ba dấu gạch chéo là bao gồm các file khác trong quá trình biên dịch. Ví dụ: lệnh sau đây hướng dẫn trình biên dịch bao gồm một file được chỉ định bởi đường dẫn trong file TypeScript có chứa.\r\n\r\n``<code>ts\r\n/// &lt;đường dẫn tham chiếu = &quot;...&quot; /&gt;\r\n</code>``\r\n\r\nLệnh ba dấu gạch chéo cũng sắp xếp đầu ra khi sử dụng --out hoặc --outFile. Các file đầu ra được tạo ra vị trí file đầu ra theo thứ tự giống như các file đầu vào.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích toán tử in?",
              "answer": "<p>Toán tử in được sử dụng để tìm xem một thuộc tính có nằm trong đối tượng được chỉ định hay không. Nó trả về true nếu thuộc tính thuộc về đối tượng. Nếu không, nó trả về false.\r\n\r\n``<code>ts\r\nconst car = { make: &#39;Hyundai&#39;, model: &#39;Elantra&#39;, year: 2017 };\r\nconsole.log(&#39;model&#39; in car);  // true\r\nconsole.log(&#39;test&#39; in car);  // false\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích từ khoá implement trong TypeScript?",
              "answer": "<p>Một implement được dùng để kiểm tra một lớp có thoả mãn hợp đồng được chỉ định bởi một interface hay không. \r\n\r\n``<code>ts\r\ninterface Runnable {\r\n    run(): void;\r\n}\r\n\r\nclass Job implements Runnable {\r\n    run() {\r\n        console.log(&quot;running the scheduled job!&quot;);\r\n    }\r\n}\r\n\r\n// Class &#39;Task&#39; incorrectly implements interface &#39;Runnable&#39;.\r\n// Property &#39;run&#39; is missing in type &#39;Task&#39; but required in type &#39;Runnable&#39;.(2420)\r\nclass Task implements Runnable {\r\n    perform() {\r\n        console.log(&quot;pong!&quot;);\r\n    }\r\n}\r\n</code>``\r\n\r\nMột lớp có thể triển khai nhiều hơn một interface. Trong trường hợp này, lớp phải chỉ định tất cả các hợp đồng của các giao diện đó.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu chuỗi ký tự là gì?",
              "answer": "<p>Trong TypeScript, bạn có thể chỉ định một chuỗi hay số cụ thể như một kiểu. \r\n\r\n``<code>ts\r\nlet foo: &quot;bar&quot; = &quot;bar&quot;;\r\n\r\n// OK\r\nfoo = &quot;bar&quot;;\r\n\r\n// Error: Type &#39;&quot;baz&quot;&#39; is not assignable to type &#39;&quot;bar&quot;&#39;.(2322)\r\nfoo = &quot;baz&quot;;\r\n</code>`<code>\r\n\r\nNhưng với kiểu chuỗi ký tự thì không hữu ích lắm. Tuy nhiên bạn có thể kết hợp chúng thành union. Điều này cho phép bạn chỉ định tất cả các giá trị chuỗi mà một biến có thể nhận, lần lượt hoạt động giống như enums. Điều này có thể hữu ích cho các tham số hàm.\r\n\r\n</code>`<code>ts\r\nfunction greet(name: string, greeting: &quot;hi&quot; | &quot;hello&quot; | &quot;hola&quot;) {\r\n// ...\r\n}\r\n\r\ngreet(&quot;John&quot;, &quot;hello&quot;);\r\n\r\n// Error: Argument of type &#39;&quot;Howdy?&quot;&#39; is not assignable to parameter of type &#39;&quot;hi&quot; | &quot;hello&quot; | &quot;hola&quot;&#39;.(2345)\r\ngreet(&quot;Mary&quot;, &quot;Howdy?&quot;);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các template literal là gì?",
              "answer": "<p>Tính năng được lấy từ ES6, trong TypeScript bạn có thể chèn giá trị của một biến vào chuỗi bằng cách sử dụng cú pháp <code>${}</code>, và chuỗi được bọc trong dấu \"`<code>&quot;.\r\n\r\n</code>`<code>ts\r\ntype Point = &quot;GraphPoint&quot;;\r\n\r\n// type Shape = &quot;Grid GraphPoint&quot;\r\ntype Shape = </code>Grid ${Point}<code>;\r\n</code>`<code>\r\n\r\nTa có thể mở rộng chúng union. Nó giúp tạo một tập tất cả các chuỗi có thể mà một thành viên union có thể thể biểu diễn.\r\n\r\n</code>`<code>ts\r\ntype Color = &quot;green&quot; | &quot;yellow&quot;;\r\ntype Quantity = &quot;five&quot; | &quot;six&quot;;\r\n\r\n// type ItemTwo = &quot;five item&quot; | &quot;six item&quot; | &quot;green item&quot; | &quot;yellow item&quot;\r\ntype ItemOne = </code>${Quantity | Color} item<code>; \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kế thừa trong TypeScript?",
              "answer": "<p>Tính kế thừa cho phép một lớp kế thừa một lớp khác, sử dụng lại và sửa đổi hành vi được định nghĩa trong lớp đó. Lớp kế thừa một lớp khác được gọi là lớp dẫn xuất và lớp nhận được kế thừa được gọi là lớp cơ sở.\r\n\r\nTrong TypeScript, một lớp chỉ có thể kế thừa từ một lớp. TypeScript sử dụng từ khóa <code>extend</code> để xác định mối quan hệ giữa lớp cơ sở và các lớp dẫn xuất.\r\n\r\n``<code>ts\r\nclass Rectangle {\r\n    length: number;\r\n    breadth: number\r\n\r\n    constructor(length: number, breadth: number) {\r\n        this.length = length;\r\n        this.breadth = breadth\r\n    }\r\n\r\n    area(): number {\r\n        return this.length * this.breadth;\r\n    }\r\n}\r\n\r\nclass Square extends Rectangle {\r\n    constructor(side: number) {\r\n        super(side, side);\r\n    }\r\n\r\n    volume() {\r\n        return &quot;Square doesn&#39;t have a volume!&quot;\r\n    }\r\n}\r\n\r\nconst sq = new Square(10);\r\n\r\nconsole.log(sq.area());  // 100\r\nconsole.log(sq.volume());  // &quot;Square doesn&#39;t have a volume!&quot;\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, vì lớp </code>Square<code> kế thừa chức năng từ </code>Rectangle<code>, chúng ta có thể tạo một biểu diễn của hình vuông và gọi cả hai phương thức </code>area()<code> và </code>volume()`.</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu điều kiện là gì?",
              "answer": "<p>Kiểu có điều kiện cho phép bạn chọn một trong hai kiểu có thể dựa trên một điều kiện. Điều kiện được thể hiện dưới dạng một bài kiểm tra mối quan hệ kiểu.\r\n\r\n``<code>ts\r\nC extends B ? TypeX : TypeY\r\n</code>``\r\n\r\nỞ đâu, nếu kiểu C kế thừa từ B, giá trị của kiểu trên là TypeX, ngược lại thì là TypeY.</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu hàm trong TypeScript?",
              "answer": "<p>Hàm là một kiểu toàn cục trong TypeScript. Nó có các thuộc tính như bind, call và apply, cùng với các thuộc tính khác có trên tất cả các giá trị hàm.\r\n\r\n``<code>ts\r\nfunction perform(fn: Function) {\r\n    fn(10);\r\n}\r\n</code>``\r\n\r\nBạn có thể gọi một giá trị của kiểu hàm, và trả về một giá trị any.</p>",
              "level": "fresher"
            },
            {
              "question": "Liệt kê một số kiểu tiện ích được cung cấp bởi TypeScript và giải thích cách sử dụng của chúng?",
              "answer": "<p>TypeScript cung cấp nhiều kiểu tiện ích khác nhau giúp cho việc chuyển đổi kiểu thông thường trở nên dễ dàng. Các loại tiện ích này có sẵn trên toàn cục. Dưới đây là một số kiểu tiện ích thiết yếu có trong TypeScript.\r\n\r\n| Kiểu tiện ích | Mô tả |\r\n|-|-|\r\n| Partial<Type> | Tạo một kiểu với tất cả các thuộc tính của Type được đặt thành tùy chọn |\r\n| Required<Type> | Tạo một kiểu bao gồm tất cả các thuộc tính của Type được đặt thành bắt buộc |\r\n| Readonly<Type> | Tạo một kiểu với tất cả các thuộc tính của Type được đặt thành readonly |\r\n| Record<Keys, Type> | Tạo một kiểu đối tượng với các khóa thuộc tính là kiểu Keys và giá trị là Type |</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "web-api",
          "name": "Câu hỏi phỏng vấn Web API",
          "description": "",
          "questions": [
            {
              "question": "Tại sao Web API quan trọng?",
              "answer": "<p>Web API được xem như một dịch vụ cơ bản cung cấp thông tin hoặc dữ liệu từ server. Nó quan trọng vì những lý do sau:\r<ul><li>Nó được dùng để cung cấp interface cho web hay ứng dụng để có thể truy cập dữ liệu.</li></ul>\r<ul><li>Nó còn được dùng cho truy cập hay lưu trữ dữ liệu vào cơ sở dữ liệu.</li></ul>\r<ul><li>Nó hỗ trợ nhiều định dạng dữ liệu khác nhau như XML, JSON,...</li></ul>\r<ul><li>Nó phù hợp với nhiều kiểu trình duyệt và thiết bị</li></ul>\r<ul><li>Nó sử dụng băng thông thấp do đó phù hợp với các thiết bị giới hạn băng thông như smartphone,...</li></ul>\r<ul><li>Từ góc nhìn doanh nghiệp, Web API ứng dụng tốt hơn cho UX/UI, tăng lưu lượng truy cập và tạo sự thu hút cho sản phẩm hay dịch vụ công ty.</li></ul>\r\n\r\n<img src=\"/interview-assets/API_Application.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Chính xác thì Web API là gì?",
              "answer": "<p>Web API (Application Programming Interfce), là một API dùng cho truy cập xuyên qua web với giao thức HTTP. Nó được xem là nền tảng tốt nhất để cho phép các dịch vụ khác truy cập dữ liệu hay dịch vụ của server. Nó có thể được xây dựng bằng các công nghệ khác nhau như Nodejs, Java, ASP.NET,...\r\n\r\n<img src=\"/interview-assets/WEB_API.png\" alt=\"\" />\r\n\r\nWeb API được dùng:\r<ul><li>Nó chứa các lớp bổ sung giúp chuẩn hóa thông tin liên lạc một cách đơn giản và cung cấp các tùy chọn khác nhau về cách định dạng đầu vào và đầu ra.</li></ul>\r<ul><li>Nếu muốn tạo các dịch vụ hướng tài nguyên, thì các dịch vụ Web API được coi là tốt nhất.</li></ul>\r<ul><li>Hỗ trợ phát triển cả RESTful và SOAP.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Kiểu trả về được hỗ trợ trong Web API?",
              "answer": "<p>Nó không có bất kỳ kiểu dữ liệu cụ thể nào. Nó có thể trả về bất kỳ loại dữ liệu nào tùy thuộc vào yêu cầu nghiệp vụ. Có nhiều phương thức HTTP như GET, POST, PUT, v.v., có thể trả về dữ liệu ở các định dạng khác nhau tùy thuộc vào trường hợp sử dụng.</p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa WCF và Web API?",
              "answer": "<p><strong>WCF (Windows Communication Foundation):</strong> là một framework dùng cho phát triển SOAP (Service-oriented applications). Framework này dùng cho phát triển, cấu hình và triển khai dịch vụ mạng phân phối.\r\n\r\n<strong>Web API:</strong> là API cho cả trình duyệt web và web server. \r\n\r\n| Web API | WCF |\r\n|-|-|\r\n| Dùng cho phát triển cả SOAP và RESTful | Chỉ dùng cho phát triển SOAP |\r\n| Hỗ trợ các tính năng MVC như routing, binding,.. | Không hỗ trợ MVC |\r\n| Chỉ dùng giao thức HTTP | Dùng nhiều giao thức HTTP, UDP,.. |\r\n| Là tốt nhất cho phát triển dịch vụ RESTful | Hỗ trợ giới hạn các dịch vụ RESTful |\r\n| Hỗ trợ định dạng UTF-8 | Hỗ trợ văn bản, mã hoá nhị phân, MTOM (Message Transmission Optimization Mechanism) |\r\n| Dùng cho tiết lộ thông tin, dữ liệu với trình duyệt hay thiết bị di động | Dùng cho tạo các dịch vụ sử dụng kênh truyền tải nhanh như TCP, UDP,... |</p>",
              "level": "middle"
            },
            {
              "question": "Web API tốt hơn WCF ở điểm nào?",
              "answer": "<p><ul><li>Web API cung cấp đầy đủ các tính năng của HTTP như URI, header, caching, versioning,...</li></ul>\r<ul><li>Web API dùng các định dạng văn bản khác nhau như XML vì nó nhanh hơn các dịch vụ.</li></ul>\r<ul><li>Web API hỗ trợ tính năng MVC.</li></ul>\r<ul><li>Web API cung cấp khả năng mở rộng tốt hơn.</li></ul>\r<ul><li>Web API sử dụng chuẩn bảo mật như xác thực token để cung cấp khả năng bảo mật dịch vụ.</li></ul>\r<ul><li>Người ta không phải xác định hoặc giải thích bất kỳ cài đặt cấu hình bổ sung nào cho các thiết bị khác nhau trong API Web.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa REST API và RESTful API?",
              "answer": "<p>| REST API | RESTful API |\r\n|-|-|\r\n| Là mẫu kiến trúc sử dụng trong dịch vụ web | Được dùng cho triển khai REST |\r\n| Định dạng dữ liệu dựa vào HTTP | Định dạng dữ liệu JSON, HTTP và văn bản |\r\n| LÀm việc của URL dựa vào request/respone | Làm việc của RESTful dựa vào ứng dụng REST |\r\n| Nó thân thiện hơn với người dùng và có khả năng thích ứng cao với tất cả các doanh nghiệp kinh doanh và CNTT | Nó quá linh hoạt |\r\n| Nó yêu cầu phát triển API cho phép tương tác giữa client và server | Nó chỉ đơn giản tuân theo cơ sở hạ tầng REST cung cấp khả năng tương tác giữa các hệ thống khác nhau trên toàn mạng |</p>",
              "level": "middle"
            },
            {
              "question": "Ưu điểm của sử dụng REST trong Web API?",
              "answer": "<p><ul><li>Nó cho phép truyền ít dữ liệu hơn giữa máy khách và máy chủ.</li></ul>\r<ul><li>Nó rất dễ sử dụng và nhẹ.</li></ul>\r<ul><li>Nó cung cấp tính linh hoạt hơn.</li></ul>\r<ul><li>Nó cũng xử lý và kiểm soát nhiều loại cuộc gọi khác nhau, trả về nhiều định dạng dữ liệu khác nhau.</li></ul>\r<ul><li>Nó được coi là tốt nhất để sử dụng nó trong các ứng dụng dành cho thiết bị di động vì nó truyền ít dữ liệu giữa máy khách và máy chủ hơn.</li></ul>\r<ul><li>Nó sử dụng các lệnh gọi HTTP đơn giản để giao tiếp giữa các máy thay vì sử dụng các tùy chọn phức tạp hơn như CORBA, COM +, SOAP hoặc RPC.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa REST và SOAP?",
              "answer": "<p><strong>REST (Representational State Transfer):</strong> mô tả một phong cách cấu trúc hệ thống mạng. Nó không yêu cầu băng thông rộng khi bạn gửi yêu cầu đến server. Nó chứa các thông điệp định dạng JSON. Ví dụ\r\n\r\n``<code>js\r\n{&quot;city&quot;:&quot;Mumbai&quot;,&quot;state&quot;:&quot;Maharashtra&quot;}\r\n</code>`<code>\r\n\r\n<strong>SOAP (Simple Object Access Protocol):</strong> Nó là một giao thức đơn giản và nhẹ thường được sử dụng để trao đổi thông tin có cấu trúc và được đánh máy trên Web. Nó hoạt động chủ yếu với HTTP và RPC. Giao thức này chủ yếu được sử dụng cho các ứng dụng B2B mà người ta có thể xác định hợp đồng dữ liệu với nó. Thông điệp SOAP có nội dung nặng hơn và do đó sử dụng băng thông lớn hơn.\r\n\r\n</code>`<code>xml\r\n&lt;?xml version=&quot;1.0&quot;?&gt;\r\n&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://www.w3.org/2001/12/soap-envelope&quot; SOAP-ENV:encodingStyle=&quot; http://www.w3.org/2001/12/soap-encoding&quot;&gt;\r\n    &lt;soap:Body&gt;\r\n        &lt;Demo.guru99WebService xmlns=&quot;http://tempuri.org/&quot;&gt;   \r\n            &lt;EmployeeID&gt;int&lt;/EmployeeID&gt;   \r\n        &lt;/Demo.guru99WebService&gt; \r\n    &lt;/soap:Body&gt;\r\n&lt;/SOAP-ENV:Envelope&gt;\r\n</code>``\r\n\r\n| SOAP | REST |\r\n|-|-|\r\n| Một giao thức gửi nhận thông điệp có định dạng XML | Một loại kiến trúc bao gồm các quy tắc để thao tác với server |\r\n| Sử dụng WSDL để giao tiếp giữa máy chủ và máy khách | Sử dụng XML hoặc JSON để gửi nhận dữ liệu |\r\n| Gọi các dịch vụ thông qua phương thức RPC | Gọi các dịch vụ qua đường dẫn URL |\r\n| Kết quả trả về không dễ đọc | Kết quả trả về dễ đọc vì đơn giản chỉ là text XML hoặc JSON |\r\n| Có thể truyền qua nhiều giao thức khác nhau như HTTP, SMTP, FTP,…\t| Chỉ có thể truyền qua HTTP |\r\n| JS có thể dùng để gọi SOAP, nhưng rất khó để làm | Quá đơn giản nếu dùng JS |\r\n| Hiệu suất không tốt bằng REST | Hiệu suất tốt hơn SOAP, tốn ít tài nguyên CPU hơn, code ngắn gọn hơn |</p>",
              "level": "middle"
            },
            {
              "question": "Giao thức hỗ trợ Web API?",
              "answer": "<p>Web API chỉ hỗ trợ giao thức HTTP</p>",
              "level": "middle"
            },
            {
              "question": "XML và JSON là gì?",
              "answer": "<p><strong>XML (Extensible Markup Language):</strong>\r<ul><li>Được thiết kế đặc biệt để lưu trữ và truyền tải dữ liệu.</li></ul>\r<ul><li>Giống như HTML nhưng linh hoạt hơn cho phép người dùng tự tạo thẻ.</li></ul>\r<ul><li>Dùng cho biểu diễn thông tin có cấu trúc như dữ liệu, tài liệu, cấu hình,...</li></ul>\r\n\r\n<strong>JSON (JavaScript Object Notation):</strong>\r<ul><li>Là định dạng nhẹ được thiết kế để lưu trữ và truyền tải dữ liệu.</li></ul>\r<ul><li>Là chuẩn định dạng văn bản dùng cho biểu diễn cấu trúc dữ liệu dựa trên đối tượng JavaScript.</li></ul>\r<ul><li>Nó nhanh và dễ sử dụng.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Đối tượng sử dụng Web API?",
              "answer": "<p>Một loạt các ứng dụng client như trình duyệt, thiết bị di động, iPhone, ..., sử dụng web API. Nó cũng dùng cùng với các ứng dụng native yêu cầu dịch vụ web nhưng không hỗ trợ SOAP. Nó cũng có thể được sử dụng bởi bất kỳ ứng dụng client nào hỗ trợ các hành động HTTP như GET, DELETE, POST, PUT.</p>",
              "level": "middle"
            },
            {
              "question": "Web API và MVC có gì khác?",
              "answer": "<p>MVC (Model-View-Controller) là mô hình thiết kế ứng dụng bao gồm 3 phần chính là model, view và controller. Nó cho phép người viết code xác định các thành phần khác nhau của ứng dụng và cập nhật chúng dễ dàng hơn. Nó chủ yếu được sử dụng để phát triển mô hình giao diện người dùng. Mục đích chính của nó là hiển thị các mẫu trong cấu trúc để giữ cho màn hình và dữ liệu được tách biệt cho phép cả hai thay đổi mà không ảnh hưởng đến những người khác.\r\n\r\n| MVC | Web API |\r\n|-|-|\r\n| Dùng cho xây dựng ứng dụng web dựa trên dữ liệu và view | Dùng cho xây dựng dịch vụ HTTP chỉ dựa trên dịch vụ |\r\n| Trả về dữ liệu dạng JSON |Trả về các định dạng dữ liệu khác nhau XML, JSON |\r\n| Hỗ trợ tự lưu trữ | Không hỗ trợ tự lưu trữ |\r\n| Không hỗ trợ dịch vụ RESTful | Hỗ trợ dịch vụ RESTful |\r\n| Trả về view (HTML) | Trả về phản hồi HTTP |\r\n\r\n<img src=\"/interview-assets/MVC_vs_Web_API.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "CORS là gì?",
              "answer": "<p>CORS (Cross-Origin Resource Sharing) là một kĩ thuật được sinh ra để làm cho việc tương tác giữa client và server được dễ dàng hơn, nó cho phép JavaScript ở một trang web có thể tạo yêu cầu HTTP lên một REST API được host ở một domain khác.\r\n\r\nTrong trường hợp đơn giản nhất, phía client (ứng dụng web đạng chạy ở trình duyệt đó) sẽ tạo yêu cầu GET, POST, PUT, HEAD,... để yêu cầu server làm một việc gì đó. Những yêu cầu này sẽ được đính kèm một header tên là <code>Origin</code> để chỉ định origin của client code (giá trị của header này chính là domain của trang web).\r\n\r\nServer sẽ xem xét <code>Origin</code> để biết được nguồn này có phải là nguồn hợp lệ hay không. Nếu hợp lệ, server sẽ trả về response kèm với header <code>Access-Control-Allow-Origin</code>. Header này sẽ cho biết xem client có phải là nguồn hợp lệ để trình duyệt tiếp tục thực hiện quá trình yêu cầu.\r\n\r\nTrong trường hợp thông thường, <code>Access-Control-Allow-Origin</code> sẽ có giá trị giống như <code>Origin</code>, một số trường hợp giá trị của <code>Access-Control-Allow-Origin</code> sẽ nhìn giống giống như Regex hay chỉ đơn giản là <code><em></code>, tuy nhiên thì cách dùng <code></em></code> thường được coi là không an toàn, ngoại trừ trường hợp API của bạn được public hoàn toàn và ai cũng có thể truy cập được.\r\n\r\nVà như thế, nếu không có header <code>Access-Control-Allow-Origin</code> hoặc giá trị của nó không hợp lệ thì trình duyệt sẽ từ chối chúng ta.\r\n\r\n<img src=\"/interview-assets/cors.png\" alt=\"\" /></p>",
              "level": "middle"
            }
          ]
        }
      ]
    },
    {
      "id": "backend",
      "name": "Backend Development",
      "icon": "storage",
      "color": "#4fc3f7",
      "subcategories": [
        {
          "id": "csharp",
          "name": "Câu hỏi phỏng vấn C#",
          "description": "",
          "questions": [
            {
              "question": "C# khác với C/C++ như thế nào?",
              "answer": "<p>C có thể xem là ngôn ngữ lập trình bậc thấp vì nó có cấu trúc, thủ tục lập trình giản đơn. C nên là lựa chọn hàng đầu khi xây dựng các chương trình lõi, hệ điều hành, chương trình nhúng….\r\n\r\nC++ có thể được phân là ngôn ngữ lập trình bậc trung. Nó là một thế hệ con của C, được thiết kế nhằm khắc phục những hạn chế của C. Nó hỗ trợ cho việc lập trình hướng đối tượng mà vẫn giữ được những tính chất ban đầu và tốc độ thực thi của C. Hoàn toàn không có lớp ảo hóa nào ở trung gian, trình biên dịch C++ chuyển trực tiếp từ mã nguồn sang mã máy.\r\n\r\nC# kế thừa C và C++, và là ngôn ngữ lập trình hướng đối tượng bậc cao, ngang hàng với các ngôn ngữ lập trình bậc cao khác như Python, Java… Lập trình viên sử dụng C#, sẽ được hỗ trợ nhiều tính năng hơn. Cũng giống như Python hay Java, mã nguồn C# sẽ được chuyển sang dạng bytecode trên máy ảo CLR (Common Language Runtime), sau đó mới chuyển sang mã máy.\r\n\r\nVới C và C++, người dùng có thể trực tiếp quản lý vùng nhớ của họ. Tuy vậy, hai ngôn ngữ lập trình này không có cơ chế dọn rác tự động.\r\n\r\nCòn với C# bạn không cần lo lắng về vùng nhớ. Nhờ hỗ trợ chức năng dọn rác tự động, ngôn ngữ này giúp bạn quản lý vùng nhớ dễ dàng và hiệu quả hơn. Khi đầy rác, vùng nhớ bị hết; nó sẽ tự xóa rác mà không cần bạn phải vào thao tác.</p>",
              "level": "fresher"
            },
            {
              "question": "CLR là gì?",
              "answer": "<p>Common Language Runtime (CLR) xử lý chương trình thực thi chương trình cho nhiều ngôn ngữ khác nhau bao gồm cả C#. Kiến trúc của CLR xử lý quản lý bộ nhớ, thu gom rác, xử lý bảo mật và trông giống như: \r\n\r\n<img src=\"/interview-assets/Common_Language_Runtime_(CLR).png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Bộ dọn rác trong C#?",
              "answer": "<p>Bộ dọn rác (garbage collection) là quá trình giải phóng bộ nhớ bị chiếm bởi các đối tượng không mong muốn. Khi bạn tạo một đối tượng, tự động một số không gian bộ nhớ được cấp cho đối tượng trong bộ nhớ heap. Bây giờ, sau khi bạn thực hiện tất cả các hành động trên đối tượng, không gian bộ nhớ bị chiếm bởi đối tượng sẽ trở thành lãng phí. Sẽ là cần thiết để giải phóng bộ nhớ. Việc thu gom rác xảy ra trong ba trường hợp: \r<ul><li>Nếu bộ nhớ bị chiếm bởi các đối tượng vượt quá ngưỡng giá trị đặt trước.</li></ul>\r<ul><li>Nếu phương thức thu gom rác được gọi</li></ul>\r<ul><li>Nếu hệ thống của bạn có bộ nhớ vật lý thấp</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu class trong C#?",
              "answer": "<p>Class trong C# chính là cách thể hiện khái niệm về lớp trong lập trình hướng đối tượng. Trong C# có 4 kiểu class:\r<ul><li><strong>static class:</strong> khai báo bởi từ khoá <code>static</code> không cho phép kế thừa. Do đó không thể tạo đối tượng từ static class.</li></ul>\r\n\r\n``<code>csharp\r\nstatic class classname\r\n{\r\n    // static data \r\n    // static methods\r\n}\r\n</code>`<code>\r<ul><li><strong>partial class:</strong> khai báo bởi từ khoá </code>partial<code> cho phép các thành viên của nó phân chia hoặc chia sẻ với file (.cs) nguồn.</li></ul>\r<ul><li><strong>abstract class:</strong> là lớp không thể khởi tạo nên bạn không thể tạo đối tượng. abstract class hoạt động dựa trên khái niệm trừu tượng trong OOP. Tính trừu tượng giúp trích xuất các chi tiết cần thiết và ẩn những chi tiết không cần thiết. </li></ul>\r<ul><li><strong>sealed class:</strong>  Lớp được đóng dấu là lớp không thể được kế thừa. Sử dụng từ khóa </code>sealead<code> để hạn chế quyền truy cập đối với người dùng kế thừa lớp đó.</li></ul>\r\n\r\n</code>`<code>csharp\r\nsealed class classname\r\n{\r\n    // static data \r\n    // static methods\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa lớp trừu tượng và interface?",
              "answer": "<p>Hãy cùng tìm hiểu sự khác biệt giữa lớp trừu tượng và interface:\r<ul><li>Các lớp trừu tượng là các lớp không thể được khởi tạo tức là chúng không thể tạo một đối tượng. Interface giống như một lớp trừu tượng vì tất cả các phương thức bên trong interface đều là phương thức trừu tượng.</li></ul>\r<ul><li>Các lớp trừu tượng có thể có cả phương thức trừu tượng và không trừu tượng nhưng tất cả các phương thức của một interface đều là phương thức trừu tượng.</li></ul>\r<ul><li>Vì các lớp trừu tượng có thể có cả phương thức trừu tượng và không trừu tượng, chúng ta cần sử dụng từ khóa <code>abstract</code> để khai báo các phương thức trừu tượng. Nhưng trong interface, không cần như vậy.</li></ul>\r<ul><li>Một lớp trừu tượng có các hàm tạo trong khi một interface thì không.</li></ul>\r\n\r\n##</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa từ khoá ref và out?",
              "answer": "<p>Từ khoá <code>ref</code> truyền đối số bằng tham chiếu chứ không phải giá trị. \r\n\r\n``<code>csharp\r\nvoid Method(ref int refArgument)\r\n{\r\n   refArgument = refArgument + 10;\r\n}\r\nint number = 1;\r\nMethod(ref number);\r\nConsole.WriteLine(number);\r\n// Output: 11\r\n</code>`<code>\r\n\r\nTừ khoá </code>out<code> truyền đối số trong phương thức và hàm. Từ khóa </code>out<code> được sử dụng để truyền các đối số trong một phương thức làm tham chiếu để trả về nhiều giá trị. Mặc dù nó giống với từ khóa </code>ref<code>, nhưng từ khóa </code>ref<code> cần phải được khởi tạo trước khi được truyền. Ở đây, các từ khóa </code>out<code> và </code>ref<code> rất hữu ích khi chúng ta muốn trả về một giá trị trong cùng các biến được truyền dưới dạng đối số.\r\n\r\n</code>`<code>csharp\r\npublic static string GetNextFeature(ref int id)  \r\n{  \r\n   string returnText = &quot;Next-&quot; + id.ToString();  \r\n   id += 1;  \r\n   return returnText;  \r\n}  \r\npublic static string GetNextFeature(out int id)  \r\n{  \r\n   id = 1;  \r\n   string returnText = &quot;Next-&quot; + id.ToString();  \r\n   return returnText;  \r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Phương thức mở rộng trong C#?",
              "answer": "<p>Các phương pháp mở rộng giúp thêm các phương pháp mới vào các phương pháp hiện có. Các phương thức được thêm vào là tĩnh. Đôi khi, khi bạn muốn thêm các phương thức vào một lớp hiện có nhưng không nhận thấy quyền sửa đổi lớp đó hoặc không có quyền, bạn có thể tạo một lớp tĩnh mới chứa các phương thức mới. Khi các phương thức mở rộng được khai báo, hãy liên kết lớp này với lớp hiện có và xem các phương thức sẽ được thêm vào lớp hiện có.\r\n\r\n``<code>csharp\r\n// C# program to illustrate the concept\r\n// of the extension methods\r\nusing System;\r\n \r\nnamespace ExtensionMethod {\r\n    static class NewMethodClass {\r\n    \r\n        // Method 4\r\n        public static void M4(this Scaler s)\r\n        {\r\n            Console.WriteLine(&quot;Method Name: M4&quot;);\r\n        }\r\n        \r\n        // Method 5\r\n        public static void M5(this Scaler s, string str)\r\n        {\r\n            Console.WriteLine(str);\r\n        }\r\n    }\r\n    \r\n    // Now we create a new class in which\r\n    // Scaler class access all the five methods\r\n    public class IB {\r\n    \r\n        // Main Method\r\n        public static void Main(string[] args)\r\n        {\r\n            Scaler s = new Scaler();\r\n            s.M1();\r\n            s.M2();\r\n            s.M3();\r\n            s.M4();\r\n            s.M5(&quot;Method Name: M5&quot;);\r\n        }\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nMethod Name: M1\r\n\r\nMethod Name: M2\r\n\r\nMethod Name: M3\r\n\r\nMethod Name: M4\r\n\r\nMethod Name: M5\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Generic trong C#?",
              "answer": "<p>Trong C#, lập trình tổng quát (generics) là một dạng lập trình đặc biệt trong đó kiểu dữ liệu (của biến thành viên, biến cục bộ, tham số, kiểu trả về của phương thức,...) không được xác định ở giai đoạn xây dựng đơn vị code (như lớp, phướng thức) mà chỉ được xác định ở giai đoạn khởi tạo và sử dụng.\r\n\r\nĐể thực hiện điều này, ở giai đoạn khai báo người ta dùng một kiểu dữ liệu giả. Ở giai đoạn sử dụng, kiểu dữ liệu giả sẽ được thay thế bằng kiểu dữ liệu thực. Cú pháp dùng cho generic:\r\n\r\n``<code>csharp\r\nGenericList&lt;float&gt; list1 = new GenericList&lt;float&gt;();\r\nGenericList&lt;Features&gt; list2 = new GenericList&lt;Features&gt;();\r\nGenericList&lt;Struct&gt; list3 = new GenericList&lt;Struct&gt;();\r\n</code>`<code>\r\n\r\nỞ đây, </code>GenericList<float><code> là lớp generic. Với mỗi thực thể của </code>Generic<T>`, mỗi khi T xuất hiện trong lớp đều được thay thế bằng kiểu tham số ở thời điểm chạy. Bằng cách thay thế T, ta tạo ra ba kiểu khác nhau sử dụng cùng một lớp.</p>",
              "level": "fresher"
            },
            {
              "question": "Lớp partial trong C# là gì?",
              "answer": "<p>Các lớp partial thực hiện chức năng của một lớp đơn lẻ thành nhiều file. Nhiều file này được kết hợp thành một trong thời gian biên dịch. Lớp partial có thể được tạo bằng từ khóa <code>partial</code>.\r\n\r\n``<code>csharp\r\npublic partial Clas_name  \r\n{\r\n   // code\r\n}\r\n</code>``\r\n\r\nBạn có thể dễ dàng chia các chức năng của phương thức, interface hoặc cấu trúc thành nhiều file. Thậm chí có thể thêm các lớp partial lồng nhau.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa late binding và early binding trong C#?",
              "answer": "<p>Late binding và early binding là hai ví dụ cho khái niệm đa hình trong OOPs.\r\n\r\nVí dụ: một hàm <code>calculateBill()</code> sẽ tính toán chi phí cho khách hàng vip, khách hàng cơ bản và khách hàng tiềm năng dựa trên các chính sách khác nhau. Việc tính toán cho tất cả đối tượng khác nhau này nhưng sử dụng cùng một hàm được gọi là đa hình.\r\n\r\nKhi đối tượng được gán một biến đối tượng trong C#, framework .NET thực hiện liên kết.\r\n\r\nKhi hàm liên kết xảy ra ở thời gian biên dịch nó được gọi là early binding. Nó kiểm tra các phương thức và thuộc tính của các đối tượng tĩnh. Với early binding, số lỗi thời gian chạy giảm đáng kể và nó thực thi khá nhanh.\r\n\r\nNhưng nếu liên kết xảy ra ở thời gian chạy, nó được gọi là late binding. Late binding xảy ra khi đối tượng là động (dựa trên dữ liệu mà nó giữ). Nó chậm hơn so với early binding</p>",
              "level": "fresher"
            },
            {
              "question": "Mảng trong C# là gì?",
              "answer": "<p>Khi một nhóm các phần tử tương tự được gộp lại với nhau dưới một tên, chúng được gọi là mảng.\r\n\r\nVd. Một mảng <code>Atea[4]: [green tea, chamomile tea, black tea, lemon tea]</code>. Độ dài của mảng xác định có bao nhiêu phần tử hiện diện trong mảng.\r\n\r\nTrong C#, việc cấp phát bộ nhớ cho các phần tử của mảng diễn ra tự động. Đây là cách các giá trị được lưu trữ trong một mảng một cách tuần tự.\r\n\r\n<img src=\"/interview-assets/arrays_in_C_.png\" alt=\"\" />\r\n\r\nCú pháp <code>&lt;Data Type&gt;[] &lt;Name_Array&gt;</code>\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Array và ArrayList trong C#?",
              "answer": "<p>Array (mảng) là một tập hợp biến có cùng kiểu được gộp lại dưới một cái tên. Trong khi ArrayList là tập hợp các đối tượng có chỉ mục riêng biệt. Với ArrayList bạn có thể truy cập với các tính ănng như cấp phát bộ nhớ động, thêm, tìm và sắp xếp mục trên ArrayList.\r<ul><li>Khi khai bao một mảng ta phải thiết lập kích cỡ tĩnh, do đó bộ nhớ là cố định. Trong khi ArrayList, có thể tăng giảm tuỳ ý.</li></ul>\r<ul><li>Mảng đi cùng với namespace <code>system.array</code> trong khi ArrayList đi cùng với namespace <code>system.collection</code>.</li></ul>\r<ul><li>Tất cả mục trong một mảng có cùng kiểu dữ liệu trong khi ArrayList có thể giống hoặc khác kiểu dữ liệu.</li></ul>\r<ul><li>Trong khi mảng không chấp nhận null, thì ArrayList chấp nhận giá trị null</li></ul>\r\n\r\n``<code>csharp\r\n// C# program to illustrate the ArrayList\r\nusing System;\r\nusing System.Collections;\r\n \r\nclass IB {\r\n \r\n    // Main Method\r\n    public static void Main(string[] args)\r\n    {\r\n    \r\n        // Create a list of strings\r\n        ArrayList al = new ArrayList();\r\n        al.Add(&quot;Bruno&quot;);\r\n        al.Add(&quot;Husky&quot;);\r\n        al.Add(10);\r\n        al.Add(10.10);\r\n    \r\n        // Iterate list element using foreach loop\r\n        foreach(var names in al)\r\n        {\r\n            Console.WriteLine(names);\r\n        }\r\n    }\r\n}\r\n</code>``\r\n\r\n## Câu hỏi phỏng vấn C# cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Kế thừa và đa kế thừa trong C#?",
              "answer": "<p>Kế thừa là một hoặc nhiều thuộc tính được truyền từ lớp cha sang lớp con.\r\n\r\n<img src=\"/interview-assets/Multiple-inheritance_in_C_.png\" alt=\"\" />\r\n\r\nVí dụ, lớp <code>C</code> kế thừa thuộc tính từ lớp <code>A</code> và lớp <code>B</code>. Đây là một ví dụ về kế thừa.\r\n\r\n``<code>csharp\r\n// C# program to illustrate\r\n// multiple class inheritance\r\nusing System;\r\nusing System.Collections;\r\n\r\n// Parent class 1\r\nclass Scaler {\r\n\r\n    // Providing the implementation\r\n    // of features() method\r\n    public void features()\r\n    {\r\n\r\n        // Creating ArrayList\r\n        ArrayList My<em>features= new ArrayList();\r\n\r\n        // Adding elements in the\r\n        // My</em>features ArrayList\r\n        My<em>features.Add(&quot;Abstraction&quot;);\r\n        My</em>features.Add(&quot;Encapsulation&quot;);\r\n        My<em>features.Add(&quot;Inheritance&quot;);\r\n\r\n        Console.WriteLine(&quot;Features provided by OOPS:&quot;);\r\n        foreach(var elements in My</em>features)\r\n        {\r\n            Console.WriteLine(elements);\r\n        }\r\n    }\r\n}\r\n\r\n// Parent class 2\r\nclass Scaler2 :Scaler{\r\n\r\n    // Providing the implementation\r\n    // of courses() method\r\n    public void languages()\r\n    {\r\n\r\n        // Creating ArrayList\r\n        ArrayList My<em>features = new ArrayList();\r\n\r\n        // Adding elements in the\r\n        // My</em>features ArrayList\r\n        My<em>features.Add(&quot;C++&quot;);\r\n        My</em>features.Add(&quot;C#&quot;);\r\n        My<em>features.Add(&quot;JScript&quot;);\r\n        \r\n\r\n        Console.WriteLine(&quot;\\nLanguages that use OOPS concepts:&quot;);\r\n        foreach(var elements in My</em>features)\r\n        {\r\n            Console.WriteLine(elements);\r\n        }\r\n    }\r\n}\r\n\r\n// Child class\r\nclass ScalertoScaler : Scaler2 {\r\n}\r\n\r\npublic class Scaler1 {\r\n\r\n    // Main method\r\n    static public void Main()\r\n    {\r\n\r\n        // Creating object of ScalertoScaler class\r\n        ScalertoScaler obj = new ScalertoScaler();\r\n        obj.features();\r\n        obj.languages();\r\n    }\r\n}\r\n</code>``\r\n\r\nC# không hỗ trợ đa kế thừa, thay vào đó bạn có thể dùng interface cho kế thừa thuộc tính bằng tên lớp.</p>",
              "level": "fresher"
            },
            {
              "question": "Boxing và Unboxing trong C#?",
              "answer": "<p><strong>Boxing</strong> là quá trình chuyển dữ liệu từ kiểu tham trị sang kiểu tham chiếu.Quá trình boxing một biến kiểu tham trị sẽ khởi tạo một đối tượng trong vùng nhớ heap và sao chép giá trị của biến tham trị vào đối tượng mới này. Và quá trình boxing được thực hiện nhờ quá trình chuyển đổi ngầm định.\r\n\r\n\r\n``<code>csharp\r\nint num = 23; // 23 will assigned to num\r\nObject Obj = num; // Boxing\r\n</code>`<code>\r\n\r\n<strong>Unboxing</strong> là quá trình ngược lại với Boxing, tức là đưa từ kiểu tham chiếu ra kiểu tham trị. Quá trình này sẽ được thực hiện một cách tường minh. Gồm có 2 bước :\r\n1. Kiểm tra chắc chắn rằng đối tượng đã được boxing đúng kiểu giá trị đưa ra.\r\n2. Sao chép giá trị sang biến dữ liệu kiểu tham trị.\r\n\r\n</code>`<code>csharp\r\nint num = 23;         // value type is int and assigned value 23\r\nObject Obj = num;    // Boxing\r\nint i = (int)Obj;    // Unboxing\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính trong C# là gì?",
              "answer": "<p>Các thuộc tính trong C# là các thành viên công khai của một lớp nơi chúng cung cấp khả năng truy cập các thành viên riêng tư của một lớp. Nguyên tắc cơ bản của đóng gói cho phép bạn ẩn một số thuộc tính nhạy cảm với người dùng bằng cách đặt các biến ở chế độ riêng tư. Các thành viên riêng tư không thể truy cập nếu không trong một lớp. Do đó, bằng cách sử dụng các thuộc tính trong C#, bạn có thể dễ dàng truy cập các thành viên riêng tư và thiết lập giá trị của chúng.\r\n\r\nCác giá trị có thể được gán dễ dàng bằng cách sử dụng các phương thức get và set, còn được gọi là trình truy cập. Trong khi phương thức get trích xuất giá trị, phương thức set sẽ gán giá trị cho các biến.</p>",
              "level": "fresher"
            },
            {
              "question": "Indexer trong C# là gì?",
              "answer": "<p>Indexer được gọi là mảng thông minh cho phép truy cập vào một biến thành viên. Các indexer cho phép các biến thành viên sử dụng các tính năng của một mảng. Chúng được tạo bằng từ khóa <code>Indexer</code>. Indexer không phải là thành viên tĩnh. \r\n\r\n``<code>csharp\r\n&lt;return type&gt; this[&lt;parameter type&gt; index]\r\n{\r\n    get{\r\n        // return the value from the specified index of an internal collection\r\n    }\r\n    set{\r\n        // set values at the specified index in an internal collection\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa toán tử == và phương thức equals() trong C#?",
              "answer": "<p>Cả hai đều dùng cho so sánh giá trị đối tượng, ví dụ:\r\n\r\n``<code>csharp\r\nint x = 10;\r\nint y = 10;\r\nConsole.WriteLine( x == y);\r\nConsole.WriteLine(x.Equals(y));\r\n\r\n// Output:\r\n// True\r\n// True\r\n</code>``\r\n\r\n<strong>Toán tử ==</strong>: là một kiểu tham chiếu có nghĩa là nó sẽ trả về true nếu điểm tham chiếu đến đối tượng giống nhau.\r\n\r\n<strong>Phương thức Equals()</strong> dùng so sánh giá trị hai được mang bởi các đối tượng. Trả về true khi tất cả giá trị được mang bởi đối tượng bằng nhau.</p>",
              "level": "fresher"
            },
            {
              "question": "Nạp chồng trong C#?",
              "answer": "<p>Nạp chồng (Overloading) có nghĩa là khi các phương thức có cùng tên nhưng mang các giá trị khác nhau để sử dụng trong một ngữ cảnh khác. Chỉ có phương thức main() không thể được nạp chồng.\r\n\r\nĐể thực hiện phương thức nạp chồng trong C#:\r<ul><li>Thay đổi số lượng tham số</li></ul>\r<ul><li>Thay đổi thứ tự tham số</li></ul>\r<ul><li>Sử dụng kiểu dữ liệu khác nhau cho tham số</li></ul>\r\n\r\nVd:\r\n\r\n``<code>csharp\r\npublic class Area {\r\n    public double area(double x) {\r\n        double area = x <em> x;\r\n        return area;\r\n    }\r\n    public double area(double a, double b) {\r\n        double area = a </em> b;\r\n        return area;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nỞ đây, phương thức Area được sử dụng hai lần. Trong khai báo đầu tiên, một đối số được sử dụng trong khi trong khai báo thứ hai, có hai đối số được sử dụng. Sử dụng các tham số khác nhau trong cùng một phương thức, chúng ta có thể nạp chồng phương thức </code>area()`.</p>",
              "level": "fresher"
            },
            {
              "question": "Reflection trong C#?",
              "answer": "<p>Reflection trong C# trích xuất metadata từ các kiểu dữ liệu trong thời gian chạy.\r\n\r\nĐể thêm reflection trong .NET, chỉ cần dùng namespace <code>System.Reflection</code> trong chương trình để truy xuất kiểu của bất cứ thứ gì từ:\r\n<em> Assembly\r\n</em> Module\r\n<em> Enum\r\n</em> MethodInfo\r\n<em> ConstructorInfo\r\n</em> MemberInfo\r\n<em> ParameterInfo\r\n</em> Type\r\n<em> FieldInfo\r\n</em> EventInfo\r<ul><li>PropertyInfo</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa hằng và readonly trong C#?",
              "answer": "<p>Từ khoá <strong>const</strong> trong C# dùng để khai báo hằng trong suốt chương trình. Điều này có nghĩa là sau khi biến được khai báo là hằng, giá trị của nó không thể thay đổi.\r\n\r\nTrong C# hằng là một số, chuỗi, tham chiếu null hoặc giá trị boolean.\r\n\r\n``<code>csharp\r\nclass IB {\r\n \r\n    // Constant fields\r\n    public const int xvar = 20;\r\n    public const string str = &quot;InterviewBit&quot;;\r\n    \r\n    // Main method\r\n    static public void Main()\r\n    {\r\n    \r\n        // Display the value of Constant fields\r\n        Console.WriteLine(&quot;The value of xvar: {0}&quot;, xvar);\r\n        Console.WriteLine(&quot;The value of str: {0}&quot;, str);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nThe value of xvar is 20.\r\nThe value of string is Interview Bit\r\n</code>`<code>\r\n\r\nMặt khác, từ khoá <strong>readonly</strong> chỉ có thể gán biến khi nó được khai báo hoặc trong một constructor của cùng một lớp mà nó được khai báo. \r\n\r\n</code>`<code>csharp\r\npublic readonly int xvar1;\r\n   public readonly int yvar2;\r\n \r\n   // Values of the readonly \r\n   // variables are assigned\r\n   // Using constructor\r\n   public IB(int b, int c)\r\n   {\r\n \r\n       xvar1 = b;\r\n       yvar2 = c;\r\n       Console.WriteLine(&quot;The value of xvar1 {0}, &quot;+\r\n                       &quot;and yvar2 {1}&quot;, xvar1, yvar2);\r\n   }\r\n \r\n   // Main method\r\n   static public void Main()\r\n   {\r\n     IB obj1 = new IB(50, 60);\r\n   }\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nThe value of xvar1 is 50, and yvar2 is 60\r\n</code>``\r<ul><li>Các hằng số là tĩnh theo mặc định trong khi readonly nên có một giá trị được gán khi phương thức khởi tạo được khai báo.</li></ul>\r<ul><li>Hằng số có thể được khai báo trong các hàm trong khi các sửa đổi readonly có thể được sử dụng với các kiểu tham chiếu.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa String và StringBuilder?",
              "answer": "<p>Sự khác biệt chính giữa String và StringBuilder là các đối tượng String là bất biến trong khi StringBuilder tạo ra một chuỗi ký tự có thể thay đổi. StringBuilder sẽ thực hiện các thay đổi đối với đối tượng hiện có hơn là tạo đối tượng mới.\r\n\r\nStringBuilder đơn giản hóa toàn bộ quá trình thực hiện thay đổi đối với đối tượng chuỗi hiện có. Vì lớp String là bất biến nên sẽ tốn kém hơn khi tạo một đối tượng mới mỗi khi chúng ta cần thực hiện thay đổi. Vì vậy, lớp StringBuilder xuất hiện có thể được gợi lên bằng cách sử dụng không gian tên System.Text.\r\n\r\nTrong trường hợp, một đối tượng chuỗi sẽ không thay đổi trong toàn bộ chương trình, thì hãy sử dụng lớp String hoặc StringBuilder khác.\r\n\r\n``<code>csharp\r\nstring s = string.Empty; \r\nfor (i = 0; i &lt; 1000; i++) \r\n{ \r\n    s += i.ToString() + &quot; &quot;; \r\n}\r\n</code>`<code>\r\n\r\nTại đây, bạn sẽ cần tạo 2001 đối tượng trong đó 2000 sẽ không được sử dụng.\r\n\r\nĐiều tương tự có thể được áp dụng bằng cách sử dụng StringBuilder:\r\n\r\n</code>`<code>csharp\r\nStringBuilder sb = new StringBuilder(); \r\nfor (i = 0; i &lt; 1000; i++) \r\n{ \r\n   sb.Append(i); sb.Append(&#39; &#39;); \r\n}\r\n</code>``\r\n\r\nBằng cách sử dụng StringBuilder ở đây, bạn cũng giảm bớt căng thẳng cho bộ cấp phát bộ nhớ.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "django",
          "name": "Câu hỏi phỏng vấn Django",
          "description": "",
          "questions": [
            {
              "question": "Giải thích kiến trúc Django?",
              "answer": "<p>Django tuân theo mô hình kiến trúc MVT (Model View Template) thay vì mô hình MVC (Model View Controller) truyền thống. Nó khác với MVC ở chỗ, logic vốn của controller được xử lý ở chính view của framework. Còn template nằm ở tầng biểu diễn. HTML được kết hợp với Django Template Language (DTL). Các nhà phát triển cung cấp model, view và template sau đó ánh xạ nó vào URL, để nó phục vụ người dùng.\r\n\r\n<img src=\"/interview-assets/mvt.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cấu trúc thư mục Django?",
              "answer": "<p><ul><li><code>manage.py</code>: dùng cho các dòng lệnh cần thiết tương tác với ứng dụng Django.</li></ul>\r<ul><li><code><strong>init</strong>.py</code>: file rỗng nói với Python rằng xem thư mục hiện tại như một package Python.</li></ul>\r<ul><li><code>settings.py</code>: thiết lập các biến môi trường cho ứng dụng như tên cơ sở dữ liệu, secret key,...</li></ul>\r<ul><li><code>urls.py</code>: tất cả url của ứng dụng sẽ ở file này.</li></ul>\r<ul><li><code>wsgi.py</code>: điểm vào của ứng dụng, dược dùng bởi các web server khi dự án được tạo thành ứng dụng thực.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Model trong Django là gì?",
              "answer": "<p>Một model trong Django là một lớp sẽ được ánh xạ thành một bảng hoặc collection của cơ sở dữ liệu. Mỗi thuộc tính của lớp trong model sẽ là một trường trong cơ sở dữ liệu, nó được định nghĩa trong <code>app/models.py</code>\r\n\r\nVí dụ:\r\n\r\n``<code>py\r\nfrom django.db import models\r\n\r\nclass SampleModel(models.Model):\r\n    field1 = models.CharField(max<em>length = 50)\r\n    field2 = models.IntegerField()\r\n\r\n    class Meta:\r\n        db</em>table = &quot;sample_model&quot;\r\n</code>`<code>\r\n\r\nTất cả model đều kết thừa từ </code>django.db.models.Model`.\r\n\r\nỞ ví dụ trên ta có hai thuộc tính (1 char và 1 integer). Meta giúp bạn thiết lập những thứ có sẵn như quyền truy cập, phiên bản số nhiều và số ít của tên, tên bảng được liên kết, có abstract hay không,...</p>",
              "level": "fresher"
            },
            {
              "question": "Template trong Django hay DTL là gì?",
              "answer": "<p>Template là một phần trong kiến trúc MVT của Django. Nó bao gồm HTML, CSS nơi các biến hay thông tin được nhúng vào từ view. Các biến hay tag sẽ được template engine nhận ra và thông dịch chúng. \r\n\r\nTemplate được render với một ngữ cảnh nhất định, để thay thế các biến thành giá trị của nó và biểu diễn trong ngữ cảnh đó, đồng thời xử lý các tag. Tất cả thứ khác sẽ được giữ nguyên.\r\n\r\nCú pháp của DTL bao gồm các cấu trsuc sau:\r<ul><li>Biến</li></ul>\r<ul><li>Tag</li></ul>\r<ul><li>Bộ lọc</li></ul>\r<ul><li>Comment</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "View trong Django là gì?",
              "answer": "<p>Một hàm view hay view, đơn giản là một hàm Python nhận các yêu cầu web và trả về phản hồi. Phản hồi có thể là nội dung HTML của một trang web, một redirect (điều hướng sang trang khác), lỗi 404, hình ảnh hay một XML hoặc JSON,...\r\n\r\nVí dụ:\r\n\r\n``<code>py\r\nfrom django.http import HttpResponse\r\ndef sample_function(request):\r\n    return HttpResponse(&quot;Welcome to Django&quot;)\r\n</code>``\r\n\r\nCó hai loại view:\r<ul><li><strong>Function-Based Views</strong>: ta import view như một hàm.</li></ul>\r<ul><li><strong>Class-based Views</strong>: tiếp cận theo hướng đối tượng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Django ORM là gì?",
              "answer": "<p>ORM (Object Relational Mapper) giúp ta tương tác với cơ sở dữ liệu theo code python thay vì viết các truy vấn sql thuần, nó giúp ta truy xuất, lưu và xoá dễ dàng hơn. Nó hoạt động ở tầng trừu tượng giữa model và cơ sở dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Static file là gì?",
              "answer": "<p>Website cần phục vụ các files như hình ảnh, js và css. Trong Django, các file này gọi là \"static file\". Nó được cung cấp bởi <code>django.contrib.staticfiles</code> để quản lý các file đấy.</p>",
              "level": "fresher"
            },
            {
              "question": "Django Rest Framework là gì?",
              "answer": "<p>Django Rest Framework (DJF) là một framework mã nguồn mở dựa trên Django để tạo RESTful API.</p>",
              "level": "fresher"
            },
            {
              "question": "Django-admin và manage.py là gì?",
              "answer": "<p>Django-admin là câu lệnh dùng cho các công việc quản trị trong Django. Bên cạnh đó, manage.py là file tự động tạo khi ta tạo dự án django. Nó không chỉ thực hiện các công việc chung như django-admin mà còn thiết lập môi trường biến <code>DJANGO<em>SETTINGS</em>MODULE</code> trỏ đến file settings.py trong dự án.\r\nCác câu lệnh thường dùng trong django.\r<ul><li><code>django-admin startproject</code> - tạo dự án Django với cấu trúc thư mục cho tên dự án nằm trong thư mục hiện tại hoặc đường dẫn.</li></ul>\r<ul><li><code>django-admin startapp</code> - tạo ứng dụng django trong dự án django với tên dự án.</li></ul>\r<ul><li><code>django-admin makemigrations</code> - tạo migration mới sau mỗi lần thay đổi model.</li></ul>\r<ul><li><code>django-admin migrate</code> - thực thi lệnh SQL, đồng bộ cơ sở dữ liệu với model và migrations.</li></ul>\r<ul><li><code>django-admin runserver</code> - chạy web server trên máy localhost. Cổng mặc định là 8000 với địa chỉ IP là 127.0.0.1. Có thể tuỳ chỉnh địa chỉ IP và port.</li></ul>\r<ul><li><code>django-admin createsuperuser</code> - tạo tài khoản với quyền quản trị.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Jinja là gì?",
              "answer": "<p>Jinja2 là một ngôn ngữ tạo template cung cấp cho các lập trình viên Python, được tạo ra dựa trên ý tưởng của Django template.\r\n\r\nJinja2 được sử dụng để tạo HTML, XML hoặc các định dạng file khác dựa trên nguyên tắc kết hợp các dữ liệu vào các vị trí đã được đánh dấu trong văn bản.</p>",
              "level": "fresher"
            },
            {
              "question": "Django URL là gì?",
              "answer": "<p>URL là một phần quan trọng trong ứng dụng web và Django cung cấp cách thiết kế để tuỳ chỉnh URL có tên là URLconf (URL Configuration). Chức năng cơ bản của nó là giúp bạn thiết kế URL ứng với các hàm view. Các URL này có thể là tĩnh hoặc động, được khai báo trong <code>urls.py</code> \r\n\r\nCú pháp:\r\n\r\n``<code>py\r\nfrom django.urls import path\r\nfrom . import views\r\nurlpatterns = [\r\n   path(&#39;data/2020/&#39;, views.data<em>2020),\r\n   path(&#39;data/&lt;int:year&gt;/&#39;, views.data</em>year)\r\n]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa ứng dụng và dự án trong Django?",
              "answer": "<p>Trong Django, dự án (project) chỉ toàn bộ ứng dụng (app) và ứng dụng là một phần trong dự án cho xử lý một trường hợp cụ thể.\r\nVí dụ, hệ thống thanh toán (app) trong ứng dụng e-commerce(project).</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu kế thừa trong Django?",
              "answer": "<p><ul><li><strong>Abstract Base Class Inheritance:</strong> dùng khi bạn cần giữ thông tin ở lớp cha để không phải ghi lại ở mỗi lớp con.</li></ul>\r<ul><li><strong>Multi-Table Model Inheritance:</strong> dùng khi phân lớp một model đã có và cần bảng riêng cho mỗi model trong cơ sở dữ liệu.</li></ul>\r<ul><li><strong>Proxy Model Inheritance:</strong>  dùng khi muốn giữ lại vài trường trong model trong khi chỉnh sửa model của hàm python.</li></ul>\r\n\r\n## Câu hỏi phỏng vấn Django cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Signals trong Django là gì?",
              "answer": "<p>Bất cứ khi nào chỉnh sửa model, ta cần kích hoạt vài hành động. Django cung cấp một cách để xử lý chúng dưới dạng tín hiệu (signal). Các tín hiệu là những tiện ích cho phép chúng ta liên kết các sự kiện với các hành động. Chúng ta có thể thực hiện những điều này bằng cách phát triển một hàm sẽ chạy khi một tín hiệu gọi nó. \r\n\r\n| Signals | Mô tả |\r\n|---------|-------|\r\n| django.db.models.pre<em>init & django.db.models.post</em>init | Gửi trước hoặc sau khi phương thức <code><em>init</em>()</code> của model được gọi |\r\n| django.db.models.signals.pre<em>save & django.db.models.signals.post</em>save | Gửi trước hoặc sau khi phương thức <code>save()</code> của model được gọi |\r\n| django.db.models.signals.pre<em>delete & django.db.models.signals.post</em>delete | Gửi trước hoặc sau phương thức <code>delete()</code> của model hoặc queryset được gọi |\r\n| django.db.models.signals.pre<em>delete & django.db.models.signals.post</em>delete | Gửi khi <code>ManyToManyField</code> được thay đổi |\r\n| django.core.signals.request<em>started & django.core.signals.request</em>finished | Gửi khi yêu cầu HTTP bắt đầu hoặc kết thúc |</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về caching trong Django?",
              "answer": "<p>Caching đề cập đến kỹ thuật lưu giữ kết quả output ở lần xử lý đầu tiên cho các lần tiếp theo nếu kết quả trùng lặp. Thay vì xử lý các yêu cầu giống nhau lại lần nữa, ta lấy kết quả cũ đã lưu, giúp truy cập nhanh hơn. Django cung cấp hệ thống cache mạnh mẽ cho lưu trữ ở các trang web động.\r\n\r\n| Cache | Mô tả |\r\n|-------|-------|\r\n| Memcached | Một memory-based cache server nhanh và hiệu quả |\r\n| FileSystem Caching | Giá trị cache được lưu từng file riêng biệt theo trật tự serialize |\r\n| Local-memory Caching | Chiến lược cache mặc định của django. Nó xử lý từng tiến trình và thread-safe. |\r\n| Database caching | Dữ liệu cache được lưu trong cơ sở dữ liệu và hoạt động hiệu quả nếu bạn đánh chỉ mục DB |</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về xác thực người dùng trong Django?",
              "answer": "<p>Django cung cấp sẵn hệ thống xác thực người dùng, với các đối tượng như <code>users</code>, <code>groups</code>, <code>user-permissions</code> và <code>user sesions</code>. Django không chỉ xác thực (authen) mà còn uỷ quyền (authorize) người dùng.\r\n\r\nCác đối tượng trong hệ thống:\r<ul><li>Users</li></ul>\r<ul><li>Permissions</li></ul>\r<ul><li>Groups</li></ul>\r<ul><li>Password Hashing System</li></ul>\r<ul><li>Forms Validation</li></ul>\r<ul><li>A pluggable backend system</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách để config file static?",
              "answer": "<p>Đảm bảo rằng <code>django.contrib.staticfiles</code> đã được thêm vào <code>INSTALLED<em>APP</code> ở file <code>settings.py</code>.\r\n\r\nNếu bạn muốn thiết lập url cho file static: <code>STATIC</em>URL = &quot;/static/&quot;</code>\r\n\r\nTrong template, sử dụng thẻ template để tạo URL cho dường dẫn liên quan:\r\n\r\n``<code>html\r\n{% load static %}\r\n&lt;img src=&quot;{% static &#39;my<em>sample/abcxy.jpg&#39; %}&quot; alt=&quot;ABC image&quot;&gt;\r\n</code>`<code>\r\n\r\nCác file static được lưu trong thư mục static trong ứng dụng. Như </code>my</em>sample/static/my_sample/abcxy.jpg`.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về vòng đời Response trong Django?",
              "answer": "<p>Bất cứ khi nào một yêu cầu (request) đến web, Django sẽ tạo một đối tượng HttpRequest bao gồm metadata của request. Sau đó Django tải view cụ thể, truyền HttpRequest như tham số đầu tiên cho hàm view. Mỗi view sẽ trả về một đối tượng HttpResponse.\r\n\r\n<img src=\"/interview-assets/lifecycle.png\" alt=\"\" />\r\n\r\n1. Đầu tiên file settings.py được tải chứa các lớp middleware khác nhau (<code>MIDDLEWARES</code>)\r\n2. Các middleware được thực thi theo thứ tự mà chúng được thiết lập trong <code>MIDDLEWAREST</code>.\r\n3. Từ đây, request được chuyển đến URL Router, thứ này chỉ cần lấy đường dẫn URL từ request và cố gắng ánh xạ với các đường dẫn URL tương ứng trong urls.py.\r\n4. Ngay sau khi nó được ánh xạ, nó sẽ gọi hàm view tương đương, từ đó một responsei tương đương được tạo ra.\r\n5. Response cũng đi qua middleware phản hồi và gửi lại cho trình duyệt.</p>",
              "level": "fresher"
            },
            {
              "question": "Cơ sở dữ liệu được hỗ trợ bởi Django?",
              "answer": "<p>Các cơ sở dữ liệu được Django hỗ trợ sẵn như PostgreSQL, MySQL, SQLite, Oracle bên cạnh đó là ODBC, Microsoft SQL Server, IBM DB2, SAP SQL. Hiện tại Django đã hỗ trợ NoSQL với mongoengine hay django-redis-cache.</p>",
              "level": "fresher"
            },
            {
              "question": "Session framework là gì?",
              "answer": "<p>Với session framework, ta có thể dễ dàng lưu trữ và truy xuất dữ liệu tuỳ ý dựa trên các lần truy cập trước. Nó lưu trữ dữ liệu phía server và xử lý các quá trình gửi nhận cookie. Do cookie chỉ bao gồm session ID, không có dữ liệu thực trừ khi bạn chỉ định nó.</p>",
              "level": "fresher"
            },
            {
              "question": "Middleware trong Django là gì?",
              "answer": "<p>Middleware là một thứ gì đó nằm giữa request và response. Nói đơn giản hơn nó là một cây cầu. Trong Django, một request được chuyển đến view thông qua middleware và dữ liệu được truyền tới response thông qua middleware.</p>",
              "level": "fresher"
            },
            {
              "question": "Context trong Django là gì?",
              "answer": "<p>Context là một tên biến mẫu ánh xạ được cấp cho các đối tượng Python trong Django. Đây là tên chung, nhưng bạn có thể đặt bất kỳ tên nào khác tùy thích nếu bạn muốn.</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm django.shortcuts.render là gì?",
              "answer": "<p>Khi một hàm view trả về một trang web như HttpResponse thay vì một chuỗi, ta sử dụng <code>render()</code>. Hàm render là một hàm nhỏ giúp lập trình viên dễ dàng truyền dữ liệu vào template. Hàm này kết hợp template với dữ liệu thông qua template engine. Sau cùng, nó trả về một HttpResponse như một văn bản đã render, để trả về dữ liệu bởi model. Do đó, render() bỏ quả hầu hết công việc so với các template engine khác.\r\n\r\nCú pháp:\r\n\r\n``<code>py\r\nrender(request, template<em>name, context=None, content</em>type=None, status=None, using=None)\r\n</code>`<code>\r\n\r\nTrong đó, </code>request<code> là một tham số dùng cho tạo response. </code>template_name<code> là HTML template dùng. </code>context` là dữ liệu được truyền vào trang web. Bạn cũng có thẻ chỉ định content-type, status của dữ liệu và render lại.</p>",
              "level": "fresher"
            },
            {
              "question": "Đặc trưng của file settings.py?",
              "answer": "<p>Như tên gọi, file này lưu trữ cấu hình hay thiết lập cho ứng dụng Django, như kết nối cơ sở dữ liệu, backend engine, middleware, các ứng dụng bên thứ 3, URL chính, thư mục lưu file static, template engine, key bảo mật, host được phép truy cập,...</p>",
              "level": "fresher"
            },
            {
              "question": "Cách xem tất cả mục trong model?",
              "answer": "<p>``<code>py\r\nModelName.objects.all()\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách lọc mục trong model?",
              "answer": "<p>``<code>py\r\nModelName.objects.filter(field_name=&quot;term&quot;)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sử dụng file-based session như thế nào?",
              "answer": "<p>Bạn cần thiết lập cài đặt <code>SESSION_ENGINE</code> thành <code>&quot;django.contrib.sessions.backends.file&quot;</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Mixin là gì?",
              "answer": "<p>Mixin là kiểu đa kế thừa trong đó ta có thể kết hợp các hành vi và thuộc tính từ nhiều hơn một lớp cha. Nó cung cấp cách thông minh giúp sử dụng lại code từ nhiều lớp. Một hạn chế của việc sử dụng các mixin này là khó phân tích xem một lớp đang làm gì và phương thức nào cần ghi đè trong trường hợp code của nó quá rải rác giữa nhiều lớp.</p>",
              "level": "fresher"
            },
            {
              "question": "Field trong Django là gì?",
              "answer": "<p>Field (trường) đề cập đến một lớp trừu tượng biểu diễn một cột trong bảng cơ sở dữ liệu. Lớp Field chỉ là một lớp con của RegisterLookupMixin. Trong Django, các trường này được dùng cho tạo bảng cơ sở dữ liệu (<code>db<em>types()</code>), được dùng để ánh xạ kiểu Python sang cơ sở dữ liệu sử dụng <code>get</em>prep<em>value()</code> và ngược lại bằng phương thúc <code>from</em>db_value()</code>. Do đó, các field là phần cơ bản trong các API khác nhau, chẳng hạn như model và querysets.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa OneToOneField và ForeignKey Field?",
              "answer": "<p>Cả hai đều kà các kiểu phổ biến dùng cho trường trong Django. Sự khác biệt của cả hai là ForeignKet bao gồm lựa chọn <code>on_delete</code> cung với một lớp model vì nó dùng cho mối quan hệ many-to-one trong khi OneToOneField dùng cho mối quan hệ one-to-one và chỉ yêu cầu lớp model.</p>",
              "level": "fresher"
            },
            {
              "question": "Kết hợp nhiều queryset trong một view?",
              "answer": "<p>Cách dễ nhất là kết hợp các queryset vào một list. Ví dụ\r\n\r\n``<code>py\r\nfrom itertools import chain\r\n\r\nresult<em>list = list(chain(model1</em>list, model2<em>list, model3</em>list))\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Lấy một mục cụ thể trong Model?",
              "answer": "<p>``<code>py\r\nModelName.objects.get(id=&quot;term&quot;)\r\n</code>`<code>\r\n\r\nNếu không có kết quả trùng, </code>get()` sẽ trả về một ngoại lệ <strong>DoesNotExist</strong>. Nếu nhiều hơn một kết quả, nó sẽ trả về <strong>MultipleObjectsReturned</strong>.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm cách nào để lấy truy vấn SQL từ queryset?",
              "answer": "<p>``<code>py\r\nprint(queryset.query)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách tuỳ chỉnh chức năng của Django Admin Interface?",
              "answer": "<p>Có nhiều cách để tùy chỉnh chức năng của Django Admin Interface. Bạn có thể dựa trên form thêm/thay đổi do Django tạo tự động, bạn có thể thêm module JavaScript bằng cách sử dụng tham số js. Tham số này về cơ bản là danh sách các URL trỏ đến các module JavaScript sẽ được đưa vào dự án của bạn trong thẻ  <code>&lt;script&gt;</code>. Bạn cũng có thể viết lượt xem cho quản trị viên nếu bạn muốn.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa select_related và prefetch_related?",
              "answer": "<p>Cả hai hàm đều dùng cho lấy các trường liên quan từ model nhưng có vài khác biệt nhỏ. <code>select<em>related</code> dùng cho mối quan hệ với foreign key tức là dùng join trên chính truy vấn trong khi <code>prefetch</em>related</code> dùng cho các lookup riêng biệt và join phía python. Ví dụ\r<ul><li><strong>select<em>related</strong></li></ul>\r\n\r\n``<code>py\r\nfrom django.db import models\r\nclass Country(models.Model):\r\n    country</em>name = models.CharField(max<em>length=5)\r\nclass State(models.Model):\r\n    state</em>name = models.CharField(max<em>length=5)\r\n    country = model.ForeignKey(Country)\r\n&gt;&gt; states = State.objects.select</em>related(&#39;country&#39;).all()\r\n&gt;&gt; for state in states:\r\n…   print(state.state<em>name) \r\n</code>`<code>\r\n\r\n</code>`<code>sql\r\nSELECT state</em>id, state<em>name, country</em>name FROM State INNER JOIN Country ON (State.country<em>id = Country.id)\r\n</code>`<code>\r<ul><li><strong>prefetch</em>related</strong></li></ul>\r\n\r\n</code>`<code>py\r\n&gt;&gt; country = Country.objects.prefetch<em>related(‘state’).get(id=1)\r\n&gt;&gt; for state in country.state.all():\r\n…   print(state.state</em>name)\r\n</code>`<code>\r\n\r\n</code>`<code>sql\r\nSELECT id, country<em>name FROM country WHERE id=1;\r\nSELECT state</em>id, state<em>name WHERE State WHERE country</em>id IN (1);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích đối tượng Q trong Django ORM?",
              "answer": "<p>Đối tượng Q được dùng cho viết các truy vấn phức tạp, như một hàm <code>filter()</code> với các điều kiện <code>AND</code> hay <code>OR</code>. Ví dụ:\r\n\r\n``<code>py\r\nfrom django.db import models\r\nfrom django.db.models import Q\r\n&gt;&gt; objects = Models.objects.get(\r\n   Q(tag__startswith=&#39;Human&#39;),\r\n   Q(category=&#39;Eye&#39;) | Q(category=&#39;Nose&#39;)\r\n)\r\n</code>`<code>\r\n\r\nNó tương tự câu truy vấn:\r\n\r\n</code>`<code>sql\r\nSELECT * FROM Model WHERE tag LIKE &#39;Human%&#39; AND (category=&#39;Eye&#39; OR category=&#39;Nose&#39;)\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "microservice",
          "name": "Câu hỏi phỏng vấn Microservice",
          "description": "",
          "questions": [
            {
              "question": "Các tính năng chính của Microservices?",
              "answer": "<p><img src=\"/interview-assets/features_of_Microservices.jpg\" alt=\"\" />\r<ul><li><strong>Phân Tách:</strong> Trong một hệ thống, các dịch vụ chủ yếu được phân tách. Do đó, toàn bộ ứng dụng có thể dễ dàng được xây dựng, thay đổi và có thể mở rộng.</li></ul>\r<ul><li><strong>Thành phần hóa:</strong> Microservice được xem như các thành phần độc lập có thể dễ dàng được trao đổi hoặc nâng cấp.</li></ul>\r<ul><li><strong>Kích cỡ nghiệp vụ:</strong> Microservice tương đối đơn giản và chỉ tập trung vào một dịch vụ.</li></ul>\r<ul><li><strong>Quyền tự chủ của nhóm:</strong> Các nhà phát triển làm việc độc lập với nhau, cho phép tiến trình dự án nhanh hơn.</li></ul>\r<ul><li><strong>Phân phối liên tục:</strong> Cho phép phát hành phần mềm thường xuyên thông qua hệ thống tự động hóa phát triển, kiểm tra và phê duyệt phần mềm.</li></ul>\r<ul><li><strong>Trách nhiệm:</strong> Microservices không tập trung vào các ứng dụng như các dự án. Thay vào đó, họ coi các ứng dụng là sản phẩm mà họ chịu trách nhiệm.</li></ul>\r<ul><li><strong>Quản trị phi tập trung:</strong> Lựa chọn công cụ phù hợp theo công việc là mục tiêu. Các nhà phát triển có thể chọn các công cụ tốt nhất để giải quyết vấn đề của họ</li></ul>\r<ul><li><strong>Kết hợp Agile:</strong> Microservices tạo điều kiện cho kết hợp với phương pháp Agile. Có thể tạo các tính năng mới một cách nhanh chóng và loại bỏ chúng bất cứ lúc nào</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thành phần chính trong Microservices?",
              "answer": "<p><em> Containers, Clustering, và Orchestration.\r\n</em> IaC [Infrastructure as Code Conception] \r\n<em> Cloud Infrastructure \r\n</em> API Gateway \r\n<em> Enterprise Service Bus \r\n</em> Service Delivery</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu nhược điểm của Microservices?",
              "answer": "<p><strong>Ưu điểm</strong>\r<ul><li>Module triển khai khép kín và độc lập.</li></ul>\r<ul><li>Các dịch vụ được quản lý độc lập.</li></ul>\r<ul><li>Để cải thiện hiệu suất, dịch vụ yêu cầu có thể được triển khai trên nhiều server.</li></ul>\r<ul><li>Nó dễ kiểm tra hơn và có ít phụ thuộc hơn.</li></ul>\r<ul><li>Khả năng mở rộng lớn hơn.</li></ul>\r<ul><li>Đơn giản trong việc debug và bảo trì.</li></ul>\r<ul><li>Giao tiếp tốt hơn giữa nhà phát triển và người dùng doanh nghiệp.</li></ul>\r<ul><li>Các nhóm phát triển có quy mô nhỏ hơn.</li></ul>\r\n\r\n<strong>Nhược điểm</strong>\r<ul><li>Do sự phức tạp của kiến trúc, việc kiểm tra và giám sát khó khăn hơn.</li></ul>\r<ul><li>Thiếu văn hóa doanh nghiệp phù hợp để nó hoạt động.</li></ul>\r<ul><li>Lập kế hoạch trước là điều cần thiết.</li></ul>\r<ul><li>Phát triển phức tạp.</li></ul>\r<ul><li>Yêu cầu một sự chuyển dịch văn hóa.</li></ul>\r<ul><li>Đắt so với monoliths.</li></ul>\r<ul><li>Nguy cơ về bảo mật.</li></ul>\r<ul><li>Việc duy trì mạng khó khăn hơn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các công cụ thường dùng cho Microservices?",
              "answer": "<p><ul><li>Wiremock</li></ul>\r<ul><li>Docker</li></ul>\r<ul><li>Hstrix</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích kiến trúc Microservice?",
              "answer": "<p><img src=\"/interview-assets/Microservice_Architecture.jpg\" alt=\"\" />\r<ul><li><strong>Clients</strong>: Người dùng khác nhau gửi yêu cầu đến thiết bị khác nhau.</li></ul>\r<ul><li><strong>Identity Provider</strong>: Xác thực định danh người dùng hoặc client và cấp token bảo mật.</li></ul>\r<ul><li><strong>API Gateway</strong>: xử lý yêu cầu từ client.</li></ul>\r<ul><li><strong>Static Content</strong>: Bao gồm tất cả nội dung của hệ thống.</li></ul>\r<ul><li><strong>Management</strong>: Dịch vụ được cản bằng trên các node và lỗi được xác định.</li></ul>\r<ul><li><strong>Service Discovery</strong>: Hướng dẫn khám phá các định tuyến để giao tiếp trong microservices.</li></ul>\r<ul><li><strong>CDN</strong>: bao gồm mạng phân phối của proxy server và trung tâm dữ liệu của họ.</li></ul>\r<ul><li><strong>Remote Service</strong>: Cung cấp khả năng truy cập từ xa vào dữ liệu hoặc thông tin trên các máy tính và thiết bị được nối mạng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Monolithic, SOA và Microservices?",
              "answer": "<p><img src=\"/interview-assets/difference_between_Monolithic__SOA_and_Microservices_Architecture.jpg\" alt=\"\" />\r\n\r\n<strong>Monolithic</strong>: Giống như một container lớn, trong đó là tất cả thành phần của ứng dụng được gói cùng với nhau. Nó được xây dựng như một hệ thống lớn với một code-base.\r\n\r\n<strong>SOA (Serivce-Oriented Architecture)</strong>: Nó là một nhóm các dịch vụ tương tác hoặc giao tiếp với nhau. Tùy thuộc vào bản chất của giao tiếp, nó có thể là trao đổi dữ liệu đơn giản hoặc nó có thể liên quan đến một số dịch vụ phối hợp một số hoạt động. \r\n\r\n<strong>Microservice</strong>: Nó liên quan đến việc cấu trúc một ứng dụng dưới dạng một cluster (cụm) các dịch vụ nhỏ, tự trị được mô hình hóa xung quanh một miền doanh nghiệp. Các module chức năng có thể được triển khai độc lập, có thể mở rộng, nhằm đạt được các mục tiêu kinh doanh cụ thể và giao tiếp với nhau qua các giao thức tiêu chuẩn.</p>",
              "level": "fresher"
            },
            {
              "question": "Cohesion và Coupling là gì?",
              "answer": "<p><strong>Khớp nối (Cohesion):</strong> Nó được định nghĩa là mối quan hệ giữa các module phần mềm A và B, và mức độ một module phụ thuộc hoặc tương tác với một module khác. Các cohesion nối được chia thành ba loại chính:\r<ul><li>Các module phụ thuộc nhiều vào nhau.</li></ul>\r<ul><li>Các module ít phụ thuộc (lỏng lẻo).</li></ul>\r<ul><li>Các module tách rời hoàn toàn.</li></ul>\r\n\r\nLoại cohesion tốt nhất là loại ít phụ thuộc, được thực hiện thông qua các interface.\r\n\r\n<strong>Liên kết (Coupling):</strong> Nó được định nghĩa là mối quan hệ giữa hai hoặc nhiều phần tử của một module phục vụ cùng một mục đích. Nói chung, một module có tính liên kết cao có thể thực hiện một chức năng cụ thể một cách hiệu quả mà không cần giao tiếp với bất kỳ module nào khác. Tính liên kết cao nâng cao chức năng của module.\r\n\r\n<img src=\"/interview-assets/Cohesion_and_Coupling.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Bounded Context là gì?",
              "answer": "<p>Một bounded context là một mẫu trung tâm trong DDD (Domain-Driven Design), đề cập đến sự cộng tác giữa các mô hình và nhóm lớn. DDD chia nhỏ các mô hình lớn thành nhiều ngữ cảnh để giúp chúng dễ quản lý hơn. Ngoài ra, nó giải thích mối quan hệ của chúng một cách rõ ràng. Khái niệm này thúc đẩy phương pháp tiếp cận hướng đối tượng để phát triển các dịch vụ gắn với mô hình dữ liệu và cũng chịu trách nhiệm đảm bảo tính toàn vẹn và khả năng thay đổi của mô hình dữ liệu nói trên.\r\n\r\n<img src=\"/interview-assets/Bounded_Context.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Viết các đặc điểm cơ bản của Thiết kế Microservice?",
              "answer": "<p><ul><li>Dựa trên khả năng kinh doanh: Các dịch vụ được phân chia và tổ chức xoay quanh khả năng kinh doanh.</li></ul>\r<ul><li>Sản phẩm không phải dự án: Một sản phẩm nên thuộc về team có trách nhiệm xử lý nó.</li></ul>\r<ul><li>Dựa vào các framework message: Loại bỏ các bus dịch vụ tập trung bằng cách nắm lấy khái niệm phân quyền.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thách thức khi sử dụng Microservices?",
              "answer": "<p>Những thách thức mà ta phải đối mặt khi sử dụng microservices có thể là cả chức năng và kỹ thuật như dưới đây:\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích PACT trong Microservices?",
              "answer": "<p>PACT được định nghĩa là một công cụ mã nguồn mở cho phép các nhà cung cấp dịch vụ và người tiêu dùng kiểm tra các tương tác một cách tách biệt với các hợp đồng đã được thực hiện để tăng độ tin cậy của tích hợp microservice. Nó cũng cung cấp hỗ trợ cho nhiều ngôn ngữ, chẳng hạn như Ruby, Java, Scala, .NET, JavaScript, Swift/Objective-C.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cách microservice giao tiếp với các phần khác?",
              "answer": "<p>Giao tiếp giữa các microservice có thể thực hiện:\r<ul><li>HTTP/REST với JSON hoặc giao thức nhị phân cho request/response.</li></ul>\r<ul><li>Websocket cho streaming</li></ul>\r<ul><li>Một broker hoặc server dùng cho các thuật toán routing.</li></ul>\r\n\r\nRabbitMQ, Kafka,... có thể dùng như một message broker, mỗi cái được xây dựng để xử lý message cụ thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Client certificates là gì?",
              "answer": "<p>Client certificates là một loại chứng chỉ kỹ thuật số thường cho phép các hệ thống client xác thực các yêu cầu của họ tới các server từ xa. Trong nhiều thiết kế xác thực lẫn nhau, nó đóng một vai trò quan trọng trong việc cung cấp sự đảm bảo mạnh mẽ về danh tính của người yêu cầu.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về CDC?",
              "answer": "<p>Như tên của nó, CDC (Consumer-Driven Contract) về cơ bản đảm bảo khả năng tương thích giao tiếp dịch vụ bằng cách thiết lập một thỏa thuận giữa người tiêu dùng và nhà cung cấp dịch vụ về định dạng dữ liệu được trao đổi giữa họ. Một thỏa thuận như thế này được gọi là hợp đồng (contract). Nó là một mẫu được sử dụng để phát triển các Microservices để chúng có thể được các hệ thống bên ngoài sử dụng một cách hiệu quả.</p>",
              "level": "fresher"
            },
            {
              "question": "Các công ty nổi tiếng sử dụng kiến trúc Microservices?",
              "answer": "<p><ul><li>Twitter</li></ul>\r<ul><li>Netflix</li></ul>\r<ul><li>Amazon</li></ul>\r\n\r\n## Câu hỏi phỏng vấn cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Semantic Monitoring là gì?",
              "answer": "<p>Semantic monitoring, còn được gọi là giám sát tổng hợp, sử dụng các bài kiểm tra tự động và giám sát ứng dụng để xác định lỗi trong quy trình kinh doanh. Công nghệ này cung cấp cái nhìn sâu hơn về hiệu suất giao dịch, tính khả dụng của dịch vụ và hiệu suất ứng dụng tổng thể để xác định các vấn đề về hiệu suất của microservices, phát hiện lỗi trong giao dịch và cung cấp mức hiệu suất tổng thể cao hơn.</p>",
              "level": "fresher"
            },
            {
              "question": "Continuos monitoring là gì?",
              "answer": "<p>Giám sát liên tục (continuos monitoring) liên quan đến việc xác định các vấn đề tuân thủ và rủi ro trong môi trường tài chính và hoạt động của công ty. Nó bao gồm con người, quy trình và hệ thống làm việc hỗ trợ hoạt động hiệu quả.</p>",
              "level": "fresher"
            },
            {
              "question": "Domain Driven Design là gì?",
              "answer": "<p>DDD (Domain Driven Design) là một phương pháp tiếp cận trong việc phân tích và phát triển phần mềm khi giải quyết những vấn đề nghiệp vụ phức tạp. Ý tưởng cơ bản của phương pháp này là việc xây dựng kết nối chặt chẽ giữa thiết kế phần mềm và mô hình nghiệp vụ trong suốt vòng đời phát triển sản phẩm. Để tạo nên sự kết nối này, DDD đưa ra 3 yêu cầu cơ bản:\r<ul><li>Trọng tâm của dự án là những nguyên tắc và logic nghiệp vụ</li></ul>\r<ul><li>Thiết kế phần mềm cần phải phản ánh chính xác mô hình nghiệp vụ</li></ul>\r<ul><li>Sự cộng tác liên tục giữa kĩ sư và chuyên gia nghiệp vụ</li></ul>\r\n\r\nKết quả của việc phân tích hệ thống dựa trên phương pháp DDD, kết hợp cùng mô hình kiến trúc Microservices giúp chúng ta tổ chức và phát triển những microservices giải quyết các vấn đề nghiệp vụ một cách tương ứng. Hoạt động kết hợp này được phản ánh qua một qui trình bao gồm các bước:\r<ul><li>Phân tích nghiệp vụ - domain model</li></ul>\r<ul><li>Định nghĩa ngữ cảnh - bounded context</li></ul>\r<ul><li>Định nghĩa đối tượng (entities), tập hợp (aggregate) và dịch vụ (service)</li></ul>\r<ul><li>Xác định microservices cần xây dựng</li></ul>\r\n\r\n<img src=\"/interview-assets/ddd.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về OAuth và OAuth2?",
              "answer": "<p><strong>OAuth</strong> là một phương thức xác thực giúp một ứng dụng bên thứ 3 có thể được ủy quyền bởi người dùng để truy cập đến tài nguyên người dùng nằm trên một dịch vụ khác. OAuth là từ ghép của O(Open) và Auth tượng trưng cho:\r<ul><li><em>Authentication</em>: xác thực người dùng.</li></ul>\r<ul><li><em>Authorization</em>: cấp quyền truy cập đến tài nguyên mà người dùng hiện đang nắm giữ.</li></ul>\r\n\r\nOAuth2 là bản nâng cấp của OAuth1.0, là một giao thức chứng thực cho phép các ứng dụng chia sẻ một phần tài nguyên với nhau mà không cần xác thực qua username và password như cách truyền thống từ đó giúp hạn chế được những phiền toái khi phải nhập username, password ở quá nhiều nơi hoặc đăng ký quá nhiều tài khoản mật khẩu mà chúng ta chẳng thể nào nhớ hết.\r\n\r\nTrong OAuth2 định nghĩa 4 vai trò:\r<ul><li><strong>Resource owner:</strong> là những người dùng có khả năng cấp quyền truy cập, chủ sở hữu của tài nguyên mà ứng dụng muốn lấy.</li></ul>\r<ul><li><strong>Resource server:</strong> nơi lưu trữ các tài nguyên, có khả năng xử lý yêu cầu truy cập đến các tài nguyên được bảo vệ.</li></ul>\r<ul><li><strong>Client</strong>: là những ứng dụng bên thứ 3 muốn truy cập vào phần tài nguyên được chia sẻ với tư cách của người sở hữu (resource owner) và tất nhiên trước khi truy cập ứng dụng cần được sự ủy quyền của người dùng.</li></ul>\r<ul><li><strong>Authorization server:</strong> làm nhiệm vụ xác thực, kiểm tra thông tin mà người dùng gửi đến từ đó cấp quyền truy cập cho ứng dụng bằng việc sinh ra các đoạn access token. Đôi khi authorization server cũng chính là resource server.</li></ul>\r\n\r\n<img src=\"/interview-assets/oauth.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Distributed Transactions là gì?",
              "answer": "<p>Giao dịch phân tán (distributed transactions) là một cách tiếp cận lỗi thời trong kiến trúc microservice ngày nay khiến nhà phát triển gặp phải các vấn đề nghiêm trọng về khả năng mở rộng. Các giao dịch được phân phối cho một số dịch vụ được gọi để hoàn thành giao dịch theo trình tự. Với rất nhiều bộ phận chuyển động, nó rất phức tạp và dễ bị hỏng hóc.</p>",
              "level": "fresher"
            },
            {
              "question": "Idempotence là gì?",
              "answer": "<p>Thuật ngữ \"Idempotence\" đề cập đến việc thực hiện lặp đi lặp lại một nhiệm vụ mặc dù cùng một kết quả. Nói cách khác, nó là một tình huống trong đó một nhiệm vụ được thực hiện lặp đi lặp lại với kết quả cuối cùng được giữ nguyên.\r\n \r\nCách sử dụng: Khi dịch vụ từ xa hoặc nguồn dữ liệu nhận được hướng dẫn nhiều lần, Idempotence đảm bảo rằng nó sẽ xử lý từng yêu cầu một lần.</p>",
              "level": "fresher"
            },
            {
              "question": "Ent-to-end microservices testing là gì?",
              "answer": "<p>Thông thường, end-to-end (E2E) microservice testing là một kỹ thuật không phối hợp, chi phí cao được sử dụng để đảm bảo rằng tất cả các thành phần hoạt động cùng nhau cho một hành trình hoàn chỉnh của người dùng. Thông thường, nó được thực hiện thông qua giao diện người dùng, bắt chước cách nó xuất hiện với người dùng. Nó cũng đảm bảo tất cả các quy trình trong quy trình làm việc hoạt động bình thường.</p>",
              "level": "fresher"
            },
            {
              "question": "Thuật ngữ Euruka trong Microservices?",
              "answer": "<p>Eureka Server, còn được gọi là Netflix Service Discovery Server, là một ứng dụng theo dõi tất cả các ứng dụng dịch vụ client. Vì mọi Microservice đăng ký với Server Eureka, Eureka biết tất cả các ứng dụng client đang chạy trên các cổng và địa chỉ IP khác nhau. Nó thường sử dụng Spring Cloud và không nặng về quá trình phát triển ứng dụng.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích sự quan trọng của reports và dashboard trong microservices?",
              "answer": "<p>Giám sát một hệ thống thường liên quan đến việc sử dụng các report (báo cáo) và dashboard (trang tổng quan). Sử dụng report và dashboard cho các microservices có thể giúp bạn:\r<ul><li>Xác định microservices hỗ trợ tài nguyên nào.</li></ul>\r<ul><li>Xác định dịch vụ nào bị ảnh hưởng bất cứ khi nào thay đổi được thực hiện hoặc xảy ra đối với các thành phần.</li></ul>\r<ul><li>Làm cho tài liệu dễ dàng truy cập bất cứ khi nào cần thiết.</li></ul>\r<ul><li>Xem lại các phiên bản thành phần đã triển khai.</li></ul>\r<ul><li>Xác định mức độ phát triển và tuân thủ từ các thành phần.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Reactive Extension là?",
              "answer": "<p>Reactive Programming như một khái niệm đã tồn tại trong hơn 20 năm nhưng đã không phát triển cho đến Reactive Extensions ra đời. Reactive Extension (còn được gọi là ReactiveX hay Rx) là giao diện lập trình ứng dụng (Application Programming Interface-API) hoặc lập trình bất đồng bộ với các luồng có thể quan sát được.\r\n\r\nReactiveX có hai lớp: lớp có thể quan sát (Observable) và lớp quan sát (Observer). Observable là nguồn dữ liệu của các luồng hoặc các sự kiện và Observer là lớp sử dụng (hoặc phản ứng lại) các phần tử được tạo ra.\r\n\r\nMột Observable có thể có nhiều Observer để mỗi mục dữ liệu được tạo ra sẽ được nhận bởi một Observer. Trong ReactiveX, một Observer theo dõi một Observable. Sau đó, Observable tạo ra các luồng dữ liệu, Observer sẽ lắng nghe và phản ứng lại. Điều này tạo ra một loạt các hoạt động trên luồng dữ liệu. Một chủ thể vừa có thể hoạt động như Observer vừa có thể đóng vai trò là Observable.\r\n\r\nChúng ta cũng có thể áp dụng toán tử cho các luồng. Các toán tử xác định cách thức và thời điểm Observable sẽ tạo luồng. Hầu hết các toán tử thực thi các hàm trên Observable và trả về một Observable.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích các kiểu test thường dùng trong Microservices?",
              "answer": "<p>Vì có nhiều microservice hoạt động cùng nhau, việc test microservice trở nên khá phức tạp khi làm việc với microservices. Do đó, các bài test được phân loại theo cấp độ của chúng:\r\n\r\n<img src=\"/interview-assets/explain-type-of-tests-mostly-used-in-microservices.jpg\" alt=\"\" />\r<ul><li><strong>Test cấp thấp:</strong> các test này xử lý với công nghệ, như unit test và performance test. Đây là quá trình tự động hoàn thành</li></ul>\r<ul><li><strong>Test cấp trung bình:</strong> chúng ta có các bài test như stress test và usability test.</li></ul>\r<ul><li><strong>Test cấp cao:</strong> chúng ta có một số test chấp nhận hạn chế. Các bài test chấp nhận giúp các bên liên quan hiểu và xác minh các tính năng của phần mềm.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Kiểm tra kim tự tháp Mike Cohn's là gì?",
              "answer": "<p>Kiểm tra kim tự tháp Mike Cohn's giải thích các kiểu khác nhau của test tự động cần cho phát triển phần mềm. Kiểm tra kim tự tháp về cơ bản là được sử dụng để tối đa hoá tự động hoá tất cả các cấp độ test, bao gồm unit testing, service testing, UI testing,...Kim tự tháp cũng cho biết rằng các unit test nhanh hơn và cô lập hơn, trong khi các ui test, tốn nhiều thời gian hơn và tập trung vào tích hợp.\r\n\r\n<img src=\"/interview-assets/Mike_Cohn’s_Test_Pyramid.jpg\" alt=\"\" />\r\n\r\nTheo kim tự tháp, số lượng bài test phải cao nhất ở lớp đầu tiên. Ở lớp service, ít test được thực hiện hơn ở mức unit test, nhưng lớn hơn ở mức end-to-end.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích Container trong Microservices?",
              "answer": "<p>Container là công nghệ hữu ích để phân bổ và chia sẻ tài nguyên. Nó được coi là phương pháp hiệu quả nhất và dễ dàng nhất để quản lý các ứng dụng dựa trên microservice để phát triển và triển khai chúng riêng lẻ. Sử dụng Docker, bạn cũng có thể đóng gói một microservice cùng với các phần phụ thuộc của nó trong một container image, sau đó có thể được sử dụng để cuộn các phiên bản theo yêu cầu của microservice mà không cần thực hiện thêm bất kỳ công việc nào.\r\n\r\n<img src=\"/interview-assets/Explain_Container_in_Microservices.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Vai trò của Docker trong Microservices?",
              "answer": "<p>Docker thường cung cấp một môi trường container, trong đó bất kỳ ứng dụng nào cũng có thể được host. Điều này được thực hiện bằng cách đóng gói chặt chẽ cả ứng dụng và các phụ thuộc cần thiết để hỗ trợ nó. Các sản phẩm đóng gói này được gọi là Container và vì Docker đã quen với việc đó nên chúng được gọi là Docker container. Về bản chất, Docker cho phép bạn chứa các microservice của mình và quản lý các microservices này dễ dàng hơn.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cách thực hiện khám phá dịch vụ trong kiến trúc microservices?",
              "answer": "<p>Có nhiều cách để thiết lập tính năng khám phá dịch vụ, nhưng Eureka của Netflix là cách hiệu quả nhất. Đây là một thủ tục đơn giản, không phức tạp và không tạo thêm nhiều dung lượng cho ứng dụng. Nó cũng hỗ trợ một loạt các ứng dụng web. Một số chú thích được cung cấp bởi Spring Cloud để làm cho việc sử dụng nó trở nên đơn giản nhất có thể và để ẩn đi các khái niệm phức tạp.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "nginx",
          "name": "Câu hỏi phỏng vấn Nginx",
          "description": "",
          "questions": [
            {
              "question": "Nginx hoạt động như thế nào?](#1-nginx-ho%E1%BA%A1t-%C4%91%E1%BB%99ng-nh%C6%B0-th%E1%BA%BF-n%C3%A0o)",
              "answer": "<p>[</p>",
              "level": "middle"
            },
            {
              "question": "Các tính năng của Nginx Server?](#2-c%C3%A1c-t%C3%ADnh-n%C4%83ng-c%E1%BB%A7a-nginx-server)",
              "answer": "<p><a href=\"#3-s%E1%BB%B1-kh%C3%A1c-bi%E1%BB%87t-gi%E1%BB%AFa-nginx-v%C3%A0-apache\" target=\"<em>blank\">3. Sự khác biệt giữa Nginx và Apache?</a>\r\n\r\n<a href=\"#4-nginx-x%E1%BB%AD-l%C3%BD-y%C3%AAu-c%E1%BA%A7u-http-nh%C6%B0-th%E1%BA%BF-n%C3%A0o\" target=\"</em>blank\">4. Nginx xử lý yêu cầu HTTP như thế nào?</a>\r\n\r\n<a href=\"#5-trong-nginx-l%C3%A0m-c%C3%A1ch-n%C3%A0o-%C4%91%E1%BB%83-ng%C4%83n-ch%E1%BA%B7n-c%C3%A1c-y%C3%AAu-c%E1%BA%A7u-x%E1%BB%AD-l%C3%BD-v%E1%BB%9Bi-t%C3%AAn-server-kh%C3%B4ng-x%C3%A1c-%C4%91%E1%BB%8Bnh\" target=\"<em>blank\">5. Trong Nginx, làm cách nào để ngăn chặn các yêu cầu xử lý với tên server không xác định?</a>\r\n\r\n<a href=\"#6-%C6%B0u-%C4%91i%E1%BB%83m-c%E1%BB%A7a-%22reverse-proxy-server%22\" target=\"</em>blank\">6. Ưu điểm của \"reverse proxy server\"?</a>\r\n\r\n<a href=\"#7-c%C3%A1ch-d%C3%B9ng-nginx-t%E1%BB%91t-nh%E1%BA%A5t\" target=\"<em>blank\">7. Cách dùng Nginx tốt nhất?</a>\r\n\r\n<a href=\"#8-ti%E1%BA%BFn-tr%C3%ACnh-master-v%C3%A0-worker-trong-nginx\" target=\"</em>blank\">8. Tiến trình master và worker trong Nginx?</a>\r\n\r\n<a href=\"#9-gi%E1%BA%A3i-th%C3%ADch-c%C3%A1ch-kh%E1%BB%9Fi-%C4%91%E1%BB%99ng-nginx-%E1%BB%9F-c%E1%BB%95ng-kh%C3%A1c-80\" target=\"<em>blank\">9. Giải thích cách khởi động Nginx ở cổng khác 80?</a>\r\n\r\n<a href=\"#10-c%C3%B3-th%E1%BB%83-thay-th%E1%BA%BF-l%E1%BB%97i-502-th%C3%A0nh-503-trong-nginx-kh%C3%B4ng\" target=\"</em>blank\">10. Có thể thay thế lỗi 502 thành 503 trong Nginx không?</a>\r\n\r\n<a href=\"#11-trong-nginx-l%C3%A0m-th%E1%BA%BF-n%C3%A0o-gi%E1%BB%AF-d%E1%BA%A5u-g%E1%BA%A1ch-ch%C3%A9o-trong-urls\" target=\"<em>blank\">11. Trong Nginx, làm thế nào giữ dấu gạch chéo trong URLs?</a>\r\n\r\n<a href=\"#12-ngxhttpupstreammodule-l%C3%A0-g%C3%AC\" target=\"</em>blank\">12. ngx<em>http</em>upstream<em>module là gì?</a>\r\n\r\n<a href=\"#13-v%E1%BA%A5n-%C4%91%E1%BB%81-c10k-l%C3%A0-g%C3%AC\" target=\"</em>blank\">13. Vấn đề C10K là gì?</a>\r\n\r\n<a href=\"#14-c%C3%A1ch-d%C3%B9ng-stubstatus-v%C3%A0-subfilter-directives\" target=\"<em>blank\">14. Cách dùng stub</em>status và sub<em>filter directives?</a>\r\n\r\n<a href=\"#15-gi%E1%BA%A3i-th%C3%ADch-nginx-c%C3%B3-h%E1%BB%97-tr%E1%BB%A3-n%C3%A9n-y%C3%AAu-c%E1%BA%A7u-l%C3%AAn-upstream-kh%C3%B4ng\" target=\"</em>blank\">15. Giải thích Nginx có hỗ trợ nén yêu cầu lên upstream không?</a>\r\n\r\n<a href=\"#16-c%C3%A1ch-l%E1%BA%A5y-th%E1%BB%9Di-gian-hi%E1%BB%87n-t%E1%BA%A1i-trong-nginx\" target=\"<em>blank\">16. Cách lấy thời gian hiện tại trong Nginx?</a>\r\n\r\n<a href=\"#17-gi%E1%BA%A3i-th%C3%ADch--s-trong-nginx-server\" target=\"</em>blank\">17. Giải thích -s trong Nginx server?</a>\r\n\r\n<a href=\"#18-c%C3%A1ch-th%C3%AAm-module-v%C3%A0o-nginx-server\" target=\"_blank\">18. Cách thêm module vào Nginx server?</a>\r\n\r\n## Câu hỏi phỏng vấn Nginx</p>",
              "level": "middle"
            },
            {
              "question": "Nginx hoạt động như thế nào?",
              "answer": "<p>Nginx được phát triển cho các mục đích tối ưu việc sử dụng (RAM) bộ nhớ thấp nhưng phục vụ được nhiều kết nối đồng thời cao hơn. Nginx sử dụng kiến trúc hướng sự kiện (event-driven) bất đồng bộ (asynchronous) và có khả năng mở rộng. Ngay cả khi bạn không cần phải xử lý hàng ngàn truy vấn đồng thời, thì bạn vẫn nên sử dụng Nginx do hiệu suất cao và yêu cầu bộ nhớ thấp của Nginx so với Apache.</p>",
              "level": "middle"
            },
            {
              "question": "Các tính năng của Nginx Server?",
              "answer": "<p><ul><li>Có khả năng xử lý hơn 10.000 kết nối cùng lúc với bộ nhớ thấp.</li></ul>\r<ul><li>Phục vụ tập tin tĩnh (static files) và lập chỉ mục tập tin.</li></ul>\r<ul><li>Tăng tốc reverse proxy bằng bộ nhớ đệm (cache), cân bằng tải đơn giản và khả năng chịu lỗi.</li></ul>\r<ul><li>Hỗ trợ tăng tốc với bộ nhớ đệm của FastCGI, uwsgi, SCGI, và các máy chủ memcached.</li></ul>\r<ul><li>Kiến trúc modular, tăng tốc độ nạp trang bằng nén gzip tự động.</li></ul>\r<ul><li>Hỗ trợ mã hoá SSL và TLS.</li></ul>\r<ul><li>Cấu hình linh hoạt; lưu lại nhật ký truy vấn</li></ul>\r<ul><li>Chuyển hướng lỗi 3XX-5XX</li></ul>\r<ul><li>Rewrite URL (URL rewriting) dùng regular expressions</li></ul>\r<ul><li>Hạn chế tỷ lệ đáp ứng truy vấn</li></ul>\r<ul><li>Giới hạn số kết nối đồng thời hoặc truy vấn từ 1 địa chỉ</li></ul>\r<ul><li>Khả năng nhúng mã PERL</li></ul>\r<ul><li>Hỗ trợ và tương thích với IPv6</li></ul>\r<ul><li>Hỗ trợ WebSockets</li></ul>\r<ul><li>Hỗ trợ truyền tải file FLV và MP4</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa Nginx và Apache?",
              "answer": "<p>| Nginx | Apache |\r\n|-|-|\r\n| Là web server dựa trên sự kiện | Là web server dựa trên tiến trình |\r\n| Tất cả yêu cầu được xử lý đơn luồng | Mỗi luồng xử lý một yêu cầu đơn |\r\n| Nginx tránh ý tượng tiến trình con | Apache dựa trên tiến trình con |\r\n| Nginx thiên về tốc độ | Apache thiên về sức mạnh |\r\n| Nginx tốt hơn khi nói đến mức tiêu thụ bộ nhớ và kết nối | Apache không đạt chuẩn khi nói đến mức tiêu thụ bộ nhớ và kết nối |\r\n| Nginx tốt hơn khi muốn cân bằng tải | Apache sẽ từ chối các kết nối mới khi lưu lượng đạt đến giới hạn của các tiến trình |\r\n| Nginx không hỗ trợ hệ điều hành như IBMi và OpenVMS | Apache hỗ trợ nhiều hệ điều hành hơn |\r\n| Nginx chỉ đi kèm tính năng cốt lỗi | Apache cung cấp nhiều hàm hơn Nginx |\r\n| Hiệu suất và khả năng mở rộng không phụ thuộc phần cứng | Phụ thuộc phần cứng như CPU hay bộ nhớ |</p>",
              "level": "middle"
            },
            {
              "question": "Nginx xử lý yêu cầu HTTP như thế nào?",
              "answer": "<p>Nginx sử dụng react pattern. Event loop chính đợi hệ điều hành báo hiệu một sự kiện sẵn sàng - sao cho dữ liệu có thể truy cập để đọc từ một socket, tại thời điểm đó, nó được đọc vào bộ đệm và được xử lý. Một luồng đơn có thể phục vụ hàng chục nghìn kết nối đồng thời.</p>",
              "level": "middle"
            },
            {
              "question": "Trong Nginx, làm cách nào để ngăn chặn các yêu cầu xử lý với tên server không xác định?",
              "answer": "<p>``<code>\r\nServer {\r\n    listen 80;\r\n\r\n    server_name &quot;&quot;;\r\n\r\n    return 444;\r\n}\r\n</code>``\r\n\r\nỞ đây, tên server được giữ dưới dạng một chuỗi trống sẽ khớp với yêu cầu mà không có trường tiêu đề <strong>Host</strong> và code không chuẩn 444 của Nginx đặc biệt được trả về sẽ chấm dứt kết nối.</p>",
              "level": "middle"
            },
            {
              "question": "Ưu điểm của \"reverse proxy server\"?",
              "answer": "<p>Reverse proxy server có thể ẩn sự hiện diện và đặc điểm của server gốc. Nó hoạt động như một trung gian giữa internet cloud và web server. Nó tốt cho lý do bảo mật, đặc biệt là khi bạn đang sử dụng các dịch vụ lưu trữ web.</p>",
              "level": "middle"
            },
            {
              "question": "Cách dùng Nginx tốt nhất?",
              "answer": "<p>Cách sử dụng tốt nhất Nginx server là triển khai nội dung HTTP động trên mạng bằng cách sử dụng server ứng dụng SCGI, WSGI, trình xử lý FastCGI cho script. Nó cũng có thể hoạt động như một bộ cân bằng tải.</p>",
              "level": "middle"
            },
            {
              "question": "Tiến trình master và worker trong Nginx?",
              "answer": "<p><ul><li><strong>Tiến trình master:</strong> nó đọc cũng như đánh giá cấu hình và duy trì tiến trình worker.</li></ul>\r<ul><li><strong>Tiến trình worker:</strong> nó xử lý yêu cầu thực.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Giải thích cách khởi động Nginx ở cổng khác 80?",
              "answer": "<p>Để khởi động Nginx ở các công khác, ta đi đến <code>/etc/Nginx/sites-enabled/</code> và nếu đây là file mặc định, thì bạn phải mở file có tên là \"default\". Chỉnh sửa file và sửa cổng mà bạn muốn</p>",
              "level": "middle"
            },
            {
              "question": "Có thể thay thế lỗi 502 thành 503 trong Nginx không?",
              "answer": "<p><ul><li>502= Bad gateway</li></ul>\r<ul><li>503= Server overloaded</li></ul>\r\n\r\nCó thể, nhưng phải đảm bảo rằng <code>fastcgi<em>intercept</em>errors</code> được đặt ON, và sử dụng điều hướng lỗi trang.\r\n\r\n``<code>\r\nLocation / {\r\n\r\nfastcgi<em>pass 127.0.01:9001;\r\n\r\nfastcgi</em>intercept<em>errors on;\r\n\r\nerror</em>page 502 =503/error_page.html;\r\n\r\n#...\r\n\r\n}\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Trong Nginx, làm thế nào giữ dấu gạch chéo trong URLs?",
              "answer": "<p>Để giữ dấu gạch chéo (/) trong URL, ta có thể dùng <code>merge<em>slashes</em>off;</code>\r\n\r\nCú pháp: <code>merge<em>slashes [on/off]</code>\r\n\r\nMặc định: <code>merge</em>slashes_on</code>\r\n\r\nNgữ cảnh: http, server</p>",
              "level": "middle"
            },
            {
              "question": "ngx_http_upstream_module là gì?",
              "answer": "<p>ngx<em>http</em>upstream_module được dùng để xác định nhóm server có thể tham chiếu bằng pass fastcgi, pass proxy, pass uwsgi, pass memcached và scgi pass directives.</p>",
              "level": "middle"
            },
            {
              "question": "Vấn đề C10K là gì?",
              "answer": "<p>Vấn đề C10K là do socket mạng không thể xử lý một số lượng lớn máy khách (10.000 người dùng) cùng một lúc.</p>",
              "level": "middle"
            },
            {
              "question": "Cách dùng stub_status và sub_filter directives?",
              "answer": "<p><em> <strong>Stub<em>status directive:</strong> Chỉ thị này được sử dụng để biết trạng thái hiện tại của Nginx như kết nối đang hoạt động hiện tại, tổng số kết nối được chấp nhận và số lượng kết nối đọc/ghi/ chờ hiện tại được xử lý\r\n</em> <strong>Sub</em>filter directive:</strong> Nó được sử dụng để tìm kiếm và thay thế nội dung theo phản hồi và khắc phục nhanh chóng dữ liệu cũ.</p>",
              "level": "middle"
            },
            {
              "question": "Giải thích Nginx có hỗ trợ nén yêu cầu lên upstream không?",
              "answer": "<p>Bạn có thể nén yêu cầu vào upstream bằng cách sử dụng <code>gunzip</code> của module Nginx. Module gunzip là một bộ lọc giải nén các phản hồi có <code>Content Encoding: gzip</code> cho các client hoặc server không hỗ trợ phương pháp mã hóa <strong>gzip</strong>.</p>",
              "level": "middle"
            },
            {
              "question": "Cách lấy thời gian hiện tại trong Nginx?",
              "answer": "<p>Để lấy thời gian hiện tại trong Nginx, ta sử dụng biến từ module SSI, <code>$date<em>gmt</code> và <code>$date</em>local</code>.\r\n\r\n``<code>\r\nProxy<em>set</em>header THE-TIME $date_gmt;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Giải thích -s trong Nginx server?",
              "answer": "<p>Để thực thi file trong Nginx, tham số -s được sử dụng.</p>",
              "level": "middle"
            },
            {
              "question": "Cách thêm module vào Nginx server?",
              "answer": "<p>Trong quá trình biên dịch, module Nginx phải được chọn vì lựa chọn thời gian chạy của module như vậy không được Nginx hỗ trợ.</p>",
              "level": "middle"
            }
          ]
        },
        {
          "id": "nodejs",
          "name": "Câu hỏi phỏng vấn Node.js",
          "description": "",
          "questions": [
            {
              "question": "First class function là gì?",
              "answer": "<p>First class function hay hàm hạng nhất là khi một hàm được sử dụng như một biến (được gán, truyền như tham số hay trả về). Có nhiều ngôn ngữ lập trình như Scala, Haskell, và JavaScript... đều có hàm hạng nhất.\r\nCác hàm này có thể truyền dưới dạng tham số hay trả về cho một hàm khác gọi là HOC(high-order function).\r\n\r\nCác hàm <code>map()</code> và <code>filter()</code> là các HOC phổ biến được dùng.</p>",
              "level": "fresher"
            },
            {
              "question": "Node.js hoạt động thế nào?",
              "answer": "<p>Node hoàn toàn theo cơ chế event-driven. Về cơ bản server bao gồm một luồng duy nhất xử lý từ sự kiện này đến sự kiện khác.\r\n\r\nMột yêu cầu mới đến là một loại sự kiện. Server bắt đầu xử lý nó và khi có hoạt động blocking IO, nó sẽ không đợi cho đến khi hoàn thành mà thay vào đó sẽ đăng ký một hàm callback. Sau đó, server ngay lập tức bắt đầu xử lý một sự kiện khác (có thể là một yêu cầu khác). Khi hoạt động IO kết thúc, đó là một loại sự kiện khác và server sẽ xử lý nó (tức là tiếp tục làm việc theo yêu cầu) bằng cách thực hiện lệnh callback ngay khi có thời gian.\r\n\r\nVì vậy, server không bao giờ cần tạo thêm các luồng hoặc chuyển đổi giữa các luồng, có nghĩa là nó có rất ít chi phí. Nếu bạn muốn sử dụng đầy đủ nhiều lõi phần cứng, bạn chỉ cần bắt đầu nhiều đối tượng node.js\r\n\r\nNền tảng Node.js không tuân theo mô hình đa luồng. Mà nó theo mô hình đơn luồng với Event Loop. Mô hình xử lý trong Node.js chủ yếu dựa trên mô hình JavaScript Event và cơ chế callback.\r\n\r\nCác bước trong mô hình xử lý đơn luồng với Event Loop:\r<ul><li>Client gửi yêu cầu đến web server.</li></ul>\r<ul><li>Web server Node.js duy trì một Thread pool để cung cấp dịch vụ cho các yêu cầu từ client.</li></ul>\r<ul><li>Node.js nhận các yêu cầu này và đặt nó vào một hàng đợi. Gọi là Event Queue.</li></ul>\r<ul><li>Trong Nodejs có một thành phần là Event Loop. Nó sử dụng một vòng lặp để nhận yêu cầu và xử lý chúng.</li></ul>\r<ul><li>Event Loop sử dụng một luồng duy nhất. Nó được gọi là trái tim của Node.js</li></ul>\r<ul><li>Event Loop kiểm tra yêu cầu có ở trong Event Queue. Nếu khong nó sẽ đợi cho đến khi yêu cầu đến.</li></ul>\r<ul><li>Nếu có, nó lấy yêu cầu từ Event Queue:</li></ul>\r<ul><li>Nó bắt đầu xử lý yêu cầu đó.</li></ul>\r<ul><li>Nếu yêu cầu đó không phải là blocking IO, thì nó xử lý và chuẩn bị phản hồi để gửi về client.</li></ul>\r<ul><li>Nếu nó cần vài thao tác blocking IO như tương tác với cơ sở dữ liệu, hệ thống file, mạng thì nó sẽ có cách tiếp cận khác:</li></ul>\r<ul><li>Kiểm tra luồng khả dụng từ Thread Pool</li></ul>\r<ul><li>Chọn luồng và gán nó cho yêu cầu client.</li></ul>\r<ul><li>Các luồng này nhận yêu cầu và xử lý chúng thực hiện hành động blocking IO, chuẩn bị phản hồi và gửi nó về Event Loop.</li></ul>\r<ul><li>Event Loop lấy nó và gửi phản hồi đó về lại client.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Quản lý package trong ứng dụng Node.js?",
              "answer": "<p>Khi thảo luận về Node js thì một điều chắc chắn không nên bỏ qua là xây dựng package quản lý sử dụng các công cụ NPM mà mặc định với mọi cài đặt Node js. Ý tưởng của mô-đun NPM là khá tương tự như Ruby-Gems: một tập hợp các hàm có sẵn có thể sử dụng được, thành phần tái sử dụng, tập hợp các cài đặt dễ dàng thông qua kho lưu trữ trực tuyến với các phiên bản quản lý khác nhau. Bên cạnh npm cũng có thể sử dụng yarn với bộ chức năng tương tự.</p>",
              "level": "fresher"
            },
            {
              "question": "Node.js có tốt hơn các framework khác?",
              "answer": "<p><ul><li><strong>Bất đồng bộ</strong>: Đặc điểm đầu tiên của Nodejs là tính bất đồng bộ. Node.js không cần đợi API trả dữ liệu về, vậy nên mọi APIs nằm trong thư viện Node.js đều không được đồng bộ, hiểu đơn giản là chúng không hề blocking (khóa). Server có cơ chế riêng để gửi thông báo và nhận phản hồi về các hoạt động của Node.js và API đã gọi.</li></ul>\r<ul><li><strong>Tốc độ nhanh</strong>: Với phần core phía dưới lập trình gần như toàn bộ bằng ngôn ngữ C++, kết hợp với V8 Javascript Engine mà Google Chrome cung cấp, tốc độ vận hành, thực hiện code của thư viện Node.js diễn ra rất nhanh.</li></ul>\r<ul><li><strong>Đơn giản/Hiệu quả</strong>: Tiến trình vận hành của Node.js đơn giản song lại mang đến hiệu năng cao nhờ ứng dụng mô hình single thread và các sự kiện lặp. Một loạt cơ chế sự kiện cho phép server trả về phản hồi bằng cách không block, đồng thời tăng hiệu quả sử dụng. Các luồng đơn cung cấp dịch vụ cho nhiều request hơn hẳn Server truyền thống.</li></ul>\r<ul><li><strong>Không đệm</strong>: Nền tảng Node.js không có vùng đệm, tức không cung cấp khả năng lưu trữ dữ liệu buffer.</li></ul>\r<ul><li><strong>Có giấy phép</strong>: Đây là nền tảng đã được cấp giấy phép, phát hành dựa trên MIT License.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các bước để luồng điều khiển kiểm soát các lệnh gọi hàm?",
              "answer": "<p><ul><li>Kiểm soát trật tự thực thi</li></ul>\r<ul><li>Thu thập dữ liệu</li></ul>\r<ul><li>Giới hạn đồng thời</li></ul>\r<ul><li>Gọi bước sau trong chương trình.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các tính năng thời gian của Node.js?",
              "answer": "<p>Các hàm Set Timer:\r<ul><li><code>setImmediate()</code> : chạy ngay lập tức (thực ra nó sẽ chạy ở lần lặp tiếp theo trong event loop)</li></ul>\r<ul><li><code>setTimeout()</code> : chạy trong một khoảng thời gian.</li></ul>\r<ul><li><code>setInterval()</code>: lặp đi lặp lại trong khoảng thời gian</li></ul>\r\n\r\nCác hàm Clear timer\r<ul><li><code>clearImmediate()</code> : dừng một đối tượng setImmediate, tạo bởi hàm setImmediate()</li></ul>\r<ul><li><code>clearTimeout()</code> : dừng một đối tượng setTimeout, tạo bởi hàm setTimeout()</li></ul>\r<ul><li><code>clearInterval()</code> : dừng một đối tượng setInterval, tạo bởi hàm setInterval()</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của promise so với callback?",
              "answer": "<p>Ưu điểm chính của việc sử dụng <strong>promise</strong> là bạn có được một đối tượng để quyết định hành động cần được thực hiện sau khi tác vụ bất đồng bộ hoàn thành. Điều này cung cấp cod dễ quản lý hơn và tránh callback hell.</p>",
              "level": "fresher"
            },
            {
              "question": "fork trong Node.js là gì?",
              "answer": "<p>Một fork dùng cho tạo các tiến trình con. Trong nodejs, nó được dùng để tạo thực thể mới của v8 để chạy nhiều worker cho thực thi code.</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao Node.js lại là đơn luồng?",
              "answer": "<p>Node.js được tạo rõ ràng như một thử nghiệm trong xử lý bất đồng bộ. Lý thuyết là thực hiện xử lý bất đồng bộ trên một luồng duy nhất có thể cung cấp hiệu suất và khả năng mở rộng cao hơn so với các triển khai đa luồng truyền thống.\r\n\r\nMột ứng dụng node.js không hoạt động chuyên sâu về CPU có thể chạy hàng nghìn kết nối đồng thời tốt hơn Apache hoặc IIS hoặc các máy chủ đa luồng khác.</p>",
              "level": "fresher"
            },
            {
              "question": "Tạo ứng dụng hello world với node.js?",
              "answer": "<p>``<code>js\r\nvar http = require(&quot;http&quot;);\r\nhttp.createServer(function (request, response) {\r\n    response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\r\n    response.end(&#39;Hello World\\n&#39;);\r\n}).listen(3000);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu hàm API trong node.js?",
              "answer": "<p>Có hai kiểu hàm API:\r<ul><li>Hàm bất đồng bộ, non-blocking: sử dụng chủ yếu cho các hoạt động I/O có thể tách ra khỏi vòng lặp chính.</li></ul>\r<ul><li>Hàm đồng bộ, blocking: sử dụng cho các hoạt động ảnh hưởng đến tiến trình đang chạy trong vòng lặp chính.</li></ul>\r\n\r\n<strong>Hàm blocking</strong> trong các thao tác blocking, tất cả code khác sẽ bị ngăn khi cho đến khi thực hiện xong thao tác IO. Vd:\r\n\r\n``<code>js\r\nconst fs = require(&#39;fs&#39;);\r\nconst data = fs.readFileSync(&#39;/file.md&#39;); // blocks here until file is read\r\nconsole.log(data);\r\n// moreWork(); will run after console.log\r\n</code>`<code>\r\n\r\nDòng code thứ hai chặn việc thực thi JavaScript bổ sung cho đến khi toàn bộ file được đọc. </code>moreWork()<code> sẽ chỉ được gọi sau </code>console.log<code>.\r\n\r\n<strong>Hàm non-blocking</strong> trong các thao tác non-blocking, nhiều lệnh gọi IO có thể thực hiện mà chương trình không bị tạm dừng. Vd:\r\n\r\n</code>`<code>js\r\nconst fs = require(&#39;fs&#39;);\r\nfs.readFile(&#39;/file.md&#39;, (err, data) =&gt; {\r\n  if (err) throw err;\r\n  console.log(data);\r\n});\r\n// moreWork(); will run before console.log\r\n</code>`<code>\r\n\r\nVì </code>fs.readFile()<code> là không chặn, </code>moreWork()` không phải đợi file đọc xong trước khi được gọi.</p>",
              "level": "fresher"
            },
            {
              "question": "REPL là gì?",
              "answer": "<p>REPL là từ viết tắt của Read Eval Print Loop (hiểu nôm na là: Đọc – Đánh giá – In – Lặp) và nó biểu diễn môi trường máy tính như màn hình console trong Linux shell nơi bạn có thể gõ các dòng lệnh và hệ thống sẽ trả về các kết quả. NodeJS cũng có môi trường REPL. Nó để thực hiện các tác vụ mong muốn:\r\n\r\n<strong>Read</strong>: Đọc các thông tin input của người dùng, chuyển đổi thành các dữ liệu Javascript và lưu trữ trong bộ nhớ.\r\n\r\n<strong>Eval</strong>: Đánh giá các cấu trúc dữ liệu này.\r\n\r\n<strong>Print</strong>: In các kết quả.\r\n\r\n<strong>Loop</strong>: Lặp các dòng lệnh đến khi người dùng gõ ctrl-c hai lần.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa bất đồng bộ và non-blocking?",
              "answer": "<p><ul><li><strong>Bất đồng bộ:</strong> Kiến trúc của bất đồng bộ giải thích rằng thông điệp được gửi sẽ không trả lời ngay lập tức giống như chúng ta gửi mail nhưng không nhận được trả lời ngay lập tức. Nó không có bất kỳ sự phụ thuộc hay thứ tự nào. Do đó cải thiện hiệu quả và hiệu suất của hệ thống. Server lưu trữ thông tin và khi hành động được thực hiện, nó sẽ được thông báo.</li></ul>\r<ul><li><strong>Non-blocking:</strong> Non-blocking phản hồi ngay lập tức với bất kỳ dữ liệu nào có sẵn. Hơn nữa, nó không chặn bất kỳ quá trình thực thi nào và tiếp tục chạy từng yêu cầu. Nếu một câu trả lời không thể được truy xuất hơn trong những trường hợp đó, API trả về ngay lập tức với một lỗi. Tính năng non-block hầu hết được sử dụng với I/O (input/output). Bản thân Node.js dựa trên mô hình I/O non-blocking. Hàm callback sẽ được gọi khi hoạt động hoàn thành. Lệnh gọi non-blocking sử dụng sự trợ giúp của javascript cung cấp chức năng callback.</li></ul>\r\n\r\n| Bất đồng bộ | Non-blocking |\r\n|-|-|\r\n| Bất đồng bộ không phản hồi ngay lập tức | Non-blocing phản hồi ngay lập tức nếu dữ liệu khả dụng còn không nó sẽ trả về lỗi |\r\n| Bất đồng bộ cải thiện hiệu quả bằng cách thực hiện tác vụ nhanh chóng vì phản hồi có thể đến sau đó, trong lúc đó có thể hoàn thành các tác vụ khác | Non-blocking không chặn bất kỳ quá trình thực thi nào và nếu dữ liệu có sẵn, nó sẽ truy xuất thông tin một cách nhanh chóng |\r\n| Là đối nghịch của đồng bộ | Là đối nghịch của blocking IO |</p>",
              "level": "fresher"
            },
            {
              "question": "Ý nghĩa của module.exports?",
              "answer": "<p>Được sử dụng để hiển thị các chức năng của một module hoặc file cụ thể sẽ được sử dụng ở những nơi khác trong dự án. Nó có thể được sử dụng để đóng gói tất cả các chức năng tương tự trong một file giúp cải thiện cấu trúc dự án.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nconst getSolutionInJavaScript = async ({\r\n    problem<em>id\r\n}) =&gt; {\r\n...\r\n};\r\nconst getSolutionInPython = async ({\r\n    problem</em>id\r\n}) =&gt; {\r\n    ...\r\n};\r\nmodule.exports = { getSolutionInJavaScript, getSolutionInPython }\r\n</code>`<code>\r\n\r\nBây giờ ta có thể sử dụng lại các hàm trên ở file khác:\r\n\r\n</code>`<code>js\r\nconst { getSolutionInJavaScript, getSolutionInPython} = require(&quot;./utils&quot;)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Công cụ dùng để đảm bảo code style nhất quán?",
              "answer": "<p>ESLint có thể dùng với bất kỳ IDE nào để đảm bảo code style nhất quán cho duy trì codebase trong tương lai.</p>",
              "level": "fresher"
            },
            {
              "question": "Callback hell là gì?",
              "answer": "<p>Callback hell là một hiện tượng ảnh hưởng đến nhà phát triển JavaScript khi cố gắng thực thi nhiều hoạt động bất đồng bộ lần lượt.\r\n\r\nMột hàm bất đồng bộ là một hàm trong đó một số hoạt động bên ngoài phải hoàn thành trước khi kết quả có thể được xử lý; nó là \"bất đồng bộ\" theo nghĩa là có một khoảng thời gian không thể đoán trước trước khi có kết quả. Các hàm như vậy yêu cầu một hàm callback để xử lý lỗi và xử lý kết quả.\r\n\r\n``<code>js\r\ngetData(function(a){\r\n    getMoreData(a, function(b){\r\n        getMoreData(b, function(c){ \r\n            getMoreData(c, function(d){ \r\n\t            getMoreData(d, function(e){ \r\n\t\t            ...\r\n\t\t        });\r\n\t        });\r\n        });\r\n    });\r\n});\r\n</code>``\r\n\r\nCách tránh callback hell\r<ul><li>Dùng async từ npm</li></ul>\r<ul><li>Dùng promise</li></ul>\r<ul><li>Dùng async-await</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Event-Loop trong Node.js là gì?",
              "answer": "<p>Event loop  là thứ cho phép Node.js thực hiện các hoạt động I/O non-blocking - mặc dù thực tế là JavaScript là đơn luồng - bằng cách giảm tải các hoạt động cho nhân hệ thống bất cứ khi nào có thể.\r\n\r\nNode.js là ứng dụng đơn luồng, nhưng hỗ trợ đồng thời thông qua khái niệm <strong>event</strong> và <strong>callbacks</strong>. Tất cả API của Node.js là bất đồng bộ và đơn luồng, ta sử dụng hàm async để duy trì tính đồng thời. Node sử dụng observer pattern. Luồng node giữ một event loop và bất cứ khi nào một tác vụ được hoàn thành, nó sẽ kích hoạt sự kiện tương ứng để báo hiệu cho hàm listener-event thực thi.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Nếu node.js đơn luồng thì nó xử lý đồng thời như thế nào?",
              "answer": "<p>Ví dụ:\r\n\r\n``<code>js\r\nconst crypto = require(&quot;crypto&quot;);\r\nconst start = Date.now();\r\nfunction logHashTime() {\r\n    crypto.pbkdf2(&quot;a&quot;, &quot;b&quot;, 100000, 512, &quot;sha512&quot;, () =&gt; {\r\n        console.log(&quot;Hash: &quot;, Date.now() - start);\r\n    });\r\n}\r\nlogHashTime();\r\nlogHashTime();\r\nlogHashTime();\r\nlogHashTime();\r\n</code>`<code>\r\n\r\nKết quả là:\r\n\r\n</code>`<code>text\r\nHash: 1213\r\nHash: 1225\r\nHash: 1212\r\nHash: 1222\r\n</code>``\r\n\r\nKhi cần xử lý đồng thời, thư viện libuv trong node.js sẽ dùng thread pool để tạo thêm luồng cho xử lý đồng thời như vậy.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa process.nextTick() và setImmediate()?",
              "answer": "<p>Cả hai đều dùng để chuyển sang chế độ bất đồng bộ bởi hàm listener.\r\n\r\n<strong>process.nextTick()</strong> đặt calblack cho thực thi còn <strong>setImmediate</strong> đẩy callback vào hàng đợi để thực thi. Vì vậy event-loop sẽ chạy như sau.\r\n\r\n<strong><code>timers–&gt;pending callbacks–&gt;idle,prepare–&gt;connections(poll,data,etc)–&gt;check–&gt;close callbacks</code></strong>\r\n\r\nỞ phương thức process.nextTick() này, thêm hàm callback để bắt đầu ở event queue kế tiếp, còn phương thức setImmediate() đặt hàm vào giai đoạn kiểm tra của event queue kế tiếp.</p>",
              "level": "fresher"
            },
            {
              "question": "Nodejs giải quyết vấn đề block I/O như thế nào?",
              "answer": "<p>Vì node có event loop có thể dùng cho tất cả hoạt động I/O bật đồng bộ mà không cần blocking ở hàm chính.\r\n\r\nVí dụ: nếu một cuộc gọi mạng xảy ra, nó sẽ được lập lịch trong event loop thay vì luồng chính. Nếu có nhiều lệnh gọi I/O như vậy, mỗi lệnh gọi sẽ được xếp vào hàng đợi tương ứng để thực thi.\r\n\r\nVì vậy, ngay cả khi đơn luồng các hoạt động I/O vẫn được xử lý theo cách non-blocking.</p>",
              "level": "fresher"
            },
            {
              "question": "Sử dụng async await trong Node.js?",
              "answer": "<p>``<code>js\r\n// this code is to retry with exponential backoff\r\nfunction wait (timeout) {\r\n    return new Promise((resolve) =&gt; {\r\n        setTimeout(() =&gt; {\r\n            resolve()\r\n        }, timeout);\r\n    });\r\n}\r\n\r\nasync function requestWithRetry (url) {\r\n    const MAX<em>RETRIES = 10;\r\n    for (let i = 0; i &lt;= MAX</em>RETRIES; i++) {\r\n        try {\r\n            return await request(url);\r\n        } catch (err) {\r\n            const timeout = Math.pow(2, i);\r\n            console.log(&#39;Waiting&#39;, timeout, &#39;ms&#39;);\r\n            await wait(timeout);\r\n            console.log(&#39;Retrying&#39;, err.message, i);\r\n        }\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Node.js stream là gì?",
              "answer": "<p>Stream là một thực thể của EventEmitter, có thể dùng cho dữ liệu streaming trong Node.js. Nó có thể dùng để xử lý và quản lý các file streaming lớn như video, mp3, ... qua mạng. Nó sử dụng buffers như bộ lưu trữ tạm thời.\r\n\r\nNó có 4 kiểu chính là:\r<ul><li><strong>Writable</strong>: streams cho phép ghi dữ liệu (ví dụ: <code>fs.createWriteStream()</code>).</li></ul>\r<ul><li><strong>Readable</strong>: streams cho phép đọc dữ liệu (ví dụ: <code>fs.createReadStream()</code>).</li></ul>\r<ul><li><strong>Duplex</strong>: streams là kết hợp của cả Readable và Writable (ví dụ <code>net.Socket</code>).</li></ul>\r<ul><li><strong>Transform</strong>: là stream Duplex có thể chỉnh sửa hoặc chuyển đổi dữ liệu khi nó được ghi hay đọc (ví dụ <code>zlib.createDeflate()</code>).</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Buffers trong node.js?",
              "answer": "<p>Buffer là một vùng lưu trữ tạm thời chứa các dữ liệu đang được chuyển từ nơi này đến nơi khác. Buffer có kích thước xác định và giới hạn. Kích thước của buffer được xác định bằng những thuật toán cho từng trường hợp cụ thể. Buffer là một kỹ thuật được phát triển nhằm ngăn chặn sự tắc nghẽn dữ liệu khi truyền từ nơi này đến nơi khác.\r\n\r\nBuffer là một class trong Node.js API dùng để giao tiếp với các dữ liệu nhị phân. Buffer class đã được khai báo trong phạm vi global trong các phiên bản Node.js sau này, nên chúng ta không cần phải <code>require(&#39;buffer&#39;)</code> để sử dụng.</p>",
              "level": "fresher"
            },
            {
              "question": "Middleware là gì?",
              "answer": "<p>Middleware nằm giữa request và logic nghiệp vụ. Nó được dùng để ghi log, giới hạn truy cập, định tuyến, xác thực hay bất cứ điều gì không phải là một phần của logic nghiệp vụ. Ngoài ra third-party middleware chẳng hạn như body-parser có thể viết middleware của riêng mình cho một trường hợp cụ thể.\r\n\r\n## Câu hỏi phỏng vấn Node.js cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích Reactor Pattern trong Nodejs?",
              "answer": "<p>Reactor Pattern là một ý tưởng về các hoạt động I/O non-blocking trong Node.js. Ơattern này cung cấp một trình xử lý (handler), với Node.js là một hàm callback, được liên kết với mỗi thao tác I/O. Khi một yêu cầu I/O được tạo, nó sẽ được gửi đến bộ phân kênh (demultiplexer).\r\n\r\nBộ phân kênh này là một interface thông báo được sử dụng để xử lý đồng thời trong chế độ I/O non-blocking và thu thập mọi yêu cầu dưới dạng sự kiện và xếp từng sự kiện vào một hàng đợi. Do đó, bộ phân kênh cung cấp Event Queue, mà chúng ta thường nghe. Khi một yêu cầu được thu thập bởi bộ phân kênh, nó sẽ trả lại quyền điều khiển cho hệ thống và không chặn I/O. Đồng thời, có Event Loop lặp lại các mục trong Event Queue. Mọi sự kiện đều có một hàm callback được liên kết với nó và hàm callback đó được gọi khi Event Loop lặp lại.\r\n\r\nNgoài ra, hàm callback chủ yếu có các lệnh callback khác được liên kết bên trong đại diện cho một số hoạt động bất đồng bộ. Các hoạt động này được chèn vào Event Queue bởi bộ phân kênh và sẵn sàng được xử lý khi Event Loop lặp lại chúng. Đó là lý do tại sao các cuộc gọi đến các hoạt động khác phải bất đồng bộ.\r\n\r\nKhi tất cả các mục trong Event Queue được xử lý và không còn hoạt động nào đang chờ xử lý, Node.js sẽ tự động dừng ứng dụng.\r\n\r\n<img src=\"/interview-assets/reactor-pattern.jpg\" alt=\"\" />\r\n\r\n1. Ứng dụng tạo hoạt động I/O mới bằng cách gửi yêu cầu đến Event Demultiplexer. Ứng dụng cũng chỉ định một trình xử lý (handler), trình xử lý này sẽ được gọi khi hoạt động hoàn tất. Gửi một yêu cầu mới đến Event Demultiplexer là một lời gọi non-blocking và ngay lập tức trả lại quyền điều khiển cho ứng dụng.\r\n2. Khi một tập hợp các thao tác I/O hoàn tất, Event Demultiplexer sẽ đẩy các sự kiện mới vào Event Queue.\r\n3. Tại thời điểm này, Event Loop lặp lại các mục của Event Queue.\r\n4. Đối với mỗi sự kiện, trình xử lý liên quan được gọi.\r\n5. Trình xử lý, là một phần của code ứng dụng, sẽ cung cấp lại quyền điều khiển cho Event Loop khi quá trình thực thi của nó hoàn tất (5a). Tuy nhiên, các hoạt động bất đồng bộ mới có thể được yêu cầu trong quá trình thực thi trình xử lý (5b), khiến các hoạt động mới được chèn vào Event Demultiplexer (1), trước khi điều khiển được đưa trở lại Event Loop.\r\n6. Khi tất cả các mục trong Event Queue được xử lý, vòng lặp sẽ chặn lại trên Event Demultiplexer, sau đó sẽ kích hoạt một chu kỳ khác.</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao tách biệt app và server trong Express?",
              "answer": "<p>Server có trách nhiệm khởi tạo routes, middleware và các logic ứng dụng khác trong khi đó app là tất cả logic nghiệp vụ để phục vụ các routes của server. Điều này đảm bảo rằng các logic nghiệp vụ sẽ được đóng gói và phân tách với logic ứng dụng giúp dự án dễ đọc và bảo trì.</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao Nodejs lại dùng V8 Engine?",
              "answer": "<p>Thực tế, ta có nhiều hơn một lựa chọn về Javascript Engine chẳng hạn như Spidermonkey từ Firefox, Chakra từ Edge nhưng V8 của Google là phiên bản phát triển nhất (vì nó là mã nguồn mở nên có một cộng đồng lớn giúp phát triển các tính năng và sửa lỗi) và nhanh nhất (vì nó được viết bằng c ++). Cho đến hiện tại nó như một  JavaScript Engine và WebAssembly.</p>",
              "level": "fresher"
            },
            {
              "question": "Thoát mã trong Node.js?",
              "answer": "<p>Thoát mã (exit code) cung cấp ý tưởng về cách tạm dừng hay huỷ chương trình.\r\n\r\nMột vài thoát mã:\r<ul><li>Uncaught fatal exception - (code - 1) - Đã có một ngoại lệ không được xử lý</li></ul>\r<ul><li>Unused - (code - 2) - Cái này được đặt trước bởi bash</li></ul>\r<ul><li>Fatal Error - (code - 5) - Đã xảy ra lỗi trong V8 với đầu ra stderr của mô tả</li></ul>\r<ul><li>Internal Exception handler Run-time failure - (code - 7) - Đã có một ngoại lệ khi hàm khởi động được gọi</li></ul>\r<ul><li>Internal JavaScript Evaluation Failure - (code - 4) - Đã có một ngoại lệ khi quá trình khởi động không thể trả về giá trị hàm khi được đánh giá.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích khái niệm stub trong Nodejs?",
              "answer": "<p>Theo dõi và xác minh cho các kiểm tra thử nghiệm node.js. Cho phép bạn xác thực và ghi đè hành vi của các đoạn code lồng nhau, chẳng hạn như phương thức, require() và npm  module hoặc thậm chí các thực thể của lớp. Thư viện này được lấy cảm hứng từ node-gently, MockJS và mock-require.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Even Emitter trong Nodejs là gì?",
              "answer": "<p>EventEmitter là một lớp Node.js bao gồm tất cả các đối tượng về cơ bản có khả năng emitting ra các sự kiện. Điều này có thể được thực hiện bằng cách đính kèm các sự kiện đã đặt tên được emitt ra bởi đối tượng bằng cách sử dụng một hàm <code>eventEmitter.on()</code>. Vì vậy, bất cứ khi nào đối tượng này throw một sự kiện, các hàm kèm theo sẽ được gọi đồng bộ.\r\n\r\nVí dụ\r\n\r\n``<code>js\r\nvar events = require(&#39;events&#39;);\r\nvar eventEmitter = new events.EventEmitter();\r\n\r\n// listener #1\r\nvar listner1 = function listner1() {\r\n   console.log(&#39;listner1 executed.&#39;);\r\n}\r\n\r\n// listener #2\r\nvar listner2 = function listner2() {\r\n   console.log(&#39;listner2 executed.&#39;);\r\n}\r\n\r\n// Bind the connection event with the listner1 function\r\neventEmitter.addListener(&#39;connection&#39;, listner1);\r\n\r\n// Bind the connection event with the listner2 function\r\neventEmitter.on(&#39;connection&#39;, listner2);\r\n\r\nvar eventListeners = require(&#39;events&#39;).EventEmitter.listenerCount\r\n   (eventEmitter,&#39;connection&#39;);\r\nconsole.log(eventListeners + &quot; Listner(s) listening to connection event&quot;);\r\n\r\n// Fire the connection event \r\neventEmitter.emit(&#39;connection&#39;);\r\n\r\n// Remove the binding of listner1 function\r\neventEmitter.removeListener(&#39;connection&#39;, listner1);\r\nconsole.log(&quot;Listner1 will not listen now.&quot;);\r\n\r\n// Fire the connection event \r\neventEmitter.emit(&#39;connection&#39;);\r\n\r\neventListeners = require(&#39;events&#39;).EventEmitter.listenerCount(eventEmitter,&#39;connection&#39;);\r\nconsole.log(eventListeners + &quot; Listner(s) listening to connection event&quot;);\r\n\r\nconsole.log(&quot;Program Ended.&quot;);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\n2 Listner(s) listening to connection event\r\nlistner1 executed.\r\nlistner2 executed.\r\nListner1 will not listen now.\r\nlistner2 executed.\r\n1 Listner(s) listening to connection event\r\nProgram Ended.\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tăng cường hiệu suất Node.js thông qua phân cluster?",
              "answer": "<p>Các ứng dụng Node.js chạy trên một bộ xử lý duy nhất, có nghĩa là theo mặc định, chúng không tận dụng được hệ thống đa lõi. Chế độ cluster được sử dụng để khởi động nhiều tiến trình node.js do đó có nhiều phiên bản của event-loop. Khi chúng tôi bắt đầu sử dụng cluster trong một ứng dụng nodejs phía sau, nhiều tiến trình node.js được tạo ra nhưng cũng có một tiến trình mẹ được gọi là trình quản lý cluster chịu trách nhiệm theo dõi tình trạng của các phiên bản riêng lẻ trong ứng dụng của ta.\r\n\r\n<img src=\"/interview-assets/clustering_in_Nodejs.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Thread pool là gì?",
              "answer": "<p>Thread pool được xử lý bởi thư viện libuv. libuv là thư viện C đa nền tảng, cung cấp hỗ trợ các hoạt động bất đồng bộ I/O như hệ thống file, mạng, đồng thời,...\r\n\r\n<img src=\"/interview-assets/nodejs-thread-pool.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "WASI là gì?",
              "answer": "<p>Web assembly cung cấp triển khai đặc tả WebAssembly System Interface thông qua API WASI trong node.js được triển khai bằng cách sử dụng lớp WASI. Việc thêm lớp WASI được thực hiện bởi nó có thể sử dụng hệ điều hành cơ bản thông qua tập hợp các hàm giống như POSIX, do đó, cho phép ứng dụng sử dụng hiệu quả hơn các tài nguyên và các tính năng yêu cầu quyền truy cập cấp hệ thống.</p>",
              "level": "fresher"
            },
            {
              "question": "Các luồng worker khác gì với cluster?",
              "answer": "<p><strong>Cluster</strong>\r<ul><li>Có một tiến trình trên mỗi CPU với IPC để giao tiếp.</li></ul>\r<ul><li>Trong trường hợp muốn nhiều server chấp nhận yêu cầu HTTP thông qua cổng đơn, cluster có thể hữu ích.</li></ul>\r<ul><li>Các tiến trình được sinh từ mỗi CPU, do đó sẽ có bộ nhớ và thực thể node riêng biệt, dẫn đến các vấn đề về bộ nhớ.</li></ul>\r\n\r\n<strong>Worker Thread</strong>\r<ul><li>Chỉ có một tiến trình trong nhiều luồng.</li></ul>\r<ul><li>Mỗi luồng có một thực thể node(một event-loop, một js-engine) với hầu hết API có thể truy cập.</li></ul>\r<ul><li>Chia sẻ bộ nhớ với các luồng khác (SharedArrayBuffer)</li></ul>\r<ul><li>Có thể được dùng cho các tác vụ đòi hỏi nhiều CPU như xử lý dữ liệu hoặc truy cập hệ thống file vì Node là đơn luồng, các tác vụ đồng bộ có thể thực hiện hiệu quả hơn nhờ worker của thread.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để đo thời gian của các hoạt động không đồng bộ?",
              "answer": "<p>API Performance cung cấp cho chúng ta các công cụ để tìm ra các chỉ số hiệu suất cần thiết. Một ví dụ đơn giản sẽ là sử dụng <code>async<em>hooks</code> và <code>perf</em>hooks</code>\r\n\r\n``<code>js\r\n&#39;use strict&#39;;\r\nconst async<em>hooks = require(&#39;async</em>hooks&#39;);\r\nconst {\r\n    performance,\r\n    PerformanceObserver\r\n} = require(&#39;perf<em>hooks&#39;);\r\nconst set = new Set();\r\nconst hook = async</em>hooks.createHook({\r\n    init(id, type) {\r\n        if (type === &#39;Timeout&#39;) {\r\n            performance.mark(</code>Timeout-${id}-Init<code>);\r\n            set.add(id);\r\n        }\r\n    },\r\n    destroy(id) {\r\n    if (set.has(id)) {\r\n        set.delete(id);\r\n        performance.mark(</code>Timeout-${id}-Destroy<code>);\r\n        performance.measure(</code>Timeout-${id}<code>,\r\n                            </code>Timeout-${id}-Init<code>,\r\n                            </code>Timeout-${id}-Destroy<code>);\r\n        }\r\n    }\r\n});\r\nhook.enable();\r\nconst obs = new PerformanceObserver((list, observer) =&gt; {\r\n    console.log(list.getEntries()[0]);\r\n    performance.clearMarks();\r\n    observer.disconnect();\r\n});\r\nobs.observe({ entryTypes: [&#39;measure&#39;], buffered: true });\r\nsetTimeout(() =&gt; {}, 1000);\r\n</code>``\r\n\r\nĐiều này sẽ cung cấp cho chúng ta thời gian chính xác để thực hiện lệnh callback.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để đo lường hiệu suất của các hoạt động không đồng bộ?",
              "answer": "<p>API Perfomance cung cấp cho chúng tôi các công cụ để tìm ra các chỉ số hiệu suất cần thiết.\r\n\r\n``<code>js\r\nconst { PerformanceObserver, performance } = require(&#39;perf_hooks&#39;);\r\nconst obs = new PerformanceObserver((items) =&gt; {\r\n    console.log(items.getEntries()[0].duration);\r\n    performance.clearMarks();\r\n});\r\nobs.observe({ entryTypes: [&#39;measure&#39;] });\r\nperformance.measure(&#39;Start to Now&#39;);\r\nperformance.mark(&#39;A&#39;);\r\ndoSomeLongRunningProcess(() =&gt; {\r\n    performance.measure(&#39;A to Now&#39;, &#39;A&#39;);\r\n    performance.mark(&#39;B&#39;);\r\n    performance.measure(&#39;A to B&#39;, &#39;A&#39;, &#39;B&#39;);\r\n});\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "php",
          "name": "Câu hỏi phỏng vấn PHP",
          "description": "",
          "questions": [
            {
              "question": "Sự khác biệt giữa biến và hằng trong PHP?",
              "answer": "<p>| Biến | Hằng |\r\n|------|------|\r\n| Có thể thay đổi giá trị khi thực thi script | Không thể thay đổi giá trị khi thực thi script |\r\n| Các biến yêu cầu bắt buộc sử dụng ký hiệu $ khi bắt đầu | Ký hiệu $ không bắt buộc khi dùng hằng |\r\n| Có thể khai báo thông qua phép gán đơn giản | Không thể khai báo qua phép gán mà phải sử dụng hàm define() |\r\n| Scope mặc định là scope đang truy cập | Có thể được truy cập bởi bất kỳ scope nào |</p>",
              "level": "fresher"
            },
            {
              "question": "Session trong PHP là gì?",
              "answer": "<p>Session là một cách để lưu trữ thông tin (trong các biến) được sử dụng trên nhiều trang.\r\n\r\nKhông giống như một cookie, thông tin session được lưu trữ trên server, chứ không được lưu trữ trên máy tính người dùng.\r\n\r\nKhi bạn làm việc với một ứng dụng, bạn mở nó, thực hiện một số thay đổi, và sau đó bạn đóng nó lại. Điều này giống như một phiên (session). Máy tính biết bạn là ai. Nó biết khi bạn bắt đầu ứng dụng và khi bạn kết thúc. Nhưng trên internet có một vấn đề: máy chủ web không biết bạn là ai hoặc bạn làm gì, vì giao thức HTTP không duy trì trạng thái.\r\n\r\nCác biến session giải quyết vấn đề này bằng cách lưu trữ thông tin người dùng được sử dụng trên nhiều trang (ví dụ: tên người dùng, sở thích, v.v.). Theo mặc định, các biến session tồn tại cho đến khi người dùng đóng trình duyệt.\r\n\r\nVì thế biến sesion giữ thông tin về một người dùng duy nhất và có sẵn cho tất cả các trang trong một ứng dụng.</p>",
              "level": "fresher"
            },
            {
              "question": "PEAR là gì?",
              "answer": "<p>PEAR là viết tắt của <strong>PHP Extension and Application Repository</strong>. Mục đích chính của nó là trở thành một kho chứa cho phần mã thư viện và mở rộng dùng cho PHP, và với tham vọng định ra các chuẩn mực có thể giúp các nhà phát triển tạo nên những dòng mã khả chuyển và có thể dùng lại.\r\n\r\nPEAR  nó cung cấp:\r<ul><li>Một thư viện có cấu trúc các mã nguồn mở cho người dùng PHP.</li></ul>\r<ul><li>Một hệ thống phân phối và đóng gói mã nguồn</li></ul>\r<ul><li>Một phong cách chuẩn viết mã trong PHP</li></ul>\r<ul><li>PHP Foundation Classes (PFC)</li></ul>\r<ul><li>PHP Extension Community Library (PECL)</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích sự khác biệt giữa `$message` và `$$message`?",
              "answer": "<p>| $message | $$message |\r\n|----------|-----------|\r\n| Là biến thông thường | Là biến tham chiếu |\r\n| Có tên và lưu trữ giá trị cố định | Lưu trữ dữ liệu về biến |\r\n| Lưu trữ dữ liệu cố định | Dữ liệu được lưu có thể thay đổi khi giá trị của biến thay đổi |</p>",
              "level": "fresher"
            },
            {
              "question": "PHP có phải là case-sensitive?",
              "answer": "<p>PHP chỉ case-sensitive một nữa. Tên các biến là phân biệt hoa thường nhưng hàm thì không. \r\n\r\nVí dụ: các hàm do người dùng định nghĩa trong PHP có thể được định nghĩa bằng chữ thường nhưng sau đó được gọi bằng chữ hoa thì nó vẫn hoạt động bình thường.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu dữ liệu trong PHP?",
              "answer": "<p><img src=\"/interview-assets/Different_Types_Of_PHP_Variables.jpg\" alt=\"\" />\r\n\r\nCó 8 kiểu dữ liệu chính trong PHP cho khai báo biến:\r<ul><li><strong>Integer:</strong> bao gồm toàn bộ số nguyên. Vd: 1235</li></ul>\r<ul><li><strong>Double:</strong> bao gồm các số dấu phẩy động như 7.786</li></ul>\r<ul><li><strong>Booleans:</strong> biểu diễn giá trị luân lý - true hoặc false.</li></ul>\r<ul><li><strong>NULL:</strong> là kiểu đặc biệt chỉ có một giá trị là NULL. Khi không có giá trị nào được gán cho một biến, nó có thể được gán với NULL. </li></ul>\r<ul><li><strong>Arrays:</strong> là tập hợp có thứ tự với kiểu dữ liệu giống nhau. </li></ul>\r<ul><li><strong>Strings:</strong> là chuỗi tuần tự các ký tự.</li></ul>\r<ul><li><strong>Resources:</strong> là biến đặc biệt bao gồm tham chiếu đến các nguồn tài nguyên bên ngoài PHP.</li></ul>\r<ul><li><strong>Objects:</strong> là thực thể của lớp bao gồm dữ liệu và hàm</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Luật đặt tên biến trong PHP?",
              "answer": "<p><ul><li>Biến phải bắt đầu với ký tự dollar \"$\", theo sau là tên biến. Ví dụ: <code>$price=100</code>, trong đó price là tên biến.</li></ul>\r<ul><li>Tên biến phải bắt đầu là một ký tự chữ cái hoặc gạch dưới.</li></ul>\r<ul><li>Tên biến có thể bao gồm chữ cái, số hay gạch dưới. Nhưng không thể sử dụng ký tự như <code>+</code>, <code>-</code>, <code>%</code>, <code>&amp;</code>,...</li></ul>\r<ul><li>Tên biến không thể bao gồm khoảng trắng.</li></ul>\r<ul><li>Biến PHP phân biệt hoa thường. Nên $NAME và $name là hai biến khác nhau.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa echo và print trong PHP?",
              "answer": "<p>| echo | print |\r\n|------|-------|\r\n| echo có thể xuất một hay nhiều chuỗi | print chỉ xuất một chuỗi và luôn trả về 1 |\r\n| echo nhanh hơn print vì không phải trả về giá trị | print chậm hơn echo |\r\n| Nếu bạn muốn truyền nhiều hơn một tham số cho echo, thì nên sử dụng dấu ngoặc đơn | Không bắt buộc phải sử dụng dấu ngoặc với danh sách đối số |</p>",
              "level": "fresher"
            },
            {
              "question": "Hạn chế của PHP?",
              "answer": "<p><ul><li>Nhược điểm phải nói đến đầu tiên khi dùng PHP chính là cấu trúc ngôn ngữ của nó nhìn không được gọn gàng cho lắm. Mọi câu lệnh được viết trong cặp câu lệnh <code>&lt;?php … ?&gt;</code>.</li></ul>\r<ul><li>Không giống như Java và C# khi bạn học thì có thể làm website, các ứng dụng điện thoại, chương trình hay phần mềm… . tuy nhiên đối với PHP chỉ có thể sử dụng làm website và các ứng dụng website mở rộng mà thôi.</li></ul>\r<ul><li>Nhược điểm lớn nhất đáng nói đến là khả năng bị sao chép và hack mã code dễ hơn và độ an toàn không cao như các ngôn ngữ lập trình khác. Nhưng từ khi lên phiên bản PHP 7 chấm trở lên đã khác phục được rất nhiều vấn đề này.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "HTML và PHP tương tác như thế nào?",
              "answer": "<p>Script PHP có thể tạo ra HTML, và có thể chuyển thông tin từ HTML sang PHP.\r\n\r\nPHP là ngôn ngữ server-side trong khi HTML là ngôn ngữ client-side. Vì vậy PHP thực thi ở phía server và tạo ra kết quả là chuỗi, mảng, đối tượng rồi hiển thị các giá trị đó ở HTML.</p>",
              "level": "fresher"
            },
            {
              "question": "@ trong PHP là gì?",
              "answer": "<p>PHP có một toán tử kiểm soát lỗi, tức là ký hiệu (<code>@</code>). Bất cứ khi nào nó được sử dụng với một biểu thức, thì tất cả thông báo lỗi nào có thể được tạo ra bởi biểu thức đó sẽ bị bỏ qua.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Parser trong PHP?",
              "answer": "<p>Một PHP Parser là một phần mềm chuyển mã nguồn PHP thành code mà máy tính có thể hiểu được. Tức là bất cứ tập hướng dẫn nào mà ta đưa ra dưới dạng code PHP đều được trình phân tích cú pháp chuyển đổi thành dạng máy có thể đọc được.\r\n\r\nTa có thể parse code PHP bằng cách dùng hàm <code>token<em>get</em>all()</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu array trong PHP?",
              "answer": "<p>Trong PHP có 3 kiểu array:\r\n\r\n<img src=\"/interview-assets/Types_of_Arrays_in_PHP.jpg\" alt=\"\" />\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích các kiểu lỗi?",
              "answer": "<p>Có 3 kiểu lỗi trong PHP:\r<ul><li><strong>Notices</strong>: là những lỗi không nghiêm trọng có thể xảy ra trong quá trình thực thi script. Những điều này không hiển thị cho người dùng. Ví dụ một biến undefined.</li></ul>\r<ul><li><strong>Warrnings</strong>: là những cảnh báo quan trọng hơn. Warning không làm gián đoạn quá trình thực thi script. Theo mặc định chúng hiển thị cho người dùng. Vd: <code>include</code> một file không tồn tại.</li></ul>\r<ul><li><strong>Fatal</strong>: là loại lỗi nghiêm trọng nhất khi xảy ra, nó sẽ chấm dứt thực thi script. Vd truy cập thuộc tính của một đối tượng không tồn tại hoặc <code>require()</code> một file không tồn tại.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Trait là gì?",
              "answer": "<p>Traits là một cơ chế để tái sử dụng code trong các ngôn ngữ đơn kế thừa như PHP. Một Trait nhằm giảm hạn chế của sự đơn thừa kế bằng cách cho phép nhà phát triển sử dụng lại các bộ phương thức một cách tự do trong một số lớp độc lập trong các hệ thống phân cấp lớp khác nhau.\r\n\r\nMột Trait tương tự như một lớp (Class), nhưng chỉ nhằm mục đích nhóm chức năng một cách chi tiết và nhất quán. Và nó không có khả năng khởi tạo ví dụ: <code>new class ABC()</code>. Nó là một sự bổ sung cho sự thừa kế truyền thống (đơn kế thừa) trong ngôn ngữ PHP.</p>",
              "level": "fresher"
            },
            {
              "question": "JavaScript có thể tương tác với PHP?",
              "answer": "<p>JavaScript là ngôn ngữ dùng cả hai phía server và client (chủ yếu), còn PHP dùng cho phía server. PHP có khả năng tạo biến JavaScript, và có thể thực thi chúng trên trình duyệt. Từ đó giúp bạn có thể chuyển các biến sang PHP bằng một URL đơn giản.</p>",
              "level": "fresher"
            },
            {
              "question": "Vòng lặp foreach trong PHP?",
              "answer": "<p>Lệnh foreach là một vòng lặp dùng trong PHP cho phép lặp qua các kiểu dữ liệu array.\r\n\r\nHoạt động của foreach rất đơn giản, với mỗi lần truyền giá trị, các phần tử được gán một giá trị và các con trỏ được tăng dần. Quá trình này được thực hiện lặp đi lặp lại cho đến khi đến cuối mảng.\r\n\r\nCú pháp :\r\n\r\n``<code>php\r\nforeach($array as $value)\r\n{\r\n    Code inside the loop;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách băm mật khẩu trong PHP?",
              "answer": "<p>Hàm <code>crypt()</code> dùng cho chức năng băm với một lượng lớn thuật toán băm có thể sử dụng như <code>sha1</code>, <code>sha256</code> hoặc <code>md5</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa include và require()?",
              "answer": "<p>Khi import một file bằng hàm <code>require()</code> nếu file không tồn tại hoặc chương trình không tìm thấy, nó sẽ trả về lỗi (<code>E<em>COMPILE</em>ERROR</code>) và tạm dừng chương trình. Còn với <code>include()</code> nó chỉ trả về cảnh báo (<code>E_WARNING</code>) và tiếp tục chương trình.</p>",
              "level": "fresher"
            },
            {
              "question": "Cookie trong PHP là gì?",
              "answer": "<p>Cookie là mẩu tin nhỏ được lưu ở máy người dùng (cụ thể là tại trình duyệt), cookie sử dụng với mục đích để theo dõi, lưu lại hoạt động truy cập. Ví dụ nhớ tên người dùng truy cập vào website có thể hoạt động qua các bước như sau:\r<ul><li>Server gửi các cookie cho trình duyệt (ví dụ tên người dùng: username) ...</li></ul>\r<ul><li>Trình duyệt lưu lại thông tin này (cookie)</li></ul>\r<ul><li>Lần sau truy cập URL cùng domain (tên miền) trình duyệt sẽ gửi ngược các cookie này lên server và server sẽ nhận được cookie, từ đó xác định được thông tin (như username) ...</li></ul>\r\nNên nhớ cookie được lưu lại ở trình duyệt, sau đó mỗi lần gửi yêu cầu đến server nó sẽ tự động gửi thông tin này đến server\r\n\r\nTheo mặc định, cookie là URL cụ thể. Ví dụ, các cookie của Gmail không được Yahoo hỗ trợ và ngược lại. Mỗi trang có thể tạo 20 cookie trong một trang web hoặc ứng dụng web. 50 byte là kích thước ban đầu của cookie và 4096 byte là kích thước tối đa của cookie.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Thuật ngữ \"Escaping to PHP\" là gì?",
              "answer": "<p>PHP parsing engine cần một cách để phân biệt code PHP với các phần tử trang khác. Cơ chế để thực hiện điều này gọi là \"escaping to PHP\". Escaping có nghĩa là giảm sự trùng lặp khi dùng chuỗi.\r\n\r\nVí dụ, khi bạn khai báo một chuỗi trong cặp dấu nháy đơn hoặc kép:\r\n\r\n\"Hello, Interviewer\"\r\n\r\nNhưng nếu ta thêm dấu nháy vào chuỗi:\r\n\r\n\"Hello \"Interviewer\"\"\r\n\r\nBây giờ ta gặp vấn đề - trình thông dịch sẽ không hiểu chuỗi kết thúc ở đấu. Nếu ta vẫn muốn giữ dấu nháy ta có hai cách. Hoặc là ta sử dụng dấu nháy đơn bọc bên ngoài.\r\n\r\n'Hello \"Interviewer\"'\r\n\r\nHoặc ta dùng escape\r\n\r\n\"Hello \\\"Interviewer\\\"\"\r\n\r\nBất kỳ dấu nháy kép nào đứng trước dấu gạch chéo đều được escape và được hiểu là một phần giá trị của chuỗi.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Path Traversal?",
              "answer": "<p>Path traversal hay còn gọi là Directory traversal là một lỗ hổng bảo mật cho phép kẻ tấn công đọc các file TÙY Ý trên server. Nó dẫn đến việc bị lộ thông tin nhạy cảm của ứng dụng web như thông tin đăng nhập, một số file hoặc thư mục hệ điều hành.\r\n\r\nSở dĩ nói là TÙY Ý, bởi vì trên server sẽ có sự phân quyền và sở hữu đối với các file và folder, admin sẽ sử dụng Access Control List để quy định ai được sử dụng những file này nhằm mục đích gì (read, write, excute). Còn Path Traversal sẽ thực hiện hành vi truy cập vào các file hay folder bị hạn chế truy cập như thế này.\r\n\r\nVí dụ: ta có một button <code>Show File</code> dùng để mở một vài URL.\r\n\r\nVới tấn công path traversal kiểu cổ điển, kẻ tấn công có thể truy cập file hệ thống <code>/etc/paswd</code> (giả sử là hệ thống Unix/Linux). Nếu ứng dụng nhận giá trị của tham số file từ URL và chuyển nó đến lệnh gọi hệ thống, nó sẽ đi qua đường dẫn tương đối <code>../../etc/passwd</code> bắt đầu từ <code>/var/www</code> và yêu cầu hệ thống tải file password.\r\n\r\nKỹ thuật này còn được gọi là <strong>dot-dot-slash</strong>, vì nó thường ký tự <code>../</code> hoặc <code>\\..</code> trên Windows để lên đường dẫn cao hơn.</p>",
              "level": "fresher"
            },
            {
              "question": "Phương thức final và lớp final là gì?",
              "answer": "<p>Từ khoá <code>final</code> trong khai báo phương thức chỉ ra rằng phương thức đó sẽ không thể bị ghi đè bởi lớp con. Một lớp được khai báo là final sẽ không thể có lớp con.\r\n\r\nĐiều này đặc biệt hữu ích khi chúng ta đang tạo một lớp bất biến như lớp String. Chỉ các lớp và phương thức mới có thể được khai báo là final, các thuộc tính không thể được khai báo là final.\r\n\r\n## Câu hỏi phỏng vấn PHP cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Các bước tạo cơ sở dữ liệu dùng PHP và MySQL?",
              "answer": "<p>4 bước để tạo cơ sở dữ liệu MySQL trong PHP:\r<ul><li>Thiết lập kết nối đến MySQL Server bằng PHP script.</li></ul>\r<ul><li>Kết nối được xác thực. Nếu nó thành công, ta có thể viết một truy vấn để kiểm thử.</li></ul>\r<ul><li>Truy vấn tạo cơ sở dữ liệu là input và được lưu dạng biến chuỗi sau đó.</li></ul>\r<ul><li>Sau đó, truy vấn tạo lần lượt được thực thi.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hàm session_start() và session_destroy() trong PHP?",
              "answer": "<p>Hàm session<em>start () được sử dụng để bắt đầu một phiên mới. Ngoài ra, nó có thể tiếp tục một phiên hiện có đang bị dừng. \r\n\r\n``<code>php\r\nsession</em>start();\r\n</code>`<code>\r\n\r\nHàm session<em>destroy() dùng để huỷ tất cả biến phiên.\r\n\r\n</code>`<code>php\r\n&lt;?php\r\nsession</em>start();\r\nsession_destroy();\r\n?&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Memcache và Memcached trong PHP là gì?",
              "answer": "<p>Memcached là một daemon bộ nhớ đệm hiệu quả được thiết kế đặc biệt để giảm tải cơ sở dữ liệu trong các ứng dụng web động. Memcache cung cấp giao diện hướng đối tượng và thủ tục tiện dụng cho Memcached.\r\n\r\nMemcache là không gian lưu trữ bộ nhớ. Chúng tôi có thể chạy Memcache trên một hoặc một số máy chủ. Do đó, có thể chia sẻ một phiên bản Memcache duy nhất giữa nhiều dự án.\r\n\r\nCó thể cấu hình một ứng dụng client để nói chuyện với một tập hợp các trường hợp riêng biệt. Do đó, nó được phép chạy hai tiến trình Memcache khác nhau trên cùng một máy chủ. Mặc dù chạy trên cùng một máy chủ, cả hai quy trình Memcache như vậy vẫn độc lập, trừ khi có một phân vùng dữ liệu</p>",
              "level": "fresher"
            },
            {
              "question": "Các cách khác nhau để xử lý tập kết quả của MySQL trong PHP?",
              "answer": "<p>Có 4 cách xử lý tập kết quả MySQL trong PHP là:\r<ul><li><code>mysqli<em>fetch</em>array()</code>: Trả về hàng hiện tại của tập kết quả dưới dạng một mảng kết hợp, một mảng số hoặc cả hai.</li></ul>\r<ul><li><code>mysqli<em>fetch</em>assoc()</code>: Trả về hàng hiện tại của tập hợp kết quả dưới dạng một mảng kết hợp.</li></ul>\r<ul><li><code>mysqli<em>fetch</em>object()</code>: Trả về hàng hiện tại của tập hợp kết quả dưới dạng một đối tượng.</li></ul>\r<ul><li><code>mysqli<em>fetch</em>row()</code>: Trả về hàng kết quả dưới dạng một mảng được liệt kê.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách kết nối URL trong PHP?",
              "answer": "<p>Bất kỳ URL nào cũng có thể kết nối đến PHP dễ dàng bằng cách dùng thư viện cURL. Nó là một thư viện mặc định với cài đặt chuẩn của PHP. \r\n\r\nThuật ngữ cURL là viết tắt của client-side URL. cURL sử dụng libcurl (client-side URL Transfer Library). Nó hỗ trợ các phương thức như FTP, FTPS, HTTP/1, HTTP POST, HTTP PUT, HTTP proxy, HTTPS, IMAP, Kerberos,... Nó cho phép bạn kết nối một URL và truy xuất hiển thi thông tin của trang web đó (như nội dung HTML của trang, HTTP Header hay dữ liệu liên kết với chúng).\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Tạo API cho PHP?",
              "answer": "<p><strong>Bước 1 - Tạo cơ sở dữ liệu</strong>\r\n\r\n``<code>sql\r\nCREATE DATABASE phptest\r\n</code>`<code>\r\n\r\n<strong>Bước 2 - Tạo bảng:</strong> Sau khi tạo cơ sở dữ liệu, bạn phải tạo một bảng với dữ liệu giả. Để tạo một bảng, hãy chạy truy vấn đưa ra bên dưới:\r\n\r\n</code>`<code>sql\r\nCREATE TABLE IF NOT EXISTS </code>transactions<code> \r\n(\r\n    </code>id<code> int(20) NOT NULL AUTO<em>INCREMENT,\r\n    </code>order</em>id<code> int(50) NOT NULL,\r\n    </code>amount<code> decimal(9,2) NOT NULL,\r\n    </code>response<em>code<code> int(10) NOT NULL,\r\n    </code>response</em>desc<code> varchar(50) NOT NULL,\r\n    PRIMARY KEY (</code>id<code>),\r\n    UNIQUE KEY </code>order<em>id<code> (</code>order</em>id<code>)\r\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\r\n</code>`<code>\r\n\r\n<strong>Bước 3 - Kết nối đến cơ sở dữ liệu:</strong> Tạo file db.php và dán đoạn code bên dưới vào nó.\r\n\r\n</code>`<code>php\r\n&lt;?php\r\n    // Enter your Host, username, password, database below.\r\n    $con = mysqli<em>connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;phptest&quot;);\r\n    if (mysqli</em>connect<em>errno())\r\n    {\r\n        echo &quot;Failed to connect to MySQL: &quot; . mysqli</em>connect<em>error();\r\n        die();\r\n    }\r\n?&gt;\r\n</code>`<code>\r\n\r\n<strong>Bước 4 - Tạo file REST API:</strong> Tạo file api.php và tiếp tục dạn đoạn code bên dưới vào.\r\n\r\n</code>`<code>php\r\n&lt;?php\r\n    header(&quot;Content-Type:application/json&quot;);\r\n    if (isset($</em>GET[&#39;order<em>id&#39;]) &amp;&amp; $</em>GET[&#39;order<em>id&#39;]!=&quot;&quot;) {\r\n        include(&#39;db.php&#39;);\r\n        $order</em>id = $<em>GET[&#39;order</em>id&#39;];\r\n        $result = mysqli<em>query($con,\r\n            &quot;SELECT * FROM </code>transactions<code> WHERE order</em>id=$order<em>id&quot;);\r\n        if(mysqli</em>num<em>rows($result)&gt;0) {\r\n            $row = mysqli</em>fetch<em>array($result);\r\n            $amount = $row[&#39;amount&#39;];\r\n                $response</em>code = $row[&#39;response<em>code&#39;];\r\n                $response</em>desc = $row[&#39;response<em>desc&#39;];\r\n            response($order</em>id, $amount, $response<em>code, $response</em>desc);\r\n            mysqli<em>close($con);\r\n        }\r\n        else {\r\n            response(NULL, NULL, 200,&quot;No Record Found&quot;);\r\n        }\r\n    }\r\n    else {\r\n        response(NULL, NULL, 400,&quot;Request is invalid&quot;);\r\n    }\r\n\r\n    function response($order</em>id,$amount,$response<em>code, $response</em>desc) {\r\n        $response[&#39;order<em>id&#39;] = $order</em>id;\r\n        $response[&#39;amount&#39;] = $amount;\r\n        $response[&#39;response<em>code&#39;] = $response</em>code;\r\n            $response[&#39;response<em>desc&#39;] = $response</em>desc;\r\n        $json<em>response = json</em>encode($response);\r\n        echo $json_response;\r\n    }\r\n?&gt;\r\n</code>``\r\n\r\nĐoạn code trên sẽ chấp nhận yêu cầu GET và trả về kết quả đầu ra ở định dạng JSON.\r\n\r\nBây giờ bạn có thể nhận được đầu ra như dưới đây:\r\n\r\n<img src=\"/interview-assets/Output.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "PDO là gì?",
              "answer": "<p>PHP Data Objects (PDO) là một lớp truy xuất cơ sở dữ liệu cung cấp một phương pháp thống nhất để làm việc với nhiều loại cơ sở dữ liệu khác nhau. Khi làm việc với PDO bạn sẽ không cần phải viết các câu lệnh SQL cụ thể mà chỉ sử dụng các phương thức mà PDO cung cấp, giúp tiết kiệm thời gian và làm cho việc chuyển đổi Hệ quản trị cơ sở dữ liệu trở nên dễ dàng hơn, chỉ đơn giản là thay đổi Connection String (chuỗi kết nối CSDL).\r\n\r\nBạn chỉ cần nắm rõ API mà PDO cung cấp là có thể làm việc được với nhiều Hệ quản trị cơ sở dữ liệu khác nhau như MySQL, SQLite, PostgreSQL, Microsoft SQL Server,... và có thể dễ dàng chuyển đổi chúng.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa GET và POST?",
              "answer": "<p>| GET | POST |\r\n|-----|------|\r\n| Phương thức GET dùng để yêu cầu dữ liệu từ một nguồn cụ thể | Phương thức POST dùng để gửi dữ liệu đến server như một package trong một giao tiếp riêng biệt với script xử lý |\r\n| Dữ liệu được gửi dưới dạng tham số URL là chuỗi các cặp tên-giá trị được phân tách bằng dấu và (&) | Dữ liệu được gửi trong POST sẽ không hiện trong URL |\r\n| Phương thức GET không thể được dùng để gửi dữ liệu nhị phân như hình ảnh hoặc tài liệu word | Phương thức POST có thể được sử dụng để gửi ASCII cũng như dữ liệu nhị phân như hình ảnh và tài liệu văn bản |\r\n| Không được sử dụng phương pháp này nếu bạn có bất kỳ thông tin nhạy cảm nào như mật khẩu được gửi đến server | Thông tin nhạy cảm có thể được gửi bằng phương pháp này |\r\n| Nó có thể được sử dụng để gửi form mà người dùng có thể đánh dấu kết quả | Không thể đánh dấu các submission bằng form với POST |\r\n| Bạn chỉ có thể sử dụng phương pháp này cho dữ liệu không an toàn | Dữ liệu được gửi qua phương thức này được bảo mật |\r\n| Phương thức GET không an toàn vì các tham số có thể được lưu trữ trong log server web hoặc lịch sử trình duyệt | Phương pháp POST an toàn hơn GET vì các tham số không được lưu trữ trong log server web hoặc lịch sử trình duyệt |</p>",
              "level": "fresher"
            },
            {
              "question": "Type hinting trong PHP là gì?",
              "answer": "<p>Trong PHP, kiểu gợi ý - type hinting, được sử dụng để chỉ định kiểu dữ liệu mong đợi (mảng, đối tượng, interface, v.v.) cho một đối số trong khai báo hàm. Nó đã được giới thiệu trong PHP5.\r\n\r\nBất cứ khi nào hàm được gọi, PHP sẽ kiểm tra xem các đối số có thuộc kiểu người dùng mong muốn hay không. Nếu đối số không thuộc kiểu được chỉ định, sẽ hiển thị lỗi và chương trình sẽ không thực thi.\r\n\r\nNó hữu ích trong việc tổ chức code tốt hơn và cải thiện thông báo lỗi.\r\n\r\n``<code>php\r\n//sendEmail() function argument $email is type hinted of Email Class. It means to call this function you must have to pass an email object otherwise an error is generated.\r\n&lt;?php\r\n    function sendEmail (Email $email)\r\n    {\r\n      $email-&gt;send();\r\n    }\r\n?&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để dừng việc thực thi script trong PHP?",
              "answer": "<p>Để chấm dứt việc thực thi script trong PHP, hàm <code>exit()</code> được sử dụng. Nó là một hàm có sẵn để xuất ra một thông báo và sau đó kết thúc script hiện tại.\r\n\r\nThông báo mà bạn muốn hiển thị được chuyển dưới dạng tham số cho hàm <code>exit()</code>. Việc kết thúc script sẽ được thực hiện bởi hàm này sau khi hiển thị thông báo. Nó là một tên bí danh của hàm <code>die()</code>. Nó không trả lại bất kỳ giá trị nào.\r\n\r\nCú pháp: <code>exit(mesage)</code>\r\n\r\nTrong đó message là một tham số được truyền dưới dạng một đối số. Nó xác định một thông báo hoặc trạng thái.\r\n\r\nVí dụ:\r\n\r\n``<code>php\r\n&lt;?php\r\n    $site = &quot;https://www.interviewbit.com//&quot;;\r\n    fopen($site,&quot;r&quot;)\r\n    or exit(&quot;Unable to connect to $site&quot;);\r\n?&gt;\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "python",
          "name": "Câu hỏi phỏng vấn Python",
          "description": "",
          "questions": [
            {
              "question": "Thế nào là ngôn ngữ kiểu động?",
              "answer": "<p>Trước khi hiểu về ngôn ngữ kiểu động ta nên biết về kiểu là gì. Trong ngôn ngữ lập trình, kiểu đề cập đến việc kiểm tra kiểu dữ liệu. Nếu một ngôn ngữ kiểu mạnh, thì <code>&quot;1&quot; + 2</code> sẽ báo lỗi vì không thể tự động ép kiểu. Nhưng nếu là ngôn ngữ kiểu yếu thì sẽ cho về kết quả là <code>12</code>.\r\n\r\nKiểm tra kiểu có hai loại:\r<ul><li><strong>Static</strong>: kiểm tra kiểu dữ liệu trước khi thực thi.</li></ul>\r<ul><li><strong>Dynamic</strong>: kiểm tra kiểu dữ liệu khi đang thực thi.</li></ul>\r\n\r\nPython là ngôn ngữ thông dịch, thực thi câu lệnh theo từng dòng do đó việc kiểm tra kiểu xảy ra khi đang thực thi. Python là ngôn ngữ kiểu động.\r\n\r\n<img src=\"/interview-assets/dynamically_typed_language.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Ngôn ngữ thông dịch là gì?",
              "answer": "<p>Ngôn ngữ thông dịch là ngôn ngữ thực thi từng dòng lệnh, ví dụ như Python, JavaScript, R, PHP và Ruby. Chương trình viết bằng ngôn ngữ thông dịch có thể chạy trực tiếp từ code, không cần bước biên dịch.</p>",
              "level": "fresher"
            },
            {
              "question": "PEP 8 là gì và tại sao nó lại quan trọng?",
              "answer": "<p>PEP là viết tắt của <strong>Python Enhancement Proposal</strong>. Một PEP là một tài liệu thiết kế chính thống cung cấp thông tin từ cộng đồng Python hoặc mô tả tính năng mới của Python. PEP 8 đặc biệt quan trọng vì nó ghi lại các hướng dẫn về phong cách code Python. Rõ ràng là việc đóng góp cho cộng đồng mã nguồn mở Python đòi hỏi bạn phải tuân theo các nguyên tắc về phong cách này một cách nghiêm ngặt.</p>",
              "level": "fresher"
            },
            {
              "question": "Scope trong Python?",
              "answer": "<p>Phạm vi (scope) đề cập đến vùng code mà từ đó đối tượng trong Python có thể truy cập được. Do đó, ta không thể truy cập bất kỳ đối tượng cụ thể nào từ bất kỳ nơi nào trong code, việc truy cập phải được cho phép theo phạm vi của đối tượng.\r\n\r\nCác kiểu phạm vi trong Python:\r<ul><li>Một <strong>local scope</strong> đề cập đến đối tượng cục bộ khả dụng trong hàm hiện tại.</li></ul>\r<ul><li>Một <strong>global scope</strong> đề cập đến đối tượng khả dụng trong suốt quá trình thực thi code kể từ khi chúng ra đời.</li></ul>\r<ul><li>Một <strong>module-level scope</strong> đề cập đến đối tượng toàn cục của module hiện tại có thể truy cập trong chương trình.</li></ul>\r<ul><li>Một <strong>outermost scope</strong> đề cập đến các tên built-in có thể gọi trong chương trình.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "List và Tuple là gì? Sự khác biệt giữa chúng?",
              "answer": "<p>List và Tuple là hai kiểu dữ liệu tuần tự cho lưu trữ tập hợp đối tượng trong Python. List được biểu diễn bằng cặp ngoặc vuông <code>[&#39;sara&#39;, 6, 0.19]</code> trong khi tuple được biểu diễn bằng dấu ngoặc đơn <code>(&#39;ansh&#39;, 5, 0.97)</code>.\r\n\r\nBên cạnh sự khác biệt về cú pháp, điểm khác biệt chính của cả hai là tuple chỉ lưu đối tượng <em>bất biến</em>. Có nghĩa là list có thể chỉnh sửa, thêm hay xoá trong khi tuple chỉ lưu hằng và không chỉnh sửa gì được. \r\n\r\n``<code>python\r\nmy<em>tuple = (&#39;sara&#39;, 6, 5, 0.97)\r\nmy</em>list = [&#39;sara&#39;, 6, 5, 0.97]\r\nprint(my<em>tuple[0])     # output =&gt; &#39;sara&#39;\r\nprint(my</em>list[0])     # output =&gt; &#39;sara&#39;\r\nmy<em>tuple[0] = &#39;ansh&#39;    # modifying tuple =&gt; throws an error\r\nmy</em>list[0] = &#39;ansh&#39;    # modifying list =&gt; list modified\r\nprint(my<em>tuple[0])     # output =&gt; &#39;sara&#39;\r\nprint(my</em>list[0])     # output =&gt; &#39;ansh&#39;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu dữ liệu trong Python?",
              "answer": "<p>Mặc dù Python không yêu cầu kiểu dữ liệu khi khai báo biến nhưng lỗi vẫn xảy là nếu ta dùng kiểu dữ liệu khác với tương thích của nó. Python cung cấp hàm <code>type()</code> và <code>isinstance()</code> để kiểm tra kiểu của các các biến. Trong Python có các kiểu dữ liệu sau:\r<ul><li><strong>None</strong>: từ khoá <code>None</code> biểu diễn giá trị null trong Python. Có thể thực hiện so sánh bằng với đối tượng kiểu None.</li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |------------|-------------|\r\n   | NoneType | Biểu diễn giá trị Null |\r<ul><li><strong>Kiểu số</strong>: có 3 kiểu số trong Python là <strong>int</strong>, <strong>float</strong> và <strong>complex</strong>. Bên cạnh đó boolean cũng là kiểu con của int.</li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |-----|-------|\r\n   | int | lưu trữ kiểu số nguyên dạng thập phân, nhị phân, bát phân |\r\n   | float | lưu trữ giá trị thập phân, phân số, số chấm động |\r\n   | complex | lưu trữ kiểu số phức (A + Bj) với A là phần thực, B là phần ảo |\r\n   | bool | lưu giá trị nhị nguyên (True hoặc False) |\r<ul><li><strong>Kiểu tuần tự</strong>: có 3 kiểu tuần tự cơ bản trong Python - <strong>list</strong>, <strong>tuple</strong> và <strong>range</strong>. Kiểu tuần tự có thể thực hiện toán tử <code>in</code> và <code>not in</code>  để duyệt qua tất cả phần tử của chúng. Các toán tử này có cùng mức độ ưu tiên với các toán tử so sánh.</li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |-----|-------|\r\n   | list | Dùng cho lưu tập hợp phần tử, có thể chỉnh sửa |\r\n   | tuple | Dùng cho lưu tập hợp phần tử, bất biến |\r\n   | range | Biểu diễn chuỗi số bất biến trong suốt quá trình thực thi |\r\n   | str | Chuỗi bất biến Unicode cho lưu trữ dữ liệu văn bản |\r\n\r\n   <em>Lưu ý</em>: thư viện chuẩn còn bổ sung hai kiểu là Binary data như <code>bytearray bytes</code>, <code>memoryview</code> và Text string như <code>str</code>.\r<ul><li><strong>Kiểu ánh xạ</strong>: Trong Python, một đối tượng ánh xạ (mapping object) là một tập hợp các cặp key-value. Nó ánh xạ giá trị (value) với key tương ứng. Kiểu dữ liệu ánh xạ duy nhất trong Python là <strong>dictionary</strong>. </li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |-----|-------|\r\n   | dict | Lưu trữ tập hợp riêng biệt dạng cặp key/value |\r<ul><li><strong>Kiểu tập hợp</strong>: hiện tại Python có hai kiểu tập hợp là <strong>set</strong> và <strong>frozenset</strong>. Kiểu set có thể thay đổi với hai phướng thức là <code>add()</code> và <code>remove()</code>, kiểu frozenset là bất biến, không thể chỉnh sửa sau khi tạo.</li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |-----|-------|\r\n   | set | Tập hợp không thứ tự có thể chỉnh sửa |\r\n   | frozenset | Tập hợp đối tượng riêng biệt bất biến |\r<ul><li><strong>Modules</strong></li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Pass trong Python?",
              "answer": "<p>Từ khoá <code>pass</code> biểu diễn toán tử null trong Python. Nó được dùng nhằm mục đích lắp đầy các khối code trống có thể thực thi trong thời gian chạy nhưng hiện tại vẫn chưa viết. Nếu không có lệnh pass, ta có thể gặp lỗi khi thực thi code.\r\n\r\n``<code>python\r\ndef myEmptyFunc():\r\n   # do nothing\r\n   pass\r\nmyEmptyFunc()    # nothing happens\r\n## Without the pass keyword\r\n# File &quot;&lt;stdin&gt;&quot;, line 3\r\n# IndentationError: expected an indented block\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Module và package trong Python?",
              "answer": "<p>Package và module là hai cơ chế cho phép <strong>lập trình module</strong> trong Python. Việc module hoá đem lại các lợi ích như:\r<ul><li><strong>Tính đơn giản:</strong> Làm việc trên một module duy nhất giúp bạn tập trung vào một phần tương đối nhỏ của vấn đề hiện tại. Điều này giúp cho việc phát triển dễ dàng hơn và ít bị lỗi hơn.</li></ul>\r<ul><li><strong>Khả năng bảo trì:</strong> Các module được thiết kế để thực thi các logic giữa các khía cạnh vấn đề khác nhau. Nếu chúng được viết theo cách làm giảm sự phụ thuộc lẫn nhau, thì các sửa đổi trong một module ít gây ảnh hưởng đến các phần khác của chương trình.</li></ul>\r<ul><li><strong>Khả năng tái sử dụng:</strong> Các hàm được khai báo trong một module có thể được sử dụng lại dễ dàng bởi các phần khác của ứng dụng.</li></ul>\r<ul><li><strong>Phạm vi:</strong> Các module thường xác định một namespace riêng biệt, giúp tránh nhầm lẫn giữa các định danh từ các phần khác của chương trình.</li></ul>\r\n\r\n<strong>Modules</strong>, là một file Python với mở rộng <code>.py</code> và có một tập hàm, lớp hoặc biến được khai báo và triển khai trong nó. Nó có thể được import ở file khác bằng lệnh <code>import</code>. Vd:\r\n\r\n``<code>py\r\nfrom foo import bar\r\n</code>`<code>\r\n\r\n<strong>Package</strong> cho phép cấu trúc phân cấp module bằng cách dùng ký hiệu </code>.`. Nếu như module giúp tránh xung đột giữa các tên biến toàn cục thì các package giúp tránh xung đột giữa các tên module.\r\n\r\nViệc tạo một package rất dễ dàng vì nó sử dụng cấu trúc file vốn có của hệ thống. Vì vậy, chỉ cần đưa các module vào một thư mục là bạn sẽ có nó, tên thư mục là tên package. Việc import một module hoặc nội dung của nó từ package này yêu cầu tên package làm tiền tố cho tên module được nối bằng dấu chấm.</p>",
              "level": "fresher"
            },
            {
              "question": "Các quyền truy cập thuộc tính trong Python?",
              "answer": "<p><ul><li><strong>Global</strong> là các biến công khai được khai báo ở global scope. Để dùng các biến này trong hàm, ta sử dụng từ khoá <code>global</code>.</li></ul>\r<ul><li><strong>Protected</strong> là thuộc tính được khai báo với dấu gạch dưới phía trước để định danh, vd <code><em>sara</code>. Nó có thể truy cập và chỉnh sửa bên ngoài lớp. </li></ul>\r<ul><li><strong>Private</strong> là thuộc tính với hai dấu gạch dưới phía trước để định danh, vd: <code></em>_ansh</code>. Nó không thể truy cập hay chỉnh sửa bên ngoài lớp.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Self trong Python?",
              "answer": "<p>Self được sử dụng để đại diện cho thực thể của lớp. Với từ khóa <code>this</code>, bạn có thể truy cập các thuộc tính và phương thức của lớp trong python. Nó liên kết các thuộc tính với các đối số đã cho. Self được sử dụng ở những nơi khác nhau và thường được cho là một từ khóa. Nhưng không giống như trong C ++, self không phải là một từ khóa trong Python.</p>",
              "level": "fresher"
            },
            {
              "question": "__init__ là gì?",
              "answer": "<p><code><strong>init</strong></code> là một phương thức khởi tạo trong Python và tự động gọi bộ nhớ cấp phát khi một đối tượng/thực thể mới được tạo. Tất cả lớp đều có phương thức <code>_<em>init</em>-</code> liên kết với chúng. Nó giúp phân biệt phương thức và thuộc tính từ biến cục bộ.\r\n\r\n``<code>py\r\n# class definition\r\nclass Student:\r\n   def <strong>init</strong>(self, fname, lname, age, section):\r\n      self.firstname = fname\r\n      self.lastname = lname\r\n      self.age = age\r\n      self.section = section\r\n# creating a new object\r\nstu1 = Student(&quot;Sara&quot;, &quot;Ansh&quot;, 22, &quot;A2&quot;)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "break, continue và pass trong Python?",
              "answer": "<p>| | |\r\n|-|-|\r\n| Break | lệnh break huỷ vòng lặp ngay lập tức và chuyển luồng điều khiển đến phần thân sau vòng lặp đó |\r\n| Continue | lệnh continue huỷ lần lặp hiện tại của câu lệnh, nó bỏ quả phần code của lần lặp hiện tại và chuyển luồng điều khiển đến lần lặp kế tiếp |\r\n| Pass | Từ khoá pass trong Python dùng để lấp đầy các empty block, tương tự một câu lệnh trống (<code>;</code>) trong Java, C++ |\r\n\r\n``<code>py\r\npat = [1, 3, 2, 1, 2, 3, 1, 0, 1, 3]\r\nfor p in pat:\r\n   pass\r\n   if (p == 0):\r\n       current = p\r\n       break\r\n   elif (p % 2 == 0):\r\n       continue\r\n   print(p)    # output =&gt; 1 3 1 3 1\r\nprint(current)    # output =&gt; 0\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Unit test trong Python là gì?",
              "answer": "<p><ul><li>Unit test là một framework kiểm thử đơn vị của Python.</li></ul>\r<ul><li>Unit test có nghĩa là kiểm tra các thành phần khác nhau của phần mềm một cách riêng biệt. Bạn có thể biết lý do tại sao unit test lại quan trọng không? Hãy tưởng tượng một tình huống, bạn đang xây dựng phần mềm sử dụng ba thành phần là A, B và C. Bây giờ, giả sử phần mềm của bạn bị hỏng tại một thời điểm. Làm thế nào bạn sẽ tìm thấy thành phần nào chịu trách nhiệm cho sự cố đó? Có thể thành phần A bị lỗi, thành phần B bị lỗi, và điều này thực sự đã làm hỏng phần mềm. Có thể có nhiều cách kết hợp như vậy.</li></ul>\r<ul><li>Đây là lý do tại sao cần phải kiểm tra từng thành phần đúng cách để thành phần nào có thể chịu trách nhiệm chính cho sự cố của phần mềm.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Docstring là gì?",
              "answer": "<p>Docstring hay documentation string là một chuỗi nhiều dòng dùng để ghi lại một đoạn code cụ thể.\r\n\r\nDocstrign mô tả hàm hoặc phương thức hoạt động.</p>",
              "level": "fresher"
            },
            {
              "question": "Slicing trong Python?",
              "answer": "<p>Slicing mô tả hành vi phân tách các mục trong một đối tượng dạng mảng (array, string, list và tuple). Cú pháp <strong>[start: stop: step]</strong>\r<ul><li><code>start</code> là chỉ mục bắt đầu tách.</li></ul>\r<ul><li><code>stop</code> là chỉ mục dừng lại.</li></ul>\r<ul><li><code>step</code> là số bước nhảy.</li></ul>\r\n\r\nGiá trị mặc định của start là 0, stop là số lượng mục, step là 1.\r\n\r\n``<code>py\r\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\nprint(numbers[1 : : 2])  \r\n\r\n#output : [2, 4, 6, 8, 10]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách thực thi Python script trên Unix?",
              "answer": "<p>Script phải bắt đầu với <code>#!/usr/bin/env python</code></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa array và list trong Python?",
              "answer": "<p><ul><li>Array (mảng) trong Python bao gồm các phần tử có cùng kiểu dữ liệu. </li></ul>\r<ul><li>List (danh sách) trong Python gồm các phần tử có thể khác kiểu dữ liệu.</li></ul>\r\n\r\n``<code>py\r\nimport array\r\na = array.array(&#39;i&#39;, [1, 2, 3])\r\nfor i in a:\r\n   print(i, end=&#39; &#39;)    #OUTPUT: 1 2 3\r\na = array.array(&#39;i&#39;, [1, 2, &#39;string&#39;])    #OUTPUT: TypeError: an integer is required (got type str)\r\n\r\na = [1, 2, &#39;string&#39;]\r\nfor i in a:\r\n   print(i, end=&#39; &#39;)    #OUTPUT: 1 2 string\r\n</code>``\r\n\r\n## Câu hỏi phỏng vấn cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Quản lý bộ nhớ trong Python?",
              "answer": "<p>Bộ nhớ trong Python được xử lý bởi <strong>Python Memory Manager</strong>. Bộ nhớ được cấp phát bởi manager trong một <strong>private heap space</strong> dành riêng cho Python. Tất cả đối tượng Python được lưu trữ trong heap này và là riêng tư, nó không thể truy cập bởi lập trình viện. Tuy nhiên, Python cung cấp một vài hàm API cốt lõi cho làm việc trên <strong>private heap space</strong>.\r\n\r\nNgoài ra, Python có một bộ dọn rác có sẵn để dọn dẹp bộ nhớ không được sử dụng cho <strong>private heap space</strong>.\r\n\r\n<img src=\"/interview-assets/Memory_Management_in_Python.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Namespace là gì?",
              "answer": "<p>Namespace trong Python đề cập đến tên đối tượng trong một chương trình duy nhất và có thể dùng mà không có xung đột. Python triển khai các namespace này như một từ điển với tên giống như là khoá ánh xạ tới đối tượng tương ứng giống như giá trị. Nó cho phép nhiều namespace sử dụng cùng tên và ánh xạ nó đến các đối tượng riêng biệt. Một vài ví dụ của namespace:\r<ul><li><strong>Local Namespace</strong> bao gồm tên cục bộ bên trong một hàm. Namespace được tạo tạm thời cho gọi hàm và sẽ bị xoá khi hàm đó trả về.</li></ul>\r<ul><li><strong>Global Namespace</strong> bao gồm tên từ các package/module khác được import để sử dụng trong dự án hiện tại. Namespace này được tạo khi package được import trong script cho đến khi script được thực thi.</li></ul>\r<ul><li><strong>Built-in Namespace</strong> bao gồm các hàm có sẵn của Python và tên có sẵn cho các kiểu thực thi khác nhau.</li></ul>\r\n\r\nVòng đời của namespace dựa trên đối tượng mà nó ánh xạ. Nên ở ngoài phạm vi của đối tượng, thì vòng đời của namespace sẽ kết thúc. Do đó, không thể truy cập vào trong đối tượng namespace từ bên ngoài namespace.\r\n\r\n<img src=\"/interview-assets/Python_namespaces.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Scope Resolution trong Python?",
              "answer": "<p>Thỉnh thoảng trong cùng một scope sẽ có đối tượng cùng tên nhưng khác chứ năng. Trong trường hợp đó, scope resolution sẽ được Python tự động chạy. Một vài ví dụ hành vi như:\r<ul><li>Module Python có tên như 'math' và 'cmath' có nhiều hàm giống nhau như <code>log10()</code>, <code>acos()</code>, <code>exp()</code>. Để giải quyết vấn đề xung đột, ta cần thêm tên module vào phía trước chúng như <code>math.exp()</code> và <code>cmath.exp()</code></li></ul>\r<ul><li>Hãy xem xét đoạn code dưới đây, một đối tượng <code>temp</code> đã được khởi tạo bằng 10 trên toàn cục và sau đó là 20 khi gọi hàm. Tuy nhiên, lệnh gọi hàm không thay đổi giá trị của <code>temp</code> trên toàn cục. Ở đây, chúng ta có thể quan sát thấy rằng Python vẽ ra một ranh giới rõ ràng giữa các biến toàn cục và cục bộ, coi các namespace của chúng là danh tính riêng biệt.</li></ul>\r\n\r\n``<code>py\r\ntemp = 10   # global-scope variable\r\ndef func():\r\n   temp = 20   # local-scope variable\r\n   print(temp)\r\nprint(temp)   # output =&gt; 10\r\nfunc()    # output =&gt; 20\r\nprint(temp)   # output =&gt; 10\r\n</code>`<code>\r\n\r\nHành vi này có thể bị ghi đè bằng cách dùng từ khoá </code>global<code> trong hàm như ví dụ bên dưới.\r\n\r\n</code>`<code>py\r\ntemp = 10   # global-scope variable\r\ndef func():\r\n   global temp\r\n   temp = 20   # local-scope variable\r\n   print(temp)\r\nprint(temp)   # output =&gt; 10\r\nfunc()    # output =&gt; 20\r\nprint(temp)   # output =&gt; 20\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Decorator trong Python là gì?",
              "answer": "<p>Decorator trong Python về cơ bản là các hàm bổ sung chức năng cho một hàm hiện có trong Python mà không thay đổi cấu trúc của chính hàm đó. Chúng được biểu diễn là <code>@decorator<em>name</code> bằng Python và được gọi theo kiểu từ dưới lên. Ví dụ:\r\n\r\n``<code>py\r\n# decorator function to convert to lowercase\r\ndef lowercase</em>decorator(function):\r\n   def wrapper():\r\n      func = function()\r\n      string<em>lowercase = func.lower()\r\n      return string</em>lowercase\r\n   return wrapper\r\n# decorator function to split words\r\ndef splitter<em>decorator(function):\r\n   def wrapper():\r\n      func = function()\r\n      string</em>split = func.split()\r\n      return string<em>split\r\n   return wrapper\r\n@splitter</em>decorator # this is executed next\r\n@lowercase<em>decorator # this is executed first\r\ndef hello():\r\n   return &#39;Hello World&#39;\r\nhello()   # output =&gt; [ &#39;hello&#39; , &#39;world&#39; ]\r\n</code>`<code>\r\n\r\nCái hay của decorator nằm ở chỗ bên cạnh việc thêm chức năng vào đầu ra của phương thức, chúng thậm chí có thể chấp nhận các đối số cho các hàm và có thể sửa đổi thêm các đối số đó trước khi truyền nó vào chính hàm. Hàm lồng nhau bên trong, tức là hàm &#39;wrapper&#39;, đóng một vai trò quan trọng ở đây. Nó được dùng để thực thi tính năng đóng gói, do đó tự ẩn mình khỏi phạm vi toàn cục.\r\n\r\n</code>`<code>py\r\n# decorator function to capitalize names\r\ndef names</em>decorator(function):\r\n   def wrapper(arg1, arg2):\r\n      arg1 = arg1.capitalize()\r\n      arg2 = arg2.capitalize()\r\n      string<em>hello = function(arg1, arg2)\r\n      return string</em>hello\r\n   return wrapper\r\n@names<em>decorator\r\ndef say</em>hello(name1, name2):\r\n   return &#39;Hello &#39; + name1 + &#39;! Hello &#39; + name2 + &#39;!&#39;\r\nsay_hello(&#39;sara&#39;, &#39;ansh&#39;)   # output =&gt; &#39;Hello Sara! Hello Ansh!&#39;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Dict và List comprehensions trong Python?",
              "answer": "<p>Python comprehensions, giống như decorator, chúng là những cấu trúc cú pháp tuyệt vời cho xây dựng một list, dictionaries hay set có thể chỉnh sửa và chọn lọc. Sử dụng comprehensions giúp tiết kiệm thời gian và code trở nên rõ ràng hơn. Ta có các ví dụ sau đây:\r<ul><li>Thực hiện phép toán trên một list:</li></ul>\r\n\r\n``<code>py\r\nmy<em>list = [2, 3, 5, 7, 11]\r\nsquared</em>list = [x<strong>2 for x in my<em>list]    # list comprehension\r\n# output =&gt; [4 , 9 , 25 , 49 , 121]\r\nsquared</em>dict = {x:x</strong>2 for x in my<em>list}    # dict comprehension\r\n# output =&gt; {11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49}\r\n</code>`<code>\r<ul><li>Thực hiện lọc theo điều kiện trên một list:</li></ul>\r\n\r\n</code>`<code>py\r\nmy</em>list = [2, 3, 5, 7, 11]\r\nsquared<em>list = [x<strong>2 for x in my</em>list if x%2 != 0]    # list comprehension\r\n# output =&gt; [9 , 25 , 49 , 121]\r\nsquared<em>dict = {x:x</strong>2 for x in my</em>list if x%2 != 0}    # dict comprehension\r\n# output =&gt; {11: 121, 3: 9 , 5: 25 , 7: 49}\r\n</code>`<code>\r<ul><li>Kết hợp nhiều list thành một:</li></ul>\r\n\r\n</code>`<code>py\r\na = [1, 2, 3]\r\nb = [7, 8, 9]\r\n[(x + y) for (x,y) in zip(a,b)]  # parallel iterators\r\n# output =&gt; [8, 10, 12]\r\n[(x,y) for x in a for y in b]    # nested iterators\r\n# output =&gt; [(1, 7), (1, 8), (1, 9), (2, 7), (2, 8), (2, 9), (3, 7), (3, 8), (3, 9)] \r\n</code>`<code>\r<ul><li>Làm phẳng list đa chiều:</li></ul>\r\n\r\n</code>`<code>py\r\nmy<em>list = [[10,20,30],[40,50,60],[70,80,90]]\r\nflattened = [x for temp in my</em>list for x in temp]\r\n# output =&gt; [10, 20, 30, 40, 50, 60, 70, 80, 90]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Lambda trong Python?",
              "answer": "<p>Lambda là một hàm ẩn danh trong Python, có thể chấp nhận bất kỳ số lượng đối số nào, nhưng chỉ có thể có một biểu thức duy nhất. Nó thường được sử dụng trong các tình huống yêu cầu một hàm ẩn danh trong một khoảng thời gian ngắn. Các hàm Lambda có thể được sử dụng theo một trong hai cách:\r<ul><li>Gán hàm lambda cho một biến:</li></ul>\r\n\r\n``<code>py\r\nmul = lambda a, b : a <em> b\r\nprint(mul(2, 5))    # output =&gt; 10\r\n</code>`<code>\r<ul><li>Bộc hàm lambda trong một hàm khác:</li></ul>\r\n\r\n</code>`<code>py\r\ndef myWrapper(n):\r\n   return lambda a : a </em> n\r\nmulFive = myWrapper(5)\r\nprint(mulFive(2))    # output =&gt; 10\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sao chép đối tượng trong Python?",
              "answer": "<p>Trong Python, câu lệnh gán (toán tử <code>=</code>) không sao chép các đối tượng. Thay vào đó, nó tạo ra một ràng buộc giữa đối tượng hiện có và tên biến mục tiêu. Để tạo bản sao của một đối tượng bằng Python, chúng ta cần sử dụng module <strong>copy</strong>. Hơn nữa, có hai cách để tạo bản sao cho đối tượng đã cho bằng cách sử dụng module <strong>copy</strong>\r<ul><li><strong>Shallow copy</strong> là một bản sao khôn ngoan của một đối tượng. Đối tượng được sao chép được tạo có bản sao chính xác của các giá trị trong đối tượng gốc. Nếu một trong hai giá trị là một tham chiếu đến các đối tượng khác, thì chỉ cần sao chép các địa chỉ tham chiếu cho cùng một.</li></ul>\r<ul><li><strong>Deep copy</strong> sao chép tất cả các giá trị một cách đệ quy từ đối tượng nguồn sang đối tượng đích, tức là nó thậm chí sao chép các đối tượng được tham chiếu bởi đối tượng nguồn.</li></ul>\r\n\r\n``<code>py\r\nfrom copy import copy, deepcopy\r\nlist<em>1 = [1, 2, [3, 5], 4]\r\n## shallow copy\r\nlist</em>2 = copy(list<em>1) \r\nlist</em>2[3] = 7\r\nlist<em>2[2].append(6)\r\nlist</em>2    # output =&gt; [1, 2, [3, 5, 6], 7]\r\nlist<em>1    # output =&gt; [1, 2, [3, 5, 6], 4]\r\n## deep copy\r\nlist</em>3 = deepcopy(list<em>1)\r\nlist</em>3[3] = 8\r\nlist<em>3[2].append(7)\r\nlist</em>3    # output =&gt; [1, 2, [3, 5, 6, 7], 8]\r\nlist_1    # output =&gt; [1, 2, [3, 5, 6], 4]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa xrange và range trong Python?",
              "answer": "<p>xrange() và range() khá giống nhau về chức năng. Cả hai đều tạo một chuỗi số nguyên, với khác biệt duy nhất là <code>range()</code> trả về một list trong khi <code>xrange()</code> trả về một đối tượng xrange.\r\n\r\nBởi vì không giống như <code>range()</code>, <code>xrange()</code> không tạo ra một list tĩnh, nó tạo ra giá trị đang di chuyển. Kỹ thuật này thường được sử dụng với generator và được gọi là <strong>yielding</strong>.\r\n\r\nYielding là rất quan trọng trong các ứng dụng mà bộ nhớ là một hằng. Việc tạo list tĩnh như trong <code>range()</code> có thể dẫn đến <code>Memory Error</code> trong những điều kiện như vậy, trong khi <code>xrange()</code> có thể xử lý nó một cách tối ưu bằng cách sử dụng vừa đủ bộ nhớ cho generator (ít hơn đáng kể khi so sánh).\r\n\r\n``<code>py\r\nfor i in xrange(10):    # numbers from o to 9\r\n   print i       # output =&gt; 0 1 2 3 4 5 6 7 8 9\r\nfor i in xrange(1,10):    # numbers from 1 to 9\r\n   print i       # output =&gt; 1 2 3 4 5 6 7 8 9\r\nfor i in xrange(1, 10, 2):    # skip by two for next\r\n   print i       # output =&gt; 1 3 5 7 9\r\n</code>`<code>\r\n\r\n<em>Lưu ý:</em> </code>xrange<code> không được hỗ trợ ở Python3. Nên </code>range<code> được dùng giống như </code>xrange` ở Python2.</p>",
              "level": "fresher"
            },
            {
              "question": "Pickling và unpickling là gì?",
              "answer": "<p>Thư viện Python cung cấp một tính năng - tuần tự hóa (serialization) ra khỏi hộp. Việc tuần tự hóa một đối tượng đề cập đến việc chuyển đổi nó thành một định dạng có thể được lưu trữ, để sau này có thể giải mã hóa đối tượng để lấy được đối tượng ban đầu. Ở đây, module <strong>pickle</strong> được dùng.\r\n\r\n<strong>Pickling:</strong>\r<ul><li>Pickling là tên của quá trình tuần tự hóa trong Python. Bất kỳ đối tượng nào trong Python đều có thể được tuần tự hóa thành một luồng byte và được kết xuất dưới dạng file trong bộ nhớ. Quá trình pickling là nhỏ gọn nhưng các đối tượng pickle có thể được nén thêm. Hơn nữa, pickle theo dõi các đối tượng mà nó đã tuần tự hóa và việc tuần tự hóa có thể di động qua các phiên bản.</li></ul>\r<ul><li>Hàm dùng cho quá trình này là <code>pickle.dump()</code>.</li></ul>\r\n\r\n<strong>Unpickling:</strong>\r<ul><li>Unpickling là nghịch đảo hoàn toàn của pickling. Nó giải mã dòng byte để tạo lại các đối tượng được lưu trữ trong file và tải đối tượng vào bộ nhớ.</li></ul>\r<ul><li>Hàm dùng cho quá trình này là <code>pickle.load()</code>.</li></ul>\r\n\r\n<img src=\"/interview-assets/differences_between_pickling_and_unpickling.jpg\" alt=\"\" />\r\n\r\n<em>Lưu ý:</em> Python có một module tuần tự hóa khác, nguyên thủy hơn được gọi là <strong>marshall</strong>, tồn tại chủ yếu để hỗ trợ các file .pyc trong Python và khác biệt đáng kể với pickle.</p>",
              "level": "fresher"
            },
            {
              "question": "Generator trong Python là gì?",
              "answer": "<p>Generator là hàm trả về một tập hợp mục có thể lặp lại, mỗi lần một mục, theo một cách nhất định. Nói chung, các generator được sử dụng để tạo các trình vòng lặp - iterator với một cách tiếp cận khác. Chúng sử dụng từ khóa <code>yield</code> thay vì quay lại để trả về một đối tượng generator. \r\n\r\nVí dụ generator với số fibonacci:\r\n\r\n``<code>py\r\n## generate fibonacci numbers upto n\r\ndef fib(n):\r\n   p, q = 0, 1\r\n   while(p &lt; n):\r\n       yield p\r\n       p, q = q, p + q\r\nx = fib(10)    # create generator object \r\n \r\n## iterating using <strong>next</strong>(), for Python2, use next()\r\nx.<strong>next</strong>()    # output =&gt; 0\r\nx.<strong>next</strong>()    # output =&gt; 1\r\nx.<strong>next</strong>()    # output =&gt; 1\r\nx.<strong>next</strong>()    # output =&gt; 2\r\nx.<strong>next</strong>()    # output =&gt; 3\r\nx.<strong>next</strong>()    # output =&gt; 5\r\nx.<strong>next</strong>()    # output =&gt; 8\r\nx.<strong>next</strong>()    # error\r\n \r\n## iterating using loop\r\nfor i in fib(10):\r\n   print(i)    # output =&gt; 0 1 1 2 3 5 8\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "PYTHONPATH là gì?",
              "answer": "<p>PYTHONPATH là một biến môi trường mà bạn có thể đặt để thêm các thư mục bổ sung nơi Python sẽ tìm kiếm các module và package. Điều này đặc biệt hữu ích trong việc duy trì các thư viện Python mà bạn không muốn cài đặt ở vị trí mặc định chung.</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm help() và dir() để làm gì?",
              "answer": "<p>Hàm <code>help()</code> dùng để hiển thị tài liệu cho các module, class, function, keyword. Nó không có tham số truyền vào, dùng để hiển thị tiện ích tương tác trên console.\r\n\r\nHàm <code>dir()</code> trả về một danh sách các thuộc tính và phương thức hợp lệ của đối tượng mà nó được gọi. Nó hoạt động khác nhau với các đối tượng khác nhau nhằm mục đích tạo ra dữ liệu phù hợp nhất thay vì thông tin đầy đủ.\r<ul><li>Đối với các đối tượng module/thư viện, nó trả về danh sách tất cả các thuộc tính, có trong module đó.</li></ul>\r<ul><li>Đối với đối tượng lớp, nó trả về danh sách tất cả các thuộc tính hợp lệ và thuộc tính cơ sở.</li></ul>\r<ul><li>Không có đối số nào được truyền, nó trả về một danh sách các thuộc tính trong phạm vi hiện tại.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa .py và .pyc?",
              "answer": "<p><ul><li>Các file <code>.py</code> chứa mã nguồn của một chương trình. Trong khi đó, file <code>.pyc</code> chứa mã bytecode của chương trình của bạn. Chúng tôi nhận được mã bytecode sau khi biên dịch file <code>.py</code> (mã nguồn). Các file <code>.pyc</code> không được tạo cho tất cả các file mà bạn chạy. Nó chỉ được tạo cho các file mà bạn nhập.</li></ul>\r<ul><li>Trước khi thực hiện một chương trình python, trình thông dịch python kiểm tra các file đã biên dịch. Nếu file có mặt, máy ảo sẽ thực thi file đó. Nếu không tìm thấy, nó sẽ kiểm tra file <code>.py</code>. Nếu được tìm thấy, hãy biên dịch nó thành file <code>.pyc</code> và sau đó máy ảo python thực thi nó.</li></ul>\r\n\r\nCó file <code>.pyc</code> giúp bạn tiết kiệm thời gian biên dịch</p>",
              "level": "fresher"
            },
            {
              "question": "Python được thông dịch?",
              "answer": "<p><ul><li>Python là một ngôn ngữ không được thông dịch hoặc biên dịch. Thông dịch hoặc biên dịch là thuộc tính của việc triển khai. Python là một bytecode (tập hợp các hướng dẫn có thể đọc được của trình thông dịch) được thông dịch chung.</li></ul>\r<ul><li>Mã nguồn là một file có phần mở rộng .py.</li></ul>\r<ul><li>Python biên dịch mã nguồn thành một tập hợp các hướng dẫn cho một máy ảo. Trình thông dịch Python là một triển khai của máy ảo đó. Định dạng trung gian này được gọi là \"bytecode\".</li></ul>\r<ul><li>Mã nguồn <code>.py</code> đầu tiên được biên dịch để cung cấp <code>.pyc</code> là mã bytecode. Bytecode này sau đó có thể được thông dịch bởi CPython chính thức hoặc JIT (trình biên dịch Just in Time) do PyPy biên dịch.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Truyền tham số bằng giá trị và bằng tham chiếu trong Python?",
              "answer": "<p><ul><li>Truyền bằng giá trị: Sao chép đối tượng thực được truyền. Thay đổi giá trị của đối tượng sao chép sẽ không ảnh hướng đến đối tượng gốc.</li></ul>\r<ul><li>Truyền bằng tham chiếu: Tham chiếu đến đối tượng thực được truyền. Thay đổi giá trị ở đối tượng mới sẽ thay đổi cả giá trị ở đối tượng gốc.</li></ul>\r\n\r\n``<code>py\r\ndef appendNumber(arr):\r\n   arr.append(4)\r\narr = [1, 2, 3]\r\nprint(arr)  #Output: =&gt; [1, 2, 3]\r\nappendNumber(arr)\r\nprint(arr)  #Output: =&gt; [1, 2, 3, 4]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Iterator trong Python?",
              "answer": "<p><ul><li>Một iterator là một đối tượng.</li></ul>\r<ul><li>Nó nhớ trạng thái của nó, tức là nó đang ở đâu trong vòng lặp (xem đoạn code bên dưới).</li></ul>\r<ul><li>Phương thức <code><strong>iter</strong>()</code> khởi tạo một iterator.</li></ul>\r<ul><li>Nó có phương thứ <code><strong>next</strong>()</code> để trả về mục tiếp theo trong lần lặp và trỏ đến phần tử tiếp theo. Khi đến cuối đối tượng có thể lặp lại <code><strong>next</strong>()</code> trả về <code>StopIteration exception</code></li></ul>\r<ul><li>Nó có thể tự lặp lại.</li></ul>\r<ul><li>Iterator là một đối tượng mà chúng ta có thể lặp qua đối tượng như list, string,..</li></ul>\r\n\r\n``<code>py\r\nclass ArrayList:\r\n   def <strong>init</strong>(self, number<em>list):\r\n      self.numbers = number</em>list\r\n   def <strong>iter</strong>(self):\r\n      self.pos = 0\r\n      return self\r\n   def <strong>next</strong>(self):\r\n      if(self.pos &lt; len(self.numbers)):\r\n         self.pos += 1\r\n         return self.numbers[self.pos - 1]\r\n      else:\r\n         raise StopIteration\r\narray<em>obj = ArrayList([1, 2, 3])\r\nit = iter(array</em>obj)\r\nprint(next(it)) #output: 2\r\nprint(next(it)) #output: 3\r\nprint(next(it))\r\n#Throws Exception\r\n#Traceback (most recent call last):\r\n#...\r\n#StopIteration\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách xoá một file trong Python?",
              "answer": "<p>Ta có thể dùng lệnh <code>os.remove(file_name)</code>:\r\n\r\n``<code>py\r\nimport os\r\nos.remove(&quot;ChangedFile.csv&quot;)\r\nprint(&quot;File Removed!&quot;)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích hàm split() và join() trong Python?",
              "answer": "<p><ul><li>Bạn có thể dùng hàm split() để tách chuỗi dựa trên một dấu phân cách trong list của chuỗi.</li></ul>\r<ul><li>Bạn có thể dùng hàm join() để kết hợp một list của chuỗi dựa trên khoảng cách đựa cho từ chuỗi đơn.</li></ul>\r\n\r\n``<code>py\r\nstring = &quot;This is a string.&quot;\r\nstring<em>list = string.split(&#39; &#39;) #delimiter is ‘space’ character or ‘ ‘\r\nprint(string</em>list) #output: [&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;string.&#39;]\r\nprint(&#39; &#39;.join(string_list)) #output: This is a string.\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "*args và *kwargs là gì?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Chỉ mục âm là gì và cách sử dụng?",
              "answer": "<p><ul><li>Chỉ mục âm là chỉ mục tính từ phía cuối của list, tuple hoặc string.</li></ul>\r<ul><li>Arr[-1] nghĩa là phần tử cuối cùng của mảng Arr[].</li></ul>\r\n\r\n``<code>py\r\narr = [1, 2, 3, 4, 5, 6]\r\n#get the last element\r\nprint(arr[-1]) #output 6\r\n#get the second last element\r\nprint(arr[-2]) #output 5\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "web-services",
          "name": "Câu hỏi phỏng vấn dịch vụ web",
          "description": "",
          "questions": [
            {
              "question": "Giải thích các kiểu dịch vụ web khác nhau?",
              "answer": "<p>Có hai kiểu dịch vụ web cơ bản là :\r\n\r\n<img src=\"/interview-assets/Web_Service_type.png\" alt=\"\" />\r\n\r\n<strong>SOAP (Simple Object Access Protocol)</strong>: Nó còn được gọi là giao thức truyền tải thông điệp độc lập với mục đích chính là truyền thông báo, và dựa trên giao thức XML. \r\n\r\n<strong>RESTful (Representational State Transfer)</strong>: Nó được phát triển để khắc phục những thiếu sót của SOAP và làm cho các dịch vụ web hiệu quả hơn.</p>",
              "level": "fresher"
            },
            {
              "question": "Các tính năng quan trọng của dịch vụ Web?",
              "answer": "<p>Một số tính năng quan trọng của dịch vụ web bao gồm:\r<ul><li>Được sử dụng để tiêu chuẩn hóa hệ thống truyền tải thông điệp XML.</li></ul>\r<ul><li>Không ràng buộc với bất kỳ ngôn ngữ lập trình hoặc hệ điều hành nào.</li></ul>\r<ul><li>Có thể tìm thấy thông qua một cơ chế tìm kiếm đơn giản.</li></ul>\r<ul><li>Có sẵn trên internet hoặc các mạng riêng.</li></ul>\r<ul><li>Hỗ trợ kết nối mềm giữa các hệ thống.</li></ul>\r<ul><li>Có thể đồng bộ hoặc bất đồng bộ.</li></ul>\r<ul><li>Hỗ trợ trao đổi dữ liệu minh bạch để tạo điều kiện tích hợp.</li></ul>\r<ul><li>Hỗ trợ giao tiếp giữa các ứng dụng khác nhau bằng HTML, XML, WSDL, SOAP, v.v.</li></ul>\r<ul><li>Hỗ trợ RPC (Remote Procedure Calls).</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thành phần của dịch vụ Web?",
              "answer": "<p>Các thành phần khác nhau của dịch vụ web:\r<ul><li>SOAP (Simple Object Access Protocol) </li></ul>\r<ul><li>UDDI (Universal Description, Discovery, and Integration) </li></ul>\r<ul><li>WSDL (Web Services Description Language) </li></ul>\r<ul><li>RDF (Resource Description Framework) </li></ul>\r<ul><li>XML (Extensible Markup Language)</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Khác biệt giữa API và dịch vụ Web?",
              "answer": "<p><strong>API (Application Programming Interface):</strong> hành động như một interface giữa hai thiết bị để chúng có thể giao tiếp với nhau mà không cần người dùng can thiệp. Một số tính năng của chúng như linh động, dễ tích hợp với GUI, ngôn ngữ độc lập,... Các API không nhất thiết phải là dịch vụ Web\r\n\r\n<strong>Dịch vụ Web:</strong> tạo điều kiện tương tác giữa hai thiết bị qua mạng. Chúng được sử dụng rộng rãi để trao đổi dữ liệu giữa các hệ thống hoặc ứng dụng. Một số tính năng của nó bao gồm liên kết mềm, hỗ trợ trao đổi dữ liệu, khả năng tương tác, khả năng mở rộng, v.v. Mọi dịch vụ Web đều là API.\r\n\r\n| API | Dịch vụ Web |\r\n|-----|-------------|\r\n| Có thể online hoặc offline | Buộc phải có mạng |\r\n| Kiến trúc gọn nhẹ | Yêu cầu SOAP cho gửi và nhận dữ liệu mạng, do đó kiến trúc không nhẹ |\r\n| Có thể dùng bất kỳ kiểu thiết kế hay giao thức nào | Chỉ dùng SOAP, thỉnh thoảng dùng REST, RPC, XML |\r\n| Không yêu cầu mạng cho các thao tác | Cần mạng cho mọi thao tác |\r\n| Mã nguồn mở và dùng XML | Mã nguồn đóng và dùng JSON |</p>",
              "level": "fresher"
            },
            {
              "question": "Các công cụ kiểm thử dịch vụ web?",
              "answer": "<p>Có nhiều công cụ khác nhau cho kiểm tra dịch vụ web:\r\n\r\n<em> SoapUI \r\n</em> Poster \r\n<em> Postman \r\n</em> REST client \r<ul><li>JMeter</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "WSDL là gì?",
              "answer": "<p>WSDL (Web Services Description Language) được coi là định dạng tiêu chuẩn được sử dụng để mô tả tính khả dụng của các dịch vụ web và cách truy cập chúng. Nó dựa trên giao thức XML để trao đổi dữ liệu trong các môi trường phân tán và phi tập trung. Nó cũng mô tả các chi tiết kỹ thuật hoặc định vị giao diện người dùng cho dịch vụ web. Tài liệu WSDL chứa một số thông tin quan trọng như được cung cấp bên dưới:\r<ul><li>Tên phương thức và tham số</li></ul>\r<ul><li>Kiểu cổng</li></ul>\r<ul><li>Dịch vụ endpoint</li></ul>\r<ul><li>Thông tin header</li></ul>\r\n\r\n<img src=\"/interview-assets/wsdl.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "XML-RPC là gì?",
              "answer": "<p>XML-RPC được xem là giao thức đơn giản và căn bản dựa trên XML để trao đổi dữ liệu giữa các thiết bị khác nhau trên mạng. Nó sử dụng HTTP như một giao thức truyền tải để truyền thông tin dữ liệu giữa hai thiết bị một cách nhanh chóng và dễ dàng. XML-RPC có thể sử dụng các ngôn ngữ như C, C++, Java, Python,...\r\n\r\n<img src=\"/interview-assets/xml-rpc.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Tính năng của XML-RPC?",
              "answer": "<p><ul><li>Nền tảng độc lập</li></ul>\r<ul><li>Cho phép ứng dụng giao tiếp đa dạng.</li></ul>\r<ul><li>Được coi là cách dễ nhất và đơn giản nhất để bắt đầu với các dịch vụ web.</li></ul>\r<ul><li>Sử dụng XML để mã hóa các cuộc gọi của nó và HTTP làm giao thức truyền tải.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "UDDI là gì?",
              "answer": "<p>UDDI (Universal Description, Discovery, and Integration) là một dịch vụ thư mục được sử dụng để mô tả, phát hành và tìm kiếm các dịch vụ web. Nó dựa trên một tập hợp các tiêu chuẩn web bao gồm HTTP, XML, SOAP, WSDL, XML. Mục tiêu chính của nó là hợp lý hóa các giao dịch kỹ thuật số và thương mại điện tử giữa các hệ thống công ty.\r\n\r\n<img src=\"/interview-assets/UDDI.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các tính năng nổi bật của UDDI",
              "answer": "<p><em> Nền tảng độc lập\r\n</em> Sử dụng WSDL để mô tả interface cho các dịch vụ web\r\n<em> Có thể giao tiếp thông qua SOAP, Java RMI và giao thức CORBA\r\n</em> Phân định giữa interface và triển khai\r<ul><li>Trung lập về giao thức</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tên ngôn ngữ thường được sử dụng bởi UDDI?",
              "answer": "<p>Ngôn ngữ thường được UDDI sử dụng là WSDL (Web Service Description Language).</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về kiến trúc dịch vụ web?",
              "answer": "<p>Mọi framework đều yêu cầu một số kiểu kiến trúc để đảm bảo rằng toàn bộ framework hoạt động hoàn hảo như mong muốn, đối với các dịch vụ web cũng vậy. Kiến trúc dịch vụ web được sử dụng để hỗ trợ nhà phát triển với các bước và thủ tục cần thiết để hoàn thành việc tạo. Kiến trúc dịch vụ web bao gồm ba vai trò riêng biệt, tức là nhà cung cấp dịch vụ (provider), người yêu cầu dịch vụ (requestor) và sổ đăng ký dịch vụ (registry). Nó cũng bao gồm ba hoạt động khác nhau bao gồm:\r\n\r\n<strong>Publish (Publication of Service Descriptions):</strong> Một mô tả dịch vụ cần được phát hành để người yêu cầu dịch vụ có thể xác định vị trí và có quyền truy cập vào nó. Nó có thể được phát hành ở bất cứ đâu tùy thuộc vào yêu cầu của ứng dụng.\r\n\r\n<strong>Find (Finding of Services Descriptions):</strong> một mô tả dịch vụ được truy xuất trực tiếp bởi người yêu cầu dịch vụ. Người yêu cầu tham khảo ý kiến của broker để tìm một dịch vụ web đã được phát hành. \r\n\r\n<strong>Bind (Invoking of Service based on Service Description):</strong> mọi dịch vụ cần được gọi. Để xác định vị trí, liên hệ và gọi dịch vụ, người yêu cầu dịch vụ bắt đầu tương tác với dịch vụ trong thời gian chạy bằng cách sử dụng các chi tiết ràng buộc trong mô tả dịch vụ.\r\n\r\n<img src=\"/interview-assets/Web_Service_roles__operation____artifacts.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Web Service Provider là gì?",
              "answer": "<p>Nhà cung cấp dịch vụ (Web Service Provider) tạo các dịch vụ web và cung cấp quyền truy cập vào ứng dụng client cần nó. Mục đích chính của nó là triển khai dịch vụ và cung cấp dịch vụ này trên internet để các ứng dụng client có thể sử dụng bất cứ khi nào được yêu cầu. Nói dễ hiểu, nó là một nền tảng để tạo và lưu trữ các dịch vụ web.</p>",
              "level": "fresher"
            },
            {
              "question": "Web Service Requestor là gì?",
              "answer": "<p>Người yêu cầu dịch vụ (Web Service Requestor) là ứng dụng client yêu cầu sử dụng dịch vụ web. Mục đích chính của nó là sử dụng một dịch vụ web hiện có bằng cách mở một kết nối mạng và gửi một yêu cầu XML. Nói một cách dễ hiểu, họ là những người sử dụng dịch vụ web.</p>",
              "level": "fresher"
            },
            {
              "question": "Web Service Registry là gì?",
              "answer": "<p>Sổ đăng ký dịch vụ (Web Service Registry) về cơ bản giống như một 'danh bạ điện thoại' cho các dịch vụ web. Nó cho phép các ứng dụng client có thể xuất bản các dịch vụ mới hoặc có thể xác định vị trí các dịch vụ đã tồn tại. Hai tiêu chuẩn đăng ký được sử dụng rộng rãi thường được hỗ trợ bởi các máy chủ ứng dụng, là ebXML (Electronic Business sử dụng XML) và UDDI (Universal Description, Discovery, and Integration).</p>",
              "level": "fresher"
            },
            {
              "question": "Các lớp khác nhau của ngăn xếp giao thức dịch vụ web?",
              "answer": "<p>Việc triển khai các dịch vụ web nói chung phụ thuộc vào các công nghệ thường được tổ chức trong một ngăn xếp nhiều lớp. Kiểm tra ngăn xếp giao thức dịch vụ web được coi là tùy chọn thứ hai để xem kiến trúc dịch vụ web. Nói một cách dễ hiểu, nó là một tập hợp các giao thức được sử dụng để khám phá và thực thi các dịch vụ web. Hiện tại, ngăn xếp giao thức dịch vụ web có bốn lớp như được đưa ra dưới đây:\r\n\r\n<img src=\"/interview-assets/Web_Service_Protocol_Stack.png\" alt=\"\" />\r\n\r\n<strong>Service Transport:</strong> Nó thường có trách nhiệm vận chuyển các thông điệp giữa các ứng dụng. Về cơ bản, nó xác định các tiêu chuẩn công nghệ cho giao tiếp và cho phép các thông điệp hoặc thông tin di chuyển trên mạng mà không gặp bất kỳ khó khăn nào. Nó sử dụng các giao thức HTTP, SMTP, FTP và DEEP để truyền thông tin.\r\n\r\n<strong>XML Messaging:</strong> Nó có trách nhiệm mã hoá thông điệp thành định dạng XML để có thể hiểu thông điệp ở cả hai phía. Lớp này thường bao gồm XML-RPC và SOAP.\r\n\r\n<strong>Service Description:</strong> Nó có trách nhiệm mô tả interface công khai với dịch vụ web cụ thể. WSDL thường được dùng cho xử lý mô tả dịch vụ.\r\n\r\n<strong>Service Discovery:</strong> Nói chung, nó có trách nhiệm tập trung dịch vụ vào một sổ đăng ký chung và cung cấp chức năng dễ dàng để xuất bản hoặc tìm kiếm các dịch vụ web. UDDI thường được sử dụng ở lớp này.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích thuật ngữ Synchronicity?",
              "answer": "<p>Tính đồng bộ (Synchronicity) thường đề cập đến sự ràng buộc của client với việc thực thi chức năng và nó có thể được thực hiện theo hai cách, tức là đồng bộ và bất đồng bộ. Trong lời gọi đồng bộ, client chặn và đợi cho đến khi dịch vụ hoàn thành hoạt động trước khi tiếp tục công việc của nó. Trong lệnh gọi bất đồng bộ, client được phép gọi một dịch vụ và thực thi các chức năng khác.\r\n\r\n## Câu hỏi phỏng vấn cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Dịch vụ web RESTful là gì?",
              "answer": "<p>REST (Representational State Transfer) là một kiến trúc stateless kiểu client-server sử dụng cho phát triển ứng dụng có thể truy cập trên toàn web. Nó là một kiểu dịch vụ web với mục tiêu chính là làm cho các dịch vụ web trở nên hiệu quả hơn. Nó có thể được định nghĩa là dịch vụ web sử dụng các phương thức HTTP để triển khai kiến trúc REST. Không giống như SOAP dựa trên giao thức, các dịch vụ RESTful dựa trên kiến trúc. Nó không chứa bất kỳ contract hoặc file WSDL nào.\r\n\r\n<img src=\"/interview-assets/Restful_Web_Service.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của dịch vụ Web RESTful?",
              "answer": "<p><ul><li>Nền tảng độc lập.</li></ul>\r<ul><li>Dễ triển khai và kiểm thử.</li></ul>\r<ul><li>Hỗ trợ các định dạng khác nhau như JSON, XML, HTML,...</li></ul>\r<ul><li>Có thể viết bằng nhiều ngôn ngữ và thực thi trên mọi nền tảng.</li></ul>\r<ul><li>Nhẹ, dễ quản lý, mở rộng và tái sử dụng.</li></ul>\r<ul><li>Nhanh và hiệu suất tốt.</li></ul>\r<ul><li>Ít tốn băng thông và tài nguyên.</li></ul>\r<ul><li>Nhiều framework khả dụng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giao thức dùng cho dịch vụ Web RESTful?",
              "answer": "<p>Giao thức sử dụng cho dịch vụ web RESTful là HTTP.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích stateless trong dịch vụ web RESTful?",
              "answer": "<p>Stateless về cơ bản là một điều kiện hoặc hạn chế trong đó các dịch vụ web RESTful không được phép giữ trạng thái client trên server theo kiến trúc REST. Client có trách nhiệm chuyển ngữ cảnh của họ đến server. Để xử lý yêu cầu của client, server sau đó sẽ lưu trữ thêm ngữ cảnh này.\r\n\r\n<strong>Ưu điểm</strong>\r\n<em> Không cần phải duy trì các tương tác trước đó với client.\r\n</em> Xử lý độc lập từng yêu cầu phương pháp.\r<ul><li>Ít phức tạp hơn và thiết kế ứng dụng được đơn giản hóa.</li></ul>\r\n\r\n<strong>Ví dụ</strong>\r\n\r\nTa có dữ liệu mẫu trong users.json như sau:\r\n\r\n``<code>js\r\n{\r\n    &quot;user1&quot; : {\r\n        &quot;name&quot; : &quot;gourav&quot;,\r\n        &quot;password&quot; : &quot;password1&quot;,\r\n        &quot;profession&quot; : &quot;officer&quot;,\r\n        &quot;id&quot;: 1\r\n    },\r\n    \r\n    &quot;user2&quot; : {\r\n        &quot;name&quot; : &quot;nikhil&quot;,\r\n        &quot;password&quot; : &quot;password2&quot;,\r\n        &quot;profession&quot; : &quot;teacher&quot;,\r\n        &quot;id&quot;: 2\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTa có triển khai với node/express như sau:\r\n\r\n</code>`<code>js\r\n// Requiring module\r\nvar express = require(&#39;express&#39;);\r\nvar app = express();\r\nvar fs = require(&quot;fs&quot;);\r\n\r\n// Sample GET API\r\napp.get(&#39;/listUsers&#39;, function (req, res) {\r\n    fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &#39;utf8&#39;, function (err, data) {\r\n        console.log( data );\r\n        res.end( data );\r\n    });\r\n})\r\n\r\n// Server setup\r\nvar server = app.listen(8081, function () {\r\n    var host = server.address().address\r\n    var port = server.address().port\r\n    console.log(&quot;Example app listening at http://%s:%s&quot;, host, port)\r\n})\r\n</code>`<code>\r\n\r\nBây giờ mở trình duyệt với đường link </code>http://127.0.0.1:8081/listUsers<code> ta có phản hồi như sau:\r\n\r\n</code>`<code>js\r\n{\r\n    &quot;user1&quot; : {\r\n        &quot;name&quot; : &quot;gourav&quot;,\r\n        &quot;password&quot; : &quot;password1&quot;,\r\n        &quot;profession&quot; : &quot;officer&quot;,\r\n        &quot;id&quot;: 1\r\n    },\r\n    \r\n    &quot;user2&quot; : {\r\n        &quot;name&quot; : &quot;nikhil&quot;,\r\n        &quot;password&quot; : &quot;password2&quot;,\r\n        &quot;profession&quot; : &quot;teacher&quot;,\r\n        &quot;id&quot;: 2\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các phương thức HTTP cho dịch vụ web RESTful?",
              "answer": "<p>Một vài phương thức HTTP như:\r<ul><li>GET: Dùng cho truy cập hay đọc tài nguyên. </li></ul>\r<ul><li>POST: Dùng cho tạo tài nguyên mới. </li></ul>\r<ul><li>PUT: Dùng cho cập nhật tài nguyên đã có. </li></ul>\r<ul><li>DELETE: Dùng cho xoá tài nguyên. </li></ul>\r<ul><li>PATCH: Dùng cho sửa đổi một phần của tài nguyên.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các Status code trong REST API?",
              "answer": "<p>Các status code phổ biển trong phản hồi HTTP:\r\n\r\n<em> 200 OK\r\n</em> 201 Created\r\n<em> 202 Accepted\r\n</em> 302 Found\r\n<em> 400 Bad Request\r\n</em> 401 Unauthorized \r\n<em> 404 Not Found\r\n</em> 405 Method Not Allowed\r\n<em> 409 Conflict\r\n</em> 500 Internal Server Error</p>",
              "level": "fresher"
            },
            {
              "question": "SOAP là gì?",
              "answer": "<p>SOAP (Simple Object Access Protocol) là một giao thức dựa trên XML được dùng cho truy cập dịch vụ web. Nó chỉ đơn giản được sử dụng để trao đổi dữ liệu hoặc thông tin giữa hai thiết bị hoặc máy tính bằng cách sử dụng request và response dựa trên định dạng XML qua các giao thức truyền tải như HTTP, SMTP, v.v.\r\n\r\n<img src=\"/interview-assets/soap_advantages.png\" alt=\"\" />\r\n\r\nƯu điểm:\r<ul><li>Ngôn ngữ và Thông tin độc lập.</li></ul>\r<ul><li>Có thể được viết trên các ngôn ngữ lập trình hoặc hệ điều hành khác nhau.</li></ul>\r<ul><li>Cung cấp vận chuyển dữ liệu cho các dịch vụ web.</li></ul>\r<ul><li>Có thể mở rộng HTTP cho truyền tin XML.</li></ul>\r<ul><li>Xác định và sử dụng bảo mật WS của riêng nó.</li></ul>\r<ul><li>Dễ dàng debug và loại bỏ các vấn đề về tường lửa.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các phần tử của SOAP message?",
              "answer": "<p>SOAP message là một tài liệu XML bao gồm 3 phần:\r\n\r\n<strong>SOAP Envelope:</strong> là phần tử bắt buộc để xác định tài liệu XML như là một SOAP mesage. Nó xác định phần bắt đầu và kết thúc của thông điệp.\r\n\r\n<strong>SOAP Header:</strong> là một phần tử tùy chọn có chứa thông tin header.\r\n\r\n<strong>SOAP Body:</strong>  là một phần tử bắt buộc chứa thông tin cuộc gọi và phản hồi. Nó bao gồm dữ liệu XML chứa thông điệp đang được gửi.\r\n\r\n<img src=\"/interview-assets/SOAP_Elements.png\" alt=\"\" />\r\n\r\nVí dụ về cấu trúc chung của XML request và response:\r\n\r\n<strong>XML Request</strong>\r\n\r\n``<code>xml\r\n&lt;Envelope xmlns=?http://schemas.xmlsoap.org/soap/envelop/?&gt;   \r\n&lt;Body&gt;   \r\n    &lt;getCourseDetailRequest xmlns=?http://udemy.com/course?&gt;   \r\n       &lt;id&gt;course1&lt;/id&gt;   \r\n    &lt;getCourseDetailRequest&gt;   \r\n&lt;/Body&gt;   \r\n&lt;/Envelope&gt;\r\n</code>`<code>\r\n\r\n<strong>XML Response</strong>\r\n\r\n</code>`<code>xml\r\n&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=?http://schemas.xmlsoap.org/soap/envelope/?&gt;   \r\n    &lt;SOAP-ENV:Header /&gt;          &lt;!?empty header--&gt;   \r\n    &lt;SOAP-ENV:Body&gt;             &lt;!?body begin--&gt;   \r\n        &lt;ns2:getCourseDetailsResponse xmlns:ns2=?http://in28mi&gt; &lt;!--content of the response--&gt;   \r\n            &lt;ns2:course&gt;   \r\n                &lt;ns2:id&gt;Course1&lt;/ns2:id&gt;   \r\n                &lt;ns2:name&gt;Spring&lt;ns2:name&gt;   \r\n                &lt;ns2:description&gt;10 Steps&lt;/ns1:description&gt;   \r\n            &lt;/ns2:course&gt;   \r\n        &lt;/ns2:getCourseDetailResponse&gt;   \r\n    &lt;/SOAP-ENV:Body&gt;    &lt;!?body end--&gt;   \r\n&lt;/SOAP-ENV:Envelope&gt; \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "SOA là gì?",
              "answer": "<p>SOA (Service Oriented Architecture) về cơ bản là một cách tiếp cận kiến trúc được thiết kế đặc biệt để hỗ trợ định hướng dịch vụ. Nó cho phép các dịch vụ giao tiếp hoặc tương tác trên các nền tảng và ngôn ngữ khác nhau để tạo thành các ứng dụng. Các ứng dụng trong SOA được phát triển trên cơ sở các dịch vụ. Nó có thể được thực hiện dễ dàng bằng cách sử dụng các giao thức khác nhau như HTTP, JMS, HTTPS, RPC, RMI, v.v.</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của SOA?",
              "answer": "<p><ul><li>Dễ dàng tích hợp.</li></ul>\r<ul><li>Các dịch vụ độc lập với nền tảng.</li></ul>\r<ul><li>Quản lý độ phức tạp để việc tích hợp trở nên dễ quản lý hơn.</li></ul>\r<ul><li>Các dịch vụ dễ kiểm tra và debug hơn.</li></ul>\r<ul><li>Dễ dàng có sẵn cho bất kỳ người yêu cầu nào.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các vấn đề bảo mật trong dịch vụ Web?",
              "answer": "<p>3 yếu tố chính cho bảo mật trong dịch vụ web là:\r<ul><li>Bảo mật</li></ul>\r<ul><li>Xác thực</li></ul>\r<ul><li>Bảo mật mạng</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thành phần cần được công khai khi triển khai dịch vụ web?",
              "answer": "<p><ul><li>Thư mục ứng dụng web</li></ul>\r<ul><li>File Webservice.asmx </li></ul>\r<ul><li>File Webservice.Disco </li></ul>\r<ul><li>File Web.Config </li></ul>\r<ul><li>Thư mục Bin</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao dịch vụ web lại quan trọng?",
              "answer": "<p>Các dịch vụ web rất quan trọng vì chúng cung cấp các giao thức web chuẩn hóa, tức là HTTP hoặc HTTPS để tương tác, giao tiếp và trao đổi thông tin ở định dạng XML qua internet. Một số lợi thế của nó bao gồm:\r<ul><li>Cho phép các thiết bị nói chuyện với nhau và chia sẻ dữ liệu hoặc dịch vụ giữa chúng.</li></ul>\r<ul><li>Làm cho nền tảng ứng dụng và công nghệ độc lập.</li></ul>\r<ul><li>Sử dụng giao thức tiêu chuẩn được chuẩn hóa để giao tiếp.</li></ul>\r<ul><li>Người dùng SOAP qua giao thức HTTP có thể sử dụng internet chi phí thấp của họ để triển khai các dịch vụ web.</li></ul>\r<ul><li>Cho phép logic nghiệp vụ của các hệ thống khác nhau khả dụng trên web.</li></ul>\r<ul><li>Có thể được sử dụng cùng lúc bởi nhiều ứng dụng client.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "DISCO là gì?",
              "answer": "<p>DISCO (Discovery) là một công nghệ của Microsoft đang được sử dụng để khám phá các dịch vụ web. Đây là quá trình định vị và thẩm vấn các mô tả dịch vụ web, là bước sơ bộ để có quyền truy cập vào các dịch vụ web qua Internet. Tổ chức cung cấp các dịch vụ web thường cung cấp file DISCO trên máy chủ của mình bao gồm các liên kết của tất cả các dịch vụ web có sẵn để nó có thể được sử dụng trong mạng cục bộ.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về BEEP?",
              "answer": "<p>BEEP (Blocks Extensible Exchange Protocol) về cơ bản là một framework IETF (Internet Engineering Task Force) thường được sử dụng để phát triển các giao thức ứng dụng mạng. Người ta có thể tạo các giao thức mới này cho các ứng dụng khác nhau như nhắn tin tức thời, quản lý mạng, truyền file, cung cấp nội dung, v.v. Nó được phân lớp trực tiếp qua TCP. BEEP có các tính năng tích hợp khác nhau như xác thực, bảo mật, giao thức bắt tay ban đầu, xử lý lỗi, v.v.</p>",
              "level": "fresher"
            },
            {
              "question": "URL trong dịch vụ web REST?",
              "answer": "<p>Trong dịch vụ web dựa trên REST, URL (Uniform Resource Locator) thường được sử dụng để định vị tài nguyên trên server đang lưu trữ dịch vụ web. Mỗi tài nguyên trong dịch vụ sẽ có ít nhất một UR: được sử dụng để xác định nó. Các client của dịch vụ web thường sử dụng URL để truy cập tài nguyên. Định dạng của nó được đưa ra dưới đây:\r\n\r\n``<code>\r\n&lt;protocol&gt;://&lt;service-name&gt;/&lt;ResourceType&gt;/&lt;ResourceID&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Bảo mật trong dịch vụ web?",
              "answer": "<p>Bảo mật được coi là một tính năng rất quan trọng trong bất kỳ ứng dụng web nào. Nó là điều cần thiết trong các dịch vụ web để chúng có thể làm cho thông tin và giao dịch bí mật hoặc nhạy cảm trở nên đáng tin cậy hơn. Trong các dịch vụ web, bảo mật đạt được thông qua SSL (Service Socket Layer) giúp phát triển nền tảng EST (Entrust Secure Transaction).</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt của dịch vụ web với CORBA và DCOM?",
              "answer": "<p>| Dịch vụ web | CORBA & DCOM |\r\n|-|-|\r\n| Các dịch vụ web về cơ bản truyền hoặc nhận thông điệp từ các ứng dụng bằng giao thức HTTP. Để encode dữ liệu, chúng sử dụng XML | Về cơ bản, chúng truyền hoặc nhận thông điệp từ các ứng dụng bằng các giao thức không chuẩn như RPC, IIOP (Inter Internet Object Protocol),... |\r\n| WSDL dùng cho xác định dịch vụ web | CORBA Interface Description Language dùng cho xác định thành phần CORBA và Mircosoft Interface Definition Language dùng cho xác định thành phần DCOM |\r\n| UDDI dùng cho khám phá dịch vụ web | CORBA registry dùng cho khám phá thành phần CORBA và DCOM registry dùng cho xác định thành phần DCOM |\r\n| Thân thiện với tường lửa | CORBA dùng giao thức IIOP không thân thiện lắm |</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "websocket",
          "name": "Câu hỏi phỏng vấn WebSocket",
          "description": "",
          "questions": [
            {
              "question": "WebSockets là gì?",
              "answer": "<p>WebSocket là công nghệ cho phép client thiết lập kết nối hai chiều <em>full-duplex</em> để giao tiếp với server.\r\n\r\nVới WebSocket, cả client và server có thể kích hoạt giao tiếp với phía còn lại, chúng có thể gửi tin nhắn cùng lúc. Ngược lại trong giao tiếp HTTP truyền thống chỉ có thể đi một chiều là client đến server.</p>",
              "level": "middle"
            },
            {
              "question": "Giải thích Server-Sent Events/EventSource?",
              "answer": "<p>SSE (Server-Sent Events) là một kỹ thuật cho gửi thông điệp, nó cho phép server đẩy cập nhật lên client bằng cách tận dụng JavaScript <code>EventSource</code>.\r\n\r\nEventSource mở một một kết nối liên tục, một chiều với server qua HTTP sử dụng header đặc biệt <code>text/event-stream</code> và lắng nghe thông điệp, được code của bạn xử lý giống như sự kiện JavaScript.\r\n\r\nServer-Sent Events (SSE) phù hợp cho các ứng dụng mà bạn không cần gửi cho server bất kỳ dữ liệu nào. Ví dụ: trang tin tức Twitter hoặc sàn chứng khoán cổ phiếu. Một điểm ưu việc khác là SSE hoạt động qua HTTP và API tương đối dễ sử dụng.\r\n\r\nTuy nhiên:\r<ul><li>SSE không hỗ trợ các trình duyệt cũ.</li></ul>\r<ul><li>Phần lớn trình duyệt giới hạn số lượng kết nối SSE mà bạn tạo cùng lúc.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Tương tác với độ trễ thấp là gì?",
              "answer": "<p><strong>Độ trễ thấp (low latency)</strong> có nghĩa là có rất ít độ trễ giữa thời gian bạn yêu cầu điều gì đó và thời gian bạn nhận được phản hồi. Như nó áp dụng cho WebSockets, nó có nghĩa là dữ liệu có thể được gửi nhanh hơn (đặc biệt là qua các liên kết chậm) bởi vì kết nối đã được thiết lập nên không cần thêm gói tin để thiết lập kết nối TCP.</p>",
              "level": "middle"
            },
            {
              "question": "Short Polling là gì?",
              "answer": "<p>Short Polling hoặc Ajax Polling là một kỹ thuật khi bạn yêu cầu client ping liên tục đến server, chẳng hạn như sau mỗi 500ms(hoặc trên một số độ trễ nhất định). Bằng cách đó, bạn nhận được dữ liệu mới sau mỗi 500ms:\r\n1. Client yêu cầu trang web từ một server bằng HTTP thông thường.\r\n2. Client nhận được trang web và thực thi JavaScript trên trang yêu cầu file từ server theo khoảng thời gian đều đặn (vd: 0.5s)\r\n3. Server tính toán từng phản hồi và gửi lại, giống như lưu lượng HTTP thông thường.\r\n\r\n<img src=\"/interview-assets/short-polling.png\" alt=\"\" />\r\n\r\nCó một số nhược điểm rõ ràng của điều này:\r<ul><li>Có độ trễ 500ms</li></ul>\r<ul><li>Nó tiêu thụ tài nguyên server với một loạt các yêu cầu và hầu hết các yêu cầu sẽ trả về trống nếu dữ liệu không được cập nhật thường xuyên.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Tại sao dùng WebSocket thay vì HTTP?",
              "answer": "<p>WebSocket là một kết nối liên tục giữa client và server. Kết nối liên tục đó cho phép những điều sau:\r<ul><li>Dữ liệu có thể được gửi từ server đến client bất kỳ lúc nào mà không cần client yêu cầu. Điều này thường được gọi là push server và rất có giá trị đối với các ứng dụng mà khách hàng cần biết khá nhanh khi có điều gì đó xảy ra trên server (chẳng hạn như một tin nhắn trò chuyện mới đã được nhận hoặc giá mới đã được cập nhật). Một client không thể push được dữ liệu qua HTTP. Client sẽ phải thường xuyên thăm dò ý kiến bằng cách đưa ra yêu cầu HTTP vài giây một lần để có được dữ liệu mới kịp thời. Client polling không hiệu quả.</li></ul>\r<ul><li>Dữ liệu có thể được gửi theo cả hai cách rất hiệu quả. Bởi vì kết nối đã được thiết lập và khung dữ liệu webSocket được tổ chức rất hiệu quả, người ta có thể gửi dữ liệu hiệu quả hơn rất nhiều thông qua một yêu cầu HTTP nhất thiết phải chứa header, cookie, v.v.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Giải thích Long Polling là gì?",
              "answer": "<p>Phương thức <strong>Long Polling</strong> được server dùng để nhận yêu cầu, nhưng không phản hồi cho đến khi nó nhận dữ liệu mới từ yêu cầu khác.\r\n\r\nLong polling hiệu quả hơn ping server liên tục vì nó giúp tiết kiệm những rắc rối khi parse header của yêu cầu, truy vấn dữ liệu mới và gửi phần hồi (thường là trống).\r\n\r\nTuy nhiên:\r<ul><li>server phải theo dõi nhiều yêu cầu và thứ tự của chúng</li></ul>\r<ul><li>yêu cầu có thể hết thời gian chờ và yêu cầu mới cần đưa ra định kỳ</li></ul>\r\n\r\nCác bước:\r\n\r\n<img src=\"/interview-assets/long-polling.png\" alt=\"\" />\r\n\r\n1. Client yêu cầu trang web từ server sử dụng HTTP thông thường.\r\n2. Client nhận trang web được yêu cầu và thực thi JavaScript trên trang yêu cầu file từ server.\r\n3. Server không phản hồi ngay lập tức với thông tin được yêu cầu mà đợi cho đến khi có thông tin mới.\r\n4. Khi có thông tin mới, server sẽ phản hồi với thông tin mới.\r\n5. Client nhận được thông tin mới và ngay lập tức gửi một yêu cầu khác đến server, bắt đầu lại quy trình.</p>",
              "level": "middle"
            },
            {
              "question": "Lợi ích của SSE so với WebSocket?",
              "answer": "<p><ul><li>Được truyền qua HTTP đơn giản thay vì một giao thức tùy chỉnh</li></ul>\r<ul><li>Có thể được lấp đầy bằng javascript để \"backport\" SSE cho các trình duyệt chưa hỗ trợ nó.</li></ul>\r<ul><li>Tích hợp hỗ trợ cho tái kết nối và id của sự kiện</li></ul>\r<ul><li>Giao thức đơn giản hơn</li></ul>\r<ul><li>Không có vấn đề gì với tường lửa của công ty thực hiện kiểm tra packet.</li></ul>\r\n\r\n#</p>",
              "level": "middle"
            },
            {
              "question": "Giải thích các kỹ thuật giao tiếp khác nhau trên web mà bạn biết?",
              "answer": "<p><ul><li><strong>AJAX</strong> - <code>request</code> → <code>response</code>. Tạo một kết nối đến server, gửi yêu cầu gồm header và dữ liệu tuỳ chọn, nhận phản hồi từ server và đóng kết nối. Được hỗ trợ trên mọi loại trình duyệt.</li></ul>\r<ul><li><strong>Long poll</strong> - <code>request</code> → <code>wait</code> → <code>response</code>. Tạo một kết nối đến server giống như AJAX, nhưng duy trì kết nối mở keep-alive trong một khoảng thời gian. Trong suốt kết nối, client có thể truy xuất dữ liệu từ server. Client phải kết nối lại đỊnh kỳ sau khi kết nối bị đóng, do hết thời gian chờ hoặc hết dữ liệu. Ở phía server, nó vẫn được xem như một yêu cầu HTTP, giống như AJAX, ngoại trừ câu trả lời cho yêu cầu xảy ra ngay bây giờ hoặc một lúc nào đó trong tương lại, được xác định bởi logic ứng dụng.</li></ul>\r<ul><li><strong>WebSockets</strong> - <code>client</code> ↔ <code>server</code>. Tạo kết nối TCP tới server và giữ nó mở nếu cần. Server hoặc client có thể dễ dàng đóng kết nối. Client trải qua quá trình bắt tay 3 bước HTTP. Nếu nó thành công, thì server và client có thể trao đổi dữ liệu theo cả hai hướng bất kỳ lúc nào. Sẽ hiệu quả nếu ứng dụng yêu cầu trao đổi dữ liệu thường xuyên theo cả hai cách. WebSockets có khung dữ liệu bao gồm che dấu cho mỗi tin nhắn được gửi từ client đến server, vì vậy dữ liệu được mã hóa đơn giản.</li></ul>\r<ul><li><strong>WebRTC</strong> - <code>peer</code> ↔ <code>peer</code>. Transport thiết lập giao tiếp giữa client và các phương tiện truyền tải, vì vậy nó có thể sử dụng UDP, TCP hoặc các lớp trừu tượng khác. Nó thường được dùng để truyền dữ liệu khối lượng lớn chẳng hạn như video/audio, trong đó độ tin cậy là thứ yêu và một vài frame có thể hy sinh đổi lại thời gian phản hồi và truyền dữ liệu. Cả hai phía (peer) có thể đẩy dữ liệu một cách độc lập. Mặc dù nó có thể được sử dụng hoàn toàn độc lập với bất kỳ server tập trung nào, nó vẫn yêu cầu một số cách trao đổi dữ liệu endPoints, trong đó trong hầu hết các trường hợp, các nhà phát triển vẫn sử dụng server tập trung để \"liên kết\" các server. Điều này chỉ được yêu cầu để trao đổi dữ liệu cần thiết để thiết lập kết nối, sau đó không cần server tập trung.</li></ul>\r<ul><li><strong>Server-Sent Events</strong> - <code>client</code> ← <code>server</code>. Client thiết lập kết nối liên tục và lâu dài với server. Chỉ server mới có thể gửi dữ liệu đến client. Nếu client muốn gửi dữ liệu đến server, nó sẽ yêu cầu sử dụng công nghệ/giao thức khác để làm điều đó. Giao thức này tương thích với HTTP và dễ triển khai trong hầu hết các nền tảng phía server. Đây là một giao thức thích hợp được sử dụng thay vì Long Polling.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa SSE và WebSocket?",
              "answer": "<p>Websockets và SSE (Server Sent Events) đều có khả năng đẩy dữ liệu lên trình duyệt, tuy nhiên chúng không phải là công nghệ cạnh tranh.\r<ul><li>Kết nối Websockets vừa có thể gửi dữ liệu đến trình duyệt vừa nhận dữ liệu từ trình duyệt. Một ví dụ điển hình về ứng dụng có thể sử dụng websockets là ứng dụng chat.</li></ul>\r<ul><li>Kết nối SSE chỉ có thể đẩy dữ liệu đến trình duyệt. Báo giá cổ phiếu trực tuyến hoặc cập nhật newsfeed hoặc nguồn cấp dữ liệu là những ví dụ điển hình về một ứng dụng có thể sử dụng SSE.</li></ul>\r\n\r\nViệc sử dụng WebSockets có thể là quá mức cần thiết đối với một số loại ứng dụng và backend có thể dễ dàng triển khai hơn với một giao thức như SSE. Hơn nữa, SSE có thể được thêm vào các trình duyệt cũ hơn không hỗ trợ nó nguyên bản chỉ sử dụng JavaScript.</p>",
              "level": "middle"
            },
            {
              "question": "Giải thích về giao thức WebSocket?",
              "answer": "<p>WebSocket là giao thức khác cho gửi và nhận thông điệp như HTTP.\r\n\r\nCả HTTP và WebSocket gửi thông điệp qua một kết nối TCP (Transmission Control Protocol), nó là một chuẩn transport-layer để đảm bảo tằng streams của byte, được gửi qua packet và phân phối đến những máy khác. Thế nên, HTTP và WebSocket sử dụng cùng cơ chế phân phối ở level packet/byte, nhưng giao thức cho cấu trúc thông điệp lại khác nhau.\r\n\r\nKhi WebSocket thiết lập kết nối đến server, client sẽ gửi một yêu cầu \"bắt tay\" HTTP với header nâng cấp, chỉ ra rằng client muốn thiết lập một kết nối webSocket. Yêu cầu được gửi có URI là <code>ws:</code> hoặc <code>wss:</code> (như http và https). Nếu server có khả năng thiết lập một kết nối WebSocket và kết nối được chấp nhận (vd, nếu yêu cầu đến cùng với xác thực) server sẽ phản hồi \"bắt tay\" thành công, được biểu thị bằng code <strong>101 Switching Protocols</strong>.\r\n\r\nSau khi kết nối được nâng cấp, giao thức chuyển từ HTTP sang WebSocket, và các packet vẫn được gửi qua TCP, nhưng bây giờ giao tiếp sẽ chuyển qua định dạng thông điệp của WebSocket. Vì TCP là giao thức bên dưới việc truyền tải packet dữ liệu, là một giao thức full-duplex, cả client và server có thể gửi dữ liệu cùng lúc. Thông điệp có thể bị phân mảnh, vì vậy có thể gửi một thông điệp lớn mà không cần khai báo trước kích thước. Trong trường hợp đó, WebSockets sẽ chia nó thành các frame. Mỗi frame chứa một header nhỏ cho biết độ dài và loại payload và liệu đây có phải là frame cuối cùng hay không.</p>",
              "level": "middle"
            },
            {
              "question": "WebSocket Frame là gì?",
              "answer": "<p>WebSocket không phải giao thức dựa trên stream như TCP, mà nó dựa trên thông điệp. Giao thức websocket giao tiếp với các <strong>frame</strong>. Frame bao gồm header và dữ liệu ứng dụng. Dữ liệu ứng dụng là bất cứ thứ gì nằm trong \"body\".\r\n\r\nPhần lớn giao thức websocket có 3 frame điều kiến và 3 frame không điều kiến:\r<ul><li>Điều khiển (control):</li></ul>\r<ul><li>'close' - nói rằng chúng tôi muốn đóng hoặc đang phản hồi về việc đóng</li></ul>\r<ul><li>'ping' - pings!</li></ul>\r<ul><li>'pong' - pongs!</li></ul>\r<ul><li>Không điều kiển (no-control):</li></ul>\r<ul><li>'text' - biểu thị chúng tôi đang gửi các byte được mã hóa \"UTF-8\"</li></ul>\r<ul><li>'binary' - biểu thị chúng tôi đang gửi các byte raw</li></ul>\r<ul><li>'continue' - biểu thị thông báo này là một đoạn tiếp nối của thông báo trước đó.</li></ul>\r\n\r\n``<code>shell\r\n0                   1                   2                   3\r\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\r\n+-+-+-+-+-------+-+-------------+-------------------------------+\r\n|F|R|R|R| opcode|M| Payload len |    Extended payload length    |\r\n|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\r\n|N|V|V|V|       |S|             |   (if payload len==126/127)   |\r\n| |1|2|3|       |K|             |                               |\r\n+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\r\n|     Extended payload length continued, if payload len == 127  |\r<ul><li>- - - - - - - - - - - - - - - +-------------------------------+</li></ul>\r\n|                               |Masking-key, if MASK set to 1  |\r\n+-------------------------------+-------------------------------+\r\n| Masking-key (continued)       |          Payload Data         |\r\n+-------------------------------- - - - - - - - - - - - - - - - +\r\n:                     Payload Data continued ...                :\r<ul><li>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</li></ul>\r\n|                     Payload Data continued ...                |\r\n+---------------------------------------------------------------+\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Khi nào WebRTC tốt hơn WebSocket?",
              "answer": "<p>Khi bạn xây dựng một ứng dụng chat cho phép video, audio và văn bản. Bạn sẽ chọn WebRTC hay WebSocket.\r<ul><li><strong>WebRTC</strong> được thiết kế để giao tiếp video/audio hiệu suất cao, chất lượng cao  và dữ liệu tùy ý. Nói cách khác, đối với các ứng dụng chính xác như những gì bạn mô tả.</li></ul>\r<ul><li>WebRTC chủ yếu là UDP. Vì vậy, lý do chính của việc sử dụng WebRTC thay vì Websocket là độ trễ. Với WebRTC, bạn có thể đạt được độ trễ thấp và phát lại mượt mà là yếu tố quan trọng đối với truyền thông VoIP.</li></ul>\r<ul><li>Với WebRTC, dữ liệu được mã hóa end-to-end và không chuyển qua server (ngoại trừ đôi khi server TURN là cần thiết, nhưng chúng không có quyền truy cập vào phần nội dung của thông điệp mà chúng chuyển tiếp).</li></ul>\r<ul><li>Các ứng dụng WebRTC cần một dịch vụ mà qua đó chúng có thể trao đổi metadata mạng và phương tiện, một quá trình được gọi là báo hiệu.</li></ul>\r<ul><li>Mặt khác, <strong>WebSocket</strong> được thiết kế để giao tiếp hai chiều giữa client và server. Có thể phát trực tuyến âm thanh và video qua WebSocket, nhưng công nghệ và API vốn dĩ không được thiết kế để phát trực tuyến hiệu quả, mạnh mẽ theo cách của WebRTC.</li></ul>\r<ul><li>Websockets sử dụng giao thức TCP. Với phát trực tuyến websocket, bạn sẽ có độ trễ cao hoặc phát lại bị giật với độ trễ thấp.</li></ul>\r<ul><li>Với Websockets, dữ liệu phải đi qua một server web trung tâm, server này thường thấy tất cả lưu lượng truy cập và có thể truy cập nó.</li></ul></p>",
              "level": "middle"
            }
          ]
        }
      ]
    },
    {
      "id": "database",
      "name": "Database",
      "icon": "database",
      "color": "#ff9800",
      "subcategories": [
        {
          "id": "mongodb",
          "name": "Câu hỏi phỏng vấn MongoDB",
          "description": "",
          "questions": [
            {
              "question": "Lợi ích của MongoDB?",
              "answer": "<p><em> Hiệu suất cao\r\n</em> Tính sẵn sàng cao – Nhân rộng\r\n<em> Khả năng mở rộng cao – Sharding\r\n</em> Năng động – Không có lược đồ cứng nhắc.\r\n<em> Linh hoạt – thêm / xóa trường có ít hoặc không ảnh hưởng đến ứng dụng\r\n</em> Dữ liệu không đồng nhất\r\n<em> Không joins\r\n</em> Phân phối được\r\n<em> Biểu diễn dữ liệu trong JSON hoặc BSON\r\n</em> Hỗ trợ không gian địa lý (Geospatial)\r<ul><li>Tích hợp dễ dàng với BigData Hadoop</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Document trong MongoDB là gì?",
              "answer": "<p>Một document trong MongoDB là một tập hợp key/value. Nó được biểu diễn bằng map, hash, hoặc dictionary. Trong JavaScript, document được biểu diễn dưới dạng các đối tượng:\r\n\r\n``<code>js\r\n{&quot;greeting&quot;: &quot;Hello world!&quot;}\r\n</code>`<code>\r\n\r\nCác document phức tạp sẽ chứa nhiều cặp key/value:\r\n\r\n</code>`<code>js\r\n{\r\n    &quot;welcome&quot;: &quot;Hello world!&quot;, \r\n    &quot;views&quot;: 3\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Collection trong MongoDB là gì?",
              "answer": "<p>Collection là một nhóm document. Nếu một document trong MongoDB tương tự như một hàng trong SQL, thì một collection sẽ tương tự như một bảng.\r\n\r\nCác document trong cùng một collection có thể khác nhau,... do tính chất <strong>lược đồ dữ liệu động</strong>.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\n{&quot;greeting&quot; : &quot;Hello world!&quot;, &quot;views&quot;: 3}\r\n{&quot;signoff&quot;: &quot;Good bye&quot;}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cơ sở dữ liệu trong MongoDB",
              "answer": "<p>Tập hợp các collection nằm trong cơ sở dữ liệu. MongoDB có thể có nhiều cơ sở dữ liệu, mỗi cơ sở dữ liệu chứa nhiều collection.\r\n\r\nMột số tên cơ sở dữ liệu dành riêng như sau:\r<ul><li><em>admin</em></li></ul>\r<ul><li><em>local</em></li></ul>\r<ul><li><em>config</em></li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "MongoDB Shell là gì?",
              "answer": "<p>Nó là một JavaScript shell cho phép tương tác với một phiên bản MongoDB từ dòng lệnh. Nhờ đó, người ta có thể thực hiện các chức năng quản trị, kiểm tra một phiên bản hoặc sử dụng MongoDB.\r\n\r\nĐể bắt đầu shell, ta chạy lệnh mongo:\r\n\r\n``<code>shell\r\n$ mongod\r\n$ mongo\r\nMongoDB shell version: 4.2.0\r\nconnecting to: test\r\n&gt;\r\n</code>`<code>\r\n\r\nShell là một trình thông dịch JavaScript đầy đủ tính năng, có khả năng chạy các chương trình JavaScript tùy ý. Hãy xem cách phép toán cơ bản hoạt động:\r\n\r\n</code>`<code>shell\r\n&gt; x = 100;\r\n200\r\n&gt; x / 5;\r\n20\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Scale-Out xảy ra như thế nào trong MongoDB?",
              "answer": "<p>Để scale out trong MongoDB, ta thực hiện Sharding.\r\n\r\nSharding là một phương pháp để lưu trữ dữ liệu (storage) của cơ sở dữ liệu trên nhiều máy chủ. MongoDB sử dụng sharding để hỗ trợ việc phân tán một lượng dữ liệu trên nhiều máy chủ, ở đây có thể là các tập collection trong DB điều này giúp cho việc truy cập nhanh hơn, giảm tải việc quá tải ổ cứng cho một vài máy chủ và giúp hệ thống dễ dàng mở rộng khi có nhu cầu hơn.\r\n\r\nMongodb Sharded Cluster bao gồm các thành phần chính như sau:\r<ul><li><strong>Shards</strong>: Là nơi chứa dữ liệu, được phân tán bởi nhiều máy chủ theo cơ chế \"replica set\".</li></ul>\r<ul><li><strong>Query routers - Mongos</strong>: Là nơi điều hướng việc client truy cập chính xác dữ liệu vào shard nào, mỗi hệ thống Sharding có thể có nhiều query router.</li></ul>\r<ul><li><strong>Config servers</strong>: Là nơi chưa các metadata (nôm na là các thông số kỹ thuật) của hệ thống Sharding, nó chứa một bản đồ dữ liệu của việc thiết lập các Shards. Query routers dùng các metadata này xác định được chính xác việc truy vấn vào Shards nào trên hệ thống. Mỗi hệ thống Sharding có chính xác là 3 file Config servers.</li></ul>\r\n\r\n<img src=\"/interview-assets/Mongos.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các tính năng của MongoDB?",
              "answer": "<p><ul><li><strong>Indexing</strong> hỗ trợ chỉ mục thứ cấp và cung cấp tính năng đánh chỉ mục duy nhất, đa hợp, không gian địa lý và toàn văn bản.</li></ul>\r<ul><li><strong>Aggregation</strong> cung cấp framework aggregation dựa trên khái niệm xử lý dữ liệu trong pipelines.</li></ul>\r<ul><li><strong>Special collection và index types</strong>: nó hỗ trợ time-to-live collection cho dữ liệu sẽ hết hạn vào một thời điểm nhất định.</li></ul>\r<ul><li><strong>File storage</strong> cung cấp giao thức đơn giản cho lưu trữ file và thông tin file.</li></ul>\r<ul><li><strong>Sharing</strong> là quá trình chia sẽ dữ liệu trên nhiều máy.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Làm sao để thêm dữ liệu trong MongoDB?",
              "answer": "<p>Phương thức thêm dữ liệu cơ bản trong MongoDB là \"insert\". Để thêm một document ta dùng <code>insertOne</code>:\r\n\r\n``<code>\r\n&gt; db.books.insertOne({&quot;title&quot;: &quot;Start With Why&quot;})\r\n</code>`<code>\r\n\r\nĐể thêm nhiều document vào một collection, ta có thể dùng </code>insertMany`, phương thức này cho phép chuyển một mảng document vào cơ sở dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để cập nhật một document?",
              "answer": "<p>Sau khi document được lưu trữ trong cơ sở dữ liệu, nó có thể được cập nhật bằng một trong các phương pháp sau: <code>updateOne</code>, <code>updateMany</code> và <code>replaceOne</code>. \r\n\r\n<code>updateOne</code> và <code>updateMany</code> mỗi cái lấy một document lọc làm tham số đầu tiên và một document chỉnh sửa làm tham số thứ hai. <code>replaceOne</code> cũng lấy một bộ lọc làm tham số đầu nhưng với tham số thức hai, <code>replaceOne</code> sẽ mong đợi tài liệu thay thế phù hợp với filter.\r\n\r\n``<code>js\r\n{\r\n   &quot;_id&quot; : ObjectId(&quot;4b2b9f67a1f631733d917a7a&quot;),\r\n   &quot;name&quot; : &quot;alice&quot;,\r\n   &quot;friends&quot; : 24,\r\n   &quot;enemies&quot; : 2\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách xoá một document?",
              "answer": "<p>Xoá trong MongoDB được hỗ trợ bằng <code>deleteOne</code> và <code>deleteMany</code>. Cả hai phương thức này đều nhận vào một bộ lọc document làm tham số đầu tiên. Bộ lọc chỉ định một tập hợp các tiêu chí phù hợp với việc xoá document.\r\n\r\n``<code>\r\n&gt; db.books.deleteOne({&quot;_id&quot; : 3})\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm sao để truy vấn trong MongoDB?",
              "answer": "<p>Phương thức <code>find</code> được dùng để thực hiện truy vấn trong MongoDB. Truy vấn trả về một tập con document trong một collection, có thể là không có document nào cũng có thể là toàn bộ. Document được trả về được xác định bởi tham số đầu tiên cần tìm là tiêu chí truy vấn document.\r\n\r\n``<code>\r\n&gt; db.users.find({&quot;age&quot; : 24})\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu dữ liệu trong MongoDB?",
              "answer": "<p>MongoDB hỗ trợ nhiều kiểu dữ liệu dưới dạng giá trị trong document. Các document trong MongoDB tương tự như các đối tượng trong JavaScript. Cùng với bản chất key/value thiết yếu của JSON, MongoDB bổ sung hỗ trợ cho một số kiểu dữ liệu bổ sung. Các kiểu dữ liệu phổ biến trong MongoDB là:\r<ul><li>Null</li></ul>\r\n\r\n``<code>js\r\n{&quot;x&quot; : null}\r\n</code>`<code>\r<ul><li>Boolean</li></ul>\r\n\r\n</code>`<code>js\r\n{&quot;x&quot; : true}\r\n</code>`<code>\r<ul><li>Number</li></ul>\r\n\r\n</code>`<code>js\r\n{&quot;x&quot; : 4}\r\n</code>`<code>\r<ul><li>String</li></ul>\r\n\r\n</code>`<code>js\r\n{&quot;x&quot; : &quot;foobar&quot;}\r\n</code>`<code>\r<ul><li>Date</li></ul>\r\n\r\n</code>`<code>js\r\n{&quot;x&quot; : new Date()}\r\n</code>`<code>\r<ul><li>Regular expression</li></ul>\r\n\r\n</code>`<code>js\r\n{&quot;x&quot; : /foobar/i}\r\n</code>`<code>\r<ul><li>Array</li></ul>\r\n\r\n</code>`<code>js\r\n{&quot;x&quot; : [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}\r\n</code>`<code>\r<ul><li>Embedded document</li></ul>\r\n\r\n</code>`<code>js\r\n{&quot;x&quot; : {&quot;foo&quot; : &quot;bar&quot;}}\r\n</code>`<code>\r<ul><li>Object ID</li></ul>\r\n\r\n</code>`<code>js\r\n{&quot;x&quot; : ObjectId()}\r\n</code>``\r<ul><li>Binary Data là một chuỗi các byte tùy ý.</li></ul>\r<ul><li>Code</li></ul>\r\n{\"x\" : function() { /<em> ... </em>/ }}</p>",
              "level": "fresher"
            },
            {
              "question": "Khi nào sử dụng MongoDB?",
              "answer": "<p>Bạn nên sử dụng MongoDB khi bạn đang xây dựng các ứng dụng internet và doanh nghiệp cần phát triển nhanh chóng và mở rộng quy mô một cách gọn gàng. MongoDB phổ biến với các nhà dev đang xây dựng các ứng dụng có khả năng mở rộng bằng cách sử dụng các phương pháp agile.\r\n\r\nMongoDB là một lựa chọn tuyệt vời nếu bạn cần:\r<ul><li>Hỗ trợ phát triển lặp đi lặp lại nhanh chóng.</li></ul>\r<ul><li>Mở rộng quy mô đến mức cao của lưu lượng đọc và ghi - MongoDB hỗ trợ mở rộng quy mô theo chiều ngang thông qua Sharding, phân phối dữ liệu trên một số máy và tạo điều kiện cho các hoạt động thông lượng cao với bộ dữ liệu lớn.</li></ul>\r<ul><li>Quy mô kho dữ liệu của bạn có một kích thước lớn.</li></ul>\r<ul><li>Phát triển loại hình triển khai khi doanh nghiệp thay đổi.</li></ul>\r<ul><li>Lưu trữ, quản lý và tìm kiếm dữ liệu với các văn bản, không gian địa lý hoặc chuỗi thời gian.</li></ul>\r\n\r\n## Câu hỏi phỏng vấn MongoDB cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về indexing trong Mongodb?",
              "answer": "<p>Chỉ mục (Index) hỗ trợ việc phân giải các truy vấn hiệu quả hơn. Nếu không có chỉ mục, MongoDB phải quét qua mọi Document của một Collection để chọn các Document mà kết nối với lệnh truy vấn. Việc quét này có thể không hiệu quả và yêu cầu MongoDB xử lý một số lượng lớn dữ liệu.\r\n\r\nChỉ mục (Index) là các cấu trúc dữ liệu đặc biệt, lưu giữ một phần nhỏ của tập hợp dữ liệu, giúp việc độc collection một cách dễ dàng hơn. Chỉ mục lưu giữ giá trị của một trường cụ thể hoặc tập hợp các trường, được sắp xếp bởi giá trị của trường như đã được xác định trong chỉ mục.\r\n\r\nĐể tạo chỉ mục, có thể dùng phương thức <code>createIndex</code>. Ví dụ:\r\n\r\n``<code>\r\n&gt; db.users.find({&quot;username&quot;: &quot;user101&quot;}).explain(&quot;executionStats&quot;)\r\n</code>`<code>\r\n\r\nỞ đây, chế độ </code>executionStats` giúp ta hiểu tác dụng của việc sử dụng một chỉ mục để đáp ứng các truy vấn.</p>",
              "level": "fresher"
            },
            {
              "question": "Chỉ mục địa lý (Geospatial Indexes) trong MongoDB?",
              "answer": "<p>MongoDB có hai loại chỉ mục đia lý là: <strong>2d</strong> và <strong>2dsphere</strong>.\r\n\r\nChỉ mục 2dsphere làm việc với các hình cầu mô phỏng bề mặt trái đất dựa trên hệ toạ độ WGS-84. Hệ toạ độ này mô hình hoá bề mặt trái đất như một hình cầu phẳng. Do đó, ác phép tính khoảng cách sử dụng chỉ mục 2dsphere, sẽ tính đến hình dạng của trái đất và cung cấp cách xử lý chính xác hơn về khoảng cách giữa hai thành phố.\r\n\r\nVí dụ: Tính toán khoảng cách giữa hai thành phố\r<ul><li>Sử dụng chỉ mục 2d cho các điểm lưu trữ trên mặt phẳng hai chiều:</li></ul>\r\n``<code>js\r\n{\r\n    &quot;name&quot; : &quot;New York City&quot;,\r\n    &quot;loc&quot; : {\r\n        &quot;type&quot; : &quot;Point&quot;,\r\n        &quot;coordinates&quot; : [50, 2]\r\n    }\r\n}\r\n</code>`<code>\r<ul><li>2dsphere cho phép bạn chỉ định các điểm, đường thẳng, đa giác ở dạng GeoJSON. Một điểm được biểu diễn bởi một mảng hai phần tử[kinh độ, vĩ độ]:</li></ul>\r\n\r\n</code>`<code>js\r\n{\r\n    &quot;name&quot; : &quot;Hudson River&quot;,\r\n    &quot;loc&quot; : {\r\n        &quot;type&quot; : &quot;LineString&quot;,\r\n        &quot;coordinates&quot; : [[0,1], [0,2], [1,2]]\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về quá trình sharding?",
              "answer": "<p>Sharding là quá trình chia nhỏ dữ liệu giữa các máy. Đôi khi người ta cũng sử dụng thuật ngữ \"partitioning\" để mô tả khái niệm này. Ta có thể lưu trữ nhiều dữ liệu hơn và xử lý nhiều tải hơn mà không yêu cầu cấu hình máy mạnh hơn, bằng cách đặt một tập con dữ liệu trên mỗi máy.\r\n\r\nTrong hình bên dưới, RS0 và RS1 là shards. Sharding trong MongoDB cho ta tạo một cụm gồm nhiều máy (shards) và chia các tập hợp trên đó. Đặt các tập con dữ liệu vào mỗi shard. Nó cho phép ứng dụng của bạn phát triển vượt ngoài giới hạn của một server độc lập.\r\n\r\n<img src=\"/interview-assets/sharded_client_connection.jpg\" alt=\"\" />\r\n\r\n<img src=\"/interview-assets/Non_sharded_client_connection.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về SET trong MongoDB?",
              "answer": "<p>Nếu giá trị của trường không tồn tại, thiết lập <code>$set</code> giá trị có thể hữu ích cho cập nhật lược đồ hay thêm khoá người dùng định nghĩa.\r\n\r\n``<code>js\r\n&gt; db.users.findOne()\r\n{\r\n   &quot;<em>id&quot; : ObjectId(&quot;4b253b067525f35f94b60a31&quot;),\r\n   &quot;name&quot; : &quot;alice&quot;,\r\n   &quot;age&quot; : 23,\r\n   &quot;sex&quot; : &quot;female&quot;,\r\n   &quot;location&quot; : &quot;India&quot;\r\n}\r\n</code>`<code>\r\n\r\nĐể thêm trường vào ta có thể dừng </code>$set<code>:\r\n\r\n</code>`<code>\r\n&gt; db.users.updateOne({&quot;</em>id&quot; : \r\nObjectId(&quot;4b253b067525f35f94b60a31&quot;)},\r\n... {&quot;$set&quot; : {&quot;favorite book&quot; : &quot;Start with Why&quot;}})\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Transaction trong MongoDB?",
              "answer": "<p>Transaction là một đơn vị xử lý logic trong cơ sở dữ liệu bao gồm một hoặc nhiều thao tác cơ sở dữ liệu, có thể là thao tác đọc hoặc ghi. Transaction cung cấp một tính năng hữu ích trong MongoDB để đảm bảo tính nhất quán.\r\n\r\nMongoDB cung cấp 2 API cho sử dụng transaction là:\r<ul><li><strong>Core API</strong>: tương tực với cú pháp của cơ sở dữ liệu quan hệ (start<em>transaction  và commit</em>transaction)</li></ul>\r<ul><li><strong>Call-back API</strong>: Đây là cách tiếp cận được khuyến nghị để sử dụng các transaction. Nó bắt đầu một transaction, thực hiện các hoạt động được chỉ định và commit (hoặc hủy bỏ do lỗi). Nó cũng tự động kết hợp logic xử lý lỗi cho \"TransientTransactionError\" và \"UnknownTransactionCommitResult\".</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "MongoDB Charts là gì?",
              "answer": "<p>MongoDB Charts là một công cụ để tạo các minh họa trực quan cho dữ liệu MongoDB của bạn. Trực quan hóa dữ liệu là một thành phần quan trọng để cung cấp sự hiểu biết rõ ràng về dữ liệu của bạn, làm nổi bật mối tương quan giữa các biến và giúp bạn dễ dàng phân biệt các mẫu và xu hướng trong bộ dữ liệu của mình. Biểu đồ MongoDB giúp cho việc truyền tải dữ liệu của bạn trở nên đơn giản hơn bằng cách cung cấp các công cụ có sẵn để dễ dàng chia sẻ và cộng tác trên các hình ảnh trực quan.\r\n\r\nCó hai cách triển khai MongoDB Charts là:\r\n\r\n<em> MongoDB Charts PaaS\r\n</em> MongoDB Charts Server</p>",
              "level": "fresher"
            },
            {
              "question": "Aggregation trong MongoDB là gì?",
              "answer": "<p>Aggregation là một framework tổng hợp dữ liệu của MongoDB. Aggregation được xây dựng dựa trên mô hình xử lý dữ liệu dưới dạng pipeline. \r\n\r\nAggregation pipeline bao gồm nhiều giai đoạn. Trong mỗi giai đoạn, chúng ta sử dụng một aggregation operator để biến đổi dữ liệu của các input document. Các output document của giai đoạn phía trước sẽ là input document của giai đoạn ngay sau. Các aggregation operator có thể được sử dụng nhiều lần trong pipeline, ngoại trừ <code>$out</code>, <code>$merge</code>, và <code>$geoNear</code>.\r\n\r\n<img src=\"/interview-assets/aggregation-framework.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về khái niệm pipeline trong MongoDB?",
              "answer": "<p>Một giai đoạn riêng lẻ của một aggregation pipeline là một đơn vị xử lý dữ liệu. Nó nhận từng dòng document đầu vào, xử lý từng document một và tạo ra từng dòng document đầu ra (xem hình bên dưới).\r\n\r\n<img src=\"/interview-assets/mongodb_aggregation_pipeline.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Replica Set trong MongoDB là gì?",
              "answer": "<p>Để giữ các bản sao dữ liệu giống hệt nhau trên nhiều server, ta sử dụng tính năng replication (sao chép). Sử dụng replication sẽ giữ cho ứng dụng của bạn chạy và dữ liệu của bạn an toàn, ngay cả khi có điều gì đó xảy ra với một hoặc nhiều server.\r\n\r\nReplication như vậy có thể được tạo bởi một replica set với MongoDB. Replica set  là một nhóm các tiến trình của Mongodb duy trì cùng một bộ dữ liệu. Các replica set cung cấp tính dự phòng và tính sẵn sàng cao và là cơ sở để triển khai nhập xuất dữ liệu khi cần thiết.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về kiến trúc Replication trong MongoDB?",
              "answer": "<p><img src=\"/interview-assets/replication_architecture.jpg\" alt=\"\" />\r<ul><li>Một replica set chỉ có duy nhất một primary. Primary sẽ nhận các yêu cầu ghi. Primary ghi các thay đổi của nó vào oplog.</li></ul>\r<ul><li>Các secondary sẽ có chung data set với primary, các yêu cầu đọc có thể scale trên primary và tất cả các secondary. Một replica set có thể có tối đa là 50 member.</li></ul>\r<ul><li>Các member luôn giữ duy trì kết nối, trong trường hợp một member chết thì các member khác sẽ tự động được chuyển đổi dự phòng. Đây là một điểm khác biệt so với mysql.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Một số tiện ích để sao lưu và khôi phục trong MongoDB là gì?",
              "answer": "<p>Mongo shell không bao gồm các chức năng xuất, nhập, sao lưu hoặc khôi phục. Tuy nhiên, MongoDB đã tạo ra các phương thức để thực hiện điều này, do đó không cần đến việc viết script hoặc GUI phức tạp. Ở đây, một số script tiện ích được cung cấp có thể được sử dụng để lấy dữ liệu vào hoặc ra cơ sở dữ liệu hàng loạt. Các script tiện ích này là:\r<ul><li>mongoimport</li></ul>\r<ul><li>mongoexport</li></ul>\r<ul><li>mongodump</li></ul>\r<ul><li>mongorestore</li></ul></p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "mysql",
          "name": "Câu hỏi phỏng vấn MySQL",
          "description": "",
          "questions": [
            {
              "question": "MySQL là gì?",
              "answer": "<p>MySQL là hệ quản trị cơ sở dữ liệu mã nguồn mở lớn nhất thế giới, đặc biết được dùng rất nhiều cho các dự án, ứng dụng, website trên internet.</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của MySQL?",
              "answer": "<p><ul><li><strong>Dễ sử dụng:</strong> MySQL là cơ sở dữ liệu tốc độ cao, ổn định, dễ sử dụng và hoạt động trên nhiều hệ điều hành cung cấp một hệ thống lớn các hàm tiện ích rất mạnh.</li></ul>\r<ul><li><strong>Độ bảo mật cao:</strong>  MySQL rất thích hợp cho các ứng dụng có truy cập CSDL trên Internet khi sở hữu nhiều nhiều tính năng bảo mật thậm chí là ở cấp cao.</li></ul>\r<ul><li><strong>Đa tính năng:</strong> MySQL hỗ trợ rất nhiều chức năng SQL được mong chờ từ một hệ quản trị cơ sở dữ liệu quan hệ cả trực tiếp lẫn gián tiếp.</li></ul>\r<ul><li><strong>Khả năng mở rộng và mạnh mẽ:</strong> MySQL có thể xử lý rất nhiều dữ liệu và hơn thế nữa nó có thể được mở rộng nếu cần thiết.</li></ul>\r<ul><li><strong>Nhanh chóng:</strong> Việc đưa ra một số tiêu chuẩn cho phép MySQL để làm việc rất hiệu quả và tiết kiệm chi phí, do đó nó làm tăng tốc độ thực thi.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu \"cơ sở dữ liệu\" là gì?",
              "answer": "<p>Cơ sở dữ liệu là hệ thống bao gồm rất nhiều thông tin, dữ liệu được xây dựng theo một cấu trúc nhất định nhằm đáp ứng nhu cầu khai thác, sử dụng của nhiều người hay chạy nhiều chương trình ứng dụng cùng một lúc.\r\n\r\nKhi áp dụng hình thức lưu trữ này, nó sẽ giúp khắc phục được những điểm yếu của việc lưu file thông thường trên máy tính. Các thông tin lưu trữ sẽ đảm bảo được nhất quán, hạn chế tình trạng trùng lặp thông tin.</p>",
              "level": "fresher"
            },
            {
              "question": "Chuẩn SQL là gì?",
              "answer": "<p>Chuẩn SQL (Structured Query Language) là ngôn ngữ sử dụng cho các RDBMS bên cạnh MySQL như Oracle, Microsoft SQL Server. Có thể coi SQL là ngôn ngữ chung mà bất cứ hệ thống cơ sở dữ liệu quan hệ (RDBMS) nào cũng phải đáp ứng.</p>",
              "level": "fresher"
            },
            {
              "question": "Một cơ sở dữ liệu MySQL bao gồm những gì?",
              "answer": "<p>Một cơ sở dữ liệu MySQL bao gồm một hay nhiều bảng, mỗi bảng gồm cột và dòng. Trong đó cột là các thuộc tính dữ liệu còn hàng là các bản ghi dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để tương tác với MySQL?",
              "answer": "<p>Có 3 cách để tương tác với MySQL:\r<ul><li>dùng lệnh trực tiếp</li></ul>\r<ul><li>qua web interface</li></ul>\r<ul><li>qua ngôn ngữ lập trình</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Truy vấn MySQL là gì?",
              "answer": "<p>Một truy vấn là một yêu cầu hay câu hỏi cụ thể. Nó đòi hỏi cơ sở dữ liệu phải trả về một hay nhiều bảng ghi cụ thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Các lệnh phổ biến trong MySQL?",
              "answer": "<p>| Command | Action |\r\n|---------|--------|\r\n| ALTER | Chỉnh sửa bảng hay cơ sở dữ liệu |\r\n| BACKUP | Phục hồi bảng |\r\n| CREATE | Tạo cơ sở dữ liệu |\r\n| DELETE | Xoá hàm của bảng |\r\n| DESCRIBE | Mô tả cột của bảng |\r\n| DROP | Xoá bảng hay cơ sở dữ liệu |\r\n| EXIT | Thoát |\r\n| GRANT | Đổi quyền người dùng |\r\n| HELP | Hiển thị bảng trợ giúp |\r\n| INSERT | Thêm dữ liệu |\r\n| LOCK | Khoá bảng |\r\n| QUIT | Giống EXIT |\r\n| RENAME | Đổi tên bảng |\r\n| SHOW | Liệt kê chi tiết đối tượng |\r\n| SOURCE | Thực thi một file |\r\n| STATUS | Hiển thị trạng thái hiện tại |\r\n| TRUNCATE | Làm trống bảng |\r\n| UNLOCK | Mở khoá bảng |\r\n| UPDATE | Cập nhật bảng ghi đã tồn tại |\r\n| USE | Sử dụng cơ sở dữ liệu |</p>",
              "level": "fresher"
            },
            {
              "question": "Cách tạo cơ sở dữ liệu trong MySQL?",
              "answer": "<p>``<code>sql\r\nCREATE DATABASE books;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách tạo bảng trong MySQL?",
              "answer": "<p>``<code>sql\r\nCREATE TABLE history (\r\n    author VARCHAR(128),\r\n    title VARCHAR(128),\r\n    type VARCHAR(16),\r\n    year CHAR(4)\r\n) ENGINE InnoDB;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách chèn dữ liệu vào MySQL?",
              "answer": "<p>Lệnh INSERT INTO dùng cho chèn bảng ghi mới vào bảng MySQL:\r\n\r\n``<code>sql\r\nINSERT INTO table<em>name (column1, column2, column3,...)\r\nVALUES (value1, value2, value3,...)\r\n</code>`<code>\r\n\r\nNếu bạn muốn thêm dữ liệu cho tất cả cột trong bảng, bạn không cần chỉ định tên cột trong truy vấn SQL. Tuy nhiên, trật tự của giá trị sẽ tương ứng với thứ tự cột của bảng.\r\n\r\n</code>`<code>sql\r\nINSERT INTO table</em>name \r\nVALUES (value1, value2, value3,...)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Xoá cột trong MySQL?",
              "answer": "<p>``<code>sql\r\nALTER TABLE classics DROP pages;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Đánh chỉ mục trong MySQL?",
              "answer": "<p>Trong MySQL, có nhiều kiểu chỉ mục khác nhau như regular index, fulltext index hay primary key. Các chỉ mục giúp ta tìm kiếm nhanh hơn. Chỉ mục gia tăng hiệu suất bằng cách đánh thứ tự dữ liệu trên đĩa, nhờ đó mà nó tìm kiếm kết quả nhanh hơn, hoặc nói cho SQL engine biết vị trí cần tìm dữ liệu.\r\n\r\nVí dụ: \r\n\r\n``<code>sql\r\nALTER TABLE history ADD INDEX(author(10));\r\nALTER TABLE history ADD INDEX(title(10));\r\nALTER TABLE history ADD INDEX(category(5));\r\nALTER TABLE history ADD INDEX(year);\r\nDESCRIBE history;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Xoá dữ liệu trong bảng MySQL?",
              "answer": "<p>``<code>sql\r\nDELETE FROM table<em>name\r\nWHERE column</em>name = value_name\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách để xem cơ sở dữ liệu trong MySQL?",
              "answer": "<p>``<code>sql\r\nmysql&gt; SHOW DATABASES;  \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu số trong MySQL?",
              "answer": "<p>| Type | Ý nghĩa |\r\n|------|---------|\r\n| TINYINIT | Số nguyên rất nhỏ |\r\n| SMALLINT | Số nguyên nhỏ |\r\n| MEDIUMINT | Số nguyên cỡ vừa |\r\n| INT | Số nguyên tiêu chuẩn |\r\n| BIGINT | Số nguyên lớn |\r\n| DECIMAL | Số thập phân |\r\n| FLOAT | Số dấu phẩy động chính xác đơn |\r\n| DOUBLE | Số dấu phẩy động chính xác kép|\r\n| BIT | trường bit |</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu chuỗi trong MySQL?",
              "answer": "<p>| Type | Ý nghĩa |\r\n|------|---------|\r\n| CHAR | chuỗi (ký tự) với độ dài cố định |\r\n| VARCHAR | chuỗi với độ dài biến |\r\n| BINARY | chuỗi nhị phân độ dài cố định |\r\n| VARBINARY | chuỗi nhị phân độ dài biến |\r\n| TINYBLOB | BLOB (đối tượng nhị phân lớn) rất nhỏ |\r\n| BLOB | Blob nhỏ |\r\n| MEDIUMBLOB | Blob trung bình |\r\n| LONGBLOB | Blob lớn |\r\n| TINYTEXT | Chuỗi rất ngắn |\r\n| TEXT | Chuỗi ngắn|\r\n| MEDIUMTEXT | Chuỗi trung bình |\r\n| LONGTEXT | Chuỗi dài |\r\n| ENUM | Mỗi giá trị cột được gán, một thành viên enum |\r\n| SET | Một tập hợp, mỗi cột giá trị được gán 0 hoặc nhiều tập hợp thành viên |\r\n| NULL | NULL trong SQL là thuật ngữ được sử dụng để biểu thị một giá trị bị thiếu. Giá trị NULL trong bảng là giá trị trong trường có vẻ như là trống. Giá trị này khác với giá trị 0 hoặc một trường có chứa khoảng trắng. |</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu dữ liệu thời gian là gì?",
              "answer": "<p>| \r\n| Type | Ý nghĩa |\r\n|------|---------|\r\n| DATE | Giá trị ngày, theo định dang \"YYYY-MM-DD\" |\r\n| TIME | Giá trị giờ, theo định dang \"hh:mm:ss\" |\r\n| DATETIMET | Giá trị ngày giờ, theo định dang \"YYYY-MM-DD hh:mm:ss\" |\r\n| TIMESTAMP | Giá trị thười gian, theo định dang \"YYYY-MM-DD hh:mm:ss\" |\r\n| YEAR | Giá trị năm, theo định dang \"YYYY\" hoặc \"YY\" |\r\n\r\nVí dụ: Để lấy bảng ghi từ Order có ngày là \"2018-11-11\":\r\n\r\n``<code>sql\r\nSELECT * FROM Orders WHERE OrderDate=&#39;2018-11-11&#39;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "BLOB trong MySQL là gì?",
              "answer": "<p>BLOB là một đối tượng nhị phân lớn (Binary Large OBject) có thể chứa một lượng lớn dữ liệu. Có bốn loại BLOB, TINYBLOB, BLOB, MEDIUMBLOB, và LONGBLOB. Những chỉ khác nhau về độ dài tối đa của các giá trị mà chúng có thể giữ.\r\n\r\nBLOB được dùng cho lưu giữ một biến có dữ liệu rất lớn. Bạn có thể lưu trữ cả quyển tiểu thuyết trong BLOB nếu cần.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách thêm người dùng vào MySQL?",
              "answer": "<p>Bạn có thể thêm người dùng bằng cách dùng lệnh CREATE và chỉ định định danh.\r\n\r\n``<code>sql\r\nCREATE USER &#39;testuser&#39; IDENTIFIED BY &quot;sample password&quot;;\r\n</code>``\r\n\r\n## Câu hỏi phỏng vấn MySQL cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "View trong MySQL là gì?",
              "answer": "<p>Trong MySQL, một view bao gồm một tập hợp hàng được trả về nếu một truy vấn được thực thi. Nó còn gọi là một \"bảng ảo\". View giúp việc truy xuất dễ dàng hơn thông qua tên alias.\r\n\r\nCác ưu điểm của view:\r<ul><li>Đơn giản</li></ul>\r<ul><li>Bảo mật</li></ul>\r<ul><li>Dễ bảo trì</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tạo và thực thi view trong MySQL?",
              "answer": "<p>Tạo một view được thực hiện thông qua lệnh CREATE VIEW. Ví dụ:\r\n\r\n``<code>sql\r\nCREATE\r\n   [OR REPLACE]\r\n   [ALGORITHM = {MERGE | TEMPTABLE | UNDEFINED }]\r\n   [DEFINER = { user | CURRENT<em>USER }]\r\n   [SQL SECURITY { DEFINER | INVOKER }]\r\n   VIEW view</em>name [(column<em>list)]\r\n   AS select</em>statement\r\n   [WITH [CASCADED | LOCAL] CHECK OPTION]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "MySQL Trigger là gì?",
              "answer": "<p>Trigger là trình kích hoạt, sẽ được kích hoạt khi có một tác động nào đó vào nó.\r\n\r\nTrong MySQL, Trigger có nghĩa là một đoạn code SQL xử lý một chức năng nào đó, nó hoạt động ngầm và được chạy khi một trong các tác động như chèn, sửa đó hay xoá dữ liệu trong bảng.\r\n\r\nTrigger có nhiều mục đích, bao gồm:\r<ul><li>Kiểm tra dữ liệu</li></ul>\r<ul><li>Đồng bộ hoá dữ liệu</li></ul>\r<ul><li>Đảm bảo các mối quan hệ giữa các bảng</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Có bao nhiêu Trigger khả dụng trong MySQL?",
              "answer": "<p>Có 6 Trigger được cho phép trong cơ sở dữ liệu MySQL:\r<ul><li>Trước khi chèn</li></ul>\r<ul><li>Sau khi chèn</li></ul>\r<ul><li>Trước khi sửa</li></ul>\r<ul><li>Sau khi sửa</li></ul>\r<ul><li>Trước khi xoá</li></ul>\r<ul><li>Sau khi xoá</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "MySQL Server là gì?",
              "answer": "<p>MySQL Server là máy tính hay một hệ các máy tính cài đặt phần mềm MySQL dành cho server để giúp bạn lưu trữ dữ liệu trên đó, để máy khách có thể truy cập vào quản lý. Dữ liệu này được đặt trong các bảng, và các bảng có mối liên hệ với nhau. MySQL server nhanh, an toàn, đáng tin cậy. Phần mềm MySQL cũng miễn phí và được phát triển, phân phối và hỗ trợ bởi Oracle Corporation.</p>",
              "level": "fresher"
            },
            {
              "question": "MySQL Client là gì?",
              "answer": "<p>Là các chương trình MySQL khả dụng để giao tiếp với server. Dành cho mục đích quản trị, các phần quan trong được liệt kê dưới đây:\r\n\r\n• <strong>mysql</strong> — Một chương trình tương tác cho phép bạn gửi các câu lệnh SQL đến server và xem kết quả. Bạn cũng có thể sử dụng mysql để thực thi các script(file chứa câu lệnh SQL).\r\n\r\n• <strong>mysqladmin</strong> — Một chương trình quản trị để thực hiện các tác vụ như tắt server, kiểm tra cấu hình hoặc theo dõi trạng thái của nó nếu nó có vẻ không hoạt động bình thường.\r\n\r\n• <strong>mysqldump</strong> — Một công cụ để sao lưu cơ sở dữ liệu của bạn hoặc sao chép cơ sở dữ liệu sang một máy chủ khác.\r\n\r\n• <strong>mysqlcheck & myisamchk</strong> — Các chương trình giúp bạn thực hiện kiểm tra, phân tích và tối ưu hóa bảng, cũng như sửa chữa nếu bảng bị hỏng. mysqlcheck hoạt động với các bảng MyISAM và ở một mức độ nào đó với các bảng cho các công cụ lưu trữ khác. myisamchk chỉ được sử dụng với các bảng MyISAM.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu quan hệ trong MySQL?",
              "answer": "<p>Có 3 kiểu quan hệ trong MySQL\r<ul><li>One-to-One: là mối quan hệ giữa hai bảng trong đó mỗi bản ghi trong một bảng được liên kết với tối đa một bản ghi trong bảng kia.</li></ul>\r<ul><li>One-to-Many: là mối quan hệ được sử dụng phổ biến nhất trong đó một bản ghi trong bảng được liên kết với nhiều bản ghi trong bảng khác.</li></ul>\r<ul><li>Many-to-Many: được sử dụng trong các trường hợp khi cần có nhiều thực thể ở cả hai bên để tạo mối quan hệ.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích kiến trúc của MySQL?",
              "answer": "<p><img src=\"/interview-assets/architecture.png\" alt=\"\" />\r\n\r\nNhư bạn có thể thấy trên hình, kiến trúc logic của MySQL gồm 3 layers chính.\r<ul><li>Layer trên cùng chỉ ra các services mà MySQL cung cấp cho các hệ thống mạng client/server bao gồm xử lí kết nối, xác thực, bảo mật.</li></ul>\r<ul><li>Layer ở giữa, là trung tâm xử lí của MySQL bao gồm việc phân tích câu truy vấn, tối ưu hóa, caching và các hàm sẵn có trong MySQL.</li></ul>\r<ul><li>Layer dưới cùng bao gồm storage engine chịu trách nhiệm cho với lưu trữ và lấy ra dữ liệu. Các storage engine phổ biến hiện nay của MySQL là InnoDB và MyISAM</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Mở rộng trong MySQL?",
              "answer": "<p>Trong MySQL, khả năng mở rộng thực ra là khả năng xử lý tải và sẽ hữu ích khi nghĩ về tải từ một số góc độ khác nhau như:\r\n\r\n<em> Số lượng dữ liệu\r\n</em> Số lượng người dùng\r\n<em> Hoạt động người dùng\r\n</em> Kích thước của các bộ dữ liệu liên quan</p>",
              "level": "fresher"
            },
            {
              "question": "Sharding trong MySQL?",
              "answer": "<p>harding là một mẫu kiến trúc cơ sở dữ liệu liên quan đến phân vùng ngang - thực tế tách một hàng bảng Bảng thành nhiều bảng khác nhau, được gọi là partitions. Mỗi partitions có cùng schema và cột, nhưng cũng có các hàng hoàn toàn khác nhau. Tương tự, dữ liệu được giữ trong mỗi partitions là duy nhất và độc lập với dữ liệu được giữ trong các partitions khác.\r\n\r\nCó thể hữu ích khi so sánh suy nghĩ về phân vùng ngang theo cách nó liên quan đến phân vùng dọc. Trong một bảng được phân vùng theo chiều dọc, toàn bộ các cột được tách ra và đưa vào các bảng mới, riêng biệt. Dữ liệu được giữ trong một phân vùng dọc độc lập với dữ liệu trong tất cả các phân vùng khác và mỗi dữ liệu chứa cả các hàng và cột riêng biệt. Sơ đồ sau minh họa cách bảng có thể được phân vùng theo cả chiều ngang và chiều dọc\r\n\r\n<img src=\"/interview-assets/sharding.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Transaction Storage Engines trong MySQL là gì?",
              "answer": "<p>Để có thể sử dụng transaction cơ sở của MySQL, bạn phải sử dụng storage engine InnoDB của MySQL. Đây là Storage Engine mặc định trong MySQL 5.7. InnoDB là một Storage Engine transaction-safe (tuân thủ ACID) cho MySQL có các commit, rollback và khả năng khôi phục lỗi để bảo vệ dữ liệu người dùng. Row-level locking của InnoDB và kiểu nonlocking read của Oracle-style làm tăng sự đồng thời và hiệu suất của nhiều người dùng. InnoDB lưu trữ dữ liệu người dùng trong các clustered indexes để giảm I/O cho các truy vấn thông thường dựa trên các primary key. Để duy trì tính toàn vẹn của dữ liệu, InnoDB cũng hỗ trợ các ràng buộc toàn vẹn Foreign Key.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "postgresql",
          "name": "Câu hỏi phỏng vấn PostgreSQL",
          "description": "",
          "questions": [
            {
              "question": "Các tính năng trong PostgreSQL?",
              "answer": "<p><ul><li>Toàn vẹn dữ liệu: Là ràng buộc loại từ, khóa khuyến nghị, Primary Keys, Foreign Keys,…</li></ul>\r<ul><li>Kiểu dữ liệu: cấu trúc, nguyên hàm, hình học và tùy chỉnh</li></ul>\r<ul><li>Hiệu suất, đồng quy: Những tính năng lập danh mục, lập danh mục nâng cao và trình lập kế hoạch,…chúng đều được thực hiện một cách tự động.</li></ul>\r<ul><li>Các chức năng bảo mật: Bảo mật, xác thực, hệ thống kiểm soát truy cập mạnh mẽ, bảo mật cấp độ cột và hàng.</li></ul>\r<ul><li>Khả năng tìm kiếm văn bản: Tìm kiếm đầy đủ những văn bản, hệ thống bao gồm các kỳ tự quốc tế thông qua ICU collations.</li></ul>\r<ul><li>Khả năng mở rộng: PostgreSQL có phương pháp lưu trữ, ngôn ngữ thủ tục, tính năng kết nối cơ sở dữ liệu hoặc luồng khác với giao diện SQL chuẩn cùng với nhiều tính năng mở rộng vượt trội khác.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Multi-version Concurrency Control trong Postgres là gì?",
              "answer": "<p>Một trong những tính năng nổi bật của Postgres đó là cách mà nó thực hiện điều khiển tương tranh giữa các transaction, nghĩa là read sẽ không bao giờ chặn write và ngược lại. Nói một cách dễ hình dung hơn, nếu hai transaction thực thi cùng một lúc thì nguyên tắc thực thi là thực thi độc lập, Postgres thực hiện được điều này là nhờ một cơ chế gọi là Multi Version Concurrency Control (MVCC)</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để đánh chỉ mục trong Postgres?",
              "answer": "<p>Chỉ mục (Indexex) là các hàm có sẵn trong Postgres được sử dụng cho các truy vấn tìm kiếm để đạt hiệu quả cao hơn đối với một bảng trong cơ sở dữ liệu. Giả sữ rằng bạn có một bảng với hàng ngìn bản ghi và câu truy vấn của bạn thì chỉ có vài bản ghi là phù hợp với điều kiện, như vậy sẽ mất rất nhiều thời gian để tìm và trả về nững hàng thoả mã điều kiện này vì nó phải thực hiện hoạt động tìm kiếm trên từng hàng đơn lẻ. Điều này chắc chẵn không hiệu quả đối với một hệ thống xử lý dữ liệu khổng lồ. Bây giờ nếu hệ thống này có một chỉ mục trên cột mà chúng tôi đang áp dụng tìm kiếm, nó có thể sử dụng một phương pháp hiệu quả để xác định các hàng phù hợp bằng cách chỉ đi qua một vài cấp độ. Đây được gọi là lập chỉ mục (indexing).\r\n\r\n``<code>sql\r\nSELECT * FROM some<em>table WHERE table</em>col=120\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để thay đổi kiểu dữ liệu của cột?",
              "answer": "<p>Có thể sử dụng lệnh ALTER TABLE như bên dưới\r\n\r\n``<code>sql\r\nALTER TABLE tname\r\nALTER COLUMN col<em>name [SET DATA] TYPE new</em>data_type;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh dùng cho tạo cơ sở dữ liệu trong Postgres?",
              "answer": "<p>Cú pháp tạo cơ sở dữ liệu trong Postgres trong psql là:\r\n\r\n``<code>sql\r\nCREATE DATABASE db_name;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách để khởi động, dừng và khởi động lại trong PostgreSQL Server?",
              "answer": "<p><ul><li>Để khởi động Postgres server:</li></ul>\r\n\r\n``<code>text\r\nservice postgresql start\r\n</code>`<code>\r<ul><li>Sau khi server khởi động thành công, sẽ có thông báo như sau:</li></ul>\r\n\r\n</code>`<code>text\r\nStarting PostgreSQL: ok\r\n</code>`<code>\r<ul><li>Để khởi động lại Postgres server:</li></ul>\r\n\r\n</code>`<code>text\r\nservice postgresql restart\r\n</code>`<code>\r<ul><li>Nếu khởi động lại thành công:</li></ul>\r\n\r\n</code>`<code>text\r\nRestarting PostgreSQL: server stopped\r\nok\r\n</code>`<code>\r<ul><li>Để dừng server, ta chạy lệnh:</li></ul>\r\n\r\n</code>`<code>text\r\nservice postgresql stop\r\n</code>`<code>\r<ul><li>Nếu dừng thành công:</li></ul>\r\n\r\n</code>`<code>text\r\nStopping PostgreSQL: server stopped\r\nok\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu partioned table?",
              "answer": "<p>Partitioned table là một cấu trúc logic được dùng cho chia một bảng lớn thành các cấu trúc nhỏ hơn gọi là partition. Cách tiếp cận này được dùng để tăng hiệu suất truy vấn khi làm việc với bảng cơ sở dữ liệu lớn. Để tạo một partition, một khoá gọi là khoá phân vùng được dùng cho các cột hoặc biểu thức, và một phương thức phân vùng cần định nghĩa. Có 3 kiểu phương thức phân vùng có sẵn được cung cấp bởi Postgres:\r<ul><li><strong>Range Partitioning</strong>: Phương pháp này được thực hiện bằng cách phân vùng dựa trên một loạt các giá trị. Phương pháp này được sử dụng phổ biến nhất dựa trên các trường ngày tháng để lấy dữ liệu hàng tháng, hàng tuần hoặc hàng năm. Trong trường hợp như giá trị thuộc phần cuối của phạm vi, ví dụ: nếu phạm vi của phân vùng 1 là 10-20 và phạm vi của phân vùng 2 là 20-30 và giá trị đã cho là 10, thì 10 thuộc về đến phân vùng thứ hai chứ không phải phân vùng đầu tiên.</li></ul>\r<ul><li><strong>List Partitioning</strong>: Phương pháp này được sử dụng để phân vùng dựa trên danh sách các giá trị đã biết. Thường được sử dụng nhất khi chúng ta có key có giá trị phân loại. Ví dụ: nhận dữ liệu bán hàng dựa trên các khu vực được chia thành quốc gia, thành phố hoặc tiểu bang.</li></ul>\r<ul><li><strong>Hash Partitioning</strong>: Phương pháp này sử dụng một hàm băm trên khoá phân vùng. Điều này được thực hiện khi không có yêu cầu cụ thể nào đối với việc phân chia dữ liệu và được sử dụng để truy cập dữ liệu riêng lẻ. Ví dụ: bạn muốn truy cập dữ liệu dựa trên một sản phẩm cụ thể, thì việc sử dụng phân vùng băm sẽ dẫn đến tập dữ liệu đã yêu cầu.</li></ul>\r\n\r\nLoại khoá phân vùng và loại phương pháp được sử dụng để phân vùng xác định mức độ tích cực của hiệu suất và mức độ quản lý của bảng được phân vùng.</p>",
              "level": "fresher"
            },
            {
              "question": "Token trong Postgres?",
              "answer": "<p>Token trong Postgres là một từ khoá, tên định danh, hằng, hay bất kỳ ký hiệu nào cho tính riêng biệt. Nó có thể được phân chia (hoặc không) bằng khoảng trắng, tab hay xuống dòng. Nếu token là từ khoá, nó thường là một lệnh hữu ích. Token có thể được tạo bằng bất kỳ code PostgreSQL nào.</p>",
              "level": "fresher"
            },
            {
              "question": "Câu lệnh TRUNCATE là gì?",
              "answer": "<p>Lệnh TRUNCATE TABLE name<em>of</em>table xoá dữ liệu một cách hiệu quả và nhanh chóng khỏi bảng.\r\n\r\n``<code>sql\r\nTRUNCATE TABLE name<em>of</em>table \r\nRESTART IDENTITY;\r\n</code>`<code>\r\n\r\nTa còn có thể dùng lệnh cho xoá nhiều bảng cùng lúc như sau:\r\n\r\n</code>`<code>sql\r\nTRUNCATE TABLE \r\n   table<em>1, \r\n   table</em>2,\r\n   table_3;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Dung lượng của một bảng trong Postgres?",
              "answer": "<p>Kích cỡ lớn nhất cho một bản là 32TB.</p>",
              "level": "fresher"
            },
            {
              "question": "Sequence trong Postgres?",
              "answer": "<p>Sequence là một đối tượng dữ liệu trong PostgreSQL, được sử dụng để tạo ra chuỗi các số tự nhiên (integer) theo 1 quy tắc nhất định. Để tạo 1 Sequece chúng ta sử dụng câu lệnh SQL là: <code>CREATE SEQUENCE</code>\r\n\r\n``<code>sql\r\nCREATE SEQUENCE serial<em>num START 100;\r\n</code>`<code>\r\n\r\nĐể lấy số 101 trong sequence, ta sử dụng phương thức </code>nextval()<code>:\r\n\r\n</code>`<code>sql\r\nSELECT nextval(&#39;serial</em>num&#39;);\r\n</code>`<code>\r\n\r\nTa cũng có thể dùng sequence trong khi chèn bản ghi:\r\n\r\n</code>`<code>sql\r\nINSERT INTO ib<em>table</em>name VALUES (nextval(&#39;serial_num&#39;), &#39;interview&#39;);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Chuỗi trong Postgres?",
              "answer": "<p>Nó là một chuỗi ký tự nằm trong dấu nháy đơn. Nó được dùng trong suốt quá trình thêm hay cập nhật ký tự trong cơ sở dữ liệu.\r\n\r\nChuỗi hằng nằm trong dấu dollar. Cú pháp <code>$tag$&lt;string_constant&gt;$tag$</code>. Thẻ trong hằng là tuỳ chọn và có thể không cần chỉ định, hằng còn được gọi là một vòng lặp chuỗi dollar kép.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm cách nào để hiện thị tất cả cơ sở dữ liệu trong Postgres?",
              "answer": "<p>Trong psql dùng lệnh <code>\\l</code> để xem tất cả cơ sở dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Xoá cơ sở dữ liệu trong Postgres?",
              "answer": "<p>Cú pháp xoá cơ sở dữ liệu như sau:\r\n\r\n``<code>sql\r\nDROP DATABASE database_name;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính ACID là gì?",
              "answer": "<p>ACID (viết tắt của Atomicity, Consistency, Isolation, Durability) là tính chất trong đó bao gồm tập hợp của 4 đặc tính khác nhau áp dụng cho một database transaction.\r<ul><li><strong>Atomicity</strong> quy định rằng tất các hành động của một transaction cần được thực hiện thành công hoặc ngược lại nếu có một hành động không được thực hiện thì sẽ không có bất cứ hành động nào khác được thực hiện thành công.</li></ul>\r<ul><li><strong>Consistency</strong> quy định tại bất kỳ thời điểm nào, trước hoặc sau một transaction được thực hiện dù lỗi hay không lỗi, thì cơ sở dữ liệu vẫn phải được giữ ở trạng thái hợp lệ (ví dụ dữ liệu phải phù hợp với các quy định được định nghĩa cho cơ sở dữ liệu).</li></ul>\r<ul><li><strong>Isolation</strong> quy định từng transaction khác nhau cần phải được thực hiện trong một môi trường độc lập, nếu có 2 transaction diễn ra tại cùng một thời điểm thì cần một cơ chế đảm bảo transaction này không ảnh hưởng tới transaction khác.</li></ul>\r<ul><li><strong>Durability</strong> quy định rằng khi transaction được diễn ra (thành công hoặc rollback lại khi có lỗi) thì sau đó dù có bất cứ sự cố nào diễn ra với cơ sở dữ liệu (mất điện, server tràn bộ nhớ...) thì khi được khôi phục lại thì dữ liệu được khôi phục sẽ giữ nguyên trạng thái trước khi có sự cố (đảm bảo không có bất cứ transaction trước đó không bị mất).</li></ul>\r\n\r\nPostgreSQL tuân theo các thuộc tính ACID.\r\n\r\n<img src=\"/interview-assets/acid.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích kiến trúc của Postgres?",
              "answer": "<p><ul><li>Kiến trúc Postgres theo mô hình client-server.</li></ul>\r<ul><li>Phía server bao gồm process manager (đơn vị quản lý tiến trình nền), query processer (trình xử lý truy vấn), utilities processer (trình xử lý đơn vị) và bộ nhớ chung, cùng nhay tạo nên thực thể Postgres cho phép truy cập dữ liệu. Ứng dụng client thực hiện việc kết nối với thực thể này và gửi yêu cầu xử lý dữ liệu đến dịch vụ. Client có thể là GUI hoặc ứng dụng web. Ứng dụng client phổ biến với Postgres là pgAdmin.</li></ul>\r\n\r\n<img src=\"/interview-assets/architecture.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh enable-debug là gì?",
              "answer": "<p>Lệnh enable-debug được dùng để cho pehsp biên dịch toàn bộ thư viện và ứng dụng. Khi nó được kích hoạt, các tiến trình hệ thống bị cản trở và làm file nhị phân tăng kích thước lên. Do đó, không nên bật nó trong môi trường production. Nó chủ yếu được dùng để debug cho các dev phát hiện ra vấn đề của họ.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách kiểm tra các hàng bị ảnh hưởng từ transactions trước đó?",
              "answer": "<p>Các tiêu chuẩn SQL nêu rõ rằng ba hiện tượng sau nên được ngăn chặn trong khi thực hiện các transactions đồng thời:\r<ul><li><strong>Dirty Reads</strong> điều này xảy ra khi một transaction tiến hành đọc dữ liệu mà chưa được commited. Ví dụ: transaction A cập nhập 1 dữ liệu, transaction B đọc dữ liệu sau khi A cập nhật xong. Nhưng vì lý do nào đó A không commit thành công, dự liệu quay trở lại trạng thái ban đầu, khi đó dữ liệu của B trở thành Dirty.</li></ul>\r<ul><li><strong>Nonrepeatable reads</strong> xảy ra khi một transaction đọc cùng 1 dữ liệu 2 lần nhưng lại nhận được giá trị khác nhau. Ví dụ: transaction A đọc 1 dữ liệu, transaction B cập nhật xóa dữ liệu đó. Nếu A đọc lại dữ liệu đó nó sẽ lấy các giá trị là khác nhau.</li></ul>\r<ul><li><strong>Phantom reads</strong> là rủi ro xảy ra với lệnh read có điều kiện. Ví dụ: giả sử transaction A đọc một tập hợp các dữ liệu đáp ứng một số điều kiện tìm kiếm, transaction B tạo ra một dữ liệu mới khớp với điều kiện được tìm kiếm cho transaction A. Nếu A thực hiện lại với điều kiện như vậy thì nó sẽ nhận dc một tập hợp các dữ liệu là không đồng nhất.</li></ul>\r\n\r\nCác tiêu chuẩn SQL xác định 4 cấp độ độc lập transactions để ứng phó với những hiện tượng này. 4 cấp độ theo tiêu chuẩn SQL là:\r<ul><li><strong>Read uncommitted:</strong> Khi transaction thực hiện ở mức này, các truy vấn vẫn có thể truy nhập vào các bản ghi đang được cập nhật bởi một transaction khác và nhận được dữ liệu tại thời điểm đó mặc dù dữ liệu đó chưa được commit. Nếu vì lý do nào đó transaction ban đầu rollback lại những cập nhật, dữ liệu sẽ trở lại giá trị cũ. Khi đó transaction thứ hai nhận được dữ liệu sai.</li></ul>\r<ul><li><strong>Read committed:</strong> Transaction sẽ không đọc được dữ liệu đang được cập nhật mà phải đợi đến khi việc cập nhật thực hiện xong. Vì thế nó tránh được dirty read như ở mức trên.</li></ul>\r<ul><li><strong>Repeatable read:</strong> Mức isolation này hoạt động nhứ mức read commit nhưng nâng thêm một nấc nữa bằng cách ngăn không cho transaction ghi vào dữ liệu đang được đọc bởi một transaction khác cho đến khi transaction khác đó hoàn tất.</li></ul>\r<ul><li><strong>Serializable:</strong> Đây là mức cao nhất của isolation levels, đảm bảo read và write locks. Trong trường hợp phép read có mệnh đề điều kiện, Serializable cũng cần đòi hỏi range lock để tránh phantom reads.</li></ul>\r\n\r\nBảng dưới đây mô tả rõ hơn:\r\n\r\n| Isolation level | Dirty Read | Phantom Read | Non-repeatable read |\r\n|-----------------|------------|--------------|---------------------|\r\n| Read Uncommitted | Có thể xảy ra | Có thể xảy ra | Có thể xảy ra |\r\n| Read Committed | Không thể xảy ra | Có thể xảy ra | Có thể xảy ra |\r\n| Repeatable Read | Không thể xảy ra | Có thể xảy ra | Không thể xảy ra |\r\n| Serializable | Không thể xảy ra | Không thể xảy ra | Không thể xảy ra |</p>",
              "level": "fresher"
            },
            {
              "question": "WAL là gì?",
              "answer": "<p>Write Ahead Logging là một tính năng làm tăng độ tin cậy của cơ sở dữ liệu bằng cách ghi log các thay đổi trước khi thực hiện bất kỳ thay đổi nào đối với cơ sở dữ liệu. Điều này đảm bảo rằng ta có đủ thông tin để khi sự cố cơ sở dữ liệu xảy ra(mất điện, process postmaster bị kill) ta có thể xác định xem công việc đã hoàn thành ở điểm nào và đưa ra điểm bắt đầu từ thời điểm nó bị ngừng hoạt động.</p>",
              "level": "fresher"
            },
            {
              "question": "Hạn chế của lệnh DROP TABLE?",
              "answer": "<p>Lệnh DROP TABLE xoá hoàn toàn dữ liệu một bảng cùng với cấu trúc của bảng đó. Trong trường hợp ta chỉ muốn xoá dữ liệu và dùng lại cấu trúc bảng để lưu trữ thì nó rất bất tiện, lời khuyền là dùng TRUNCATE cho những trường hợp này.</p>",
              "level": "fresher"
            },
            {
              "question": "Thực hiện tìm kiếm không phân biệt hoa thường trong Postgres?",
              "answer": "<p>Để thực hiện tìm kiếm không phân biệt hoá thường với các biểu thức chính thống trong Postgres, ta có thể dùng biểu thức POSIX <code>(~<em>)</code>. Ví dụ:\r\n\r\n``<code>sql\r\n&#39;interview&#39; ~</em> &#39;.<em>INTervIew.</em>&#39;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Backup cơ sở dữ liệu trong Postgres?",
              "answer": "<p>Ta có thể thực hiện bằng công cụ <strong>pg<em>dump</strong> để kết xuất tất cả nội dụng từ cơ sở dữ liệu vào một file duy nhất. Các bước.\r\n\r\nBước 1: Vào thư mục gốc của Postgres:\r\n\r\n``<code>text\r\nC:\\&gt;cd C:\\Program Files\\PostgreSQL\\10.0\\bin\r\n</code>`<code>\r\n\r\nBước 2: Thực thi chương trình pg</em>dump để kết xuất dữ liệu:\r\n\r\n</code>`<code>text\r\npg<em>dump -U postgres -W -F t sample</em>data &gt; C:\\Users\\admin\\pgbackup\\sample<em>data.tar\r\n</code>``\r\n\r\nCơ sở dữ liệu được kết xuất sẽ được lưu trữ ở file sample</em>data.tar ở vị trí cụ thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Postgres có hỗ trợ full-text search?",
              "answer": "<p>Full-text search (FTS) là một kỹ thuật tìm kiếm kết quả trên cơ sở dữ liệu chứa \"toàn bộ\" các kí tự (text) của một hoặc một số tài liệu, bài báo,…(document), hoặc là của website. Nó được hỗ trợ trong các hệ thống cơ sở dữ liệu nâng cao như SOLR hoặc ElasticSearch. Tuy nhiên, hiện tại Postgres cũng hỗ trợ khá cơ bản tính năng này.</p>",
              "level": "fresher"
            },
            {
              "question": "Truy vấn song song trong Postgres?",
              "answer": "<p>Là một tính năng được cung cấp trong PostgreSQL để đưa ra các kế hoạch truy vấn có khả năng khai thác nhiều bộ xử lý CPU để thực hiện các truy vấn nhanh hơn. \r\n\r\n<img src=\"/interview-assets/parallel_queries_in_PostgreSQL.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Triggers?",
              "answer": "<p>Trigger là một thủ tục SQL được thực thi ở phía server khi có một sự kiện như Insert, Delete, hay Update. Trigger là một loại stored procedure đặc biệt (không có tham số) được thực thi (execute) một cách tự động khi có một sự kiện thay đổi dữ liệu (data modification). Trigger được lưu trữ và quản lý trong Server DB, được dùng trong trường hợp ta muốn kiểm tra các ràng buộc toàn vẹn trong DB.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa commit và checkpoint?",
              "answer": "<p>Hành động commit đảm bảo sự nhất quán dữ liệu của transaction được duy trì và nó kết thúc transaction hiện tại. Commit thêm một bản ghi vào log và mô tả là COMMIT trong bộ nhớ. Trong khi đó, checkpoint là cơ chế đồng bộ dữ liệu cập nhật (đã commit) từ bộ nhớ đệm xuống dưới đĩa cứng.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "sql",
          "name": "Câu hỏi phỏng vấn SQL",
          "description": "",
          "questions": [
            {
              "question": "Cơ sở dữ liệu là gì?",
              "answer": "<p>Cơ sở dữ liệu là một tập hợp dữ liệu có tổ chức, được lưu trữ và truy xuất từ một hệ thống máy tính cục bộ hoặc từ xa. Cơ sở dữ liệu có thể rất lớn và phức tạp, những cơ sở dữ liệu như vậy được phát triển bằng cách sử dụng các phương pháp thiết kế và mô hình hóa cố định.</p>",
              "level": "middle"
            },
            {
              "question": "DBMS là gì?",
              "answer": "<p>DBMS là viết tắt của Database Management System. DBMS là một phần mềm hệ thống chịu tránh nhiệm tạo, truy xuất, chỉnh sửa và quản lý cơ sở dữ liệu. Nó đảm bảo rằng dữ liệu của ta sẽ được tổ chức nhất quán, và dễ dàng truy cập bằng cách dùng interface giữa cơ sở dữ liệu và người dùng hay phần mềm ứng dụng.</p>",
              "level": "middle"
            },
            {
              "question": "RDBMS là gì? Nó khác với DBMS như thế nào",
              "answer": "<p>RDBMS là viết tắt của Relational Database Management System. Điểm khác biệt của nó với DBMS là RDBMS lưu trữ dữ liệu ở dạng bảng, và các mối quan hệ được xác định là các trường chung giữa các bảng này. Các RDBMS phổ biến nhất hiện này có thể kể đến: MySQL, Oracle, PostgreSQL, Microsoft SQL Server,...\r\n\r\n<img src=\"/interview-assets/dbms_vs_rdbms.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "SQL là gì?",
              "answer": "<p>SQL là viết tắt của Structured Query Language. Nó là ngôn ngữ chuẩn cho các RDBMS. Nó đặc biệt hữu ích trong việc tổ chức dữ liệu bao gồm các thực thế và các mối quan hệ giữa các thực thế khác nhau của dữ liệu.</p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa SQL và MySQL?",
              "answer": "<p>SQL như đã nói ở trên là ngôn ngữ chuẩn cho truy vấn và quản lý cơ sở dữ liệu. Còn MySQL là một RDBMS giống như Postgres hay Oracle, được dùng để quản lý cơ sở dữ liệu SQL.\r\n\r\n<img src=\"/interview-assets/sql_vs_mysql.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Bảng và trường là gì?",
              "answer": "<p>Bảng là một tập hợp dữ liệu có tổ chức được lưu trữ dưới dạng hàng và cột. Các cột có thể được phân loại thành hàng dọc và hàng ngang. Các cột trong bảng được gọi là trường trong khi các hàng có thể được gọi là bản ghi.</p>",
              "level": "middle"
            },
            {
              "question": "Ràng buộc trong SQL?",
              "answer": "<p>Các ràng buộc được sử dụng để chỉ định các quy tắc liên quan đến dữ liệu trong bảng. Nó có thể được áp dụng cho một hoặc nhiều trường trong bảng SQL, khi bắt đầu tạo bảng hoặc sau khi tạo bằng lệnh <code>ALTER TABLE</code>. Các ràng buộc là:\r<ul><li><strong>NOT NULL</strong> - Không được thêm giá trị <code>NULL</code> vào một cột.</li></ul>\r<ul><li><strong>CHECK</strong> - Xác minh rằng tất cả các giá trị trong một trường thỏa mãn một điều kiện.</li></ul>\r<ul><li><strong>DEFAULT</strong> - Tự động gán giá trị mặc định nếu không có giá trị nào được chỉ định cho trường.</li></ul>\r<ul><li><strong>UNIQUE</strong> - Đảm bảo các giá trị được chèn vào trường là duy nhất trong bảng.</li></ul>\r<ul><li><strong>INDEX</strong> - Đánh chỉ mục một trường, giúp truy xuất nhanh hơn.</li></ul>\r<ul><li><strong>PRIMARY KEY</strong> - Định danh duy nhất cho từng bản ghi trong bảng.</li></ul>\r<ul><li><strong>FOREIGN KEY</strong> - Đảm bảo tính toàn vẹn tham chiếu cho một bản ghi trong bảng khác.</li></ul>\r\n\r\n## 8. Khoá chính là gì?\r\n\r\nRàng buộc <code>PRIMARY KEY</code> là định danh duy nhất cho mỗi hàng trong bảng. Nó phải chứa các giá trị <code>UNIQUE</code> và có ràng buộc <code>NOT NULL</code> ngầm.\r\n\r\nMột bảng trong SQL bị hạn chế nghiêm ngặt chỉ có một khóa chính, bao gồm một hoặc nhiều trường (cột).\r\n\r\n``<code>sql\r\nCREATE TABLE Students (   /<em> Create table with a single field as primary key </em>/\r\n   ID INT NOT NULL\r\n   Name VARCHAR(255)\r\n   PRIMARY KEY (ID)\r\n);\r\n\r\nCREATE TABLE Students (   /<em> Create table with multiple fields as primary key </em>/\r\n   ID INT NOT NULL\r\n   LastName VARCHAR(255)\r\n   FirstName VARCHAR(255) NOT NULL,\r\n   CONSTRAINT PK<em>Student\r\n   PRIMARY KEY (ID, FirstName)\r\n);\r\n\r\nALTER TABLE Students   /<em> Set a column as primary key </em>/\r\nADD PRIMARY KEY (ID);\r\nALTER TABLE Students   /<em> Set multiple columns as primary key </em>/\r\nADD CONSTRAINT PK</em>Student   /<em>Naming a Primary Key</em>/\r\nPRIMARY KEY (ID, FirstName);\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Ràng buộc UNIQUE là gì?",
              "answer": "<p>Ràng buộc <code>UNIQUE</code> đảm bảo rằng tất cả các giá trị trong một cột là khác nhau. Điều này cung cấp tính duy nhất cho (các) cột và giúp xác định từng hàng duy nhất. Không giống như khóa chính, có thể có nhiều ràng buộc <code>UNIQUE</code> được xác định trên mỗi bảng. Cú pháp code cho <code>UNIQUE</code> khá giống với cú pháp của <code>PRIMARY KEY</code> và có thể được sử dụng thay thế cho nhau.\r\n\r\n``<code>sql\r\nCREATE TABLE Students (   /<em> Create table with a single field as unique </em>/\r\n   ID INT NOT NULL UNIQUE\r\n   Name VARCHAR(255)\r\n);\r\n\r\nCREATE TABLE Students (   /<em> Create table with multiple fields as unique </em>/\r\n   ID INT NOT NULL\r\n   LastName VARCHAR(255)\r\n   FirstName VARCHAR(255) NOT NULL\r\n   CONSTRAINT PK<em>Student\r\n   UNIQUE (ID, FirstName)\r\n);\r\n\r\nALTER TABLE Students   /<em> Set a column as unique </em>/\r\nADD UNIQUE (ID);\r\nALTER TABLE Students   /<em> Set multiple columns as unique </em>/\r\nADD CONSTRAINT PK</em>Student   /<em> Naming a unique constraint </em>/\r\nUNIQUE (ID, FirstName);\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Khoá ngoại là gì?",
              "answer": "<p><code>FOREIGN KEY</code> bao gồm một hoặc một tập hợp các trường trong bảng tham chiếu đến <code>PRIMARY KEY</code> trong một bảng khác. Ràng buộc khóa ngoại đảm bảo tính toàn vẹn tham chiếu trong mối quan hệ giữa hai bảng.\r\n\r\nBảng có ràng buộc khóa ngoại được gắn nhãn là bảng con và bảng chứa khóa chính được gắn nhãn là bảng tham chiếu hoặc bảng cha.\r\n\r\n``<code>sql\r\nCREATE TABLE Students (   /<em> Create table with foreign key - Way 1 </em>/\r\n   ID INT NOT NULL\r\n   Name VARCHAR(255)\r\n   LibraryID INT\r\n   PRIMARY KEY (ID)\r\n   FOREIGN KEY (Library<em>ID) REFERENCES Library(LibraryID)\r\n);\r\n\r\nCREATE TABLE Students (   /<em> Create table with foreign key - Way 2 </em>/\r\n   ID INT NOT NULL PRIMARY KEY\r\n   Name VARCHAR(255)\r\n   LibraryID INT FOREIGN KEY (Library</em>ID) REFERENCES Library(LibraryID)\r\n);\r\n\r\nALTER TABLE Students   /<em> Add a new foreign key </em>/\r\nADD FOREIGN KEY (LibraryID)\r\nREFERENCES Library (LibraryID);\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "JOIN là gì? Liệt kê các kiểu JOIN?",
              "answer": "<p>Mệnh đề SQL Join được sử dụng để kết hợp các bản ghi (hàng) từ hai hoặc nhiều bảng trong cơ sở dữ liệu SQL dựa trên một cột có liên quan giữa hai bảng.\r\n\r\n<img src=\"/interview-assets/sql_join.jpg\" alt=\"\" />\r\n\r\nCó 4 kiểu JOIN trong SQL:\r<ul><li><strong>INNER JOIN</strong>: truy xuất các bảng ghi có giá trị phù hợp giữa hai bảng liên quan đến join. Đấy là kiểu join được sử dụng rộng rãi cho truy vấn.</li></ul>\r\n\r\n``<code>sql\r\nSELECT <em>\r\nFROM Table<em>A\r\nJOIN Table</em>B;\r\nSELECT </em>\r\nFROM Table<em>A\r\nINNER JOIN Table</em>B;\r\n</code>`<code>\r<ul><li><strong>LEFT (OUTER) JOIN</strong>: Truy xuất tất cả các bản ghi/hàng từ bên trái và các bản ghi/hàng phù hợp từ bảng bên phải.</li></ul>\r\n\r\n</code>`<code>sql\r\nSELECT <em>\r\nFROM Table<em>A A\r\nLEFT JOIN Table</em>B B\r\nON A.col = B.col;\r\n</code>`<code>\r<ul><li><strong>RIGHT (OUTER) JOIN</strong>: Truy xuất tất cả các bản ghi/hàng từ bên phải và các bản ghi/hàng phù hợp từ bảng bên trái.</li></ul>\r\n\r\n</code>`<code>sql\r\nSELECT </em>\r\nFROM Table<em>A A\r\nRIGHT JOIN Table</em>B B\r\nON A.col = B.col;\r\n</code>`<code>\r<ul><li><strong>FULL (OUTER) JOIN</strong>: Truy xuất tất cả các bản ghi có sự phù hợp trong bảng bên trái hoặc bên phải.</li></ul>\r\n\r\n</code>`<code>sql\r\nSELECT *\r\nFROM Table<em>A A\r\nFULL JOIN Table</em>B B\r\nON A.col = B.col;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Self-Join là gì?",
              "answer": "<p>Self JOIN à một trường hợp join thông thường trong đó một bảng được liên kết với chính nó dựa trên một số mối quan hệ giữa (các) cột của chính nó. Self-Join  sử dụng mệnh đề INNER JOIN hoặc LEFT JOIN và tên bí danh bảng để gán các tên khác nhau cho bảng trong truy vấn. \r\n\r\n``<code>sql\r\nSELECT A.emp<em>id AS &quot;Emp</em>ID&quot;,A.emp<em>name AS &quot;Employee&quot;,\r\nB.emp</em>id AS &quot;Sup<em>ID&quot;,B.emp</em>name AS &quot;Supervisor&quot;\r\nFROM employee A, employee B\r\nWHERE A.emp<em>sup = B.emp</em>id;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Cross-Join là gì?",
              "answer": "<p>Cross-Join có thể được định nghĩa là một tích descartes của hai bảng trong phép join. Bảng sau khi join có số hàng là tích descartes số hàng của hai bảng. Nếu mệnh đề WHERE được sử dụng trong cross-join thì truy vấn sẽ hoạt động giống như một INNER JOIN. \r\n\r\n``<code>sql\r\nSELECT stu.name, sub.subject \r\nFROM students AS stu\r\nCROSS JOIN subjects AS sub;\r\n</code>``\r\n\r\n<img src=\"/interview-assets/cross_join.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Đánh chỉ mục là gì? Giải thích các kiểu chỉ mục khác nhau?",
              "answer": "<p>Chỉ mục trong cơ sở dữ liệu là một dạng cấu trúc dữ liệu cung cấp chức năng tìm kiếm dữ liệu nhanh trong cột hay bảng. Nó tăng tốc độ chi truy cập dữ liệu từ cơ sở dữ liệu với chi phí bổ sung ghi và bộ nhớ để duy trì cấu trúc dữ liệu chỉ mục. \r\n\r\n``<code>sql\r\nCREATE INDEX index<em>name   /<em> Create Index </em>/\r\nON table</em>name (column<em>1, column</em>2);\r\nDROP INDEX index<em>name;   /<em> Drop Index </em>/\r\n</code>`<code>\r\n\r\nCác kiểu chỉ mục có thể được tạo cho các mục đích khác nhau:\r<ul><li><strong>Unique/Non-Unique Index</strong>: chỉ mục duy nhất là chỉ mục giúp duy trì tính toàn vẹn của dữ liệu bằng cách đảm bảo rằng không có hai hàng dữ liệu nào trong bảng có giá trị khoá giống nhau. Khi một chỉ mục duy nhất đã được xác định cho một bảng, tính duy nhất được thực thi bất cứ khi nào khoá được thêm vào hay thay đổi chỉ mục.</li></ul>\r\n\r\n</code>`<code>sql\r\nCREATE UNIQUE INDEX myIndex\r\nON students (enroll</em>no);\r\n</code>``\r\n\r\nNgược lại các chỉ mục không phải là duy nhất không được dùng để ràng bụooc các bảng mà chúng được liên kết với nhau. Các chỉ mục này được dùng để cải thiện hiệu suất truy vấn bằng cách duy trì thứ tự được sắp xếp của các giá trị dữ liệu được sắp xếp thường xuyên.\r<ul><li><strong>Clustered/Non-Clustered Index</strong>: </li></ul>\r\n\r\nClustered Index lưu trữ và sắp xếp dữ liệu vật lý trong bảng dựa trên các giá trị khóa của chúng. Các cột khóa này được chỉ định trong định nghĩa index. Mỗi bảng chỉ có duy nhất một Clusterd Index vì bản thân các dòng dữ liệu được lưu trữ và sắp xếp theo thứ tự vật lý dựa trên các cột trong loại Index này.\r\n\r\nNon-Clustered có một cấu trúc tách biệt với dữ liệu hàng trong bảng. Mỗi một index loại này chứa các giá trị của các cột khóa trong khai báo của index, và mỗi một bản ghi giá trị của key trong index này chứa một con trỏ tới dòng dữ liệu tương ứng của nó trong bảng.</p>",
              "level": "middle"
            },
            {
              "question": "Toàn vẹn dữ liệu là gì?",
              "answer": "<p>Toàn vẹn dữ liệu (data integrity) là sự dảm bảo tính nhất quán và chính xác của dữ liệu trong toàn bộ vòng đời của chúng. Nó là một khía cạnh quan trọng trong thiết kế, triển khai và sử dụng bất kỳ hệ thống nào lưu trữ, xử lý hoặc truy xuất dữ liệu. Nó cũng xác định các ràng buộc toàn vẹn để thực thi các quy tắc nghiệp vụ trên dữ liệu khi nó được nhập vào ứng dụng hoặc cơ sở dữ liệu.</p>",
              "level": "middle"
            },
            {
              "question": "Truy vấn là gì?",
              "answer": "<p>Truy vấn là một yêu cầu về dữ liệu hay thông tin từ một bảng hay là kết hợp nhiều bảng trong cơ sở dữ liệu. Một truy vấn có thể là truy vấn chọn lựa hoặc truy vấn hành động.\r\n\r\n``<code>sql\r\nSELECT fname, lname    /<em> select query </em>/\r\nFROM myDb.students\r\nWHERE student<em>id = 1;\r\n</code>`<code>\r\n</code>`<code>sql\r\nUPDATE myDB.students    /<em> action query </em>/\r\nSET fname = &#39;Captain&#39;, lname = &#39;America&#39;\r\nWHERE student</em>id = 1;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Truy vấn con là gì? Các kiểu truy vấn con?",
              "answer": "<p>Truy vấn con (còn được gọi truy vấn phụ hay truy vấn lồng nhau) là một truy vấn bên trong truy vấn SQL khác và được nhúng bên trong mệnh đề WHERE. Một truy vấn con được sử dụng để trả về dữ liệu mà sẽ được sử dụng trong truy vấn chính như là một điều kiện để thu hẹp dữ liệu được thu nhận. Ví dụ, ta cần lấy thông tin liên hệ của học sinh đã tham gia vào học môn toán:\r\n\r\n``<code>sql\r\nSELECT name, email, mob, address\r\nFROM myDb.contacts\r\nWHERE roll<em>no IN (\r\n   SELECT roll</em>no\r\n   FROM myDb.students\r\n   WHERE subject = &#39;Maths&#39;);\r\n</code>``\r\n\r\nCó hai loại truy vấn con là: <strong>tương quan</strong> và <strong>không tương quan</strong>:\r<ul><li>Một truy vấn con không tương quan là truy vấn con độc lập với truy vấn bên ngoài. Truy vấn con không tương quan được thi hành thi hành đầu tiên và một lần duy nhất cho toàn bộ câu lệnh. Kết quả của truy vấn con được điền vào truy vấn bên ngoài, và cuối cùng thi hành truy vấn bên ngoài.</li></ul>\r<ul><li>Một truy vấn con tương quan không độc lập với truy vấn bên ngoài. Một truy vấn con tương quan là một truy vấn con sử dụng các giá trị từ truy vấn bên ngoài trong mệnh đề WHERE của nó</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Lệnh SELECT là gì?",
              "answer": "<p>SELECT là hoạt động trong SQL dùng để lấy dữ liệu từ bảng. Dữ liệu trả về được lưu vào bảng kết quả, được gọi là <em>result-set</em>.\r\n\r\n``<code>sql\r\nSELECT * FROM myDB.students;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Các mệnh đề phổ biến được dùng với SELECT trong SQL?",
              "answer": "<p>Các mệnh đề thường được dùng với SELECT có thể kể đến:\r<ul><li><strong>WHERE</strong> dùng để chỉ định bản ghi cần lấy dựa trên một điều kiện cụ thể.</li></ul>\r<ul><li><strong>ORDER BY</strong> dùng để sắp xếp bảng ghi theo một thứ tự tăng dần hay giảm dần của một vài trường.</li></ul>\r\n\r\n``<code>sql\r\nSELECT *\r\nFROM myDB.students\r\nWHERE graduation_year = 2019\r\nORDER BY studentID DESC;\r\n</code>`<code>\r<ul><li><strong>GROUP BY</strong> dùng để nhóm các bản ghi có dữ liệu giống hệt nhau có thể được dùng cho kết hợp hay tổng hợp để tạo kết quả tóm tắt từ cơ sở dữ liệu.</li></ul>\r<ul><li><strong>HAVING</strong> dùng để lọc các bản ghi kết hợp với mệnh đề GROUP BY. Nó khác với WHERE ở cho WHERE không thể lọc cảc bản ghi đã tổng hợp.</li></ul>\r\n\r\n</code>`<code>sql\r\nSELECT COUNT(studentId), country\r\nFROM myDB.students\r\nWHERE country != &quot;INDIA&quot;\r\nGROUP BY country\r\nHAVING COUNT(studentID) &gt; 5;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Các lệnh UNION, MINUS và INTERSECT là gì?",
              "answer": "<p><ul><li>Toán tử <strong>UNION</strong> kết hợp và trả về tập kết quả được truy xuất bởi hai hoặc nhiều câu lệnh SELECT.</li></ul>\r<ul><li>Toán tử <strong>MINUS</strong> trong SQL được sử dụng để loại bỏ các bản sao khỏi tập kết quả thu được bởi truy vấn SELECT thứ hai khỏi tập kết quả thu được bởi truy vấn SELECT đầu tiên và sau đó trả về kết quả đã lọc từ truy vấn đầu tiên.</li></ul>\r<ul><li>Mệnh đề <strong>INTERSECT</strong> trong SQL kết hợp tập kết quả được tìm nạp bởi hai câu lệnh SELECT trong đó các bản ghi từ một khớp với nhau và sau đó trả về giao điểm này của các tập kết quả.</li></ul>\r\n\r\nMột số điều kiện nhất định cần phải được đáp ứng trước khi thực hiện một trong các câu lệnh trên trong SQL\r<ul><li>Mỗi câu lệnh SELECT trong mệnh đề phải có cùng số cột</li></ul>\r<ul><li>Các cột cũng phải có kiểu dữ liệu tương tự</li></ul>\r<ul><li>Các cột trong mỗi câu lệnh SELECT nhất thiết phải có cùng thứ tự</li></ul>\r\n\r\n``<code>sql\r\nSELECT name FROM Students   /<em> Fetch the union of queries </em>/\r\nUNION\r\nSELECT name FROM Contacts;\r\nSELECT name FROM Students   /<em> Fetch the union of queries with duplicates</em>/\r\nUNION ALL\r\nSELECT name FROM Contacts;\r\n</code>`<code>\r\n</code>`<code>sql\r\nSELECT name FROM Students   /<em> Fetch names from students </em>/\r\nMINUS     /<em> that aren&#39;t present in contacts </em>/\r\nSELECT name FROM Contacts;\r\n</code>`<code>\r\n</code>`<code>sql\r\nSELECT name FROM Students   /<em> Fetch names from students </em>/\r\nINTERSECT    /<em> that are present in contacts as well </em>/\r\nSELECT name FROM Contacts;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Con trỏ là gì? Cách dùng con trỏ?",
              "answer": "<p>Con trỏ cơ sở dữ liệu là một cấu trúc điều khiển cho phép duyệt các bảng ghi trong cơ sở dữ liệu. Ngoài ra, con trỏ còn tạo điều kiện thuận lợi cho việc xử lý sau khi duyệt, chẳng hạn như truy xuất, thêm và xóa các bản ghi cơ sở dữ liệu. Chúng có thể được xem như một con trỏ đến một hàng trong một tập hợp các hàng.\r\n\r\n#</p>",
              "level": "middle"
            },
            {
              "question": "Thực thể và quan hệ là gì?",
              "answer": "<p><strong>Entity (thực thể):</strong> Một thực thể có thể là một đối tượng trong thế giới thực, hữu hình hoặc vô hình, có thể dễ dàng xác định được. Ví dụ, trong cơ sở dữ liệu trường đại học, sinh viên, giáo sư, phòng ban và dự án có thể được coi là thực thể. Mỗi thực thể có một số thuộc tính liên quan cung cấp cho nó một định danh.\r\n\r\n<strong>Relationships (quan hệ):</strong> Mối quan hệ hoặc liên kết giữa các thực thể có liên quan gì đó với nhau. Ví dụ - Bảng của nhân viên trong cơ sở dữ liệu của công ty có thể được liên kết với bảng lương trong cùng một cơ sở dữ liệu.\r\n\r\n<img src=\"/interview-assets/Entities_and_Relationships.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Các kiểu quan hệ trong SQL?",
              "answer": "<p><ul><li><strong>One-to-One</strong>: là mối quan hệ giữa hai bảng trong đó mỗi bản ghi trong một bảng được liên kết với tối đa một bản ghi trong bảng kia.</li></ul>\r<ul><li><strong>One-to-Many</strong>: là mối quan hệ được sử dụng phổ biến nhất trong đó một bản ghi trong bảng được liên kết với nhiều bản ghi trong bảng khác.</li></ul>\r<ul><li><strong>Many-to-Many</strong>: được sử dụng trong các trường hợp khi cần có nhiều thực thể ở cả hai bên để tạo mối quan hệ.</li></ul>\r<ul><li><strong>Self-Referencing Relationships</strong>: được dùng khi một bảng cần tạo mối quan hệ với chính nó.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Alias trong SQL là gì?",
              "answer": "<p>Alias (bí danh) là một tính năng của SQL được hầu hết các RDBMS hỗ trợ. Nó là tên tạm thời được gán cho bảng hoặc cột, để phục vụ cho một truy vấn SQL cụ thể. Ngoài ra, bí danh có thể được sử dụng như một kỹ thuật xáo trộn để bảo mật tên thật của các trường cơ sở dữ liệu. Bí danh bảng còn được gọi là tên tương quan.\r\n\r\nAlias được biểu diễn bởi từ khoá AS, nhưng một số trường hợp có thể tạo tên bí danh mà không cần dùng nó. ví dụ:\r\n\r\n``<code>sql\r\nSELECT A.emp<em>name AS &quot;Employee&quot;  /<em> Alias using AS keyword </em>/\r\nB.emp</em>name AS &quot;Supervisor&quot;\r\nFROM employee A, employee B   /<em> Alias without AS keyword </em>/\r\nWHERE A.emp<em>sup = B.emp</em>id;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "View là gì?",
              "answer": "<p>View là một bảng ảo dựa trên tập kết quả từ câu lệnh SQL. Một view bao gồm hàng và cột như một bảng thực. Các trường trong view là các trường từ một hay nhiều bảng thực ở cơ sở dữ liệu.\r\n\r\n<img src=\"/interview-assets/SQL_View.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Normalization là gì?",
              "answer": "<p>Chuẩn hóa (normalization) là để giúp cho việc tổ chức dữ liệu trong cơ sở dữ liệu một cách hiệu quả. Có hai mục đích chính để chuẩn hóa dữ liệu:\r<ul><li>Giảm lượng dữ liệu dư thừa (ví dụ như lưu trữ cùng một dữ liệu trong 1 bảng)</li></ul>\r<ul><li>Đảm bảo độc lập dữ liệu (dữ liệu liên quan đặt trong cùng 1 bảng) </li></ul>\r\n\r\nCả 2 mục đích trên đều giúp giảm thiểu không gian sử dụng trong cơ sở dữ liệu và đảm bảo dữ liệu được lưu trữ một cách logic.</p>",
              "level": "middle"
            },
            {
              "question": "Denormalization là gì?",
              "answer": "<p>Denormalization là quá trình ngược lại với normalization, trong đó lược đồ dữ đã chuẩn hoá bị chuyển đổi thành một lược đồ có thông tin dư thừa. Hiệu suất được cải thiện bằng cách sử dụng bộ dự phòng và giữ cho dữ liệu dự phòng nhất quán.</p>",
              "level": "middle"
            },
            {
              "question": "Các dạng chuẩn hoá?",
              "answer": "<p>Dạng chuẩn hoá được dùng cho loại bỏ hay làm giảm sự dư thừa trong bảng cơ sở dữ liệu. Các dạng chuẩn hoá là:\r\n\r\n<strong>Dạng chuẩn hoá thứ nhất:</strong> Một bảng (quan hệ) được gọi là ở dạng chuẩn 1NF nếu và chỉ nếu toàn bộ các miền giá trị của các cột có mặt trong bảng (quan hệ) đều chỉ chứa các giá trị nguyên tố.\r\n\r\nNếu một quan hệ có chứa một thuộc tính tổng hợp hoặc nhiều giá trị, nó sẽ vi phạm dạng chuẩn thứ nhất. Chúng ta hãy xem bảng <code>student</code> sau đây. Mỗi học sinh trong bảng, có tên, địa chỉ của mình và những cuốn sách mà họ mượn từ thư viện công cộng.\r\n\r\n<div align=\"center\">\r\nStudents Table\r\n\r\n<img src=\"/interview-assets/Students_Table.png\" alt=\"\" />\r\n</div>\r\n\r\nTa có thể thấy trường <code>Books Issued</code> có nhiều một giá trị bảng ghi, và nó vi phạm dạng chuẩn hoá thứ nhất. Để giải quyết vấn đề này ta tách biệt các bản ghi trên mỗi book issued.\r\n\r\n<div align=\"center\">\r\nStudents Table (1st Normal Form)\r\n\r\n<img src=\"/interview-assets/Students_Table_(1st_Normal_Form).png\" alt=\"\" />\r\n</div>\r\n\r\n<strong>Dạng chuẩn hoá thứ hai:</strong>\r\n\r\nMột quan hệ là dạng chuẩn hoá thứ hai nếu nó thoả mãn điều kiện của dạng chuẩn hoá thứ nhất và các thuộc tính không khoá phải phụ thuộc hàm đầy đủ vào khoá chính.\r\n\r\n<strong>Ví dụ 1:</strong> Ta có thể thấy, bảng Students ở dạng 1NF có một khoá ở dạng [Student, Address] có thể xác định duy nhất tất cả các bản ghi trong bảng. Trường <code>Book Isued</code> (thuộc tính non-prime) phụ thuộc một phần vào trường <code>Student</code>. Do đó bảng không thuộc 2NF. Để chuyển nó thành dạng 2NF, chúng ta sẽ phân chia bảng thành hai bảng trong khi chỉ định thuộc tính PRIMARY KEY mới để xác định các bản ghi riêng lẻ trong bảng Students. FOREIGN KEY sẽ được đặt trên bảng khác để đảm bảo tính toàn vẹn của tham chiếu.\r\n\r\n<div align=\"center\">\r\nStudents Table (2nd Normal Form)\r\n\r\n<img src=\"/interview-assets/Students_Table_(2nd_Normal_Form).png\" alt=\"\" />\r\n</div>\r\n\r\n<div align=\"center\">\r\nBooks Table (2nd Normal Form)\r\n\r\n<img src=\"/interview-assets/Books_Table_(2nd_Normal_Form).png\" alt=\"\" />\r\n</div>\r\n\r\n<strong>Ví dụ 2:</strong> xem xét các phụ thuộc sau trong quan hệ R(W, X, Y, Z)\r\n\r\n``<code>text\r\nWX -&gt; Y    [W và X cùng quyết định Y] \r\nXY -&gt; Z    [X và Y cùng quyết định Z] \r\n</code>`<code>\r\n\r\nỞ đây, WX là khoá tiềm năng duy nhất và không có phụ thuộc vào phần nào, tức là bất kỳ tập con thích hợp nào của WX cũng không xác định thuộc tính non-prime trong mối quan hệ.\r\n\r\n<strong>Dạng chuẩn hoá thứ 3:</strong>\r\n\r\nMột quan hệ là dạng chuẩn hoá thứ ba nếu nó thoả mãn điều kiện của dạng chuẩn hoá thứ hai và các thuộc tính không khoá phải phụ thuộc trực tiếp vào khoá chính.\r\n\r\n<strong>Ví dụ:</strong> Xem xét bảng Student ở trên. Ta có thể thấy, bảng Student ở dạng 2NF có một khoá đơn </code>Student_ID<code> (PRIMARY KEY) có thể định danh duy nhất bản ghi trong bảng. Trường </code>Salutation<code> (thuộc tính non-prime), lại phụ thuộc vào trường </code>Student` nhiều hơn khoá chính. Do đó, bảng không phải dạng 3NF. Để chuyển nó về 3NF, ta sẽ tách bảng lần nữa thành hai phần trong khi chỉ định FOREIGN KEY mới cho định danh salutations với từng bản ghi trong bảng Student. PRIMARY KEY sẽ được đặt trên bảng Salutation để định danh cho từng bản ghi.\r\n\r\n<div align=\"center\">\r\nStudents Table (3rd Normal Form)\r\n\r\n<img src=\"/interview-assets/Students_Table(3rd_Normal_Form).png\" alt=\"\" />\r\n</div>\r\n\r\n<div align=\"center\">\r\nBooks Table (3rd Normal Form)\r\n\r\n<img src=\"/interview-assets/Books_Table_(2nd_Normal_Form).png\" alt=\"\" />\r\n</div>\r\n\r\n\r\n<div align=\"center\">\r\nSalutations Table (3rd Normal Form)\r\n\r\n<img src=\"/interview-assets/Salutations_Table_(3rd_Normal_Form).png\" alt=\"\" />\r\n</div></p>",
              "level": "middle"
            },
            {
              "question": "Lệnh TRUNCATE, DELETe và DROP là gì?",
              "answer": "<p>Lệnh DELETE để xoá hàng trong bảng.\r\n\r\n``<code>sql\r\nDELETE FROM Candidates\r\nWHERE CandidateId &gt; 1000;\r\n</code>`<code>\r\n\r\nLệnh TRUNCATe để xoá tất cả hàng trong bảng và giải phóng không gian của bảng.\r\n\r\n</code>`<code>sql\r\nTRUNCATE TABLE Candidates;\r\n</code>`<code>\r\n\r\nLệnh DROP để xoá một đối tượng từ cơ sở dữ liệu. Nếu xoá một bảng tất cả các hàng và cấu trúc của bảng đó sẽ bị xoá khỏi cơ sở dữ liệu.\r\n\r\n</code>`<code>sql\r\nDROP TABLE Candidates;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa lệnh DELETE và TRUNCATE là gì?",
              "answer": "<p>Lệnh <strong>TRUNCATE</strong> được sử dụng để xóa tất cả các hàng khỏi bảng và giải phóng không gian chứa bảng.\r\n\r\nLệnh <strong>DELETE</strong> chỉ xóa các hàng khỏi bảng dựa trên điều kiện được đưa ra trong mệnh đề WHERE hoặc xóa tất cả các hàng khỏi bảng nếu không có điều kiện nào được chỉ định. Nhưng nó không giải phóng không gian chứa bảng.</p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa lệnh DROP và TRUNCATE là gì?",
              "answer": "<p>Nếu một bảng bị DROP, tất cả những thứ liên quan đến các bảng đó cũng bị loại bỏ. Điều này bao gồm - các mối quan hệ được xác định trên bảng với các bảng khác, kiểm tra tính toàn vẹn và các ràng buộc, quyền truy cập và các trợ cấp khác mà bảng có. Để tạo và sử dụng lại bảng ở dạng ban đầu, tất cả các quan hệ, kiểm tra, ràng buộc, đặc quyền và quan hệ này cần phải được xác định lại. Tuy nhiên, nếu một bảng bị TRUNCATe, không có vấn đề nào ở trên tồn tại và bảng vẫn giữ được cấu trúc ban đầu của nó.</p>",
              "level": "middle"
            },
            {
              "question": "Các hàm Aggregate và Scalar là gì?",
              "answer": "<p>Một hàm Aggregate (tổng hợp) thực hiện các hoạt động trên một tập hợp các giá trị để trả về giá trị duy nhât. Hàm tổng hợp thường được sử dụng với mệnh đề GROUP BY và HAVING của câu lệnh SELECT. Sau đây là các hàm tổng hợp SQL được sử dụng rộng rãi:\r<ul><li><strong>AVG()</strong> - Tính giá trị trung bình của tập hợp giá trị..</li></ul>\r<ul><li><strong>COUNT()</strong> - Đếm số lượng bảng ghi trong bảng cụ thể hay view.</li></ul>\r<ul><li><strong>MIN()</strong> - Tính giá trị nhỏ nhất của tập hợp giá trị.</li></ul>\r<ul><li><strong>MAX()</strong> - Tính giá trị lớn nhất của tập hợp giá trị.</li></ul>\r<ul><li><strong>SUM()</strong> - Tính tổng giá trị của tập hợp giá trị.</li></ul>\r<ul><li><strong>FIRST()</strong> - Lấy phần tử đầu tiên trong tập hợp giá trị.</li></ul>\r<ul><li><strong>LAST()</strong> - Lấy phần tử cuối cùng trong tập hợp giá trị.</li></ul>\r\n\r\n<em>Lưu ý</em>: Tất cả hàm tổng hợp trên đều bỏ qua giá trị NULL ngoại trừ COUNT.\r\n\r\nMột hàm Scalar (vô hướng) trả về giá trị duy nhất dựa trên giá trị đầu vào. Các hàm scalar phổ biến.\r<ul><li><strong>LEN()</strong> - Tính toán độ dài của trường (cột) được cho.</li></ul>\r<ul><li><strong>UCASE()</strong> - Chuyển đổi tập hợp giá trị chuỗi sang ký tự in hoa.</li></ul>\r<ul><li><strong>LCASE()</strong> - Chuyển đổi tập hợp giá trị chuỗi sang ký tự in thường.</li></ul>\r<ul><li><strong>MID()</strong> - Trích xuất chuỗi con từ tập giá trị chuỗi trong bảng.</li></ul>\r<ul><li><strong>CONCAT()</strong> - Nối hai hay nhiều chuỗi.</li></ul>\r<ul><li><strong>RAND()</strong> - Tạo một tập hợp ngẫu nhiên các số có độ dài nhất định.</li></ul>\r<ul><li><strong>ROUND()</strong> - Làm tròn số cho một trường số.</li></ul>\r<ul><li><strong>NOW()</strong> - Trả về ngày giờ hiện tại.</li></ul>\r<ul><li><strong>FORMAT()</strong> - Đặt định dạng để hiển thị một tập hợp các giá trị.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Hàm người dùng định nghĩa là gì?",
              "answer": "<p>Các hàm do người dùng định nghĩa trong SQL giống như các hàm trong bất kỳ ngôn ngữ lập trình nào khác. Nó nhận các tham số, thực hiện các phép tính phức tạp và trả về một giá trị. Chúng được viết để sử dụng logic lặp đi lặp lại bất cứ khi nào được yêu cầu. Có hai loại hàm do người dùng định nghĩa trong SQL:\r<ul><li>Scalar Function: Như đã giải thích ở trên, hàm scalar do người dùng định nghĩa trả về một giá trị scalar.</li></ul>\r<ul><li>Table-Valued Function: trả về một giá trị dạng bảng.</li></ul>\r<ul><li><strong>Inline</strong>: trả về một bảng dựa trên câu lệnh SELECT duy nhất.</li></ul>\r<ul><li><strong>Multi-statement</strong>: trả về một tập kết quả dạng bảng, nhiều câu lệnh SELECT có thể dùng trong thân hàm.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "OLTP là gì?",
              "answer": "<p>OLTP là viết tắt của Online Transaction Processing, là một lớp ứng dụng phần mềm có khả năng hỗ trợ các chương trình hướng giao dịch. Một thuộc tính thiết yếu của hệ thống OLTP là khả năng duy trì tính đồng thời của nó. Để tránh các điểm lỗi đơn lẻ, hệ thống OLTP thường được phân tán. Các hệ thống này thường được thiết kế cho một số lượng lớn người dùng thực hiện các giao dịch ngắn hạn. Các truy vấn cơ sở dữ liệu thường đơn giản, yêu cầu thời gian phản hồi nhỏ hơn giây và trả về tương đối ít bản ghi. Dưới đây là cái nhìn rõ về hoạt động của hệ thống OLTP.\r\n\r\n<img src=\"/interview-assets/OLTP.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa OLTP và OLAP?",
              "answer": "<p><ul><li><strong>OLTP</strong> là viết tắt của Online Transaction Processing, là một loại ứng dụng phần mềm có khả năng hỗ trợ các chương trình hướng giao dịch. Một thuộc tính quan trọng của hệ thống OLTP là khả năng duy trì tính đồng thời của nó. Hệ thống OLTP thường tuân theo một kiến trúc phi tập trung để tránh các điểm lỗi đơn lẻ. Các hệ thống này thường được thiết kế cho một lượng lớn người dùng thực hiện các giao dịch ngắn hạn. Các truy vấn liên quan đến cơ sở dữ liệu như vậy thường đơn giản, cần thời gian phản hồi nhanh và trả về tương đối ít bản ghi. Số lượng giao dịch mỗi giây đóng vai trò như một thước đo hiệu quả cho các hệ thống như vậy.</li></ul>\r<ul><li><strong>OLAP</strong> là viết tắt của Online Analytical Processing, một loại chương trình phần mềm được đặc trưng bởi tần suất giao dịch trực tuyến tương đối thấp. Các truy vấn thường quá phức tạp và liên quan đến nhiều tập hợp. Đối với hệ thống OLAP, thước đo hiệu quả phụ thuộc nhiều vào thời gian phản hồi. Các hệ thống như vậy được sử dụng rộng rãi để khai thác dữ liệu hoặc duy trì dữ liệu lịch sử, tổng hợp, thường là trong các lược đồ đa chiều.</li></ul>\r\n\r\n<img src=\"/interview-assets/differences_between_OLTP_and_OLAP.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Collation là gì?",
              "answer": "<p>Collation - đối chiếu - đề cập đến một tập hợp các quy tắc xác định cách dữ liệu được sắp xếp và so sánh. Các quy tắc xác định chuỗi ký tự chính xác được sử dụng để sắp xếp dữ liệu ký tự. Nó kết hợp các tùy chọn để chỉ định độ phân biệt chữ hoa chữ thường, dấu trọng âm, kiểu ký tự kana và độ rộng ký tự. Dưới đây là các loại collation khác nhau:\r<ul><li><strong>Case sensitivity</strong>: A và a là khác nhau.</li></ul>\r<ul><li><strong>Accent sensitivity</strong>: a và á là khác nhau.</li></ul>\r<ul><li><strong>Kana sensitivity</strong>: Các ký tự kana của Nhật Bản như Hiragana và Katakana là khác nhau.</li></ul>\r<ul><li><strong>Width sensitivity</strong>: Cùng một ký tự được biểu thị bằng byte đơn (half-width) và byte kép (full-width) là khác nhau.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Stored Procedure là gì?",
              "answer": "<p>Stored procedure là một chương trình con có sẵn cho các ứng dụng truy cập vào hệ thống quản lý cơ sở dữ liệu quan hệ (RDBMS). Một stored procedure cung cấp một lớp bảo mật quan trọng giữa user và database. Những người dùng cuối không thể thực thi được một số tác vụ quan trọng trong database, bằng cách cung cấp các stored procedure, người dùng cuối có thể thoải moái sử dụng để thực thi các tác vụ này mà không cần quan tâm bên dưới đang làm gì. \r\n\r\n``<code>sql\r\nDELIMITER $$\r\nCREATE PROCEDURE FetchAllStudents()\r\nBEGIN\r\nSELECT *  FROM myDB.students;\r\nEND $$\r\nDELIMITER ;\r\n</code>``\r\n\r\n<img src=\"/interview-assets/Stored_Procedure.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Stored Procedure đệ quy là gì?",
              "answer": "<p>Một stored procedure tự gọi chính nó cho đến khi tới giới hạn gọi là stored procedure đệ quy. Hàm đệ quy này giúp người lập trình triển khai cùng một bộ code nhiều lần khi được yêu cầu. Một số ngôn ngữ lập trình SQL giới hạn độ sâu đệ quy để ngăn một vòng lặp vô hạn các lệnh gọi procedure gây ra stack overflow, điều này làm chậm hệ thống và có thể dẫn đến sự cố hệ thống.\r\n\r\n``<code>sql\r\nDELIMITER $$     /<em> Set a new delimiter =&gt; $$ </em>/\r\nCREATE PROCEDURE calctotal( /<em> Create the procedure </em>/\r\n   IN number INT,   /<em> Set Input and Ouput variables </em>/\r\n   OUT total INT\r\n) BEGIN\r\nDECLARE score INT DEFAULT NULL;   /<em> Set the default value =&gt; &quot;score&quot; </em>/\r\nSELECT awards FROM achievements   /<em> Update &quot;score&quot; via SELECT query </em>/\r\nWHERE id = number INTO score;\r\nIF score IS NULL THEN SET total = 0;   /<em> Termination condition </em>/\r\nELSE\r\nCALL calctotal(number+1);   /<em> Recursive call </em>/\r\nSET total = total + score;   /<em> Action after recursion </em>/\r\nEND IF;\r\nEND $$     /<em> End of procedure </em>/\r\nDELIMITER ;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Làm thế nào để tạo một bảng trống có cấu trúc giống hệt một bảng khác?",
              "answer": "<p>Việc tạo các bảng trống có cùng cấu trúc có thể được thực hiện một cách thông minh bằng cách tìm nạp các bản ghi của một bảng vào một bảng mới bằng cách sử dụng toán tử INTO trong khi sửa mệnh đề WHERE là sai đối với tất cả các bản ghi. Do đó, SQL tạo bảng mới với cấu trúc trùng lặp để chấp nhận các bản ghi đã tìm nạp nhưng vì không có bản ghi nào được tìm nạp do mệnh đề WHERE đang hoạt động nên không có gì được chèn vào bảng mới.\r\n\r\n``<code>sql\r\nSELECT * INTO Students_copy\r\nFROM Students WHERE 1 = 2;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Pattern Matching trong SQL?",
              "answer": "<p>SQL pattern matching cung cấp mẫu tìm kiếm dữ liệu nếu bạn không có manh mối nào về từ cần tìm. Loại truy vấn SQL này sử dụng các ký tự đại diện để khớp với một mẫu chuỗi, thay vì viết từ chính xác. Toán tử LIKE được sử dụng cùng với SQL Wildcards để tìm nạp thông tin cần thiết. \r\n\r\n<strong>Sử dụng % cho tìm kiếm đơn giản</strong>\r\n\r\nKý tự đại diện% khớp với nhiều ký tự thuộc bất kỳ loại nào và có thể được sử dụng để xác định ký tự đại diện cả trước và sau mẫu. Tìm kiếm một sinh viên trong cơ sở dữ liệu của bạn với tên bắt đầu bằng chữ K:\r\n\r\n``<code>sql\r\nSELECT <em>\r\nFROM students\r\nWHERE first<em>name LIKE &#39;K%&#39;\r\n</code>`<code>\r\n\r\n<strong>Sử dụng từ khoá NOT</strong>\r\n\r\nSử dụng từ khóa NOT để chọn các bản ghi không khớp với mẫu. Truy vấn này trả về tất cả các sinh viên có tên không bắt đầu bằng K.\r\n\r\n</code>`<code>sql\r\nSELECT </em>\r\nFROM students\r\nWHERE first</em>name NOT LIKE &#39;K%&#39;\r\n</code>`<code>\r\n\r\n<strong>Sử dụng % hai lần</strong>\r\n\r\nTìm kiếm bất kỳ sinh viên nào trong cơ sở dữ liệu có K trong tên.\r\n\r\n</code>`<code>sql\r\nSELECT <em>\r\nFROM students\r\nWHERE first<em>name LIKE &#39;%K%&#39;\r\n</code>`<code>\r\n\r\n<strong>Sử dụng </em> để chỉ định vị trí cụ thể</strong>\r\n\r\nKý tự đại diện <em> khớp chính xác với một ký tự thuộc bất kỳ loại nào. Nó có thể được sử dụng cùng với% ký tự đại diện. Truy vấn này tìm nạp tất cả học sinh có chữ cái K ở vị trí thứ ba trong tên của họ.\r\n\r\n</code>`<code>sql\r\nSELECT </em>\r\nFROM students\r\nWHERE first</em>name LIKE &#39;_<em>K%&#39;\r\n</code>`<code>\r\n\r\n<strong>Chỉ định độ dài cụ thể</strong>\r\n\r\nKý tự đại diện </em> đóng một vai trò quan trọng như một giới hạn khi nó khớp chính xác với một ký tự. Nó giới hạn độ dài và vị trí của các kết quả phù hợp. Ví dụ \r\n\r\n</code>`<code>sql\r\nSELECT <em>   /</em> Matches first names with three or more letters <em>/\r\nFROM students\r\nWHERE first<em>name LIKE &#39;</em>_<em>%&#39;\r\n\r\nSELECT </em>   /<em> Matches first names with exactly four characters </em>/\r\nFROM students\r\nWHERE first</em>name LIKE &#39;____&#39;\r\n</code>``</p>",
              "level": "middle"
            }
          ]
        }
      ]
    },
    {
      "id": "devops",
      "name": "DevOps",
      "icon": "settings",
      "color": "#9c27b0",
      "subcategories": [
        {
          "id": "docker",
          "name": "Câu hỏi phỏng vấn Docker",
          "description": "",
          "questions": [
            {
              "question": "Giải thích vòng đời Docker từ lúc tạo file docker-compose tới khi build image và chạy container?",
              "answer": "<p>Vòng đời Docker từ việc tạo file cấu hình đến khi có container đang chạy bao gồm các giai đoạn chính sau:\r\n\r\n<img src=\"/interview-assets/Docker_Lifecycle_Workflow.png\" alt=\"Docker Lifecycle Workflow\" />\r\n\r\n<strong>1. Giai đoạn Tạo file docker-compose.yml</strong>\r\n\r\nĐây là bước đầu tiên trong quy trình, nơi bạn định nghĩa kiến trúc ứng dụng của mình:\r\n\r\n``<code>yaml\r\nversion: '3.8'\r\nservices:\r\n  web:\r\n    build: ./frontend\r\n    ports:\r\n      - \"3000:3000\"\r\n    depends_on:\r\n      - api\r\n  api:\r\n    build: ./backend\r\n    ports:\r\n      - \"8080:8080\"\r\n    environment:\r\n      - DB_HOST=database\r\n    depends_on:\r\n      - database\r\n  database:\r\n    image: postgres:14\r\n    environment:\r\n      - POSTGRES_PASSWORD=secret\r\n    volumes:\r\n      - db_data:/var/lib/postgresql/data\r\nvolumes:\r\n  db_data:\r\n</code>``\r\n\r\nFile này định nghĩa:\r\n<ul><li><strong>Services</strong>: Các container sẽ chạy (web, api, database)</li></ul>\r\n<ul><li><strong>Build context</strong>: Đường dẫn đến Dockerfile cho mỗi service</li></ul>\r\n<ul><li><strong>Port mapping</strong>: Ánh xạ cổng từ host vào container</li></ul>\r\n<ul><li><strong>Dependencies</strong>: Thứ tự khởi động các service</li></ul>\r\n<ul><li><strong>Environment variables</strong>: Biến môi trường cho container</li></ul>\r\n<ul><li><strong>Volumes</strong>: Lưu trữ dữ liệu persistent</li></ul>\r\n\r\n<strong>2. Giai đoạn Tạo Dockerfile cho từng service</strong>\r\n\r\nMỗi service cần có Dockerfile riêng để định nghĩa cách build image:\r\n\r\n``<code>dockerfile\r\n# Dockerfile cho frontend\r\nFROM node:18-alpine\r\nWORKDIR /app\r\nCOPY package*.json ./\r\nRUN npm install\r\nCOPY . .\r\nEXPOSE 3000\r\nCMD [\"npm\", \"start\"]\r\n</code>``\r\n\r\n``<code>dockerfile\r\n# Dockerfile cho backend\r\nFROM python:3.9-slim\r\nWORKDIR /app\r\nCOPY requirements.txt .\r\nRUN pip install -r requirements.txt\r\nCOPY . .\r\nEXPOSE 8080\r\nCMD [\"python\", \"app.py\"]\r\n</code>``\r\n\r\n<strong>3. Giai đoạn Build Image với docker-compose build</strong>\r\n\r\nKhi chạy lệnh <code>docker-compose build</code>, quá trình sau sẽ diễn ra:\r\n\r\n``<code>bash\r\ndocker-compose build\r\n</code>``\r\n\r\n<strong>Quy trình build từng layer:</strong>\r\n\r\n<ul><li><strong>Layer 1 - Base Image</strong>: Docker tải base image (node:18-alpine, python:3.9-slim)</li></ul>\r\n<ul><li><strong>Layer 2 - Working Directory</strong>: Tạo thư mục làm việc trong container</li></ul>\r\n<ul><li><strong>Layer 3 - Dependencies</strong>: Copy file package.json/requirements.txt và cài đặt dependencies</li></ul>\r\n<ul><li><strong>Layer 4 - Application Code</strong>: Copy toàn bộ source code vào container</li></ul>\r\n<ul><li><strong>Layer 5 - Configuration</strong>: Cấu hình port, environment, và command để chạy</li></ul>\r\n\r\n<img src=\"/interview-assets/Docker_Image_Layers.png\" alt=\"Docker Image Layers\" />\r\n\r\n<strong>Docker Layer Caching:</strong> Docker sử dụng cơ chế cache thông minh:\r\n<ul><li>Nếu một layer không thay đổi (ví dụ: base image hoặc dependencies), Docker sẽ sử dụng lại layer đã cache</li></ul>\r\n<ul><li>Chỉ build lại các layer bị thay đổi và các layer phía sau nó</li></ul>\r\n<ul><li>Điều này giúp tăng tốc đáng kể quá trình build</li></ul>\r\n\r\n<strong>4. Giai đoạn Tạo Container từ Image</strong>\r\n\r\nSau khi build xong image, sử dụng lệnh <code>docker-compose up</code> để tạo và chạy container:\r\n\r\n``<code>bash\r\ndocker-compose up -d\r\n</code>``\r\n\r\nQuá trình tạo container:\r\n\r\n<ul><li><strong>Create Container</strong>: Docker tạo container từ image đã build</li></ul>\r\n<ul><li><strong>Network Setup</strong>: Tạo network riêng cho các container có thể giao tiếp với nhau</li></ul>\r\n<ul><li><strong>Volume Mount</strong>: Gắn volumes để lưu trữ dữ liệu persistent</li></ul>\r\n<ul><li><strong>Port Binding</strong>: Ánh xạ cổng từ container ra host</li></ul>\r\n<ul><li><strong>Environment Variables</strong>: Inject biến môi trường vào container</li></ul>\r\n\r\n<strong>5. Giai đoạn Chạy Container</strong>\r\n\r\nContainer lifecycle khi chạy:\r\n\r\n<ul><li><strong>Starting</strong>: Container khởi động theo thứ tự dependencies (database → api → web)</li></ul>\r\n<ul><li><strong>Running</strong>: Container chạy CMD đã định nghĩa trong Dockerfile</li></ul>\r\n<ul><li><strong>Health Check</strong>: Docker kiểm tra health status của container</li></ul>\r\n<ul><li><strong>Logging</strong>: Logs được thu thập và có thể xem qua <code>docker-compose logs</code></li></ul>\r\n\r\n<strong>Các lệnh quản lý container:</strong>\r\n\r\n``<code>bash\r\n# Xem trạng thái container\r\ndocker-compose ps\r\n\r\n# Xem logs\r\ndocker-compose logs -f service_name\r\n\r\n# Dừng container\r\ndocker-compose stop\r\n\r\n# Khởi động lại\r\ndocker-compose restart\r\n\r\n# Dừng và xóa container\r\ndocker-compose down\r\n\r\n# Xóa cả volumes\r\ndocker-compose down -v\r\n</code>``\r\n\r\n<strong>6. Quá trình Communication giữa các Container</strong>\r\n\r\nDocker Compose tự động tạo một network bridge cho phép:\r\n<ul><li>Container có thể gọi nhau qua service name (ví dụ: api có thể kết nối database qua hostname \"database\")</li></ul>\r\n<ul><li>DNS resolution tự động cho các service</li></ul>\r\n<ul><li>Isolation giữa các ứng dụng khác nhau</li></ul>\r\n\r\n<strong>Tóm tắt toàn bộ workflow:</strong>\r\n\r\n<ol>\r\n<li><strong>Định nghĩa</strong>: Tạo docker-compose.yml và Dockerfile</li>\r\n<li><strong>Build</strong>: <code>docker-compose build</code> → Tạo images từ Dockerfile theo layers</li>\r\n<li><strong>Create</strong>: <code>docker-compose up</code> → Tạo containers, networks, volumes</li>\r\n<li><strong>Run</strong>: Containers khởi động và chạy ứng dụng</li>\r\n<li><strong>Manage</strong>: Quản lý lifecycle với các lệnh docker-compose</li>\r\n</ol>\r\n\r\n<strong>Best Practices:</strong>\r\n<ul><li>Sử dụng <code>.dockerignore</code> để loại trừ file không cần thiết</li></ul>\r\n<ul><li>Sắp xếp Dockerfile theo thứ tự: dependencies trước, code sau (để tối ưu cache)</li></ul>\r\n<ul><li>Sử dụng multi-stage builds để giảm kích thước image</li></ul>\r\n<ul><li>Định nghĩa health checks trong docker-compose.yml</li></ul>\r\n<ul><li>Sử dụng volumes cho dữ liệu persistent</li></ul>\r\n<ul><li>Set resource limits (CPU, memory) để tránh container chiếm hết tài nguyên</li></ul>\r\n\r\n``<code>yaml\r\nservices:\r\n  api:\r\n    build: ./backend\r\n    deploy:\r\n      resources:\r\n        limits:\r\n          cpus: '0.5'\r\n          memory: 512M\r\n    healthcheck:\r\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health\"]\r\n      interval: 30s\r\n      timeout: 10s\r\n      retries: 3\r\n</code>``\r\n\r\nHiểu rõ vòng đời này giúp developer debug hiệu quả hơn và tối ưu hóa quá trình development và deployment.</p>",
              "level": "senior"
            },
            {
              "question": "Giải thích về container trong Docker?",
              "answer": "<p><ul><li>Nói một cách đơn giản nhất, container bao gồm các ứng dụng và tất cả các phụ thuộc của chúng.</li></ul>\r<ul><li>Chúng chia sẻ nhân và tài nguyên hệ thống với các container khác và chạy như các hệ thống biệt lập trong hệ điều hành chủ.</li></ul>\r<ul><li>Mục đích chính của container là loại bỏ sự phụ thuộc vào cơ sở hạ tầng trong khi triển khai và chạy các ứng dụng. Điều này có nghĩa là bất kỳ ứng dụng được chứa trong container nào cũng có thể chạy trên bất kỳ nền tảng nào bất kể cơ sở hạ tầng đang được sử dụng bên dưới.</li></ul>\r<ul><li>Về mặt kỹ thuật, chúng chỉ là các phiên bản runtime của docker image.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Docker image là gì?",
              "answer": "<p>Chúng là các gói thực thi (được đóng gói với code ứng dụng và phần phụ thuộc, gói phần mềm, v.v.) nhằm mục đích tạo container. Docker image có thể được triển khai cho bất kỳ môi trường docker nào và các container có thể được xoay ở đó để chạy ứng dụng.</p>",
              "level": "fresher"
            },
            {
              "question": "DockerFile là gì?",
              "answer": "<p>Nó là một file văn bản có tất cả các lệnh cần được chạy để xây dựng một image nhất định.\r\n\r\n<img src=\"/interview-assets/Docker_File.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Chức năng của hypervisor là gì?",
              "answer": "<p>Hypervisor là một phần mềm giúp cho quá trình ảo hóa diễn ra vì nó đôi khi được gọi là Virtual Machine Monitor. Điều này phân chia tài nguyên của hệ thống máy chủ và phân bổ chúng cho từng môi trường khách được cài đặt.\r\n\r\n<img src=\"/interview-assets/Hypervisor.png\" alt=\"\" />\r\n\r\nĐiều này có nghĩa là nhiều hệ điều hành có thể được cài đặt trên một hệ thống máy chủ duy nhất. Hypervisor có 2 loại:\r\n\r\n1. Native Hypervisor: Loại này còn được gọi là Bare-metal Hypervisor và chạy trực tiếp trên hệ thống máy chủ bên dưới, điều này cũng đảm bảo quyền truy cập trực tiếp vào phần cứng máy chủ, đó là lý do tại sao nó không yêu cầu hệ điều hành cơ bản.\r\n2. Hosted Hypervisor: Loại này sử dụng hệ điều hành máy chủ cơ bản đã được cài đặt hệ điều hành hiện có.</p>",
              "level": "fresher"
            },
            {
              "question": "Docker compose là gì?",
              "answer": "<p>Nó là một file YAML bao gồm tất cả các chi tiết liên quan đến các dịch vụ, mạng và khối lượng khác nhau cần thiết để thiết lập ứng dụng dựa trên Docker. Vì vậy, docker-compose được sử dụng để tạo nhiều container, lưu trữ chúng và thiết lập giao tiếp giữa chúng. Với mục đích giao tiếp giữa các container, các cổng được tiếp xúc bởi từng container.</p>",
              "level": "fresher"
            },
            {
              "question": "Docker namespace là gì?",
              "answer": "<p>Namespace về cơ bản là một tính năng của Linux đảm bảo phân vùng tài nguyên hệ điều hành theo cách loại trừ lẫn nhau. Điều này hình thành khái niệm cốt lõi đằng sau quá trình container hóa khi namespace giới thiệu một lớp cách ly giữa các container. Trong docker, namespace đảm bảo rằng các container có thể di động và chúng không ảnh hưởng đến máy chủ bên dưới. Ví dụ về các loại namespace hiện đang được Docker hỗ trợ - PID, Mount, User, Network, IPC.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách hiển thị trạng thái của tất cả docker container bằng dòng lệnh?",
              "answer": "<p>``<code>\r\ndocker ps -a\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Dữ liệu được lưu trữ trong container sẽ bị mất trong những trường hợp nào?",
              "answer": "<p>Dữ liệu của container vẫn ở trong đó cho đế khi bạn xóa container.</p>",
              "level": "fresher"
            },
            {
              "question": "Docker image registry?",
              "answer": "<p>Theo thuật ngữ đơn giản, Docker image registry là một khu vực lưu trữ các docker image. Thay vì chuyển đổi các ứng dụng thành container mỗi lần, một nhà phát triển có thể sử dụng trực tiếp các iamge được lưu trữ trong registry.\r\nDocker image registry có thể là công khai hoặc riêng tư và DockerHub là tổ chức đăng ký công khai phổ biến và nổi tiếng nhất hiện có.</p>",
              "level": "fresher"
            },
            {
              "question": "Các thành phần trong Docker?",
              "answer": "<p>Có 3 thành phần Docker là:\r\n\r\n<em> <strong>Docker Client:</strong> Thành phần này sẽ thực hiện hành động \"build\" và \"run\" nhằm mục đích mở ra giao tiếp với docket host.\r\n</em> <strong>Docker Host:</strong> Thành phần này gồm daemon chính của docker, các host container và image của chúng. Daemon thiết lập một kết nối đến docker registry.\r<ul><li><strong>Docker Registry:</strong> Thành phần này lưu trữ docker image. Nó có thể là công khai hoặc riêng tư. Các registry công khai nổi tiếng là Docker Hub và Docker Cloud.</li></ul>\r\n\r\n<img src=\"/interview-assets/docker_components.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Docker Hub là gì?",
              "answer": "<p><ul><li>Là một nền tảng đám mây được cung cấp bởi Docker cho phép lưu trữ công khai image của Docker đồng thời cho phép tìm kiếm và chia sẻ với người khác.</li></ul>\r<ul><li>Image có thể được đẩy lên Docker Hub bằng câu lệnh <code>docker push</code>.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh để export một docket image như một archive?",
              "answer": "<p>Cú pháp đó là:\r\n\r\n``<code>\r\ndocker save -o &lt;exported_name&gt;.tar &lt;container-name&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh để import một Docker image đến một Docker host khác?",
              "answer": "<p>``<code>\r\ndocker load -i &lt;export<em>image</em>name&gt;.tar\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể xoá container bị tạm dừng khỏi Docker không?",
              "answer": "<p>Không thể! Container phải bị dừng trạng thái trước khi ta có thể xoá chúng.</p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh kiểm tra phiên bản Docker client và server?",
              "answer": "<p>Để kiểm tra tất cả không tin phiên bản client và server là:\r\n\r\n``<code>\r\ndocker version\r\n</code>`<code>\r\n\r\nĐể lấy chỉ phiên bản server, ta có thể chạy:\r\n\r\n</code>`<code>\r\ndocker version --format &#39;{{.Server.Version}}&#39;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa ảo hoá (virtualization) và containerization?",
              "answer": "<p>| virtualization | containerization |\r\n|-|-|\r\n| Nó giúp chạy nhiều hệ điều hành trên phần cứng của một server vật lý | Nó giúp triển khai nhiều ứng dụng trên cùng hệ điều hành trên một máy ảo hoặc server |\r\n| Hypervisors cung cấp các máy ảo tổng thể cho hệ điều hành khách | Container đảm bảo cung cấp môi trường/không gian người dùng biệt lập để chạy các ứng dụng. Mọi thay đổi được thực hiện trong container không phản ánh trên server hoặc các container khác của cùng server |\r\n| Các máy ảo này tạo thành một phần trừu tượng của lớp phần cứng hệ thống, điều này có nghĩa là mỗi máy ảo trên host hoạt động giống như một máy vật lý | Container tạo thành sự trừu tượng của lớp ứng dụng có nghĩa là mỗi container tạo thành một ứng dụng khác nhau |</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa lớp COPY và ADD trong Dockerfile?",
              "answer": "<p>Cả hai có chức năng giống nhau, nhưng <code>COPY</code> được ưa thích hơn vì mức độ minh bạch cao hơn <code>ADD</code>.\r\n\r\n<code>COPY</code> cung cấp các hỗ trợ cơ bản cho sao chép file cục bộ trong khi <code>ADD</code> cung cấp tính năng bổ sung như URL từ xa và hỗ trợ xuất <code>tar</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Container có thể tự khởi động lại?",
              "answer": "<p>Có, chỉ có thể thực hiện được khi đang sử dụng một số chính sách do docker xác định trong khi sử dụng lệnh <code>run</code> của docker. Sau đây là các chính sách hiện có:\r\n1. <strong>Off</strong>: container sẽ không được khởi động lại trong trường hợp nó bị dừng hoặc bị lỗi.\r\n2. <strong>Un-failure</strong>: Ở đây, container chỉ khởi động lại khi nó gặp lỗi không liên quan đến người dùng.\r\n3. <strong>Unless-stop</strong>: Sử dụng chính sách này, đảm bảo rằng container chỉ có thể khởi động lại khi người dùng thực hiện lệnh để dừng nó.\r\n4. <strong>Always</strong>: Bất kể lỗi hay dừng, container luôn được khởi động lại trong loại chính sách này.\r\n\r\nCác chính sách này có thể dùng như sau:\r\n\r\n``<code>\r\ndocker run -dit — restart [restart-policy-value] [container_name]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Docker Image và Layer?",
              "answer": "<p>Image: được xây dựng từ một loạt các lớp instruction. Một image tương ứng với container và được sử dụng để vận hành nhanh chóng do cơ chế lưu vào bộ nhớ đệm của mỗi bước.\r\n\r\nLayer: Mỗi layer tương ứng với một instruction của image của Dockerfile. Nói đơn giản hơn layer còn là image nhưng nó là image của instruction.\r\n\r\nVí dụ:\r\n\r\n``<code>\r\nFROM ubuntu:18.04 \r\nCOPY . /myapp \r\nRUN make /myapp \r\nCMD python /myapp/app.py \r\n</code>``\r\n\r\nQuan trọng hơn, mỗi layer là một tập khác cảu layer trước đó.\r\n\r\nKết quả xây dựng file docker này là một image. Trong khi instruction hiện tại trong file thêm layer vào image.</p>",
              "level": "fresher"
            },
            {
              "question": "Mục đích của tham số volume trong lệnh chạy docker là gì?",
              "answer": "<p>Cú pháp của lệnh chạy docker sử dụng volumn là: <code>docker run -v host<em>path:docker</em>path &lt;container_name&gt;</code>.\r\n\r\nTham số volume được dùng cho đồng bộ hoá một thư mục trong container với bất kỳ thư mục host nào. Ví dụ: <code>docker run -v /data/app:usr/src/app myapp</code>. Lệnh trên gắn thứ mục <code>/data/app</code> trong host vào thư mục <code>usr/src/app</code>. Ta có thể đồng bộ container với file dữ liệu từ host mà không cần khởi động lại.\r\n\r\nĐiều này đảm bảo rằng ngay cả khi container bị xóa, dữ liệu của container vẫn tồn tại trong vị trí host lưu trữ được ánh xạ theo volume, làm cho nó trở thành cách dễ dàng nhất để lưu trữ dữ liệu container.</p>",
              "level": "fresher"
            },
            {
              "question": "Docker volume được lưu ở đâu trong docker?",
              "answer": "<p>Volume được tạo và quản lý bởi Docker và không thể truy cập bằng thực thể khác docker. Nó được lưu trữ trong hệ thống file host Docker ở <code>/var/lib/docker/volumes/</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh docker info là gì?",
              "answer": "<p>Lệnh lấy thông tin chi tiết về Docker được cài đặt trên hệ thống host. Thông tin có thể giống như số lượng container hoặc image và chúng đang chạy ở trạng thái nào và các thông số kỹ thuật phần cứng như tổng bộ nhớ được cấp phát, tốc độ của bộ xử lý, phiên bản kernel,...</p>",
              "level": "fresher"
            },
            {
              "question": "Ý nghĩa của các lệnh up, run và start của docker compose?",
              "answer": "<p><ul><li>Sử dụng lệnh <code>up</code> để duy trì docker-compose (lý tưởng là mọi lúc), chúng ta có thể khởi động hoặc khởi động lại tất cả các mạng, dịch vụ và driver được liên kết với ứng dụng được chỉ định trong file docker-compos.yml. Bây giờ, nếu chúng ta đang chạy docker-compose ở chế độ \"attached\" thì tất cả log từ các container sẽ có thể truy cập được đối với chúng ta. Trong trường hợp docker-compose được chạy ở chế độ \"detached\", thì khi các container được khởi động, nó sẽ thoát ra và không hiển thị log nào.</li></ul>\r<ul><li>Sử dụng lệnh <code>run</code>, docker-compose có thể chạy các tác vụ một lần hoặc đột xuất dựa trên các yêu cầu nghiệp vụ. Ở đây, tên dịch vụ phải được cung cấp và docker chỉ bắt đầu dịch vụ cụ thể đó và cả các dịch vụ khác mà dịch vụ đích phụ thuộc (nếu có).</li></ul>\r<ul><li>Lệnh này hữu ích để kiểm tra container và cũng thực hiện các tác vụ như thêm hoặc xóa dữ liệu vào container,...</li></ul>\r<ul><li>Sử dụng lệnh <code>start</code>, chỉ những container đó mới có thể được khởi động lại đã được tạo và sau đó dừng lại. Điều này không hữu ích cho việc tạo các container mới của riêng nó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các yêu cầu cơ bản để Docker chạy trên mọi hệ thống?",
              "answer": "<p>Docker có thể chạy trên cả nền tảng Linux và Windows.\r<ul><li>Đối với nền tảng Windows, ít nhất docker cần có Windows 10 64bit với bộ nhớ RAM 2GB. Đối với các phiên bản thấp hơn, có thể cài đặt docker bằng cách sử dụng toolbox trợ giúp. Docker có thể được tải xuống từ trang web https://docs.docker.com/docker-for-windows/.</li></ul>\r<ul><li>Đối với nền tảng Linux, Docker có thể chạy trên nhiều phiên bản Linux khác nhau như Ubuntu> = 12.04, Fedora> = 19, RHEL> = 6.5, CentOS> = 6, v.v.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách đăng nhập vào docker registry?",
              "answer": "<p>Sử dụng lệnh <code>docker login</code>  để đăng nhập vào kho lưu trữ đám mây của riêng họ có thể được nhập và truy cập.</p>",
              "level": "fresher"
            },
            {
              "question": "Các instructions phổ biến trong Dockerfile?",
              "answer": "<p><ul><li><strong>FROM:</strong> dùng cho thiết lập image cơ sở cho instruction sắp tới. File docker được xem là hợp lệ nếu nó bắt đầu bằng FROM.</li></ul>\r<ul><li><strong>LABEL:</strong> dùng cho tổ chức image dựa trên dự án, module hoặc license. Nó còn giúp tự động hoá như một cặp key-value cụ thể trong khi xác định label mà sau này có thể được truy cập và xử lý theo chương trình.</li></ul>\r<ul><li><strong>RUN:</strong> dùng cho thực thi instruction theo sau nó trên top image hiện tại trong lớp mới. Lưu ý: mỗi lần thực thi lệnh RUN, chúng ta thêm các lớp trên image và sử dụng lớp đó cho các bước tiếp theo.</li></ul>\r<ul><li><strong>CMD:</strong> dùng cho cung cấp giá trị mặc định của container thực thi. Trong trường hợp nhiều lệnh CMD, lệnh cuối cùng sẽ được xem xét.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Daemon Logging và Container Logging?",
              "answer": "<p>Trong Docker, logging được hỗ trợ ở hai level là level Daemon và level Container.\r<ul><li><strong>Daemon</strong>: gồm 4 kiểu level:</li></ul>\r<ul><li>Debug có tất cả dữ liệu xuất hiện trong quá trình thực thi của tiến trình daemon.</li></ul>\r<ul><li>Info quan tâm tất cả thông tin cùng với lỗi trong suốt quá trị thực thi tiến trình daemon.</li></ul>\r<ul><li>Error gồm các lỗi xảy ra trong quá trình thực thi tiến trình daemon.</li></ul>\r<ul><li>Fatal chức lỗi fatal trong quá trình thực thi tiến trình daemon.</li></ul>\r<ul><li><strong>Container:</strong></li></ul>\r<ul><li>Level container có thể thực hiện logging bằng lệnh: <code>sudo docker run –it &lt;container<em>name&gt; /bin/bash</code>.</li></ul>\r<ul><li>Để kiểm tra log của level container ta có thể thực hiện: <code>sudo docker logs &lt;container</em>id&gt;</code>.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách thiết lập giao tiếp giữa docker host và linux host?",
              "answer": "<p>Điều này có thể được thực hiện bởi mạng bằng cách xác định \"ipconfig\" trên docker host. Lệnh này đảm bảo rằng một adapter ethernet được tạo miễn là docker có mặt trong host.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách xoá một container?",
              "answer": "<p>Ta có hai bước xoá container:\r\n1. <code>docker stop &lt;container<em>id&gt;</code>\r\n2. <code>docker rm &lt;container</em>id&gt;</code></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa CMD và ENTRYPOINT?",
              "answer": "<p><ul><li>Lệnh CMD cung cấp các giá trị mặc định có thể thực thi cho một container đang thực thi. Trong trường hợp file thực thi phải được bỏ qua thì việc sử dụng lệnh ENTRYPOINT cùng với định dạng mảng JSON phải được kết hợp.</li></ul>\r<ul><li>ENTRYPOINT chỉ định rằng lệnh bên trong nó sẽ luôn được chạy khi container khởi động. Lệnh này cung cấp một tùy chọn để cấu hình các tham số và các file thực thi. Nếu DockerFile không có lệnh này, thì nó sẽ vẫn được kế thừa từ image cơ sở được đề cập trong lệnh FROM.</li></ul>\r<ul><li>ENTRYPOINT được sử dụng phổ biến nhất là <code>/bin/sh</code> hoặc <code>/bin/bash</code> cho hầu hết các image cơ sở.</li></ul>\r\n\r\nThực tế, tất cả Dockerfile nên có ít nhất một trong hai lệnh.\r\n\r\n## Câu hỏi phỏng vấn Docker cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể dùng JSON thay cho YAML khi phát triển docker-compose trong Docker không?",
              "answer": "<p>Có thể. Ta có thể chạy docker-compose trong json, như\r\n\r\n``<code>shell\r\ndocker-compose -f docker-compose.json up\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn có thể chạy bao nhiêu container trong docker và các yếu tố ảnh hưởng đến giới hạn này là gì?",
              "answer": "<p>Không có giới hạn xác định rõ ràng về số lượng container có thể chạy trong docker. Nhưng tất cả phụ thuộc vào những hạn chế - cụ thể hơn là những hạn chế về phần cứng. Kích thước của ứng dụng và tài nguyên CPU có sẵn là 2 yếu tố quan trọng ảnh hưởng đến giới hạn này. Trong trường hợp ứng dụng của bạn không quá lớn và bạn có tài nguyên CPU dồi dào, thì chúng ta có thể chạy một số lượng lớn các container.</p>",
              "level": "fresher"
            },
            {
              "question": "Vòng đời của container trong Docker?",
              "answer": "<p>Các giai đoạn khác nhau của docker container từ khi bắt đầu tạo cho đến khi kết thúc được gọi là vòng đời của docker container.\r\n\r\nCác giai đoạn quan trọng nhất là:\r<ul><li><strong>Created:</strong> Đây là trạng thái mà container vừa được tạo mới nhưng chưa bắt đầu.</li></ul>\r<ul><li><strong>Running:</strong> Trong trạng thái này, container sẽ chạy với tất cả các quy trình liên quan của nó.</li></ul>\r<ul><li><strong>Paused:</strong>  Trạng thái này xảy ra khi container đang chạy bị tạm dừng.</li></ul>\r<ul><li><strong>Stopped:</strong> Trạng thái này xảy ra khi container đang chạy đã bị dừng.</li></ul>\r<ul><li><strong>Deleted:</strong> Trong trường hợp này, container ở trạng thái chết.</li></ul>\r\n\r\n<img src=\"/interview-assets/docker-container-lifecycle.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để sử dụng docker cho nhiều môi trường ứng dụng?",
              "answer": "<p><ul><li>Tính năng docker-compose của docker sẽ hỗ trợ bạn tại đây. Trong file docker-compose, chúng ta có thể xác định nhiều dịch vụ, mạng và container cùng với ánh xạ volume một cách rõ ràng và sau đó chúng ta chỉ cần gọi lệnh <code>docker-compose up</code>.</li></ul>\r<ul><li>Khi có nhiều môi trường tham gia - đó có thể là máy chủ dev, staging, uat hoặc production, chúng ta muốn xác định các quy trình và phụ thuộc dành riêng cho server chủ để chạy ứng dụng. Trong trường hợp này, chúng ta có thể tiếp tục tạo file docker-compose theo môi trường cụ thể có tên là <code>docker-compos. {environment}.yml</code> và sau đó dựa trên môi trường, chúng ta có thể thiết lập và chạy ứng dụng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Làm sao đảm bảo container1 chạy trước container2 trong khi dùng docker compose?",
              "answer": "<p>Docker-compose không đợi bất kỳ container nào \"sẵn sảng\" trước khi đến container kế tiếp. Để thực thi như vậy, ta có thể sử dụng:\r<ul><li>Bạn có thể sử dụng “depend<em>on” đã được thêm vào phiên bản 2 của docker-compose khi được hiển thị trong file docker-compose.yml mẫu bên dưới:</li></ul>\r\n\r\n``<code>\r\nversion: &quot;2.4&quot;\r\nservices:\r\n backend:\r\n   build: .\r\n   depends</em>on:\r<ul><li>db</li></ul>\r\n db:\r\n   image: postgres\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "golang",
          "name": "Câu hỏi phỏng vấn Golang",
          "description": "",
          "questions": [
            {
              "question": "Golang là gì?",
              "answer": "<p><ul><li>Go là một ngôn ngữ lập trình đa năng, cấp cao, static typing và mạnh mẽ bằng cách cung cấp hỗ trợ cho việc thu gom rác và lập trình đồng thời.</li></ul>\r<ul><li>Trong Go, các chương trình được xây dựng bằng cách sử dụng các package (gói) giúp quản lý các phần dependencies (phụ thuộc) một cách hiệu quả. Nó cũng sử dụng mô hình compile-link để tạo các file nhị phân thực thi từ mã nguồn. </li></ul>\r<ul><li>Go là một ngôn ngữ đơn giản với cấu trúc cú pháp thanh lịch và dễ hiểu. Nó có một tập hợp có sẵn các thư viện tiêu chuẩn mạnh mẽ giúp các nhà phát triển giải quyết vấn đề mà không cần đến các package của bên thứ ba. </li></ul>\r<ul><li>Go có hỗ trợ first-class cho concurrency có khả năng sử dụng kiến trúc bộ xử lý đa lõi theo lợi thế của nhà phát triển và sử dụng bộ nhớ hiệu quả. Điều này giúp các ứng dụng mở rộng quy mô theo cách đơn giản hơn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao nên học Golang?",
              "answer": "<p>Go tuân theo nguyên tắc phát huy tác dụng tối đa với nỗ lực tối thiểu. Mọi tính năng và cú pháp của Go đều được phát triển để giúp các lập trình viên dễ dàng sử dụng. Sau đây là những ưu điểm của Go:\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Golang package là gì?",
              "answer": "<p>Go Package (gọi tắt là <code>pkg</code>) là một đường dẫn đến workspace của Go bao gồm file nguồn hoặc các package khác của nó. Tất cả các phần code từ biến đến hàm được viết trong file nguồn sẽ được lưu trong package được liên kết. Tất cả file nguồn nên nằm trong một package.\r\n\r\nNhư ảnh bên dưới, ta có thể thấy Go Package được biểu diễn như một các hộp nơi chứa tất cả file nguồn Go hoặc mở rộng <code>.go</code>. Ta cũng có thể lưu package Go trong một package khác.\r\n\r\n<img src=\"/interview-assets/Golang_packages.png\" alt=\"\" />\r\n\r\nPackage được khai báo ở đầu file với cú pháp\r\n\r\n``<code>go\r\npackage &lt;package<em>name&gt;\r\n</code>`<code>\r\n\r\nVà được import theo cú pháp\r\n\r\n</code>`<code>go\r\nimport &lt;package</em>name&gt;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Golang là case sensitive hay insensitive?",
              "answer": "<p>Go là ngôn ngữ case-sensitive.</p>",
              "level": "fresher"
            },
            {
              "question": "Go Pointer là gì?",
              "answer": "<p>Con trỏ (pointer) trong Go là các biến giữ địa chỉ của biến khác. Con trỏ hỗ trợ hai toán tử là:\r<ul><li>Toán tử <code><em></code>: còn được gọi là toán tử tham chiếu được dùng để truy cập giá trị trong địa chỉ được lưu trữ bởi con trỏ.</li></ul>\r<ul><li>Toán tử <code>&amp;</code>: còn được gọi là toán tử địa chỉ được dùng để trả về địa chỉ của biến được lưu trữ bởi con trỏ.</li></ul>\r\n\r\nĐiều này được minh họa trong sơ đồ dưới đây. Ở đây, chúng ta có một biến <code>x</code> được gán cho <code>100</code>. Chúng ta lưu trữ <code>x</code> trong địa chỉ bộ nhớ <code>0x0201</code>. Bây giờ, khi chúng ta tạo một con trỏ tên <code>Y</code> cho biến <code>x</code>, chúng ta gán giá trị là <code>&amp;x</code> để lưu trữ địa chỉ của biến <code>x</code>. Biến con trỏ được lưu trong địa chỉ <code>0x0208</code>. Bây giờ để lấy giá trị được lưu trong địa chỉ được lưu trong con trỏ, chúng ta chỉ cần viết <code>int z: = </em> Y</code>.\r\n\r\n<img src=\"/interview-assets/Golang_pointers.png\" alt=\"\" />\r\n\r\nCon trỏ được dùng cho các mục đích sau:\r<ul><li>Cho phép hàm thay đổi trực tiếp giá trị tham số được truyền cho nó. </li></ul>\r<ul><li>Để tăng hiệu suất trong các trường hợp cạnh khi có cấu trúc dữ liệu lớn. Sử dụng con trỏ giúp sao chép dữ liệu lớn một cách hiệu quả.</li></ul>\r<ul><li>Giúp biểu thị sự thiếu giá trị. Ví dụ: trong khi giải nén dữ liệu JSON vào một struct, sẽ rất hữu ích khi biết nếu khóa có hay không có thì khóa hiện diện với giá trị 0.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Chuỗi ký tự trong Golang?",
              "answer": "<p>Chuỗi ký tự là những biến lưu trữ các hằng chuỗi có thể là một ký tự đơn lẻ hoặc có thể là kết quả của việc nối một chuỗi ký tự. Go cung cấp hai loại chuỗi ký tự:\r<ul><li>Chuỗi ký tự thuần: Ở đây giá trị của chuỗi không bị gián đoạn giữa các dấu backqoute(<code>).</li></ul>\r\n\r\n</code>`<code>go\r\n</code>interview<code>\r\n</code>`<code>\r<ul><li>Chuỗi ký tự thông dịch: ở đây các chuỗi ký tự được đặt trong dấu hoặc kép, giá trị có thể xuống dòng.</li></ul>\r\n\r\n</code>`<code>go\r\n&quot;Interviewbit\r\nWebsite&quot;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cú pháp vòng lặp for trong Golang?",
              "answer": "<p>Cú pháp vòng lặp for như sau:\r\n\r\n``<code>go\r\nfor [condition |  ( init; condition; increment ) | Range]  \r\n{  \r\n   statement(s);  \r\n   //more statements\r\n}\r\n</code>`<code>\r\n\r\nTrong đó:\r<ul><li>Bước </code>init<code> thực thi đầu tiên. Điều này chỉ được thực hiện một lần khi bắt đầu vòng lặp. Nhằm mục đích khai báo và khởi tạo các biến điều khiển vòng lặp. Trường này là tùy chọn nếu chúng ta đã khởi tạo các biến điều khiển vòng lặp trước đó. Ngay cả khi chúng ta không làm gì ở đây, dấu chấm phẩy vẫn cần phải hiện diện.</li></ul>\r<ul><li>Bước </code>condition<code> là để đánh giá. Nếu </code>condition<code> thoả mãn, thân vòng lặp sẽ được thực thi. Nếu </code>condition<code> không thoả mãn, vòng lặp sẽ dùng lại. Sau khi thân vòng lặp thực thi nếu điều kiện vẫn thoả mãn nó sẽ thực thi lệnh </code>increment<code> để cập nhật biến điều kiển vòng lặp. Quá trình này được tiếp tục đến khi nào </code>condition<code> trở thành false.</li></ul>\r<ul><li>Nếu </code>Range<code> được đề cập, vòng lặp sẽ thực thi với từng mục trong Range.</li></ul>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>go\r\npackage main\r\n\r\nimport &quot;fmt&quot;\r\n\r\nfunc main() {\r\n   // For loop to print numbers from 1 to 5\r\n   for j := 1; j &lt;= 5; j++ {\r\n      fmt.Println(j)\r\n   }\r\n\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\n1\r\n2\r\n3\r\n4\r\n5\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Phạm vi biến trong Go?",
              "answer": "<p>Phạm vi biến được định nghĩa là một phần của chương trình mà biến có thể được truy cập. Mọi biến đều được xác định phạm vi tĩnh (có nghĩa là phạm vi biến có thể được xác định tại thời điểm biên dịch) trong Go có nghĩa là phạm vi được khai báo tại thời điểm biên dịch chính nó. Có hai phạm vi trong cờ vây, đó là:\r<ul><li>Biến cục bộ: Được khai bao trong một hàm hay khối chỉ được truy cập trong các hàm/khối đó.</li></ul>\r<ul><li>Biến toàn cục: Được khai báo bên ngoài hàm hay khối được truy cập trên toàn bộ file.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Goroutine là gì?",
              "answer": "<p>Goroutines là các hàm hoặc phương thức chạy đồng thời với các hàm/ phương thức khác. Goroutines có thể được coi là những luồng gọn nhẹ. Chi phí tạo một Goroutine tương đối thấp so với một luồng. Do vậy, những ứng dụng Go có hàng ngàn Goroutines chạy đồng thời là điều hết sức bình thường. Goroutines được quản lý bởi Go Runtime. \r\n\r\nTa có thể bắt đầu một goroutines bắt cách chỉ định từ khoá <code>go</code> trước khi gọi hàm. Hàm sau đó sẽ được gọi và chạy như một goroutine.\r\n\r\n``<code>go\r\npackage main\r\nimport (\r\n   &quot;fmt&quot;\r\n   &quot;time&quot;\r\n)\r\nfunc main() {\r\n   go sampleRoutine()\r\n   fmt.Println(&quot;Started Main&quot;)\r\n   time.Sleep(1 * time.Second)\r\n   fmt.Println(&quot;Finished Main&quot;)\r\n}\r\n\r\nfunc sampleRoutine() {\r\n   fmt.Println(&quot;Inside Sample Goroutine&quot;)\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta thấy hàm </code>sampleRoutine()<code> được gọi bởi từ khoá </code>go<code> ở phía trước. Khi một hàm được gọi là một goroutine, nó sẽ trả về ngay lập tức dòng kế tiếp trong chương trình đó là lý do tại sao &quot;Started Main&quot; sẽ in đầu tiên, và goroutine sẽ được lên lịch và chạy đồng thời trong nền. Câu lệnh </code>sleep<code> đảm bảo rằng goroutine sẽ hoàn thành trước hàm main.\r\n\r\nKết quả chương trình:\r\n\r\n</code>`<code>\r\nStarted Main\r\nInside Sample Goroutine\r\nFinished Main\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể trả về nhiều giá trị từ một hàm trong Go?",
              "answer": "<p>Có, bằng cách phân tách các giá trị bằng dấu phẩy trong câu lênh return và gán nó cho nhiều biến như ví dụ bên dưới:\r\n\r\n``<code>go\r\npackage main\r\nimport (\r\n\t&quot;fmt&quot;\r\n)\r\n\r\nfunc reverseValues(a,b string)(string, string){\r\n   return b,a    //notice how multiple values are returned\r\n}\r\n\r\nfunc main(){\r\n   val1,val2:= reverseValues(&quot;interview&quot;,&quot;question&quot;)    // notice how multiple values are assigned\r\n   fmt.Println(val1, val2)\r\n}\r\n</code>`<code>\r\n\r\nỞ ví dụ trên, ta có hàm </code>reverseValues<code> đơn giản là đảo ngược trật tự input. Trong \r\nmain, ta gọi hàm </code>reverseValues<code> và giá trị trả về đượC gán cho </code>val1<code> và </code>val2<code>.\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nquestion interview\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể khai báo nhiều biến khác kiểu trong cùng một dòng không?",
              "answer": "<p>``<code>go\r\nvar a,b,c= 9, 7.1, &quot;interviewbit&quot;\r\n</code>``\r\n\r\nCó, ở trên ta gán kiểu integer, float và chuỗi cho ba biến trong cùng một dòng.</p>",
              "level": "fresher"
            },
            {
              "question": "Slice trong Go là gì?",
              "answer": "<p>Slice là kiểu dữ liệu mô tả dãy các đối tượng cùng kiểu dữ liệu như mảng nhưng không cố định chiều dài như mảng. Slice được khai báo là <code>[]&lt;kiểu dữ liệu&gt;</code> nên nó như là mảng không xác định chiều dài. Thực ra mỗi khi khai báo 1 biến kiểu slice, Go sẽ tạo 1 mảng để chứa dữ liệu cho nó.\r\n\r\nMột biến kiểu slice gồm 3 thành phần: \r<ul><li>Con trỏ tham chiếu đến mảng chứa các phần tử của slice.</li></ul>\r<ul><li>Chiều dài (số phần tử).</li></ul>\r<ul><li>Sức chứa (số phần tử tối đa, là chiều dài mảng chứa các phần tử). </li></ul>\r\n\r\nVí dụ\r\n\r\n``<code>go\r\npackage main\r\n \r\nimport &quot;fmt&quot;\r\n \r\nfunc main() {\r\n \r\n   // Creating an array\r\n   arr := [6]string{&quot;This&quot;,&quot;is&quot;, &quot;a&quot;,&quot;Go&quot;,&quot;interview&quot;,&quot;question&quot;}\r\n\r\n   // Print array\r\n   fmt.Println(&quot;Original Array:&quot;, arr)\r\n\r\n   // Create a slice\r\n   slicedArr := arr[1:4]\r\n\r\n   // Display slice\r\n   fmt.Println(&quot;Sliced Array:&quot;, slicedArr)\r\n\r\n   // Length of slice calculated using len()\r\n   fmt.Println(&quot;Length of the slice: %d&quot;, len(slicedArr))\r\n\r\n   // Capacity of slice calculated using cap()\r\n   fmt.Println(&quot;Capacity of the slice: %d&quot;, cap(slicedArr))\r\n}\r\n</code>`<code>\r\n\r\nỞ đây ta sử dụng slice để tìm 3 phần tử tính từ phần tử thứ 2 trong mảng gốc. Sau đó ta tìm độ dài và sức chứa của slice.\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nOriginal Array: [This is a Go interview question ]\r\nSliced Array: [is a Go]\r\nLength of the slice: 3\r\nThe capacity of the slice: 5\r\n</code>``\r\n\r\n<img src=\"/interview-assets/slice.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Go Interface là gì?",
              "answer": "<p>Go interface là một tập hợp các phương thức đặc trưng xác định. Nó là kiểu tuỳ chọn cho phép nhận các giá trị có triển khai các phương thức này. Các interface là trừu tượng, đó là lý do ta không thể tạo đối tượng của nó. Nhưng ta có thể tạo biến interface sau đó gán cho một giá trị cụ thể mà các phương thức interface yêu cầu. Interface có thể hoạt động như:\r\n1. Tập hợp phương thức đặc trưng\r\n2. Kiểu tuỳ chọn\r\n\r\nChúng được tạo bằng từ khoá <code>type</code> theo sau tên của interface và cuối cùng là từ khoá <code>interface</code>. Cú pháp:\r\n\r\n``<code>go\r\ntype name<em>of</em>interface interface {\r\n   // Method signatures\r\n}\r\n</code>`<code>\r\n\r\nInterface cũng thúc đẩy tính trừu tượng. Trong Go, ta có thể dùng interface để tạo các trừu tượng chung có thể được sử dụng bằng nhiều kiểu bằng cách xác định các khai báo phương thức tương thích với interface.\r\n\r\n</code>`<code>go\r\npackage main\r\n \r\nimport &quot;fmt&quot;\r\n \r\n// &quot;Triangle&quot; data type\r\ntype Triangle struct {\r\n\tbase, height float32\r\n}\r\n \r\n// &quot;Square&quot; data type\r\ntype Square struct {\r\n\tlength float32\r\n}\r\n \r\n// &quot;Rectangle&quot; data type\r\ntype Rectangle struct {\r\n\tlength, breadth float32\r\n}\r\n \r\n// To calculate area of triangle\r\nfunc (triangle Triangle) Area() float32 {\r\n\treturn 0.5 <em> triangle.base </em> triangle.height\r\n}\r\n \r\n// To calculate area of square\r\nfunc (square Square) Area() float32 {\r\n\treturn square.length <em> square.length\r\n}\r\n \r\n// To calculate area of rectangle\r\nfunc (rect Rectangle) Area() float32 {\r\n\treturn rect.length </em> rect.breadth\r\n}\r\n \r\n// Area interface for achieving abstraction\r\ntype Area interface {\r\n\tArea() float32\r\n}\r\n \r\nfunc main() {\r\n\t// Declare and assign values to varaibles\r\n\ttriangleObject := Triangle{base: 20, height: 10}\r\n\tsquareobject := Square{length: 25}\r\n\trectObject := Rectangle{length: 15, breadth: 20}\r\n \r\n\t// Define a variable of type interface\r\n\tvar shapeObject Area\r\n \r\n\t// Assign to &quot;Triangle&quot; type variable to the Area interface\r\n\tshapeObject = triangleObject\r\n\tfmt.Println(&quot;Triangle Area = &quot;, shapeObject.Area())\r\n \r\n\t// Assign to &quot;Square&quot; type variable to the Area interface\r\n\tshapeObject = squareobject\r\n\tfmt.Println(&quot;Square Area = &quot;, shapeObject.Area())\r\n \r\n\t// Assign to &quot;Rectangle&quot; type variable to the Area interface\r\n\tshapeObject = rectObject\r\n\tfmt.Println(&quot;Rectangle Area = &quot;, shapeObject.Area())\r\n}\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, ta có 3 kiểu hình dạng là triangle, square và rectangle. Ta cũng khai báo hàm </code>Area()<code> để tính toán diện tích của các hình dựa trên input được truyền. Ta cũng khai báo interface tên </code>Area<code> để xác định phương thức đặt trưng </code>Area()<code>. Trong hàm main, ta tạo đối tương gán đối tượng với interface và tính diện tích theo phương thức được khai báo trong interface. Do đó, ta không cần biết cụ thể về hàm được gọi. Phương thức interface sẽ giải quyết vấn đề này khi xem xét kiểu đối tượng. Điều này gọi là trừu tượng.\r\n\r\n</code>`<code>\r\nTriangle Area =  100\r\nSquare Area =  625\r\nRectangle Area =  300\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Golang có nhanh hơn các ngôn ngữ lập trình khác?",
              "answer": "<p>Golang nhanh hơn các ngôn ngữ lập trình khác vì mô hình đồng thời và quản lý bộ nhớ đơn giản và hiệu quả. Quá trình biên dịch mã máy diễn ra rất nhanh và hiệu quả. Ngoài ra, các phần phụ thuộc được liên kết với một tệp nhị phân duy nhất, do đó loại bỏ các phần phụ thuộc vào máy chủ.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách kiểm tra key trong Go map?",
              "answer": "<p>Map nói chung là một tập hợp các phần tử theo cặp key-value. Một key đề cập đến một value. Map cung cấp truy cập nhanh hơn với độ phức tạp O(1) đối với các giá trị nếu biết key. Một map được biểu diễn như hình bên dưới.\r\n\r\n<img src=\"/interview-assets/How_can_we_check_if_the_Go_map_contains_a_key.png\" alt=\"\" />\r\n\r\nMỗi lần giá trị được lưu trữ trong cặp key-value trong map, ta có thể truy xuất đến đối tượng bằng cách dùng <code>map<em>name[key</em>name]</code> và ta có thể kiểm tra key có tồn tại không bằng cách thực hiện như sau:\r\n\r\n``<code>go\r\nif val, isExists := map_obj[&quot;foo&quot;]; isExists {\r\n   //do steps needed here\r\n}\r\n</code>`<code>\r\n\r\nTừ đoạn code trên, chúng ta có thể thấy rằng hai biến đang được khởi tạo. Biến </code>val<code> sẽ nhận giá trị tương ứng với khóa &quot;foo&quot; từ map. Nếu không có giá trị nào, ta sẽ nhận được &quot;giá trị không&quot; và biến khác </code>isExists<code> sẽ nhận giá trị bool là true nếu khóa &quot;foo&quot; có trong map, ngược lại thì là false. Sau đó, điều kiện </code>isExists` được kiểm tra, nếu giá trị là true, thì phần thân của if sẽ được thực thi.</p>",
              "level": "fresher"
            },
            {
              "question": "Go Channel là gì?",
              "answer": "<p>Go channel là một phương tiện sử dụng goroutines giao tiếp các giá trị dữ liệu với nhau. Nó là một kỹ thuật cho phép truyền dữ liệu đến các goroutines khác. Một channel có thể truyền dữ liệu cùng kiểu. Việc truyền dữ liệu trong channel là hai chiều có nghĩa là các goroutines có thể sử dụng cùng một channel để gửi hoặc nhận dữ liệu như thể hiện trong hình ảnh bên dưới:\r\n\r\n<img src=\"/interview-assets/Go_channels.png\" alt=\"\" />\r\n\r\nMột channel có thể tạo với từ khoá <code>chan</code>:\r\n\r\n``<code>go\r\nvar channel<em>name chan Type\r\n</code>`<code>\r\n\r\nNó cũng có thể tạo bằng hàm </code>make()<code>:\r\n\r\n</code>`<code>go\r\nchannel</em>name:= make(chan Type)\r\n</code>`<code>\r\n\r\nĐể gửi dữ liệu tới channel, ta có thể dùng toán tử </code><-<code>:\r\n\r\n</code>`<code>go\r\nchannel<em>name &lt;- element\r\n</code>`<code>\r\n\r\nĐể nhận dữ liệu ta có thể dùng cú pháp:\r\n\r\n</code>`<code>go\r\nchannel</em>name &lt;- element\r\n</code>``\r\n\r\n## Câu hỏi phỏng vấn Golang cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích đoạn code bên dưới?",
              "answer": "<p>``<code>go\r\ntype DemoStruct struct {\r\n   Val int\r\n}\r\n//A.\r\nfunc demo<em>func() DemoStruct {\r\n   return DemoStruct{Val: 1}\r\n}\r\n//B.\r\nfunc demo</em>func() <em>DemoStruct {\r\n   return &amp;DemoStruct{}\r\n}\r\n//C.\r\nfunc demo_func(s </em>DemoStruct) {\r\n   s.Val = 1\r\n}\r\n</code>`<code>\r\n\r\nA - Vì hàm có kiểu trả về là struct, nên hàm sẽ trả về bản sao của struct với giá trị là 1.\r\nB - Vì hàm trả về </code>*DemoStruct<code>, là một tham chiếu đến struct, nó trả về con trỏ đến giá trị struct được tạo trong hàm.\r\nC - Vì hàm mong đợi đối tượng struct hiện có là một tham số trong hàm, và ta đặt giá trị cho thuộc tính của nó, khi kết thúc quá trình thực hiện, giá trị của biến </code>Val` của đối tượng struct được đặt thành 1.</p>",
              "level": "fresher"
            },
            {
              "question": "Định dạng chuỗi mà không in nó?",
              "answer": "<p>Ta có thể dùng hàm Sprintf như sau:\r\n\r\n``<code>go\r\nreturn fmt.Sprintf (&quot;Size: %d MB.&quot;, 50)\r\n</code>`<code>\r\n\r\nHàm định dạng </code>fmt.Sprintf` mà không in nó ra.</p>",
              "level": "fresher"
            },
            {
              "question": "Type Assertion trong Go là gì?",
              "answer": "<p>Type assertion nhận giá trị interface và truy xuất giá trị của kiểu dữ liệu được chỉ định rõ ràng. Cú pháp:\r\n\r\n``<code>go\r\nt := i.(T)\r\n</code>`<code>\r\n\r\nỞ đây, câu lệnh khẳng định rằng giá trị interface </code>i<code> có kiểu cụ thể là </code>T<code> và gán giá trị của kiểu </code>T<code> cho biến </code>t<code>. Trong trường hợp không có kiểu cụ thể </code>T<code>, thì câu lệnh sẽ dẫn đến panic.\r\n\r\nĐể kiểm tra, nếu một interface có kiểu cụ thể, chúng ta có thể thực hiện bằng cách sử dụng hai giá trị được trả về bởi xác nhận kiểu. Một giá trị là giá trị cơ bản và giá trị kia là giá trị bool cho biết xác nhận đã hoàn thành hay chưa. Cú pháp sẽ là:\r\n\r\n</code>`<code>go\r\nt, isSuccess := i.(T)\r\n</code>`<code>\r\n\r\nỞ đây, nếu giá trị interface </code>i<code> có </code>T<code>, thì giá trị cơ bản sẽ được gán cho </code>t<code> và giá trị </code>isSuccess<code> trở thành true. Ngược lại, câu lệnh </code>isSuccess` sẽ false và giá trị của t sẽ có giá trị 0 tương ứng với kiểu T. Điều này đảm bảo không có panic nếu khẳng định không thành công.</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểm tra kiểu của biến khi đang chạy?",
              "answer": "<p>Trong Go, chúng ta có thể sử dụng một kiểu switch đặc biệt để kiểm tra kiểu biến khi đang chạy. Câu lệnh switch này được gọi là <strong>type switch</strong>.\r\n\r\nHãy xem xét đoạn code sau, nơi chúng ta đang kiểm tra kiểu của biến v và thực hiện một số thao tác.\r\n\r\n``<code>go\r\nswitch v := param.(type) { \r\ndefault:\r\n   fmt.Printf(&quot;Unexpected type %T&quot;, v)\r\ncase uint64:\r\n   fmt.Println(&quot;Integer type&quot;)\r\ncase string:\r\n   fmt.Println(&quot;String type&quot;)\r\n}\r\n</code>``\r\n\r\nTrong đoạn code trên, chúng ta đang kiểm tra kiểu của biến v, nếu kiểu của biến là uint64, thì đoạn code sẽ in \"\"Integer type\". Nếu kiểu của biến là một chuỗi, cpde sẽ in ra \"String type\". Nếu kiểu không khớp, default sẽ được thực thi và nó chạy các câu lệnh trong khối default.</p>",
              "level": "fresher"
            },
            {
              "question": "Có nên sử dụng biến toàn cục trong các chương trình triển khai goroutines?",
              "answer": "<p>Việc sử dụng các biến toàn cục trong goroutines không được khuyến khích vì nó có thể được nhiều goroutines truy cập và sửa đổi đồng thời. Điều này có thể dẫn đến kết quả ngoài dự tính.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách sử dụng một empty struct?",
              "answer": "<p>Empty struct được dùng khi ta muốn tiết kiệm bộ nhớ. Điều này là do chúng không sử dụng bất kỳ bộ nhớ nào cho các giá trị. Cú pháp là:\r\n\r\n``<code>go\r\na := struct{}{}\r\n</code>`<code>\r\n\r\nKích thước của empty struct là 0 khi sử dụng </code>println(unsafe.Sizeof(a))<code>.\r\n\r\nLợi ích của empty struct là cho các nhà phát triển thấy rằng chúng không có bất kỳ giá trị nào. Mục đích là thông tin thuần tuý. Một số ví dụ trong đó empty struct rất hữu ích như sau: \r<ul><li><strong>Khi triển khai tập dữ liệu:</strong> ta có thể dùng empty struct để triển khai một tập dữ liệu.</li></ul>\r\n\r\n</code>`<code>go\r\nmap<em>obj := make(map[string]struct{})\r\nfor </em>, value := range []string{&quot;interviewbit&quot;, &quot;golang&quot;, &quot;questions&quot;} {\r\n   map<em>obj[value] = struct{}{}\r\n}\r\nfmt.Println(map</em>obj)\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nmap[interviewbit:{} golang:{} questions:{}]\r\n</code>`<code>\r\n\r\nỞ đây, ta khởi tạo giá trị của key bằng một empty struct và khởi tạo </code>map<em>obj<code> từ empty struct đó.\r<ul><li>Trong duyệt đồ thị trong bản đồ theo dõi các đỉnh đã truy cập. Ví dụ, hãy xem xét đoạn code dưới đây, ta đang khởi tạo giá trị của empty struct đã truy cập đỉnh.</li></ul>\r\n\r\n</code>`<code>go\r\nvisited := make(map[string]struct{})\r\nfor </em>, isExists := visited[v]; !isExists {\r\n   // First time visiting a vertex.\r\n   visited[v] = struct{}{}\r\n}\r\n</code>`<code>\r\n\r\nKhi một channel cần gửi tín hiệu sự kiện mà không cần gửi bất kỳ dữ liệu nào. Từ đoạn code dưới đây, ta có thể thấy rằng ta đang gửi một tín hiệu bằng cách gửi empty struct đến channel đuọc gửi đến workerRoutine.\r\n\r\n</code>`<code>go\r\nfunc workerRoutine(ch chan struct{}) {\r\n   // Receive message from main program.\r\n   &lt;-ch\r\n   println(&quot;Signal Received&quot;)\r\n\r\n   // Send a message to the main program.\r\n   close(ch)\r\n}\r\n\r\nfunc main() {\r\n   //Create channel\r\n   ch := make(chan struct{})\r\n   \r\n   //define workerRoutine\r\n   go workerRoutine(ch)\r\n\r\n   // Send signal to worker goroutine\r\n   ch &lt;- struct{}{}\r\n\r\n   // Receive a message from the workerRoutine.\r\n   &lt;-ch\r\n   println(“Signal Received&quot;)\r\n}\r\n</code>`<code>\r\n\r\nKết quả là:\r\n\r\n</code>`<code>\r\nSignal Received\r\nSignal Received\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách sao chép slice và map trong Go?",
              "answer": "<p><strong>Sao chép slice:</strong> Ta có thể dùng phương thức có sẵn <code>copy()</code> như sau:\r\n\r\n``<code>go\r\nslice1 := []int{1, 2}\r\nslice2 := []int{3, 4}\r\nslice3 := slice1\r\ncopy(slice1, slice2)\r\nfmt.Println(slice1, slice2, slice3)\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta sao chép giá trị của </code>slice2<code> vào </code>slice1<code> và sử dụng </code>slice3<code> để giữa một tham chiếu đến slice gốc để kiểm tra slice có được sao chép hay không. Kết quả sẽ là:\r\n\r\n</code>`<code>\r\n[3 4] [3 4] [3 4]\r\n</code>`<code>\r\n\r\nNếu ta muốn sao chép slice mà không có nội dung, ta chỉ cần dùng toán tử </code>=<code> như code bên dưới:\r\n\r\n</code>`<code>go\r\nslice1 := []int{1, 2}\r\nslice2 := []int{3, 4}\r\nslice3 := slice1\r\nslice1 = slice2\r\nfmt.Println(slice1, slice2, slice3)\r\n</code>`<code>\r\n\r\nKết quả là:\r\n\r\n</code>`<code>\r\n[3 4] [3 4] [1 2]\r\n</code>`<code>\r\n\r\n<strong>Sao chép map:</strong> Ta có thể sao chép một map bằng cách duyệt qua khoá của map. Không có hàm có sẵn cho sao chép map. Code thực hiện điều đó có thể là:\r\n\r\n</code>`<code>go\r\nmap1 := map[string]bool{&quot;Interview&quot;: true, &quot;Bit&quot;: true}\r\nmap2 := make(map[string]bool)\r\nfor key, value := range map1 {\r\n\tmap2[key] = value\r\n}\r\n</code>`<code>\r\n\r\nỞ code trên, ta lặp qua nội dung của </code>map1<code> và thêm giá trị vào </code>map2<code> với khoá tương ứng.\r\n\r\nNếu ta chỉ muốn sao chép mô tả không có nội dung của map, ta có thể dùng toán tử </code>=<code> như sau:\r\n\r\n</code>`<code>go\r\nmap1 := map[string]bool{&quot;Interview&quot;: true, &quot;Bit&quot;: true}\r\nmap2 := map[string]bool{&quot;Interview&quot;: true, &quot;Questions&quot;: true}\r\nmap3 := map1\r\nmap1 = map2    //copy description\r\nfmt.Println(map1, map2, map3)\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nmap[Interview:true Questions:true] map[Interview:true Questions:true] map[Interview:true Bit:true]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "GoPATH khác với GoROOT như thế nào?",
              "answer": "<p>Biến GoPATH là một biến môi trường được sử dụng để tượng trưng cho các thư mục ngoài <code>$GoROOT</code>, kết hợp nguồn và mã nhị phân của dự án Go. Biến <code>GoROOT</code> xác định vị trí của Go SDK. Chúng ta không phải sửa đổi biến trừ khi ta dự định sử dụng nhiều phiên bản Go. GoPATH xác định gốc của không gian làm việc trong khi GoROOT xác định vị trí của Go SDK.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách xử lý lỗi trong Go?",
              "answer": "<p>Trong Go, lỗi là một kiểu interface trong đó bất kỳ kiểu nào triển khia phương thức <code>Error()</code> đều được xem là lỗi. Go không có <code>try/catch</code> như các ngôn ngữ lập trình khác để xử lý lỗi. Thay vào đó chúng trả về dưới dạng bình thường. Cú pháo tạo interface lỗi:\r\n\r\n``<code>go\r\ntype error_name interface {\r\n   Error() string\r\n}\r\n</code>`<code>\r\n\r\nChúng ta sử dụng điều này bất cứ khi nào ta nhận thấy rằng có khả năng một hàm có thể bị sai trong quá trình chuyển đổi kiểu hoặc các cuộc gọi mạng. Hàm sẽ trả về một lỗi dưới dạng biến trả về của nó nếu có sự cố. Người gọi phải kiểm tra giá trị lỗi này và xác định lỗi. Bất kỳ giá trị nào khác </code>nil` được gọi là lỗi.\r\n\r\nLà một phần của các phương pháp xử lý lỗi, các lớp bảo vệ nên được sử dụng thay thế cho các câu lệnh if-else. Chúng cũng nên được gói theo cách có ý nghĩa vì chúng có thể được chuyển qua call stack. Các lỗi cùng loại không nên được ghi lại hoặc xử lý nhiều lần.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách truy cập dữ liệu đồng thời nào an toàn hơn? Map hay Channel?",
              "answer": "<p>Channel an toàn hơn cho truy cập dữ liệu đồng thời vì nó có cơ chế blocking/locking để goroutines chia sẻ bộ nhớ đồng thời giữa nhiều luồng.\r\n\r\nMap không an toàn vì nó không có cơ chế locking. Khi sử dụng map, ta phải sử dụng cơ chế locking như mutex để gửi dữ liệu một cách an toàn thông qua goroutines.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách sắp xếp một slice của struct tuỳ chỉnh?",
              "answer": "<p>Ta có thể sắp xếp một slice của struct tuỳ chỉnh bằng cách dùng hàm <code>sort.Sort</code> và <code>sort.Stable</code>. Các phương thức này sắp xếp bắt kỳ tập hợp nào triển khai interface <code>sort.Interface</code> có phương thức <code>Len()</code>, <code>Less()</code> và <code>Swap()</code> như bên dưới:\r\n\r\n``<code>go\r\ntype Interface interface {\r\n   // Find number of elements in collection\r\n   Len() int\r\n   \r\n   // Less method is used for identifying which elements among index i and j are lesser and is used for sorting\r\n   Less(i, j int) bool\r\n   \r\n   // Swap method is used for swapping elements with indexes i and j\r\n   Swap(i, j int)\r\n}\r\n</code>`<code>\r\n\r\nVí dụ ta có struct như sau:\r\n\r\n</code>`<code>go\r\ntype Human struct {\r\n   name string\r\n   age int\r\n}\r\n</code>`<code>\r\n\r\nNgoài ra, hãy xem xét chúng ta có một slice của struct </code>Human<code> thuộc loại </code>AgeFactor<code> cần được sắp xếp dựa trên độ tuổi. </code>AgeFactor<code> thực hiện các phương thức của </code>sort.Interface<code>. Sau đó, chúng ta có thể gọi phương thức </code>sort.Sort()<code> trên đối tượng như được hiển thị trong đoạn code dưới đây:\r\n\r\n</code>`<code>go\r\n// AgeFactor implements sort.Interface that sorts the slice based on age field.\r\ntype AgeFactor []Human\r\nfunc (a AgeFactor) Len() int           { return len(a) }\r\nfunc (a AgeFactor) Less(i, j int) bool { return a[i].age &lt; a[j].age }\r\nfunc (a AgeFactor) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\r\n\r\nfunc main() {\r\n   audience := []Human{\r\n      {&quot;Alice&quot;, 35},\r\n      {&quot;Bob&quot;, 45},\r\n      {&quot;James&quot;, 25},\r\n   }\r\n   sort.Sort(AgeFactor(audience))\r\n   fmt.Println(audience) \r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\n[{James 25} {Alice 35} {Bob 45}]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hiểu gì về Shadowing trong Go?",
              "answer": "<p>Shadowing là một nguyên tắc khi một biến ghi đè một biến trong một phạm vi cụ thể. Điều này có nghĩa là khi một biến được khai báo trong inner scope có cùng tên và kiểu dữ liệu ở outer scope, thì biến đó được xem là shadow (che khuất). Biến bên ngoài được khai báo trước biến shadow.\r\n\r\n``<code>go\r\nvar numOfCars = 2    // Line 1\r\ntype Car struct{\r\n\tname string\r\n\tmodel string\r\n\tcolor string\r\n}\r\ncars:= [\r\n   {\r\n      name:&quot;Toyota&quot;,\r\n      model:&quot;Corolla&quot;,\r\n      color:&quot;red&quot;\r\n   },\r\n   {\r\n      name:&quot;Toyota&quot;,\r\n      model:&quot;Innova&quot;,\r\n      color:&quot;gray&quot;\r\n   }\r\n]\r\n\r\nfunc countRedCars(){\r\n   for i:=0; i&lt;numOfCars; i++{\r\n      if cars[i].color == &quot;red&quot; {\r\n         numOfCars +=1    // Line 2\r\n         fmt.Println(&quot;Inside countRedCars method &quot;, numOfCars)    //Line 3\r\n      }\r\n   }   \r\n}\r\n</code>`<code>\r\n\r\nỞ đây ta gọi hàm </code>countRedCars<code> trong đó ta sẽ đếm số lượng xe màu đỏ. Ta có biến </code>numOfCars<code> khai báo ở dòng 1. Trong phương thức </code>countRedCars<code> ta có lệnh if để kiểm tra có phải màu đỏ không, nếu có tăng </code>numOfCars<code> lên 1. Điểm hấp dẫn ở đây là giá trị của biến </code>numOfCars<code> sau khi kết thúc lệnh if sẽ ảnh hưởng đến giá trị biến </code>numOfCars` ở outer scope.</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm variadic trong Go là gì?",
              "answer": "<p>Hàm nhận một số đối số thay đổi được gọi là hàm variadic. Chúng ta có thể truyền không hoặc nhiều tham số trong hàm variadic. Ví dụ tốt nhất về một hàm variadic là <code>fmt.Printf</code> yêu cầu một đối số cố định làm tham số đầu tiên và nó có thể chấp nhận bất kỳ đối số nào. Cú pháp của hàm variadic là:\r<ul><li>Ở đây, chúng ta thấy rằng kiểu của tham số cuối cùng được đặt trước bởi ký hiệu dấu ba chấm (...) cho biết rằng hàm có thể nhận bất kỳ số lượng tham số nào nếu kiểu được chỉ định.</li></ul>\r<ul><li>Bên trong hàm variadic, <code>... type</code> có thể được hình dung như một slice. Chúng ta cũng có thể chuyển slice hiện có (hoặc nhiều slice) của kiểu được đề cập đến hàm dưới dạng tham số thứ hai. Khi không có giá trị nào được chuyển vào trong hàm variadic, slice được coi là nil.</li></ul>\r<ul><li>Các hàm này thường được sử dụng để định dạng chuỗi.</li></ul>\r<ul><li>Tham số Variadic không thể được chỉ định làm giá trị trả về, nhưng chúng ta có thể trả về biến kiểu slice từ hàm</li></ul>\r\n\r\nVí dụ:\r\n\r\n``<code>go\r\nfunc function_name(arg1, arg2...type)type{\r\n   // Some statements\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>go\r\npackage main\r\n \r\nimport(\r\n   &quot;fmt&quot;\r\n   &quot;strings&quot;\r\n)\r\n \r\n// Variadic function to join strings and separate them with hyphen\r\nfunc joinstring(element...string)string{\r\n   return strings.Join(element, &quot;-&quot;)\r\n}\r\n \r\nfunc main() {\r\n   \r\n  // To demonstrate zero argument\r\n   fmt.Println(joinstring())\r\n    \r\n   // To demonstrate multiple arguments\r\n   fmt.Println(joinstring(&quot;Interview&quot;, &quot;Bit&quot;))\r\n   fmt.Println(joinstring(&quot;Golang&quot;, &quot;Interview&quot;, &quot;Questions&quot;))\r\n    \r\n}\r\n</code>`<code>\r\n\r\nỞ đây hàm variadic là </code>joinstring<code> nhận một lượng tham số kiểu string. Ta đang cố gắng nối các đối số được phân tách bằng ký hiệu gạch nối. Ở đây đang chứng minh hành vi của hàm variadic bằng cách đầu tiên chuyển 0 đối số và sau đó chuyển nhiều đối số cho hàm. Kết quả:\r\n\r\n</code>`<code>\r\nInterview-Bit\r\nGolang-Interview-Questions\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về kiểu dữ liệu byte và rune?",
              "answer": "<p><code>byte</code> và <code>rune</code> là hai kiểu số nguyên là tên bí danh cho <code>uint8</code> và <code>int32</code>.\r\n\r\nbyte biểu diễn ký tự ASCII trong khi rune biểu diễn ký tự Unicode mặc định là UTF-8.\r\n\r\nCác ký tự hoặc chuỗi rune có thể biểu diễn bằng dấu nháy đơn như 'a', 'v', '\\n'.\r\n\r\nRune còn gọi là điểm code và có thể có giá trị số. Vd như <code>0x61</code> tương ứng với ký tự <code>a</code>.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "kubernetes",
          "name": "Câu hỏi phỏng vấn Kubernetes",
          "description": "",
          "questions": [
            {
              "question": "Làm thế nào để thực hiện bảo trì trên nút K8?",
              "answer": "<p>Bất cứ khi nào có sẵn các bản vá bảo mật, quản trị viên Kubernetes phải thực hiện nhiệm vụ bảo trì để áp dụng bản vá bảo mật cho container đang chạy nhằm ngăn nó khỏi lỗ hổng bảo mật, đây thường là một phần không thể tránh khỏi trong quản trị. Hai lệnh sau rất hữu ích để thoát nút K8s một cách an toàn.\r\n\r\n``<code>\r\nkubectl cordon\r\nkubectl drain –ignore-daemon set\r\n</code>`<code>\r\n\r\nLệnh đầu tiên chuyển node sang chế độ bảo trì hoặc làm cho node không khả dụng, tiếp theo là lệnh </code>kubectl drain<code> sẽ loại bỏ pod khỏi node. Sau khi lệnh thoát thành công, bạn có thể thực hiện bảo trì.\r\n\r\nLưu ý nếu bạn muốn thực hiện bảo trì trên một pod đơn, có thể dùng hai lệnh sau:\r<ul><li></code>kubectl get nodes<code>: hiển thị tất cả node</li></ul>\r<ul><li></code>kubectl drain <node name>`: thoát một node cụ thể</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Làm cách nào để kiểm soát việc sử dụng tài nguyên của POD?",
              "answer": "<p>Ta có thể dùng limit và request:\r<ul><li><strong>Request:</strong> Số lượng tài nguyên đang được yêu cầu cho một container. Nếu một container vượt quá yêu cầu tài nguyên của nó, nó sẽ được điều chỉnh trở lại.</li></ul>\r<ul><li><strong>Limit:</strong> Giới hạn trên đối với các tài nguyên mà một container duy nhất có thể sử dụng. Nếu nó cố gắng vượt quá giới hạn được xác định trước này, nó có thể bị chấm dứt nếu K8 quyết định rằng một container khác cần những tài nguyên này. Nếu bạn nhạy cảm với việc khởi động lại pod, bạn nên đặt tổng tất cả các giới hạn tài nguyên container nhỏ hơn hoặc bằng tổng dung lượng tài nguyên cho cụm của bạn.</li></ul>\r\n\r\nVí dụ:\r\n\r\n``<code>\r\napiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n name: demo\r\nspec:\r\n containers:\r<ul><li>name: example1</li></ul>\r\n image:example/example1\r\n resources:\r\n   requests:\r\n     memory: &quot;<em>Mi&quot;\r\n     cpu: &quot;</em>m&quot;\r\n   limits:\r\n     memory: &quot;<em>Mi&quot;\r\n     cpu: &quot;</em>m&quot;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các dịch vụ K8 khác nhau chạy trên một nút?",
              "answer": "<p>Cụm K8 bao gồm hai kiểu nút là executor node và dịch vụ master.\r\n\r\n<strong>Executor node:</strong>\r<ul><li>Kube-proxy: dịch vụ này có trách nhiệm giao tiếp của pods trong cụm và đến bên ngoài mạng, nó chạy trên mọi nút. Dịch vụ này chịu trách nhiệm duy trì giao thức mạng khi pod của bạn thiết lập một giao tiếp mạng.</li></ul>\r<ul><li>kubelet: Mỗi nút chạy một dịch vụ kubelet để cập nhật nút đang chạy tương ứng với file cấu hình (YAML hay JSON).</li></ul>\r\n\r\n<em>Lưu ý</em>: dịch vụ kubelet chỉ dành cho các container được tạo bởi Kubernetes.\r\n\r\n<strong>Dịch vụ master</strong>\r<ul><li>Kube-apiserver: Dịch vụ master API hành động như một entry point đến cụm K8.</li></ul>\r<ul><li>Kube-scheduler: Lập lịch POD theo các tài nguyên có sẵn trên các executor node.</li></ul>\r<ul><li>Kube-controller-manager: là một vòng điều khiển theo dõi trạng thái được chia sẻ của cụm thông qua apiserver và thực hiện các thay đổi cố gắng di chuyển trạng thái hiện tại sang trạng thái ổn định mong muốn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "PBD là gì?",
              "answer": "<p>Quản trị viên Kubernetes có thể tạo một loại triển khai: PodDisruptBudget (PBD) để ứng dụng có tính khả dụng cao, nó đảm bảo rằng số lượng tối thiểu các pods đang chạy được thừa nhận như đã đề cập trong thuộc tính <code>minAvailable</code>. Điều này rất hữu ích khi thực hiện thoát, nơi thoát sẽ tạm dừng cho đến khi PDB được thừa nhận để đảm bảo tính sẵn sàng cao (High Availability) của ứng dụng. Spec sau đây cũng hiển thị minAvailable là 2 ngụ ý số lượng tối thiểu của một pods có sẵn (ngay cả sau cuộc bầu cử).\r\n\r\n``<code>\r\napiVersion: policy/v1beta1\r\nkind: PodDisruptionBudget\r\nmetadata:\r\n name: zk-pdb\r\nspec:\r\n minAvailable: 2\r\n selector:\r\n   matchLabels:\r\n     app: zookeeper\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Init container là gì?",
              "answer": "<p>Init Containers là các container chạy trước khi container chính chạy với ứng dụng được container hóa của bạn. Chúng thường chứa các script thiết lập chuẩn bị môi trường cho ứng dụng được chứa trong container của bạn. Init Containers cũng đảm bảo môi trường máy chủ rộng hơn đã sẵn sàng để ứng dụng của bạn bắt đầu chạy.</p>",
              "level": "fresher"
            },
            {
              "question": "Vai trò của cân bằng tải trong Kubernetes?",
              "answer": "<p>Load balancer (cân bằng tải) là một cách để phân phối lưu lượng trên nhiều server, nó hữu ích cho việc đảm bảo ứng dụng luôn khả dụng với người dùng.\r\n\r\n<img src=\"/interview-assets/Load_Balancer.jpg\" alt=\"\" />\r\n\r\nTrong Kubernetes, như hình trên tất cả lưu lượng truy cập đến một địa chỉ IP đơn trên bộ cân bằng tải, để lộ dịch vụ của bạn với internet bên ngoài, nó định tuyến các lưu lượng truy cập đến một pod (thông qua dịch vụ) cụ thể bằng thuật toán Round-Robin. Ngay cả khi bất kỳ pod nào gặp sự cố, cân bằng tải cũng được thông báo để không chuyển lưu lượng truy cập đến nút không khả dụng đó. Do đó, bộ cân bằng tải trong Kubernetes chịu trách nhiệm phân phối một tập hợp các tác vụ (lưu lượng) đến các nhóm.</p>",
              "level": "fresher"
            },
            {
              "question": "Các điều cần biết để bảo mật Kubernetes?",
              "answer": "<p>Mặc định, POD có thể giao tiếp với bất kỳ POD nào khác, ta có thể thiết lập chính sách mạng để giới hạn các giao tiếp đó.\r<ul><li>RBAC (Role-based access control) để thu hẹp các quyền.</li></ul>\r<ul><li>Dùng namespace để thiết lập ranh giới bảo mật.</li></ul>\r<ul><li>Thiết lập chính sách điều khiển quản trị để tránh chạy các container đặc quyền.</li></ul>\r<ul><li>Bật logging kiểm tra.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách giám sát cụm Kubernetes?",
              "answer": "<p>Prometheus dùng cho giám sát Kubernetes. Hệ sinh thái Prometheus bao gồm các thành phần sau:\r<ul><li>Server chính Prometheus nơi scrape và lưu trữ dữ liệu thời gian</li></ul>\r<ul><li>Thư viện client cho các lệnh code ứng dụng.</li></ul>\r<ul><li>Cổng push cho hỗ trợ công việc ngắn hạn.</li></ul>\r<ul><li>Exporter đặc biệt cho dịch vụ như StatsD, HAProxy, Graphite,...</li></ul>\r<ul><li>Quản lý cảnh báo để xử lý cảnh báo trên các công cụ hỗ trợ khác nhau.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Lấy logs trung tâm của POD?",
              "answer": "<p>Kiến trúc này phụ thuộc vào ứng dụng và nhiều yếu tố khác. Sau đây là các mẫu logging phổ biến\r<ul><li>Node level logging agent.</li></ul>\r<ul><li>Streaming sidecar container.</li></ul>\r<ul><li>Sidecar container với logging agent.</li></ul>\r<ul><li>Xuất trực tiếp logs từ ứng dụng.</li></ul>\r\n\r\nTrong quá trình thiết lập, journalbeat và filebeat đang chạy dưới dạng daemonset. Các logs được thu thập bởi những thứ này được chuyển sang kafka, cuối cùng được chuyển vào ngăn xếp ELK.\r\n\r\nĐiều tương tự cũng có thể thực hiện được bằng cách sử dụng ngăn xếp EFK và fluentd-bit.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để biến dịch vụ trong spec bên dưới thành dịch vụ bên ngoài?",
              "answer": "<p>``<code>\r\nspec:\r\n  selector:\r\n    app: some-app\r\n  ports:\r<ul><li>protocol: UDP</li></ul>\r\n      port: 8080\r\n      targetPort: 8080\r\n</code>`<code>\r\n\r\nThêm LoadBalancer và nodePort như bên dưới:\r\n\r\n</code>`<code>\r\nspec:\r\n selector:\r\n   app: some-app\r\n type: LoadBalancer\r\n ports:\r<ul><li>protocol: UDP</li></ul>\r\n     port: 8080\r\n     targetPort: 8080\r\n     nodePort: 32412\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hoàn thành file thông số cấu hình sau để làm cho nó Ingress?",
              "answer": "<p>``<code>\r\nmetadata:\r\n  name: someapp-ingress\r\nspec:\r\n</code>`<code>\r\n\r\nThực hiện:\r\n\r\n</code>`<code>\r\napiVersion: networking.k8s.io/v1\r\nkind: Ingress\r\nmetadata:\r\n name: someapp-ingress\r\nspec:\r\n rules:\r<ul><li>host: my.host</li></ul>\r\n   http:\r\n     paths:\r<ul><li>backend:</li></ul>\r\n         serviceName: someapp-internal-service\r\n         servicePort: 8080\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cấu hình TLS với Ingress?",
              "answer": "<p>Thêm tls và secretName:\r\n\r\n``<code>\r\nspec:\r\n tls:\r<ul><li>hosts:</li></ul>\r<ul><li>some_app.com</li></ul>\r\n   secretName: someapp-secret-tls\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Có vấn đề gì khi dùng namespace mặc định?",
              "answer": "<p>Chỉ sử dụng namespace mặc định, sẽ trở nên khó khăn theo thời gian để có được cái nhìn tổng quan về tất cả các ứng dụng bạn có thể quản lý trong cụm của mình. Namespace giúp dễ dàng tổ chức các ứng dụng thành các nhóm có ý nghĩa, chẳng hạn như namespace của tất cả các ứng dụng giám sát và namespace cho tất cả các ứng dụng bảo mật, v.v.\r\n\r\nNamespace cũng có thể hữu ích để quản lý môi trường Blue/Green trong đó mỗi namespace có thể bao gồm một phiên bản ứng dụng khác nhau và cũng chia sẻ tài nguyên trong namespace khác (namespace như logging, giám sát, v.v.).\r\n\r\nMột trường hợp sử dụng khác cho namespace là một cụm có nhiều nhóm. Khi nhiều đội sử dụng cùng một cụm, họ có thể dẫm chân lên nhau. Ví dụ: nếu họ kết thúc việc tạo một ứng dụng có cùng tên, điều đó có nghĩa là một trong các nhóm sẽ ghi đè ứng dụng của nhóm kia vì không thể có hai ứng dụng trong Kubernetes có cùng tên (trong cùng một namespace).</p>",
              "level": "fresher"
            },
            {
              "question": "Cho biết dịch vụ và namespace trong file sau?",
              "answer": "<p>``<code>\r\napiVersion: v1\r\nkind: ConfigMap\r\nmetadata:\r\n  name: some-configmap\r\ndata:\r\n  some_url: silicon.chip\r\n</code>``\r\n\r\nTrả lời - Dịch vụ là \"silicon\", namespace là \"chip\".</p>",
              "level": "fresher"
            },
            {
              "question": "Operator là gì?",
              "answer": "<p>\"Các operator là mở rộng phần mềm cho K8s sử dụng các tài nguyên tùy chỉnh để quản lý các ứng dụng và các thành phần của chúng. Các operator tuân theo các nguyên tắc Kubernetes, đặc biệt là vòng điều khiển.\"</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao lại cần Operator?",
              "answer": "<p>Quá trình quản lý các ứng dụng trong Kubernetes không đơn giản như quản lý các ứng dụng không trạng thái, trong đó việc đạt được trạng thái mong muốn và nâng cấp đều được xử lý theo cùng một cách cho mọi bản sao. Trong các ứng dụng trạng thái, việc nâng cấp mỗi bản sao có thể yêu cầu xử lý khác nhau do tính chất trạng thái của ứng dụng, mỗi bản sao có thể ở một trạng thái khác nhau. Do đó, chúng tôi thường cần một operator để quản lý các ứng dụng trạng thái. Operator Kubernetes phải hỗ trợ việc này.\r\n\r\nĐiều này cũng sẽ giúp tự động hóa quy trình tiêu chuẩn trên nhiều cụm Kubernetes</p>",
              "level": "fresher"
            },
            {
              "question": "GKE là gì?",
              "answer": "<p>GKE là Google Kubernetes Engine dùng cho quản lý và điều phối container Docker. Với sự trợ giúp của Google Public Cloud, ta còn có thể điều phối trên cụm container.</p>",
              "level": "fresher"
            },
            {
              "question": "Ingress Default Backend là gì?",
              "answer": "<p>Nó chỉ định những gì cần làm với một yêu cầu đến cụm Kubernetes không được ánh xạ tới bất kỳ backend nào, tức là phải làm gì khi không có quy tắc nào được xác định cho yêu cầu HTTP đến. Nếu backend mặc định không được xác định, bạn nên xác định nó để người dùng vẫn thấy một số loại thông báo thay vì một lỗi không rõ ràng.\r\n\r\n## Câu hỏi phỏng vấn Kubernetes cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Cách để chạy Kubernetes cục bộ?",
              "answer": "<p>Kubernetes có thể được thiết lập cục bộ bằng cách sử dụng công cụ Minikube. Nó chạy một nhóm nút đơn trong một máy ảo trên máy tính. Do đó, nó cung cấp một cách hoàn hảo cho người dùng vừa mới học Kubernetes.</p>",
              "level": "fresher"
            },
            {
              "question": "Cân bằng tải với Kubernetes?",
              "answer": "<p>Cân bằng tải là một trong những cách phổ biến và tiêu chuẩn để hiển thị các dịch vụ. Có hai loại cân bằng tải trong K8s và chúng là:\r<ul><li><strong>Internal load balancer</strong> - Loại cân bằng này tự động cân bằng tải và phân bổ các pod với tải đến cần thiết.</li></ul>\r<ul><li><strong>External load balancer</strong> - Loại cân bằng này hướng lưu lượng truy cập từ các tải bên ngoài đến các pod backend.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "File cấu hình triển khai bên dưới nghĩa là gì?",
              "answer": "<p>``<code>\r\nspec:\r\n  containers:\r<ul><li>name: USER<em>PASSWORD</li></ul>\r\n      valueFrom:\r\n        secretKeyRef:\r\n          name: some-secret\r\n          key: password\r\n</code>``\r\n\r\n<em>Giải thích</em>\r\n\r\nBiến môi trường USER</em>PASSWORD sẽ lưu giá trị từ khoá mật khẩu được gọi trong \"some-secret\". Nói cách khác bạn tham chiếu một giá trị từ một Kubernetes Secret.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Docker Swarm và Kubernetes?",
              "answer": "<p><ul><li>Quy trình cài đặt của K8s rất phức tạp nhưng nếu nó được cài đặt một lần thì cụm này rất mạnh mẽ. Mặt khác, quá trình cài đặt Docker Swarm rất đơn giản nhưng cụm không mạnh mẽ chút nào.</li></ul>\r<ul><li>Kubernetes có thể xử lý quy mô tự động nhưng Docker Swarm không thể xử lý tự động mở rộng các nhóm dựa trên tải đến.</li></ul>\r<ul><li>Kubernetes là một Framework đầy đủ. Vì nó duy trì trạng thái cụm ổn định hơn nên tự động thay đổi tỷ lệ không nhanh như Docker Swarm.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách khắc phục sự cố nếu POD không lên lịch?",
              "answer": "<p>Trong bộ lập lịch của K8 chịu trách nhiệm tạo các pod vào các nút. Có nhiều yếu tố có thể dẫn đến POD không thể khởi động. Phổ biến nhất là hết tài nguyên, hãy sử dụng các lệnh như <code>kubectl description &lt;POD&gt; -n &lt;Namespace&gt;</code> để xem lý do tại sao POD không được khởi động. Ngoài ra, hãy theo dõi kubectl để nhận các sự kiện để xem tất cả các sự kiện đến từ cụm.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách chạy POD trên một nút cụ thể?",
              "answer": "<p>Các cách khác nhau để làm điều đó:\r<ul><li><strong>nodeName</strong>: chỉ định tên của nút trong cấu hình thông số POD, nó sẽ cố chạy POD trên nút đã chỉ định.</li></ul>\r<ul><li><strong>nodeSelector</strong>: Gán một nhãn cụ thể cho nút có tài nguyên đặc biệt và sử dụng cùng một nhãn trong thông số POD để POD sẽ chỉ chạy trên nút đó.</li></ul>\r<ul><li><strong>nodeaffinities</strong>: <code>WhileSchedulingIgnoredDuringExecution</code>, <code>favouriteDuringSchedulingIgnoredDuringExecution</code> là các yêu cầu cứng và mềm để chạy POD trên các nút cụ thể. Điều này sẽ thay thế nodeSelector trong tương lai. Nó phụ thuộc vào các nhãn nút.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các cách khác nhau để cung cấp kết nối mạng bên ngoài cho K8 là gì?",
              "answer": "<p>Theo mặc định, POD sẽ có thể kết nối với mạng bên ngoài nhưng ngược lại, chúng ta cần thực hiện một số thay đổi. Các tùy chọn sau có sẵn để kết nối với POD từ thế giới bên ngoài.\r<ul><li>Nodeport (hiển thị cổng trên mỗi nút cho giao tiếp với chúng)</li></ul>\r<ul><li>Load balancers (Lớp L4 của giao thức TCP/IP)</li></ul>\r<ul><li>Ingress (Lớp L7 của giao thức TCP/IP)</li></ul>\r\n\r\nMột phương thức khác là dùng kube-proxy để hiển thị dịch vụ với IP cụm trên cổng hệ thống cục bộ.\r\n\r\n``<code>\r\n$ kubectl proxy --port=8080 \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào chúng ta có thể chuyển tiếp cổng '8080 (container) -> 8080 (service) -> 8080 (ingress) -> 80 (browser) và nó có thể được thực hiện như thế nào?",
              "answer": "<p>Ingress đang để lộ cổng 80 ra bên ngoài để trình duyệt truy cập và kết nối với dịch vụ lắng nghe trên 8080. Theo mặc định, ingress sẽ lắng nghe trên cổng 80. \"Ingress controller\" là một nhóm nhận lưu lượng truy cập bên ngoài và xử lý quá trình ingress và được định cấu hình bởi tài nguyên ingress. Vì vậy, bạn cần phải cấu hình ingress selector và nếu không có 'ingress controller selector' được đề cập thì không có bộ ingress controller nào sẽ quản lý quá trình ingress.\r\n\r\nConfig ingress có thể như sau:\r\n\r\n``<code>\r\nhost: abc.org\r\nhttp:\r\npaths:\r\nbackend:\r\nserviceName: abc-service\r\nservicePort: 8080\r\nThen the service will look like\r\nkind: Service\r\napiVersion: v1\r\nmetadata:\r\nname: abc-service\r\nspec:\r\nports:\r\nprotocol: TCP\r\nport: 8080 # port to which the service listens to\r\ntargetPort: 8080\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        }
      ]
    },
    {
      "id": "basics",
      "name": "Computer Science Basics",
      "icon": "school",
      "color": "#f44336",
      "subcategories": [
        {
          "id": "algorithms",
          "name": "Thuật toán",
          "description": "",
          "questions": [
            {
              "question": "Làm thế nào để so sánh hai thuật toán trên cùng một vấn đề?",
              "answer": "<p>Độ phức tạp của một thuật toán là một kỹ thuật được sử dụng để phân loại mức độ hiệu quả của một thuật toán so với các thuật toán khác. Nó tập trung vào kích thước của tập dữ liệu được xử lý ảnh hưởng đến thời gian thực thi như thế nào. Trong lập trình, tính toán độ phức tạp của thuật toán là rất quan trọng. Bạn nên phân loại các thuật toán theo lượng thời gian hoặc không gian mà chúng chiếm dụng và mô tả thời gian hoặc không gian mà chúng chiếm dưới dạng một hàm của kích thước đầu vào.\r\n\r\n<em> <strong>Độ phức tạp thời gian (Complex of Time)</strong>: thời gian chạy của một chương trình được xem như một hàm phụ thuộc vào kích thước đầu vào được gọi là độ phức tạp thời gian.\r\n</em> <strong>Độ phức tạp không gian (Complex of Space)</strong>: dựa trên không gian mà chương trình yêu cầu để xử lý hoàn tất một tác vụ.\r\n\r\n> Trước đây, bộ nhớ phần cứng bị hạn chế nên độ phức tạp không gian là rất quan trọng, nhưng ngày nay bộ nhớ máy tính rất lớn, nên khi đề cập đến độ phức tạp người ta chủ yếu tập trung vào độ phức tạp thời gian.</p>",
              "level": "fresher"
            },
            {
              "question": "Trường hợp tốt nhất, xấu nhất và trung bình?",
              "answer": "<p>Nền tảng toán học cho hiệu suất thực thi thuật toán được xác định bằng tiệm cận. Ta có thể quyết định trường hợp tốt nhất, xấu nhất và trung bình của một thuật toán bằng cách dùng tiệm cận.\r\n\r\n<em> <strong>Trường hợp tốt nhất:</strong> là tập dữ liệu được sắp xếp sao cho thuật toán hoạt động nhanh nhất hay tốn ít không gian nhất. Ví dụ như trong tìm kiếm nhị phân, trường hợp tốt nhất là khi giá trị cần tìm ở giữa mảng dữ liệu, lúc đó thuật toán có độ phức tạp thời gian là <code>O(1)</code>.\r\n</em> <strong>Trường hợp xấu nhất:</strong> ngược lại với trường hợp tốt nhất, là khi tập dữ liệu khiến thuật toán mất nhiều thời gian và không gian thực thi nhất. Ví dụ, trong quicksort trường hợp xấu nhất là khi giá trị <code>pivot</code> là phần tử lớn nhất hoặc nhỏ nhất của <code>sublist</code>, lúc này sẽ có độ phức tạp thời gian là <code>O(n^2)</code> với n là kích thước của tập dữ liệu cần sắp xếp.\r\n<em> <strong>Trường hợp trung bình:</strong> theo lý thuyết về độ phức tạp, thì trường hợp trung bình là lượng tài nguyên mà chương trình cần dùng, được tính trung bình trên tất cả đầu vào có thể. Vd, độ phức tạp trung bình của quicksort là <code>O(n</em>log(n))</code>, với n là kích thước của tập dữ liệu cần sắp xếp.</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về ký hiệu tiệm cận?",
              "answer": "<p>Phân tích tiệm cận là một kỹ thuật được dùng để xác định hiệu quả của một thuật toán mà không dựa vào các thông số kỹ thuật phần cứng và tránh để thuật toán so sánh chính nó với cách tiếp cận lãng phí thời gian. Với phân tích tiệm cận, ký hiệu tiệm cận là một kỹ thuật toán học được dùng để chỉ ra độ phức tạp thời gian của thuật toán.\r\n\r\nTa có 3 ký hiệu tiệm cận phổ biến như sau:\r<ul><li><strong>Ký hiệu theta (θ)</strong>: dùng để xác định chính xác <em>dáng điệu tiệm cận</em>. Nó liên kết các hàm từ bên trên và bên dưới để xác định dáng điệu tiệm cận. Bỏ qua các số hạng bậc thấp và các hằng số đứng đầu là một cách đơn giản để lấy ký hiệu theta cho một biểu thức.</li></ul>\r\n\r\n<img src=\"/interview-assets/The_Theta_Notation.png\" alt=\"\" />\r<ul><li><strong>Ký hiệu O lớn</strong>: dùng để xác định cận trên của một thuật toán. Xem xét thuật toán Insert Sort: trong trường hợp tốt nhất nó cần thời gian tuyến tính và trường hợp xấu nhất cần thời gian bậc hai. Insert Sort có độ phức tạp thời gian là (O(n^2)). Nó hữu ích khi ta chỉ có cận trên về độ phức tạp thời gian của thuật toán.</li></ul>\r\n\r\n<img src=\"/interview-assets/Big_O.png\" alt=\"\" />\r<ul><li><strong>Ký hiệu omega (Ω)</strong>: dùng để cung cấp cận dưới cho một hàm, ngược với ký hiệu O lớn. Nó hữu ích khi ta chỉ có cận dưới của độ phức tạp thời gian của thuật toán.</li></ul>\r\n\r\n<img src=\"/interview-assets/Omega.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Viết chương trình đổi giá trị hai số mà không dùng biến tạm?",
              "answer": "<p>Đây là một câu hỏi thường gặp trong các cuộc phỏng vấn ở nhiều công ty khác nhau. Có nhiều cách để đổi giá trị cho hai số, tuy nhiên ở đây điều kiệu là không được dùng biến tạm. Đối với bài toán này, nếu bạn có thể giải quyết tình huống overflow bạn sẽ để lại ấn tượng tốt với người phỏng vấn.\r\n\r\nGiả sử ta có hai số nguyên a và b, với <code>a=5</code> và <code>b=6</code> ta cần hoán đổi hai số này mà không cần dùng biến tạm, ta có thể làm như sau:\r\n\r\n``<code>java\r\na = a + b;\r\nb = a - b; // this will act like (a+b) - b, and now b equals a.\r\na = a - b; // this will act like (a+b) - a, and now an equals b.\r\n</code>`<code>\r\n\r\nĐã xong, nhưng nó có một vấn đề là nếu phép cộng vượt quá giá trị lớn nhất của kiểu int (như </code>Integer.MAX<em>VALUE<code> trong Java) hoặc nếu phép trừ nhỏ hơn giá trị nhỏ nhất (</code>Integer.MIN</em>VALUE`) thì nó sẽ gây ra hiện tượng overflow.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về mô hình Chia Để Trị. Liệt kê các thuật toán sử dụng mô hình này?",
              "answer": "<p>Chia để trị là một mô hình thuật toán, không phải thuật toán. Nó được xây dựng để xử lý một lượng lớn dữ liệu, bằng cách chia nhỏ nó thành từng phần nhỏ hơn và xác định giải pháp cho các phần nhỏ. Nó kết hợp giải pháp của tất cả phần nhỏ thành một giải pháp toàn cục duy nhất. Dưới đây là mô hình của chia để trị:\r\n\r\n<em> <strong>Devider</strong>: Tách bài toán ban đầu thành một tập các bài toán con.\r\n</em> <strong>Conquer</strong>: Giải quyết từng bài toán con đơn lẻ.\r\n<em> <strong>Combiner</strong>: Kết hợp giải pháp của các bài toán con thành một giải pháp tổng thể.\r\n\r\n<img src=\"/interview-assets/Divide_and_Conquer.png\" alt=\"\" />\r\n\r\nCác thuật toán dùng mô hình chia để trị:\r\n\r\n</em> Binary Search\r\n<em> Merge Sort\r\n</em> Strassen's Matrix Multiplication\r\n<em> Quick Sort\r\n</em> Closest pair of points</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về thuật toán tham lam và liệt kê các ví dụ sử dụng nó?",
              "answer": "<p>Thuật toán tham lam là một phương pháp nhằm mục địch chọn ra quyết định tối ưu nhất ở mỗi bước con, cuối cùng dẫn đến giải pháp tối ưu tổng thể. Tức là, tại mỗi thời điểm thuật toán luôn chọn câu trả lời tốt nhất ngay lập tức mà không cần cân nhắc tương lai. Cũng có thể nói thuật toán sẽ chọn ra câu trả lời tốt nhất hiện có, bất kể hậu quả là gì. Các thuật toán tham lam có thể tìm ra câu trả lời không phải là tối ưu nhất trong một số trường hợp.\r\n\r\nCác ví dụ sử dụng thuật toán tham lam:\r\n\r\n<em> Prim's Minimal Spanning Tree Algorithm\r\n</em> Kruskal's Minimal Spanning Tree Algorithm\r\n<em> Travelling Salesman Problem\r\n</em> Fractional Knapsack Problem\r\n<em> Dijkstra's Algorithm\r\n</em> Job Scheduling Problem\r\n<em> Graph Map Coloring\r\n</em> Graph Vertex Cover</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về thuật toán tìm kiếm? Liệt kê vài thuật toán tìm kiếm?",
              "answer": "<p>Thuật toán tìm kiếm được sử dụng để tìm kiếm một phần tử hoặc lấy nó ra từ một cấu trúc dữ liệu (thường là một danh sách các phần tử). Các thuật toán này được chia thành hai loại dựa trên loại hoạt động tìm kiếm:\r\n\r\n<em> <strong>Tìm kiếm tuần tự</strong>: Phương pháp này duyệt qua danh sách các phần tử liên tục, kiểm tra từng phần tử và báo cáo nếu phần tử cần tìm có được tìm thấy hay không. Tìm kiếm tuyến tính là một ví dụ về Thuật toán tìm kiếm tuần tự.\r\n</em> <strong>Tìm kiếm theo khoảng</strong>: các thuật toán này được tạo đặc biệt cho tìm kiếm trên các cấu trúc dữ liệu đã sắp xếp. Vì nó hướng đến tìm kiếm ở trung tâm cấu trúc và chia ra thành các khoảng nhỏ, để tìm kiếm mục tiêu. Các loại thuật toán này hiệu quả hơn nhiều so với tìm kiếm tuần tự. Tìm kiếm Nhị phân là một ví dụ về tìm kiếm theo khoảng</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả thuật toán tìm kiếm tuyến tính?",
              "answer": "<p>Để tìm kiếm một phần tử trong một tập hợp phần tử, có thể sử dụng tìm kiếm tuyến tính. Nó hoạt động bằng cách duyệt qua tập phần tử từ đầu đến cuối và quan sát thuộc tính của tất cả phần tử đã đi qua. Giả sử ta có trường hợp với mảng chỉ toàn số nguyên, ta muốn tìm và in tất cả vị trí của phần tử trùng với một giá trị cụ thể (còn gọi là <code>key</code> trong tìm kiếm tuyến tính). Tìm kiếm tuyến tính hoạt động như sau:\r\n\r\n1. Dùng vòng lặp duyệt qua danh sách phần tử đã cho.\r\n2. Với mỗi lần lặp, so sánh giá trị hiện tại với key.\r\n3. Nếu trùng in ra vị trí của phần tử hiện tại.\r\n4. Chuyển đến phần tử kế tiếp nếu giá trị không trùng.\r\n5. Lặp lại từ 1 đến 4 cho đến khi hết danh sách.\r\n\r\n<img src=\"/interview-assets/Linear_Search_Algorithm.png\" alt=\"\" />\r\n\r\nĐộ phức tạp thời gian của thuật toán tìm kiếm tuyến tính là <code>O(n)</code> trong đó n là kích thước của danh sách các phần tử và độ phức tạp không gian của nó là không đổi, nghĩa là <code>O(1)</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả thuật toán tìm kiếm nhị phân?",
              "answer": "<p>Để áp dụng tìm kiếm nhị phân trên danh sách các phần tử, điều kiện tiên quyết là danh sách các phần tử phải được sắp xếp. Nó dựa trên mô hình thuật toán Chia để Trị. Trong tìm kiếm nhị phân, ta chia khoảng tìm kiếm thành hai phần để tìm trong danh sách đã sắp xếp. Ta bắt đầu bằng cách tạo khoảng trên toàn bộ danh sách. Nếu giá trị của khoá tìm kiếm nhỏ hơn phần tử ở giữa khoảng, thì khoảng đó được thu hẹp về trước, còn không nó sẽ được thu hẹp về sau. Ta tiếp tục thực hiện chia trên các khoảng nhỏ cho đến khi tìm được kết quả. Dưới đây là mô tả thuật toán tìm kiếm nhỉ phân.\r\n\r\n1. <code>x</code> sẽ được so sánh với phần tử ở giữa\r\n2. Trả về nếu <code>x</code> trùng với phần tử ở giữa\r\n3. Ngược lại nếu <code>x</code> lớn hơn, <code>x</code> chỉ có thể ở nữa phía sau của mảng vì mảng được sắp xếp theo thứ tự tăng dần. Ta lặp lại với nữa mảng con phía sau.\r\n4. Nếu như <code>x</code> bé hơn, <code>x</code> chỉ có thể ở nữa phía trước của mảng, ta lặp lại với nữa mảng con phía trước.\r\n5. Nếu các khoảng được chia chỉ còn một phần tử(không thể chia nữa), ta dừng tìm kiếm nhị phân.\r\n\r\nĐộ phức tạp thời gian của tìm kiếm nhị phân là <code>O(log(n))</code> với n là kích thước của danh sách phần tử và độ phức tạp không gian là <code>O(1)</code></p>",
              "level": "fresher"
            },
            {
              "question": "Viết ra một thuật toán để thêm một nút vào danh sách liên kết được sắp xếp theo thứ tự tăng dần (duy trì thuộc tính sắp xếp)?",
              "answer": "<p>Dưới đây là một thuật toán để thêm một nút vào danh sách liên kết được sắp xếp:\r\n\r\n1. Kiểm tra danh sách liên kết có rỗng hay không. Nếu có tạo nút <code>head</code> và trả về.\r\n2. Kiểm tra giá trị của nút thêm vào có nhỏ hơn nút <code>head</code> hay không. Nếu có, đặt nó ở đầu và biến nó thành <code>head</code>.\r\n3. Nếu không thì thì sử dụng vòng lặp để thêm nút đó vào vào vị trí thích hợp. Bằng cách bắt đầu duyệt từ nút <code>head</code> trỏ đến phần tử kế tiếp cho đến khi tìm được nút có giá trị lớn hơn nút đầu vào.\r\n4. Sau khi tìm được vị trí cần chèn thì thực hiện chèn nút.</p>",
              "level": "fresher"
            },
            {
              "question": "Viết thuật toán đếm số nút lá trong cây nhị phân?",
              "answer": "<p>Dưới đây là một thuật toán để đếm số lượng nút lá trong cây nhị phân:\r\n\r\n1. Nếu nút hiện tại là null, trả về giá trị 0.\r\n2. Nếu gặp phải nút lá, nghĩa là nếu nút trái và nút phải của nút hiện tại đều rỗng, thì trả về 1.\r\n3. Tính đệ quy số nút lá bằng cách cộng số nút lá trong cây con bên trái với số nút lá trong cây con bên phải.</p>",
              "level": "fresher"
            },
            {
              "question": "Quy hoạch động là gì? Liệt kê các vấn đề sử dụng quy hoạch động?",
              "answer": "<p><img src=\"/interview-assets/Dynamic_Programming.png\" alt=\"\" />\r\n\r\nQuy hoạch động chủ yếu là tối ưu hoá đệ quy. Ta có thể sử dụng Quy hoạch động để tối ưu hoá bất kỳ giải pháp đệ quy nào có các lời gọi lặp lại cho cùng một đầu vào. Mục đích đơn giản là để lưu trữ kết quả các vấn đề con cho lần tính toán tiếp theo. Độ phức tạp thời gian của sự tối ưu hoá này được giảm theo cấp số nhân. Ví dụ: nếu  ta tạo một giải pháp đệ quy đơn giản cho số Fibonacci, thì độ phức tạp về thời gian là cấp số nhân, nhưng nếu ta tối ưu hóa nó bằng cách lưu trữ các câu trả lời cho các bài toán con bằng Quy hoạch động, thì độ phức tạp về thời gian là tuyến tính. \r\n\r\nCode minh hoạ như sau:\r\n\r\n<strong>Với đệ quy (không QHĐ)</strong>: Độ phức tạp về thời gian của code đã cho sẽ theo cấp số nhân.\r\n\r\n``<code>cpp\r\nint nFibonacci(int n){\r\n   if(n == 0 || n == 1) return n;\r\n   else return nFibonacci(n - 1) + nFibonacci(n - 2);\r\n}\r\n</code>`<code>\r\n\r\n<strong>Với đệ quy (dùng QHĐ)</strong>: Độ phức tạp về thời gian của code đã cho sẽ là tuyến tính.\r\n\r\n</code>`<code>cpp\r\nint nFibonacci(int n){\r\n   vector&lt;int&gt; fib(n + 1);\r\n   fib[0] = 0;\r\n   fib[1] = 1;\r\n   for(int i = 2;i &lt;= n;i ++){\r\n      fib[i] = fib[i - 1] + fib[i - 2];\r\n   }\r\n   return fib[n]; \r\n}\r\n</code>``\r\n\r\nMột vài vấn đề cần dùng Quy Hoạch động:\r<ul><li>Tìm số Fibonacci thứ n</li></ul>\r<ul><li>Tìm chuỗi con chung dài nhất giữa hai chuỗi.</li></ul>\r<ul><li>Tìm chuỗi con Palindromic dài nhất trong một chuỗi.</li></ul>\r<ul><li>Vấn đề Knapsack (hoặc 0-1) rời rạc.</li></ul>\r<ul><li>Đường đi ngắn nhất giữa hai nút bất kỳ trong đồ thị (Thuật toán Floyd Warshall).</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Viết thuật toán đảo chuỗi. Ví dụ như nhập vào Hello đảo thành Olleh?",
              "answer": "<p>Thuật toán cho đảo chuỗi như sau:\r\n\r\n1. Ta có hai biến là <code>l</code> và <code>r</code>.\r\n2. Gán giá trị cho <code>l</code> là 0 và <code>r</code> là chiều dài chuỗi - 1.\r\n3. Hoán đổi giá trị của các ký tự ở vị trí <code>l</code> và <code>r</code> trong chuỗi.\r\n4. Tăng <code>l</code> lên một đơn vị.\r\n5. Giảm <code>r</code> xuống một đơn vị.\r\n6. Nếu giá trị <code>r</code> lớn hơn <code>l</code>, trở về bước 3.\r\n7. Dừng.</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về thuật toán BFS (Breadth First Search)?",
              "answer": "<p>Thuật toán duyệt đồ thị ưu tiên chiều rộng (Breadth-first search - BFS) là một trong những thuật toán tìm kiếm cơ bản và thiết yếu trên đồ thị. Mà trong đó, những đỉnh nào gần đỉnh xuất phát hơn sẽ được duyệt trước. Nó bắt đầu bằng cách duyệt qua đồ thị từ nút gốc và đi đến tất cả các nút lân cận. Nó chọn nút gần nhất và từ đó truy cập tất cả các nút chưa được truy cập. Cho đến khi nó đến nút mục tiêu, thuật toán lặp lại cùng một phương pháp cho mỗi nút gần nhất.\r\n\r\nThuật toán BFS được đưa ra dưới đây:\r\n\r\n1. Đặt <code>status = 1</code> làm bước đầu tiên cho tất cả các nút (trạng thái sẵn sàng).\r\n2. Đặt <code>status</code> của nút ban đầu A là <code>2</code>, tức là trạng thái chờ.\r\n3. Lặp lại các bước 4 và 5 cho đến khi đầy hàng đợi.\r\n4. Dequeue và xử lý nút N từ hàng đợi, thiết lập <code>status</code> của nó thành 3, nghĩa là trạng thái đã xử lý.\r\n5. Đặt tất cả nút lân cận của N đang ở trạng thái sẵn sàng (<code>status = 1</code>) vào hàng đợi và chuyển <code>status</code> của chúng thành 2 (trạng thái chờ)\r\n6. Thoát.</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về thuật toán DFS (Depth First Search)?",
              "answer": "<p>Tìm kiếm ưu tiên chiều sâu hay tìm kiếm theo chiều sâu là một kỹ thuật để duyệt hoặc tìm kiếm trên các cấu trúc dữ liệu như cây và đồ thị. Thuật toán bắt đầu ở nút gốc (trong trường hợp đồ thị, bất kỳ nút ngẫu nhiên nào cũng có thể được sử dụng làm nút gốc) và kiểm tra từng nhánh càng xa càng tốt trước khi kiểm tra lại. Vì vậy, ý tưởng cơ bản là bắt đầu tại gốc hoặc bất kỳ nút nào tùy ý và đánh dấu nó, sau đó tiến tới nút không được đánh dấu tiếp theo và lặp lại cho đến khi không còn nút nào chưa được đánh dấu. Sau đó, quay lại và kiểm tra xem có bất kỳ nút nào chưa được đánh dấu để vượt qua không. Cuối cùng, in các nút của đường đi. Thuật toán DFS được đưa ra dưới đây:\r\n\r\n1. Tạo một hàm đệ quy lấy chỉ mục của nút và một mảng đã đi qua làm đầu vào.\r\n2. Đặt nút hiện tại thành nút đã truy cập và hiển thị nó.\r\n3. Gọi hàm đệ quy với chỉ mục của nút liền kề sau khi đi ngang qua tất cả các nút lân cận và không được đánh dấu.\r\n\r\n## Câu hỏi phỏng vấn cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Cách mà thuật toán mã hoá hoạt động?",
              "answer": "<p>Quá trình chuyển đổi từ văn bản thuần (plaintext) thành một dạng mã bí mật \"ciphertext\" được gọi là quá trình mã hoá. Trong mật mã học, kỹ thuật này sử dụng một chuỗi còn gọi là \"khoá\" để chuyển đổi văn bản. Khoá càng lớn càng có nhiều bản tiềm năng để tạo thành bản mã hoá - ciphertext. Phần lớn các thuật toán mã hóa sử dụng các khối đầu vào cố định với độ dài từ 64 đến 128 bit, trong khi các thuật toán khác sử dụng kỹ thuật dòng.</p>",
              "level": "fresher"
            },
            {
              "question": "Các thuật toán mã hoá phổ biến hiện nay?",
              "answer": "<p>Một số thuật toán mật mã được sử dụng rộng rãi nhất như sau:\r<ul><li>IDEA</li></ul>\r<ul><li>CAST</li></ul>\r<ul><li>CMEA</li></ul>\r<ul><li>3-way</li></ul>\r<ul><li>Blowfish</li></ul>\r<ul><li>GOST</li></ul>\r<ul><li>LOKI</li></ul>\r<ul><li>DES và Triple DES.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả thuật toán merge sort?",
              "answer": "<p>Merge sort (tạm dịch là sắp xếp trộn) là một thuật toán sắp xếp đa dụng có hiệu quả rất cao. Nó được xếp vào thể loại sắp xếp so sánh. Năm 1945, John von Neumann đã phát minh ra phương pháp sắp xếp trộn, dựa trên mô hình thuật toán chia để trị. Sau đây là cách sắp xếp trộn hoạt động:\r<ul><li>Chia danh sách chưa được sắp xếp thành n danh sách con,  mỗi danh sách có một phần tử (danh sách một phần tử được coi là đã sắp xếp).</li></ul>\r<ul><li>Gộp các danh sách con nhiều lần để tạo ra danh sách con được sắp xếp mới cho đến khi chỉ còn lại một danh sách con. Danh sách con cuối cùng chính là danh sách đã sắp xếp.</li></ul>\r\n\r\nĐộ phức tạp thời gian của sắp xếp trộn là <code>O(n*log(n))</code> với n là kích thước của danh sách phần tử cần sắp xếp, còn độ phức tạp không gian là <code>O(n)</code>.\r\n\r\n<img src=\"/interview-assets/merge_sort_algorithm.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả thuật toán quick sort?",
              "answer": "<p>Quicksort (tạm dịch là sắp xếp nhanh) là một thuật toán sắp xếp tại chỗ (có nghĩa là một thuật toán biến đổi đầu vào mà không sử dụng cấu trúc dữ liệu phụ). Nó được tạo ra bởi nhà khoa học máy tính người Anh Tony Hoare vào năm 1959 và được công bố vào năm 1961, đến nay nó vẫn là một thuật toán sắp xếp phổ biến. Nó có thể nhanh hơn một chút so với merge sort và nhanh hơn hai hoặc ba lần so với heap sort khi được thực hiện đúng cách. \r\n\r\nQuicksort dựa trên mô hình thuật toán chia để trị. Nó thực hiện bằng cách chọn một phần tử \"pivot\" từ mảng và tách mảng thành hai mảng con dựa trên việc các phần tử còn lại lớn hơn hay bé hơn pivot. Do đó, nó còn được gọi là sắp xếp phân vùng. Mảng con sau đó sẽ được sắp xếp với đệ quy.\r\n\r\nSau đây là các bước cho quicksort:\r<ul><li>Nếu có ít hơn hai phần tử trong mảng, trả về ngay lập tức vì không thể làm gì khác. </li></ul>\r<ul><li>Nếu không, chọn một giá trị làm <code>pivot</code> (chốt), cách lựa chọn là tuỳ ý, song vẫn có một số cách lựa chọn tiêu biểu như sau:</li></ul>\r<ul><li>Chọn phần tử đứng đầu hoặc đứng cuối.</li></ul>\r<ul><li>Chọn phần tử đứng giữa.</li></ul>\r<ul><li>Chọn phần tử trung vị trong 3 phần tử đứng đầu, đứng giữa và đứng cuối.</li></ul>\r<ul><li>Chọn phần tử ngẫu nhiên. (Cách này có thể dẫn đến khả năng rơi vào các trường hợp đặc biệt)</li></ul>\r<ul><li>Xác định điểm phân chia sao cho tất cả các phần tử có giá trị nhỏ hơn <code>pivot</code> đều xuất hiện trước và tất cả các phần tử có giá trị lớn hơn <code>pivot</code> sẽ xuất hiện sau nó; các phần tử có giá trị bằng <code>pivot</code> có thể xuất hiện theo một trong hai hướng.</li></ul>\r<ul><li>Áp dụng quicksort đệ quy lên các phạm vi con cả trước và sau điểm phân chia, loại bỏ phần tử bằng <code>pivot</code> tại điểm phân chia khỏi cả hai phạm vi.</li></ul>\r\n\r\n<img src=\"/interview-assets/quicksort.gif\" alt=\"\" />\r\n\r\nPhân tích toán học của Quicksort cho thấy rằng, trường hợp trung bình sẽ mất độ phức tạp thời gian <code>O(n * log(n))</code> để sắp xếp n mục. Trong trường hợp xấu nhất, nó phải thực hiện với độ phức tạp thời gian là <code>O(n ^ 2)</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả thuật toán bubble sort cùng với ví dụ?",
              "answer": "<p>Sắp xếp nổi bọt là một thuật toán sắp xếp cơ bản lặp lại qua một danh sách, so sánh các phần tử liền kề và hoán đổi chúng nếu chúng không theo thứ tự. Danh sách được lặp đi lặp lại nhiều lần cho đến khi nó được sắp xếp. Phương pháp này được đặt tên theo cách mà các phần tử nhỏ hơn hoặc lớn hơn \"nổi bọt\" lên đầu danh sách. Phương pháp đơn giản này hoạt động không tốt trong các tình huống thực tế và chủ yếu được sử dụng trong giảng dạy. Lấy một ví dụ để hiểu cách sắp xếp nổi bọt hoạt động:\r\n\r\nGiả sử rằng mảng cần sắp xếp là (50 10 40 20 80). Các lần sắp xếp nổi bọt như sau:\r<ul><li><strong>Lần đầu tiên</strong>:</li></ul>\r<ul><li>(50 10 40 20 80) -> (10 50 40 20 80), Vì 50 > 10, thuật toán so sánh hai phần tử đầu tiên và hoán đổi chúng.</li></ul>\r<ul><li>(10 50 40 20 80) -> (10 40 50 20 80), Vì 50 > 40, thuật toán hoán đổi các giá trị ở vị trí thứ hai và thứ ba.</li></ul>\r<ul><li>(10 40 50 20 80) -> (10 40 20 50 80), Vì 50 > 20, thuật toán hoán đổi phần tử thứ ba và thứ tư.</li></ul>\r<ul><li>(10 40 20 50 80) -> (10 40 20 50 80), không hoán đổi phần tử thứ tư và thứ năm vì chúng đã có thứ tự (80 > 50).</li></ul>\r<ul><li><strong>Lần thứ hai</strong>:</li></ul>\r<ul><li>(10 40 20 50 80) -> (10 40 20 50 80), Các phần tử ở vị trí thứ nhất và thứ hai theo thứ tự nên không hoán đổi vị trí.</li></ul>\r<ul><li>(10 40 20 50 80) -> (10 20 40 50 80), Vì 40 > 20, thuật toán hoán đổi các giá trị ở vị trí thứ hai và thứ ba.</li></ul>\r<ul><li>(10 20 40 50 80) -> (10 20 40 50 80), Các phần tử ở vị trí thứ ba và thứ tư theo thứ tự nên không hoán đổi vị trí.</li></ul>\r\n(10 20 40 50 80) -> (10 20 40 50 80), Các phần tử ở vị trí thứ tư và thứ năm theo thứ tự nên không hoán đổi vị trí.\r\n\r\nMảng hiện tại đã được sắp xếp, nhưng thuật toán nổi bọt không biết điều đó. Để chắc chắn, nó phải hoàn thành một vòng lặp nữa mà không có bất kỳ sự hoán đổi nào.\r<ul><li><strong>Lần thứ hai</strong>:</li></ul>\r<ul><li>( 10 20 40 50 80 ) –> ( 10 20 40 50 80 ), Các phần tử ở vị trí thứ nhất và thứ hai theo thứ tự nên không hoán đổi vị trí.</li></ul>\r<ul><li>( 10 20 40 50 80 ) –> ( 10 20 40 50 80 ), Các phần tử ở vị trí thứ hai và thứ ba theo thứ tự nên không hoán đổi vị trí.</li></ul>\r<ul><li>( 10 20 40 50 80 ) –> ( 10 20 40 50 80 ), Các phần tử ở vị trí thứ ba và thứ tư theo thứ tự nên không hoán đổi vị trí.</li></ul>\r<ul><li>( 10 20 40 50 80 ) –> ( 10 20 40 50 80 ), Các phần tử ở vị trí thứ tư và thứ năm theo thứ tự nên không hoán đổi vị trí.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Viết thuật toán tính tổng mảng con lớn nhất của một mảng cho trước. Nói cách khác, tìm tổng lớn nhất có thể đạt được bằng cách lấy các phần tử được sắp xếp từ một mảng số nguyên cho trước?",
              "answer": "<p>Thuật toán Kadane có thể được sử dụng để tìm tổng mảng con lớn nhất cho một mảng nhất định. Từ trái sang phải, thuật toán của Kadane tìm kiếm mảng được cung cấp. Sau đó, nó tính toán mảng con có tổng lớn nhất kết thúc ở vị trí <code>j</code> trong bước thứ <code>j</code> và tổng này được lưu trữ trong biến <code>currentSum</code>. Sau đó, nó tính toán mảng con với tổng lớn nhất ở bất kỳ vị trí nào trong mảng con bắt đầu từ vị trí đầu tiên đến vị trí thứ <code>j</code>, nghĩa là <code>A[1 ... j]</code> và lưu trữ nó trong biến <code>bestSum</code>. Điều này được thực hiện bằng cách lấy giá trị lớn nhất của biến <code>currentSum</code> cho đến bây giờ và sau đó lưu trữ nó trong biến <code>bestSum</code>. Cuối cùng, giá trị của <code>bestSum</code> được trả về là câu trả lời cuối cùng cho vấn đề của chúng ta.\r\n\r\nMã giả:\r\n\r\n``<code>\r\nStep 1: Khởi tạo biến:\r\nbestSum = INT_MIN\r\ncurrentSum = 0 // nếu mảng trống, giá trị khởi tạo là 0\r\nStep 2: Lặp qua tất cả phần tử trong mảng A\r\n   (a) currentSum  = currentSum  + A[i]\r\n   (b) if(bestSum &lt; currentSum)\r\n      bestSum = currentSum \r\n   (c) if(currentSum  &lt; 0)\r\n      currentSum = 0\r\nStep 3: return bestSum\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích Thuật toán Dijkstra để tìm đường đi ngắn nhất giữa một nút đến bất kỳ nút nào khác trong đồ thị?",
              "answer": "<p>Thuật toán Dijkstra là một phương pháp xác định đường đi ngắn nhất giữa các nút trong đồ thị, có thể được sử dụng để mô tả mạng lưới đường. Edsger W. Dijkstra, một nhà khoa học máy tính, đã tạo ra nó vào năm 1956 và công bố nó ba năm sau đó. Có rất nhiều biến thể của thuật toán. Thuật toán Dijkstra ban đầu dùng để tìm ra đường đi ngắn nhất giữa hai nút, nhưng một biến thể nổi tiếng hơn đã đặt một nút duy nhất làm nút \"nguồn\" và tìm các đường đi ngắn nhất từ ​​nguồn đến tất cả các nút khác trong đồ thị. Chúng ta hãy xem xét Thuật toán Dijkstra để tìm đường đi ngắn nhất giữa một nút nhất định trong đồ thị đến bất kỳ nút nào khác:\r\n\r\nĐầu tiên ta gọi nút nơi chúng ta bắt đầu quá trình là nút ban đầu. Khoảng cách từ nút ban đầu đến Y là khoảng cách của nút Y.Thuật toán Dijkstra sẽ bắt đầu với khoảng cách không giới hạn và cố gắng cải thiện chúng trong từng bước:\r<ul><li>Bước 1: Đánh dấu tất cả các nút chưa được truy cập. Tập hợp chưa được truy cập là tập hợp tất cả các nút chưa được truy cập.</li></ul>\r<ul><li>Bước 2: Gán giá trị khoảng cách dự kiến ​​cho mỗi nút: đặt nó thành 0 cho nút đầu tiên của chúng ta và vô cùng cho tất cả các nút khác. Độ dài của đường đi ngắn nhất được phát hiện cho đến nay giữa nút <code>v</code> và nút ban đầu là khoảng cách dự kiến ​​của nút <code>v</code>. Bởi vì không có đỉnh nào khác ngoài nút ban đầu, tất cả các khoảng cách dự kiến ​​khác được đặt thành vô cùng. Đặt nút hiện tại là nút ban đầu</li></ul>\r<ul><li>Bước 3: Xem xét tất cả các nút lân cận không được truy cập của nút hiện tại và xác định khoảng cách gần đúng của chúng qua nút hiện tại. So sánh khoảng cách dự kiến ​​mới được tính toán với giá trị được chỉ định hiện tại và chọn giá trị nhỏ hơn. Nếu nút hiện tại <code>A</code> có khoảng cách là 5 và cạnh liên kết nó với nút lân cận <code>B</code> có độ dài là 3 thì khoảng cách từ B đến A sẽ là 5 +3 = 8. Thay đổi B thành 8 nếu trước đó nó được đánh dấu bằng khoảng cách lớn hơn 8. Nếu không, giá trị hiện tại sẽ được giữ lại.</li></ul>\r<ul><li>Bước 4: Đánh dấu nút hiện tại là đã được truy cập và xóa nó khỏi tập hợp chưa được truy cập khi chúng ta đã xem xét tất cả các nút lân cận chưa được truy cập của nút hiện tại. Một nút đã được truy cập sẽ không bao giờ được kiểm tra lại.</li></ul>\r<ul><li>Dừng lại nếu nút đích đã được đánh dấu là đã truy cập hoặc nếu khoảng cách dự kiến ​​nhỏ nhất giữa các nút trong tập hợp chưa truy cập là vô cùng. Thuật toán hoàn tất.</li></ul>\r<ul><li>Bước 5: Nếu không, hãy quay lại bước 3 và chọn nút chưa truy cập được chỉ định với khoảng cách dự kiến ​​ngắn nhất làm nút hiện tại mới.</li></ul>\r\n\r\n<img src=\"/interview-assets/Dijkstra's_Algorithm.png\" alt=\"\" />\r\n\r\nKhông bắt buộc phải đợi cho đến khi nút đích được \"truy cập\" như mô tả ở trên, trong khi xây dựng một đường đi: thuật toán có thể kết thúc khi nút đích có khoảng cách dự kiến nhỏ nhất trong số tất cả các nút \"chưa được truy cập\" (và do đó có thể được chọn là nút tiếp theo \"hiện tại\"). Đối với các đồ thị có hướng tùy ý với trọng số không giới hạn, thuật toán Dijkstra là tiệm cận của thuật toán đường đi ngắn nhất với nguồn đơn nhanh nhất được biết đến với độ phức tạp theo thời gian là <code>O(|E| + |V|log(|V|))</code>, trong đó |V| là số nút và |E| là số cạnh trong đồ thị.</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể sử dụng tìm kiếm nhị phân với danh sách liên kết không?",
              "answer": "<p>Không. Bởi vì truy cập ngẫu nhiên không thể thực hiện trong danh sách liên kết, việc truy cập phần tử ở giữa trong thời gian không đổi hoặc O(1) là không thể. Do đó, việc sử dụng thuật toán tìm kiếm nhị phân trên danh sách được liên kết là không thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Thuật toán đệ quy là gì? Nêu các quy tắc quan trọng mà mọi thuật toán đệ quy phải tuân theo?",
              "answer": "<p>Thuật toán đệ quy là một cách giải quyết một vấn đề phức tạp bằng cách chia nó thành các bài toán con nhỏ hơn và nhỏ hơn nữa cho đến khi vấn đề đủ nhỏ để giải quyết nhanh chóng. Nó thường liên quan đến một hàm gọi chính nó (thuộc tính của hàm đệ quy).\r\n\r\nBa quy tắc phải được tuân theo bởi tất cả các thuật toán đệ quy như sau:\r\n\r\n1. Một thuật toán đệ quy phải gọi chính nó, một cách đệ quy.\r\n2. Một thuật toán đệ quy phải có một trường hợp cơ sở.\r\n3. Một thuật toán đệ quy phải thay đổi trạng thái của nó và chuyển sang trường hợp cơ sở.</p>",
              "level": "fresher"
            },
            {
              "question": "Viết một thuật toán để chèn một nút trong Cây tìm kiếm nhị phân?",
              "answer": "<p>Dưới đây là một thuật toán để chèn một nút trong Cây tìm kiếm nhị phân:\r\n\r\n1. Gán nút hiện tại cho <code>root</code>.\r\n2. Nếu giá trị của <code>root</code> lớn hơn giá trị được thêm vào:\r<ul><li>Nếu <code>root</code> có nút con bên trái, hãy chuyển sang bên trái.</li></ul>\r<ul><li>Còn không thì chèn nó ở đây.</li></ul>\r\n3. Nếu giá trị của <code>root</code> nhỏ hơn giá trị được thêm vào:\r<ul><li>Nếu <code>root</code> có nút con bên phải, hãy chuyển sang bên phải.</li></ul>\r<ul><li>Còn không thì chèn nó ở đây.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Phân biệt select sort và insert sort?",
              "answer": "<p><strong>Insert Sort</strong>: Sắp xếp chèn phân tách danh sách thành các danh sách con được sắp xếp và không được sắp xếp. Nó sẽ chèn từng phần tử vào vị trí thích hợp trong danh sách con được sắp xếp. Sau khi chèn, đầu ra là một danh sách con được sắp xếp. Nó hoạt động lặp đi lặp lại trên tất cả các phần tử của danh sách con không được sắp xếp và chèn chúng vào danh sách con được sắp xếp theo thứ tự.\r\n\r\n<strong>Select Sort</strong>: Sắp xếp lựa chọn là một kỹ thuật sắp xếp tại chỗ. Nó tách bộ sưu tập dữ liệu thành các danh sách con được sắp xếp và không được sắp xếp. Phần tử tối thiểu từ danh sách con chưa được sắp xếp sau đó được chọn và đặt trong danh sách đã sắp xếp. Điều này lặp lại cho đến khi tất cả các phần tử trong danh sách con chưa được sắp xếp đã được sử dụng bởi danh sách con được sắp xếp.\r\n\r\n<em>Lưu ý</em>: Cả hai đều dùng hai danh sách con, đã sắp xếp và chưa sắp xếp, đồng thời đặt từng phần tử vào danh sách con đã sắp xếp. Sắp xếp chèn lấy phần tử hiện được chọn và đặt nó vào mảng đã sắp xếp ở đúng điểm trong khi vẫn giữ các thuộc tính sắp xếp chèn. Mặt khác, sắp xếp lựa chọn tìm kiếm phần tử nhỏ nhất trong danh sách con chưa được sắp xếp và thay thế nó với phần tử hiện tại.</p>",
              "level": "fresher"
            },
            {
              "question": "Định nghĩa duyệt cây và liệt kê một số thuật toán để duyệt cây nhị phân?",
              "answer": "<p>Quá trình truy cập tất cả các nút của một cây được gọi là quá trình duyệt qua cây.\r\n\r\nMột số thuật toán để duyệt cây nhị phân như sau:\r<ul><li>Duyệt tiền thứ tự.</li></ul>\r<ul><li>Duyệt trung thứ tự.</li></ul>\r<ul><li>Duyệt hậu thứ tự.</li></ul>\r<ul><li>Tìm kiếm theo chiều sâu.</li></ul>\r<ul><li>Duyệt ZigZag.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả thuật toán sắp xếp Heap sort?",
              "answer": "<p>Heap sort là thuật toán dựa trên so sánh. Heap sort tương tự selection sort trong đó nó chia mảng đầu vào thành hai mảng con đã sắp xếp và chưa sắp xếp, nó giảm phạm vi mảng chưa được sắp xếp cho đến phần tử cuối cùng và đặt nó vào mảng đã sắp xếp. Không giống như selection sort, heap sort không phải lãng phí thời gian cho quét mảng chưa sắp xếp một cách tuyến tính, thay vào đó nó giữ mảng chưa sắp xếp ở cấu trúc dữ liệu heap để xác định phần tử lớn nhất trong từng bước mở rộng.\r\n\r\nĐầu tiên heap sort chuyển đổi mảng sang heap. Với heap giá trị lớn nhất được lưu ở gốc. Thuật toán hoán đổi giá trị gốc và giá trị cuối cùng của heap, sau đó giảm kích thước của heap đi 1 và lọc giá trị đầu tiên mới vào vị trí heap của nó. Quá trình này lặp đi lặp lại cho đến khi kích thước của heap là 1.\r<ul><li>Với danh sách, hãy dùng hàm <code>buildMaxHeap()</code>. Hàm này còn được gọi là <code>heapify()</code> tạo một heap từ một danh sách trong thác tác O(n).</li></ul>\r<ul><li>Hoán đổi phần tử đầu và cuối của heap. Giảm kích thước của nó đi 1.</li></ul>\r<ul><li>Để sàng lọc phần tử ban đầu mới vào chỉ mục thích hợp của nó trong heap, hãy sử dụng hàm <code>siftDown()</code>.</li></ul>\r<ul><li>Trừ khi kích thước của heap là một, lặp lại bước 2.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Độ phức tạp không gian của thuật toán sắp xếp chèn là gì?",
              "answer": "<p>Sắp xếp chèn là một phương pháp sắp xếp tại chỗ, có nghĩa là nó không yêu cầu bất kỳ lưu trữ dữ liệu bổ sung nào. Trong sắp xếp chèn, chỉ một phần tử danh sách duy nhất phải được lưu trữ bên ngoài dữ liệu ban đầu, dẫn đến độ phức tạp không gian không đổi hoặc độ phức tạp không gian O (1).</p>",
              "level": "fresher"
            },
            {
              "question": "Độ phức tạp không gian của thuật toán sắp xếp lựa chọn là gì?",
              "answer": "<p>Sắp xếp lựa chọn là một phương pháp sắp xếp tại chỗ, có nghĩa là nó không yêu cầu bất kỳ bộ nhớ bổ sung hoặc lưu trữ dữ liệu tối thiểu nào. Do đó, thuật toán sắp xếp lựa chọn có độ phức tạp không gian không đổi hoặc độ phức tạp không gian O (1).</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "cpp",
          "name": "Câu hỏi phỏng vấn C++",
          "description": "",
          "questions": [
            {
              "question": "Các kiểu dữ liệu trong C++?",
              "answer": "<p>Có 4 kiểu dữ liệu trong C++:\r<ul><li>Kiểu nguyên thuỷ, như char, short, int, float, long, double, bool,...</li></ul>\r<ul><li>Kiểu dẫn xuất, như array, pointer,..</li></ul>\r<ul><li>Enum</li></ul>\r<ul><li>Kiểu người dùng định nghĩa: structure, class,...</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa C và C++?",
              "answer": "<p>| C | C++ |\r\n|---|-----|\r\n| C là ngôn ngữ hướng thủ tục | C++ là ngôn ngữ hướng đối tượng |\r\n| C không hỗ trợ ẩn dữ liệu | Dữ liệu được ẩn bởi tính đóng gói đảm bảo cấu trúc dữ liệu và phép toán được sử dụng nội bộ |\r\n| C là tập con của C++ | C++ là mở rộng của C |\r\n| Không hộ trợ nạp chồng | Hỗ trợ nạp chồng hàm và toán tử |\r\n| Không có tính năng namespace | Có tính năng namespace để tránh xung đột |\r\n| Hàm không thể định nghĩa bên trong cấu trúc | Hàm có thể định nghĩa bên trong cấu trúc |\r\n| hàm calloc() và malloc() dùng cho cấp phát bộ nhớ và free() để giải phóng | toán tử new dùng cho cấp phát bộ nhớ và toán tử delete dùng cho giải phóng bộ nhớ |</p>",
              "level": "fresher"
            },
            {
              "question": "Lớp và đối tượng trong C++ là gì?",
              "answer": "<p>Một lớp là kiểu người dùng tự định nghĩa có dữ liệu và hàm thành viên. Dữ liệu là các biến và hàm là các hàm thực hiện hành động trên các biến.\r\n\r\nĐối tượng là một thực thể của lớp. \r\n\r\nVí dụ:\r\n\r\n``<code>cpp\r\nclass A {\r\n    private:\r\n        int data;\r\n    public:\r\n        void func() {\r\n\r\n        }\r\n}\r\n</code>``\r\n\r\n<img src=\"/interview-assets/Class_in_C__.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa struct và class?",
              "answer": "<p>| Struct | Class |\r\n|--------|-------|\r\n| Các thành viên của struct mặc định là public | Thành viên của class mặc định là private |\r\n| Khi dẫn xuất một struct từ một struct khác, truy cập mặc định cho struct cơ sở là public | Khi dẫn xuất một class, truy cập mặc định là private |</p>",
              "level": "fresher"
            },
            {
              "question": "Nạp chồng toán tử là gì?",
              "answer": "<p>Nạp chồng toán tử là một yếu tố rất cần thiết để thực hiện các hoạt động trên các kiểu dữ liệu do người dùng xác định. Bằng cách nạp chồng toán tử, chúng ta có thể sửa đổi ý nghĩa mặc định thành các toán tử như +, -, *, /, <=, v.v.\r\n\r\nVí dụ: Đoạn code bên dưới thực hiện công hai số phức bằng nạp chồng toán tử\r\n\r\n``<code>cpp\r\nclass complex{\r\n    private:\r\n        float r, i;\r\n    public:\r\n        complex(float r, float i){\r\n            this-&gt;r=r;\r\n            this-&gt;i=i;\r\n        }\r\n        complex(){}\r\n        void displaydata(){\r\n            cout&lt;&lt;&quot;real part = &quot;&lt;&lt;r&lt;&lt;endl;\r\n            cout&lt;&lt;&quot;imaginary part = &quot;&lt;&lt;i&lt;&lt;endl;\r\n        }\r\n        complex operator+(complex c) {\r\n            return complex(r+c.r, i+c.i);\r\n        }\r\n};\r\n\r\nint main(){\r\n    complex a(2,3);\r\n    complex b(3,4);\r\n    complex c=a+b;\r\n    c.displaydata();\r\n    return 0;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Đa hình trong C++?",
              "answer": "<p>Đa hình nói một cách đơn giản có nghĩa là có nhiều dạng. Hành vi của nó là khác nhau trong các tình huống khác nhau. Và điều này xảy ra khi chúng ta có nhiều lớp có liên quan với nhau theo kế thừa.\r\n\r\nVí dụ: Ta có một lớp cơ sở được gọi là <code>Car</code> có một phương thức được gọi là <code>car_brand()</code>. Các loại xe có nguồn gốc có thể là Mercedes, BMW, Audi - Và chúng cũng có cách triển khai xe của riêng mình\r\n\r\nHai loại đa hình trong c ++ là:\r<ul><li>Đa hình thời gian biên dịch</li></ul>\r<ul><li>Đa hình thời gian chạy</li></ul>\r\n\r\n<img src=\"/interview-assets/Polymorphism_in_C__.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về constructor trong C++?",
              "answer": "<p>Contrustor là một hàm thành viên được thực thi tự động bất cứ khi nào đối tượng được tạo. Constructor có cùng tên với lớp để trình biên dịch biết hàm thành viên nào là constructor. Constructor không có kiểu trả về.\r\n\r\n``<code>cpp\r\nclass A{\r\n    private:\r\n        int val;\r\n    public:\r\n        A(int x){             //one argument constructor\r\n            val=x;\r\n        }\r\n        A(){                    //zero argument constructor\r\n        }\r\n}\r\nint main(){\r\n    A a(3);     \r\n\r\n    return 0;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm ảo là gì?",
              "answer": "<p>Hàm ảo là một hàm thành viên trong lớp cơ sở mà bạn xác định lại trong một lớp dẫn xuất. Một hàm ảo được khai báo bằng từ khóa <code>virtual</code>. Khi hàm được tạo ảo, C++ xác định hàm nào sẽ được gọi trong thời gian chạy dựa trên kiểu đối tượng được trỏ bởi con trỏ lớp cơ sở.</p>",
              "level": "fresher"
            },
            {
              "question": "So sánh đa hình thời gian chạy và đa hình thời gian biên dịch?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm bạn và lớp bạn là gì?",
              "answer": "<p>Một lớp bạn có thể truy cập thành viên pulic, protected hay private của lớp khác mà lớp đó được khai báo là bạn.\r\n\r\nGiống như lớp bạn, hàm bạn cũng có thể truy cập các thành viên private, protected và public. Nhưng, hàm bạn không phải là hàm thành viên.\r\n\r\n``<code>cpp\r\nclass A{\r\n    private:\r\n        int data<em>a;\r\n    public:\r\n        A(int x){\r\n            data</em>a=x;\r\n        }\r\n    friend int fun(A, B);\r\n}\r\nclass B{\r\n    private:\r\n        int data<em>b;\r\n    public:\r\n        A(int x){\r\n            data</em>b=x;\r\n        }\r\n        friend int fun(A, B);\r\n}\r\nint fun(A a, B b){\r\n    return a.data<em>a+b.data</em>b;\r\n}\r\nint main(){\r\n    A a(10);\r\n    B b(20);\r\n    cout&lt;&lt;fun(a,b)&lt;&lt;endl;\r\n    return 0;\r\n}\r\n</code>``\r\n\r\nDo đó, ta có thể truy cập dữ liệu private của lớp A và B.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu truy cập trong C++?",
              "answer": "<p><ul><li>Public: tất cả dữ liệu và hàm thành viên đều có thể truy cập từ bên ngoài lớp.</li></ul>\r<ul><li>Protected: tất cả dữ liệu và hàm thành viên đều có thể truy cập từ bên trong lớp và lớp dẫn xuất.</li></ul>\r<ul><li>Private: tất cả dữ liệu và hàm thành viên đều chỉ có thể truy cập từ bên trong lớp.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Function inline là gì?",
              "answer": "<p>Inline functions (hàm nội tuyến) là một loại hàm trong ngôn ngữ lập trình C++. Từ khoá inline được sử dụng để đề nghị (không phải là bắt buộc) trình biên dịch thực hiện inline expansion (khai triển nội tuyến) với hàm đó hay nói cách khác là chèn code của hàm đó tại địa chỉ mà nó được gọi.\r\n\r\nVí dụ:\r\n\r\n``<code>cpp\r\ninline int max(int a, int b)\r\n{\r\n\treturn a &gt; b ? a : b;\r\n}\r\n\r\nint main()\r\n{\r\n\tcout &lt;&lt; max(3, 6) &lt;&lt; &#39;\\n&#39;;\r\n\tcout &lt;&lt; max(6, 3) &lt;&lt; &#39;\\n&#39;;\r\n\r\n\treturn 0;\r\n}\r\n</code>`<code>\r\n\r\nKhi được biên dịch, code được tạo như sau:\r\n\r\n</code>`<code>cpp\r\nint main()\r\n{\r\n\tcout &lt;&lt; (3 &gt; 6 ? 3 : 6) &lt;&lt; &#39;\\n&#39;;\r\n\tcout &lt;&lt; (6 &gt; 3 ? 6 : 3) &lt;&lt; &#39;\\n&#39;;\r\n\r\n\treturn 0;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tham chiếu trong C++ là gì?",
              "answer": "<p>Tham chiếu giống như con trỏ, sau khi một tham chiếu được khởi tạo với một biến, biến đó có thể truy cập đến cả tên biến và tên tham chiếu.\r\n\r\n``<code>cpp\r\nint x=10;\r\nint &amp;ref=x;           //reference variable\r\n</code>`<code>\r\n\r\nNếu chúng ta thay đổi giá trị của </code>ref<code>, nó sẽ được phản ánh trong </code>x`. Khi một biến tham chiếu được khởi tạo, nó không thể tham chiếu đến bất kỳ biến nào khác. Chúng ta có thể khai báo một mảng con trỏ nhưng một mảng tham chiếu thì không thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Trừu tượng trong C++ là gì?",
              "answer": "<p>Trừu tượng là quá trình hiển thị các chi tiết cần thiết cho người dùng và ẩn các chi tiết mà ta không muốn hiển thị cho người dùng hoặc ẩn các chi tiết không liên quan đến một người dùng cụ thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể nạp chồng destructor không? Tại sao?",
              "answer": "<p>Không thể nạp chồng destructor, vì destructor không nhận về bất kỳ tham số nào, thế nên nó chỉ làm một việc là huỷ đối tượng.</p>",
              "level": "fresher"
            },
            {
              "question": "Gọi bởi giá trị và gọi bởi tham chiếu?",
              "answer": "<p>Trong phương thức gọi bởi giá trị, chúng ta truyền một bản sao của tham số được truyền cho các hàm. Đối với các giá trị được sao chép này, một bộ nhớ mới được gán và các thay đổi được thực hiện đối với các giá trị này không phản ánh biến trong hàm chính.\r\n\r\nTrong phương thức gọi bởi tham chiếu, chúng ta chuyển địa chỉ của biến và địa chỉ được sử dụng để truy cập đối số thực được sử dụng trong lệnh gọi hàm. Vì vậy, các thay đổi được thực hiện trong tham số sẽ làm thay đổi đối số truyền.</p>",
              "level": "fresher"
            },
            {
              "question": "Lớp trừu tường là gì?",
              "answer": "<p>Một lớp được gọi là một lớp trừu tượng khi mà các đối tượng của nó không bao giờ có thể được tạo ra. Một lớp như vậy tồn tại như một lớp cha cho các lớp dẫn xuất. Chúng ta có thể làm cho một lớp trở nên trừu tượng bằng cách đặt một hàm thuần ảo trong lớp.</p>",
              "level": "fresher"
            },
            {
              "question": "Destructor trong C++ là gì?",
              "answer": "<p>Một constructor được tự động gọi khi một đối tượng được tạo lần đầu tiên. Tương tự như vậy khi một đối tượng bị hủy, một hàm có tên là destructor sẽ tự động được gọi. Một destructor có cùng tên với constructor (giống với tên lớp) nhưng đứng trước một dấu ngã <code>~</code>.\r\n\r\n``<code>cpp\r\nclass A{\r\n    private:\r\n        int val;\r\n    public:\r\n        A(int x){           \r\n            val=x;\r\n        }\r\n\r\n        A(){                \r\n        }\r\n\r\n        ~A(){                  //destructor\r\n        }\r\n}\r\nint main(){\r\n    A a(3);     \r\n    return 0;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm tĩnh và biến tĩnh là gì?",
              "answer": "<p>Khi một biến trong một lớp được khai báo là <code>static</code>, không gian cho nó sẽ được cấp cho thời gian tồn tại của chương trình. Bất kể có bao nhiêu đối tượng của lớp đó đã được tạo, chỉ có một bản sao của thành viên tĩnh. Vì vậy, cùng một thành viên tĩnh có thể được truy cập bởi tất cả các đối tượng của lớp đó.\r\n\r\nMột hàm thành viên tĩnh có thể được gọi ngay cả khi không có đối tượng nào của lớp tồn tại và hàm tĩnh được truy cập chỉ bằng cách sử dụng tên lớp và toán tử phân giải phạm vi <code>::</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về kế thừa?",
              "answer": "<p>Kế thừa là quá trình tạo các lớp mới, được gọi là lớp dẫn xuất, từ các lớp hiện có. Các lớp hiện có này được gọi là các lớp cơ sở. Các lớp dẫn xuất kế thừa tất cả các khả năng của lớp cơ sở nhưng có thể thêm các tính năng và cải tiến mới của riêng chúng.\r\n\r\n<img src=\"/interview-assets/Inheritance_in_C__.png\" alt=\"\" />\r\n\r\nCác lớp <code>Bus</code>, <code>Car</code> và <code>Truck</code> kế thừa thuộc tính từ lớp <code>Vehicle</code>. Điều quan trọng nhất của kế thừa là khả năng sử dụng lại code.\r\n\r\n## Câu hỏi phỏng vấn C++ cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Copy constructor là gì?",
              "answer": "<p>Một copy constructor là một hàm thành viên được tạo khi một đối tượng sử dụng đối tượng khác ở cùng lớp.\r\n\r\n``<code>cpp\r\nclass A{\r\n    int x,y;\r\n    A(int x, int y){\r\n        this-&gt;x=x;\r\n        this-&gt;y=y;\r\n    }\r\n\r\n};\r\nint main(){\r\n    A a1(2,3);\r\n    A a2=a1;     //default copy constructor is called\r\n    return 0;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa shallow copy và deep copy?",
              "answer": "<p>| Shallow Copy | Deep Copy |\r\n|--------------|-----------|\r\n| Lưu trữ tham chiếu của đối tượng từ địa chỉ bộ nhớ gốc | Tạo một bản sao mới và riêng biệt của toàn bộ đối tượng với địa chỉ bộ nhớ duy nhất của nó |\r\n| Nhanh hơn | Chậm hơn |\r\n| Phản ánh những thay đổi được thực hiện đối với đối tượng mới/được sao chép trong đối tượng gốc | Không phản ánh những thay đổi được thực hiện đối với đối tượng mới/được sao chép trong đối tượng gốc |</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt hàm ảo và hàm thuần ảo?",
              "answer": "<p>Một hàm ảo là một hàm thành viên trong lớp cơ sở mà bạn xác định lại trong một lớp dẫn xuất. Nó được khai báo bằng từ khóa <code>virtual</code>.\r\n\r\n``<code>cpp\r\nclass base {\r\n    public:\r\n        virtual void func() {\r\n\r\n        }\r\n};\r\n</code>`<code>\r\n\r\nMột hàm thuần ảo là một hàm không có phần thực thi và được khai báo bằng cách gán với 0. Nó không có phần thân.\r\n\r\n</code>`<code>cpp\r\nclass base{\r\n    public:\r\n        virtual void fun()=0;\r\n};\r\n</code>``\r\n\r\nỞ đây, dấu = không liên quan gì đến việc gán và giá trị 0 không được gán cho bất kỳ thứ gì. Nó được sử dụng để chỉ cho trình biên dịch biết rằng một hàm sẽ thuần và nó sẽ không có gì cả.</p>",
              "level": "fresher"
            },
            {
              "question": "Nếu lớp D có nguồn gốc từ một lớp cơ sở B. Khi tạo một đối tượng kiểu D thì thứ tự constructor của các lớp này sẽ được gọi như thế nào?",
              "answer": "<p>Lớp dẫn xuất có hai phần, một phần cơ sở và một phần dẫn xuất. Khi C++ xây dựng các đối tượng dẫn xuất, nó sẽ làm như vậy theo từng giai đoạn. Đầu tiên, lớp cơ sở nhất (ở trên cùng của cây kế thừa) được xây dựng. Sau đó, mỗi lớp con được xây dựng theo thứ tự cho đến khi lớp con nhiều nhất được xây dựng cuối cùng.\r\nVì vậy, constructor đầu tiên của lớp B sẽ được gọi và sau đó mới gọi constructor của lớp D.\r\n\r\nTrong quá trình huỷ thứ tự ngược lại được tuân theo. Đó là destructor bắt đầu từ lớp dẫn xuất nhất và hoạt động theo cách của nó xuống lớp cơ sở.\r\nVì vậy, destructor đầu tiên của lớp D sẽ được gọi và sau đó sẽ đến destructor của lớp B.</p>",
              "level": "fresher"
            },
            {
              "question": "Ta có thể gọi hàm ảo từ một constructor không?",
              "answer": "<p>Có, chúng ta có thể gọi một hàm ảo từ một constructor. Nhưng hành vi có một chút khác biệt trong trường hợp này. Khi một hàm ảo được gọi, cuộc gọi ảo sẽ được giải quyết trong thời gian chạy. Nó luôn luôn là hàm thành viên của lớp hiện tại được gọi. Tức là hàm ảo không hoạt động trong constructor.\r\n\r\n``<code>cpp\r\nclass base{\r\n    private:\r\n        int value;\r\n    public:\r\n        base(int x){\r\n            value=x;\r\n        }\r\n        virtual void fun(){\r\n        \r\n        }\r\n}\r\n\r\nclass derived{\r\n    private:\r\n        int a;\r\n    public:\r\n        derived(int x, int y):base(x){\r\n            base *b;\r\n            b=this;\r\n            b-&gt;fun();      //calls derived::fun()\r\n        }\r\n        void fun(){\r\n            cout&lt;&lt;&quot;fun inside derived class&quot;&lt;&lt;endl;\r\n        }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Con trỏ void là gì?",
              "answer": "<p>Con trỏ void là một con trỏ không có kiểu dữ liệu nào được liên kết với nó. Nó có thể chứa bất kỳ loại địa chỉ nào.\r\n\r\n``<code>cpp\r\nvoid <em>ptr;\r\nchar </em>str;\r\n\r\np = str;        // no error\r\nstr = p;        // error because of type mismatch\r\n</code>`<code>\r\n\r\nChúng ta có thể gán một con trỏ thuộc bất kỳ loại nào cho một con trỏ void nhưng điều ngược lại là không đúng trừ khi bạn ép kiểu nó bằng\r\n\r\n</code>`<code>cpp\r\nstr=(char*) ptr;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Con trỏ this là gì?",
              "answer": "<p>Các hàm thành viên của mọi đối tượng đều có một con trỏ được đặt tên là <code>this</code>, con trỏ này trỏ đến chính đối tượng. Giá trị <code>this</code> được đặt thành địa chỉ của đối tượng mà nó được gọi. Nó có thể được sử dụng để truy cập dữ liệu trong đối tượng mà nó trỏ tới.\r\n\r\n``<code>cpp\r\nclass A{\r\n    private:\r\n        int value;\r\n    public:\r\n        void setvalue(int x){\r\n            this-&gt;value=x; \r\n        }\r\n};\r\n\r\nint main(){\r\n    A a;\r\n    a.setvalue(5);\r\n    return 0;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cấp phát và giải phóng bộ nhớ trong C++?",
              "answer": "<p>Toán tử <code>new</code> dùng cho cấp phát bộ nhớ và toán tử <code>delete</code> dùng cho giải phóng bộ nhớ trong C++.\r\n\r\n``<code>cpp\r\nint value=new int;  \t\t//allocates memory for storing 1 integer\r\ndelete value;          \t\t// deallocates memory taken by value\r\n\r\nint *arr=new int[10];    \t//allocates memory for storing 10 int\r\ndelete []arr;              \t// deallocates memory occupied by arr\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "cyber",
          "name": "Câu hỏi phỏng vấn an ninh mạng",
          "description": "",
          "questions": [
            {
              "question": "Đối tượng chính trong an ninh mạng là gì?",
              "answer": "<p>Mục tiêu chính của an ninh mạng là bảo vệ dữ liệu. Để bảo vệ dữ liệu khỏi các cuộc tấn công mạng, lĩnh vực bảo mật đưa ra mô hình tam giác gồm ba nguyên tắc. Bộ ba CIA là tên cho nguyên tắc này. Mô hình CIA nhằm giúp các tổ chức phát triển các chính sách cho kiến trúc bảo mật thông tin của họ. Một hoặc nhiều nguyên tắc này sẽ bị phá vỡ khi phát hiện ra vi phạm bảo mật. Tính bảo mật, tính toàn vẹn và tính khả dụng là ba thành phần của mô hình CIA. Đó là một mô hình bảo mật hướng dẫn các cá nhân trên nhiều khía cạnh của bảo mật CNTT. Chúng ta hãy xem xét kỹ hơn từng phần.\r\n\r\n<img src=\"/interview-assets/Cyber_Security_objectives.jpg\" alt=\"\" />\r<ul><li><strong>Tính bảo mật</strong> của thông tin là mức độ bảo mật cần thiết nhằm đảm bảo những dữ liệu quan trọng không bị rò rỉ hay tiết lộ. Kẻ tấn công có thể thực hiện nhiều phương thức nhằm đạt được mục đích là lấy những thông tin mong muốn. Những phương thức đó có thể là giám sát hệ thống mạng, lấy các file chứa mật khẩu, hay social engineering. Thông tin có thể bị lộ do không sử dụng các phương thức mã hóa đủ mạnh khi truyền hay lưu trữ thông tin.</li></ul>\r<ul><li><strong>Tính toàn vẹn</strong> của thông tin là mức độ bảo mật cần thiết nhằm đảm bảo độ tin tưởng của thông tin không bị thay đổi hay chỉ được chỉnh sửa bởi người có thẩm quyền. Kẻ tấn công có thể thực hiện nhiều phương thức nhằm thay đổi những thông tin mong muốn. Những phương thức đó có thể là đột nhập vượt qua các quá trình xác thực, hoặc tấn công khai thác lỗ hổng bảo mật của hệ thống. Đây là mức độ bảo mật thông tin quan trọng, hàng năm có rất nhiều tổ chức doanh nghiệp bị tấn công khai thác lỗ hổng bảo mật và bị thay đổi dữ liệu.</li></ul>\r<ul><li><strong>Tính khả dụng</strong>, khả năng đáp ứng của thông tin là điều rất quan trọng, điều này thể hiện tính sẵn sàng phục vụ của các dịch vụ. Khả năng đáp ứng của hệ thống chịu ảnh hưởng bởi khá nhiều thành phần: có thể là phần cứng, phần mềm hay hệ thống backup. Khả năng đáp ứng của hệ thống cần được tính đến dựa trên số người truy cập và mức độ quan trọng của dữ liệu.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa mối đe dọa, lỗ hổng bảo mật và rủi ro?",
              "answer": "<p><strong>Threat:</strong> Mối đe dọa là bất kỳ dạng nguy cơ nào có khả năng phá hủy hoặc đánh cắp dữ liệu, làm gián đoạn hoạt động hoặc gây hại nói chung. Phần mềm độc hại, lừa đảo, vi phạm dữ liệu và thậm chí cả những nhân viên không có đạo đức đều là những ví dụ về các mối đe dọa.\r\nCác tác nhân đe dọa, có thể là các cá nhân hoặc nhóm với nhiều nguồn gốc và động cơ khác nhau. Hiểu các mối đe dọa là điều cần thiết để phát triển các biện pháp giảm thiểu rủi ro và đưa ra các quyết định về an ninh mạng sáng suốt. Thông tin tình báo về mối đe dọa là thông tin liên quan đến các mối đe dọa và tác nhân đe dọa.\r\n\r\n<strong>Vulnerability:</strong> Lỗ hổng bảo mật là một lỗ hổng trong phần cứng, phần mềm, nhân sự hoặc quy trình mà các tác nhân đe dọa có thể sử dụng để đạt được mục tiêu của họ.\r\n\r\nCác lỗ hổng vật lý, chẳng hạn như thiết bị mạng bị lộ công khai, lỗ hổng phần mềm, chẳng hạn như lỗ hổng tràn bộ đệm trong trình duyệt và thậm chí lỗ hổng con người, chẳng hạn như một nhân viên dễ bị tấn công lừa đảo, đều là những ví dụ về lỗ hổng.\r\n\r\nQuản lý lỗ hổng bảo mật là quá trình xác định, báo cáo và sửa chữa các lỗ hổng. Lỗ hổng zero-day là lỗ hổng chưa có biện pháp khắc phục.\r\n\r\n<strong>Risk:</strong> Xác suất của một mối đe dọa và hậu quả của một lỗ hổng được kết hợp để tạo thành rủi ro. Nói một cách khác, rủi ro là khả năng tác nhân đe dọa khai thác thành công một lỗ hổng, có thể được tính bằng công thức:\r\n\r\n<img src=\"/interview-assets/Risk___Likelihood_of_a_threat__Vulnerability_Impact.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "XSS là gì? Và cách ngăn chặn nó?",
              "answer": "<p>Cross-site scripting (XSS) là một kiểu tấn công bảo mật trong đó kẻ tấn công đưa các tập lệnh độc hại vào phần nội dung của các trang web đáng tin cậy khác. Tấn công Cross-site scripting xảy ra khi một nguồn không đáng tin cậy được phép đưa code của chính nó vào một ứng dụng web và mã độc đó được bao gồm trong nội dung gửi đến trình duyệt của nạn nhân.\r\n\r\nXSS là một trong những lỗ hổng ứng dụng web phổ biến nhất và xảy ra khi một ứng dụng web sử dụng đầu vào từ người dùng không được xác thực hoặc không được mã hóa trong đầu ra mà nó tạo ra. Tấn công XXS cho phép kẻ tấn công đóng giả người dùng, nạn nhân, và thực hiện bất kỳ hành động nào mà người dùng có thể thực hiện, cũng như truy cập bất kỳ dữ liệu nào của người dùng. Nếu người dùng có quyền truy cập đặc quyền vào ứng dụng, kẻ tấn công có thể kiểm soát hoàn toàn chức năng và dữ liệu của ứng dụng.\r\n\r\n<img src=\"/interview-assets/XSS.jpg\" alt=\"\" />\r\n\r\nCách ngăn chặn XSS có thể đơn giản trong một số trường hợp, nhưng có thể khó hơn nhiều trong những trường hợp khác, tùy thuộc vào độ tinh vi của ứng dụng và cách nó xử lý dữ liệu do người dùng kiểm soát. Nói chung, việc ngăn chặn các lỗ hổng XSS gần như chắc chắn sẽ cần sự kết hợp của các biện pháp sau: \r<ul><li>Escape đầu vào của người dùng là một cách để ngăn các lỗ hổng XSS xuất hiện trong các ứng dụng. Điều này có nghĩa là lấy dữ liệu mà ứng dụng đã nhận được và đảm bảo an toàn trước khi hiển thị nó cho người dùng. Escape input từ người dùng sẽ khiến các ký tự quan trọng trong dữ liệu mà trang web nhận được không bị hiểu là mã thực thi. Nhờ đó ngăn trình duyệt diễn giải các ký tự được sử dụng để báo hiệu bắt đầu hoặc kết thúc mã thực thi và dịch chúng thành \"escaped\". Ví dụ, các ký tự như dấu ngoặc kép, dấu ngoặc đơn, dấu ngoặc vuông và một số dấu chấm câu khác đôi khi được sử dụng để làm nổi bật mã thực thi. Escape các ký tự này có nghĩa là chuyển đổi chúng từ các ký tự đơn thành các chuỗi khi trình duyệt biên dịch.</li></ul>\r<ul><li>Sàng lọc đầu vào của người dùng là một cách khác để ngăn chặn các cuộc tấn công Cross-site scripting, đặc biệt hữu ích trên các trang web cho phép HTML markup. Phương pháp ngăn chặn này sẽ xóa sạch dữ liệu chứa các ký tự có khả năng thực thi, thay đổi đầu vào người dùng thành định dạng có thể chấp nhận và đảm bảo dữ liệu nhận được không thể được hiểu là mã thực thi.</li></ul>\r<ul><li>Xác thực đầu vào đảm bảo việc ứng dụng hiển thị dữ liệu chính xác và ngăn dữ liệu độc hại gây hại cho trang web, cơ sở dữ liệu và người dùng. Xác thực đầu vào giúp ngăn XSS trong các biểu mẫu vì nó ngăn người dùng thêm các ký tự đặc biệt vào các trường nhập dữ liệu trang web bằng cách từ chối yêu cầu. Xác thực đầu vào giúp giảm khả năng gây ảnh hưởng tiêu cực, nếu kẻ tấn công phát hiện ra một lỗ hổng XSS ở đâu đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tường lửa là gì?",
              "answer": "<p>Tường lửa (Firewall) là một hệ thống an ninh mạng, có thể dựa trên phần cứng hoặc phần mềm, sử dụng các quy tắc để kiểm soát lưu lượng truy cập vào, ra khỏi hệ thống. Tường lửa hoạt động như một rào chắn giữa mạng an toàn (LAN) và mạng không an toàn (Internet). Nó kiểm soát các truy cập đến nguồn lực của mạng thông qua một mô hình kiểm soát chủ động. Nghĩa là, chỉ những truy cập phù hợp với chính sách được định nghĩa trong tường lửa mới được truy cập vào mạng, mọi truy cập khác đều bị từ chối.\r\n\r\nNhư trong hình bên dưới là tường lửa giữa LAN và Internet.\r\n\r\n<img src=\"/interview-assets/Firewall.jpg\" alt=\"\" />\r\n\r\nCó hai loại tường lửa trong hệ thống là: một cái dùng bộ lọc tầng network còn cái kia dùng server proxy ở tầng network hay application.</p>",
              "level": "fresher"
            },
            {
              "question": "VPN là gì?",
              "answer": "<p>Thuật ngữ VPN dùng để chỉ Virtual Private Network, một mạng riêng ảo. Nó cho phép bạn kết nối máy tính của mình với mạng riêng, kết nối được mã hóa để ẩn địa chỉ IP của bạn, cho phép bạn chia sẻ dữ liệu và truy cập web một cách an toàn đồng thời bảo vệ danh tính trực tuyến của bạn. Nó chống lại việc nghe trộm lưu lượng truy cập bất hợp pháp và cho phép người dùng làm việc từ xa. Trong các công ty, công nghệ VPN thường được sử dụng.\r\n\r\n<img src=\"/interview-assets/VPN.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Hacker black hat, white hat và grey hat là gì?",
              "answer": "<p>Một cách tổng quát, hacker được chia ra làm ba loại là: black hat, grey hat và white hat.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Các loại an ninh mạng?",
              "answer": "<p>An ninh mạnh có thể được phân loại thành 7 loại riêng biệt:\r\n\r\n<em> <strong>Bảo mật mạng:</strong> Là quá trình bảo vệ mạng máy tính chống lại sự truy cập trái phép, những kẻ xâm nhập, tấn công, làm gián đoạn và lạm dụng phần cứng và phần mềm. Bảo mật này hỗ trợ trong việc bảo vệ tài sản của tổ chức khỏi các mối đe dọa từ bên ngoài lẫn bên trong. Ví dụ: Sử dụng Tường lửa.\r\n</em> <strong>Bảo mật ứng dụng:</strong> Nó đòi hỏi phải bảo vệ phần mềm và thiết bị an toàn trước các cuộc tấn công nguy hiểm. Điều này có thể được thực hiện bằng cách thường xuyên cập nhật các ứng dụng để đảm bảo rằng chúng an toàn trước các mối đe dọa.\r\n<em> <strong>Bảo mật dữ liệu:</strong> Nó đòi hỏi phải có một hệ thống lưu trữ dữ liệu mạnh mẽ để đảm bảo tính toàn vẹn và quyền riêng tư của dữ liệu trong quá trình lưu trữ và vận chuyển.\r\n</em> <strong>Quản lý danh tính:</strong> Nó đề cập đến quá trình xác định quyền truy cập của mỗi cá nhân bên trong một tổ chức. Ví dụ: Hạn chế quyền truy cập vào dữ liệu theo vai trò công việc của một cá nhân trong công ty.\r\n<em> <strong>Bảo mật hoạt động:</strong> Nó đòi hỏi phải phân tích và đưa ra quyết định về cách xử lý và bảo mật dữ liệu. Ví dụ: Lưu trữ dữ liệu ở dạng mã hóa trong cơ sở dữ liệu.\r\n</em> <strong>Bảo mật di động:</strong> Nó đề cập đến việc bảo vệ dữ liệu tổ chức và cá nhân được lưu giữ trên các thiết bị di động như điện thoại di động, máy tính bảng và các thiết bị tương tự khác chống lại nhiều cuộc tấn công thù địch. Truy cập trái phép, mất hoặc trộm thiết bị, phần mềm độc hại và các mối đe dọa khác là những ví dụ về những mối nguy hiểm này.\r<ul><li><strong>Bảo mật đám mây:</strong> Nó đề cập đến việc bảo vệ dữ liệu được lưu giữ trong môi trường kỹ thuật số hoặc trong cơ sở hạ tầng đám mây cho một tổ chức. Nó sử dụng nhiều nhà cung cấp dịch vụ đám mây khác nhau, bao gồm AWS, Azure, Google và các nhà cung cấp khác, để đảm bảo bảo vệ khỏi nhiều mối đe dọa.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của an ninh mạng?",
              "answer": "<p>Sau đây là một số ưu điểm của việc áp dụng an ninh mạng:\r<ul><li>Doanh nghiệp được bảo vệ khỏi các cuộc tấn công mạng và vi phạm dữ liệu.</li></ul>\r<ul><li>Cả dữ liệu và mạng máy tính đều được bảo vệ.</li></ul>\r<ul><li>Quyền truy cập trái phép của người dùng được hạn chế ở mức tối thiểu.</li></ul>\r<ul><li>Có thời gian phục hồi nhanh hơn sau khi bị tấn công.</li></ul>\r<ul><li>Bảo vệ cho người dùng và thiết bị endpoint.</li></ul>\r<ul><li>Hoạt động nhất quán.</li></ul>\r<ul><li>Các nhà phát triển, đối tác, người tiêu dùng, các bên liên quan và nhân viên có mức độ tin tưởng cao hơn vào danh tiếng của công ty.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Botnet là gì?",
              "answer": "<p>Botnet thuật ngữ đầy đủ là \"Bots network\" dùng để chỉ một mạng lưới các máy tính bị chi phối bởi ai đó và bị điều khiển bởi một con máy tính khác từ xa. Botnet là một phần mềm độc hại, đa phần các máy tính đều bị nhiễm bởi một Bot nào đó mà chúng ta không thể nào phát hiện được.\r\n\r\n<img src=\"/interview-assets/Botnet.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Honeypot là gì?",
              "answer": "<p>Honeypot là một hệ thống tài nguyên thông tin được xây dựng với mục đích giả dạng đánh lừa những kẻ sử dụng và xâm nhập không hợp pháp, thu hút sự chú ý của chúng, ngăn không cho chúng tiếp xúc với hệ thống thật.\r\n\r\nHoneypot có thể giả dạng bất cứ loại máy chủ tài nguyên nào như là Mail Server, Domain Name Server, Web Server… Honeypot sẽ trực tiếp tương tác với tin tặc và tìm cách khai thác thông tin về tin tặc như hình thức tấn công, công cụ tấn công hay cách thức tiến hành thay vì bị tấn công.\r\n\r\n<img src=\"/interview-assets/Honeypot.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Đánh giá lỗ hổng và Kiểm tra thâm nhập?",
              "answer": "<p>Đánh giá lỗ hổng và kiểm tra thâm nhập là hai cụm từ khác nhau, song cả hai đều phục vụ cùng một mục đích: bảo mật môi trường mạng.\r\n\r\n<img src=\"/interview-assets/Vulnerability_Assessment_and_Penetration_Testing.jpg\" alt=\"\" />\r\n\r\n<strong>Đánh giá lỗ hổng bảo mật (Vulnerability Asessment)</strong> là quá trình kiểm tra, tìm tòi, nhận diện các biện pháp an toàn cũng như lỗ hổng của hệ thống và ứng dụng. Các hệ thống và ứng dụng được kiểm tra để nhận định tính hiệu quả của các tầng bảo mật hiện thời trong việc chống lại các tấn công và lạm dụng.\r\n\r\n<strong>Kiểm tra thâm nhập (Penetration Testing)</strong> là một cuộc tấn công mạng mô phỏng được ủy quyền trên máy tính, nhằm đánh giá tính bảo mật của hệ thống. Quá trình thử nghiệm được thực hiện để xác định tất cả điểm yếu (còn được gọi là lỗ hổng), bao gồm khả năng các bên không được phép truy cập vào những tính năng và dữ liệu hệ thống, cũng như điểm mạnh là cho phép đánh giá rủi ro trên toàn hệ thống.\r\n\r\nĐánh giá lỗ hổng tương tự như việc bước đến một cánh cửa và kiểm tra xem nó có được mở khóa hay không trước khi dừng lại. Kiểm tra thâm nhập tiến xa hơn một bước, không chỉ kiểm tra xem cửa có mở khóa hay không mà còn mở cửa và bước vào ngay.</p>",
              "level": "fresher"
            },
            {
              "question": "Null Session nghĩa là gì?",
              "answer": "<p>Một phiên truy cập từ xa được tạo lập khi người dùng đăng nhập từ xa vào một máy tính sử dụng một tên người dùng và mật khẩu có quyền truy cập vào tài nguyên hệ thống. Tiến trình đăng nhập này được thực hiện qua giao thức SMB (Server Message Block) và dịch vụ Windows Server. Những kết nối này hoàn toàn hợp pháp khi những thông tin đăng nhập chính xác được sử dụng.\r\n\r\nMột Null Session xảy ra khi người dùng thực hiện kết nối tới một hệ thống Windows mà không sử dụng tên người dùng hay mật khẩu. Hình thức kết nối này không thể thực hiện trên bất kỳ hình thức chia sẻ Windows thông thường nào, tuy nhiên lại có thể thực hiện trên chia sẻ quản trị IPC (Interprocess Communication).</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu tấn công mạng phổ biến",
              "answer": "<p><ul><li>Malware </li></ul>\r<ul><li>Cross-Site Scripting (XSS) </li></ul>\r<ul><li>Denial-of-Service (DoS)</li></ul>\r<ul><li>Domain Name System Attack</li></ul>\r<ul><li>Man-in-the-Middle Attacks </li></ul>\r<ul><li>SQL Injection Attack </li></ul>\r<ul><li>Phishing</li></ul>\r<ul><li>Session Hijacking</li></ul>\r<ul><li>Brute Force</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tấn công brute force là gì?",
              "answer": "<p>Tấn công Brute Force là một loại tấn công mạng, trong đó bạn có một phần mềm, xoay vòng các ký tự khác nhau, kết hợp để tạo ra một mật khẩu đúng. Phần mềm Brute Force Attack password cracker đơn giản sẽ sử dụng tất cả các kết hợp có thể để tìm ra mật khẩu cho máy tính hoặc máy chủ mạng. Nó rất đơn giản và không sử dụng bất kỳ kỹ thuật thông minh nào. Vì phương pháp này chủ yếu dựa trên toán học, phải mất ít thời gian hơn để crack mật khẩu, bằng cách sử dụng các ứng dụng brute force thay vì tìm ra chúng theo cách thủ công. Nói phương pháp này dựa trên toán học vì máy tính làm rất tốt các phép toán và thực hiện chúng trong vài giây, nhanh hơn rất nhiều lần so với bộ não con người (mất nhiều thời gian hơn để tạo ra các sự kết hợp).\r\n\r\n<img src=\"/interview-assets/brute-force-in-cyber-security.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Shouder surfing là gì?",
              "answer": "<p>Là một kỹ thuật thu thập password bằng cách xem qua vai người khác khi họ đăng nhập vào hệ thống. Hacker có thể xem người sử dụng thông tin đăng nhập và sau đó sử dụng password đó để giành được quyền truy xuất đến hệ thống.\r\n\r\n<img src=\"/interview-assets/Shoulder_Surfing.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Phishing là gì?",
              "answer": "<p>Phishing (Tấn công giả mạo) là hình thức tấn công mạng mà kẻ tấn công giả mạo thành một đơn vị uy tín để lừa đảo người dùng cung cấp thông tin cá nhân cho chúng.\r\n\r\nThông thường, tin tặc sẽ giả mạo thành ngân hàng, trang web giao dịch trực tuyến, ví điện tử, các công ty thẻ tín dụng để lừa người dùng chia sẻ các thông tin nhạy cảm như: tài khoản & mật khẩu đăng nhập, mật khẩu giao dịch, thẻ tín dụng và các thông tin quý giá khác.\r\n\r\nPhương thức tấn công này thường được tin tặc thực hiện thông qua email và tin nhắn. Người dùng khi mở email và click vào đường link giả mạo sẽ được yêu cầu đăng nhập. Nếu “mắc câu”, tin tặc sẽ có được thông tin ngay tức khắc.\r\n\r\n<img src=\"/interview-assets/phishing.jpg\" alt=\"\" />\r\n\r\nBạn có thể tự bảo vệ mình khỏi các cuộc tấn công giả mạo bằng cách làm theo các nguyên tắc sau:\r<ul><li>Đừng đưa ra những thông tin quan trọng trên những trang web mà bạn không biết.</li></ul>\r<ul><li>Kiểm tra tính bảo mật của trang web.</li></ul>\r<ul><li>Sử dụng tường lửa.</li></ul>\r<ul><li>Sử dụng công cụ Anti-Phishing.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa mã hoá và băm?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Xác thực hai yếu tố là gì?",
              "answer": "<p>Xác thực hai yếu tố (2FA), thường được gọi là xác minh hai bước hoặc xác thực yếu tố kép, là một phương pháp bảo mật trong đó người dùng xác thực danh tính của họ bằng hai yếu tố xác thực độc lập. Quy trình này được thực hiện để bảo vệ tốt hơn thông tin đăng nhập của người dùng cũng như các tài nguyên mà người dùng có quyền truy cập. Xác thực một yếu tố (SFA), trong đó người dùng chỉ cung cấp một yếu tố - thường là mật khẩu hoặc mật mã - cung cấp mức độ bảo mật thấp hơn so với xác thực hai yếu tố (TFA). Vì chỉ sở hữu mật khẩu của người dùng là không đủ để thực hiện kiểm tra xác thực, xác thực hai yếu tố bổ sung thêm một lớp bảo mật cho quá trình xác thực, khiến những kẻ tấn công khó truy cập vào thiết bị hoặc tài khoản trực tuyến của một người hơn.\r\n\r\n<img src=\"/interview-assets/Two-factor_authentication_(2FA).jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để tránh tấn công brute force?",
              "answer": "<p>Có nhiều kỹ thuật để ngăn chặn cuộc tấn công brute force, trong đó một chính sách mật khẩu mạnh mẽ là rõ ràng nhất. Ví dụ như mật khẩu người dùng phải ít nhất 16 ký tự: có ký tự chữ hoa, chữ thường, số và ký tự đặc biệt. Bên cạnh đó là cấm các mật khẩu phổ biến như <code>12345678</code> hay <code>qwerty</code>.\r\n\r\nTấn công brute fotce cũng có thể tránh bằng các phương pháp sau:\r<ul><li>Giới hạn số lần đăng nhập không thành công.</li></ul>\r<ul><li>Thay đổi file sshd<em>config, khiến người dùng root không thể truy cập qua SSH.</li></ul>\r<ul><li>Thay đổi cổng mặc định trong file sshd</em>config.</li></ul>\r<ul><li>Sử dụng Captcha.</li></ul>\r<ul><li>Giới hạn thông tin đăng nhập với một địa chỉ IP nhất định.</li></ul>\r<ul><li>Xác thực hai yếu tố.</li></ul>\r<ul><li>Theo dỗi log của server.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tấn công xen giữa là gì?",
              "answer": "<p>Tấn công xen giữa (Man in the Middle) là một cuộc tấn công mà kẻ tấn công bí mật chuyển tiếp và có thể làm thay đổi giao tiếp giữa hai bên mà họ tin rằng họ đang trực tiếp giao tiếp với nhau. Một ví dụ về các cuộc tấn công man-in-the-middle là nghe trộm (eavesdropping), trong đó kẻ tấn công kết nối độc lập với các nạn nhân và chuyển tiếp thông tin giữa họ để họ tin rằng họ đang nói chuyện trực tiếp với nhau qua kết nối riêng tư, trong khi thực ra toàn bộ cuộc trò chuyện được kiểm soát bởi kẻ tấn công. Người tấn công phải có khả năng đánh chặn tất cả các thông tin liên quan đi lại giữa hai nạn nhân và thêm những thông tin mới. Điều này đơn giản trong nhiều trường hợp; ví dụ, một kẻ tấn công trong phạm vi tiếp nhận của một điểm truy cập không dây (Wi-Fi) không được mã hóa có thể chèn mình như một \"người đàn ông ở giữa\" (man-in-the-middle).\r\n\r\n<img src=\"/interview-assets/man-middle-attack.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa bảo vệ thông tin và bảo đảm thông tin?",
              "answer": "<p><strong>Bảo vệ thông tin (information protection)</strong> là bảo vệ dữ liệu khỏi bị truy cập trái phép bằng cách sử dụng mã hóa, phần mềm bảo mật và các phương pháp khác.\r\n\r\n<strong>Bảo đảm thông tin (information assurance)</strong> là đảm bảo tính toàn vẹn của dữ liệu bằng cách duy trì tính khả dụng, xác thực và bí mật của nó, cùng những thứ khác.\r\n\r\n## Câu hỏi phỏng vấn an ninh mạng cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa VPN và VLAN?",
              "answer": "<p>Các công ty sử dụng VLAN để hợp nhất các thiết bị được phân tán trên một số địa điểm từ xa vào một miền broadcast duy nhất. Mặt khác, VPN được sử dụng để truyền dữ liệu an toàn giữa hai văn phòng của cùng một tổ chức hoặc giữa các văn phòng của các công ty khác nhau. Các cá nhân cũng sử dụng nó cho nhu cầu cá nhân của họ.\r\n\r\nVLAN là một kiểu con VPN. VPN là viết tắt của Virtual Private Network, là công nghệ tạo ra một đường hầm ảo để truyền dữ liệu an toàn qua Internet.\r\n\r\nBởi vì nó cho phép mã hóa và ẩn danh, VPN là một giải pháp tiên tiến hơn nhưng đắt tiền hơn. VLAN hữu ích để phân đoạn mạng thành các phần hợp lý để quản lý dễ dàng hơn, nhưng nó thiếu các đặc tính bảo mật của VPN.\r\n\r\nVLAN giảm thiểu số lượng bộ định tuyến cần thiết cũng như chi phí triển khai bộ định tuyến. VPN cải thiện hiệu quả tổng thể của mạng.\r\n\r\n<img src=\"/interview-assets/vlan-vs_-vpn.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Bảo mật toàn phần và bảo vệ dữ liệu là gì?",
              "answer": "<p><strong>Permiter-based cybersecurity hay bảo mật toàn phần</strong> đòi hỏi phải áp dụng các biện pháp bảo mật để bảo vệ mạng của công ty bạn khỏi tin tặc. Nó kiểm tra những người cố gắng đột nhập vào mạng của bạn và ngăn chặn bất kỳ nỗ lực xâm nhập đáng ngờ nào. \r\n\r\n<strong>Data-based protection hay bảo vệ dữ liệu</strong> đề cập đến việc sử dụng các biện pháp bảo mật trên dữ liệu. Nó không bị ảnh hưởng bởi kết nối mạng. Do đó, bạn có thể theo dõi và bảo vệ dữ liệu của mình bất kể dữ liệu được lưu trữ ở đâu, ai truy cập hoặc kết nối nào được sử dụng để truy cập.</p>",
              "level": "fresher"
            },
            {
              "question": "SSL và HTTPS cái nào đáng tin cậy hơn?",
              "answer": "<p><ul><li>SSL là viết tắt của Secure Sockets Layer, là một công nghệ tiêu chuẩn cho phép hai hoặc nhiều bên giao tiếp an toàn qua internet. Để cung cấp bảo mật, nó hoạt động trên HTTP. Nó hoạt động ở tầng Presentation. </li></ul>\r<ul><li>HTTPS là viết tắt của Hypertext Transfer Protocol Secure, là kết hợp của HTTP và SSL, sử dụng mã hoá để tạo ra trải nghiệm lướt web an toàn hơn. Hoạt động của HTTPS liên quan đến 4 tầng trên cùng của mô hình OSI, tức là tầng Application, Presentation, Session, và Transport.</li></ul>\r\n\r\n<img src=\"/interview-assets/which-is-more-reliable-ssl-or-https.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa mã hoá đối xứng và bất đối xứng?",
              "answer": "<p>| Mã hoá đối xứng | Mã hoá bất đối xứng |\r\n|-----------------|---------------------|\r\n| Cả mã hoá và giải mã dùng cùng khoá | Cần hai khoá để mã hoá và giải mã |\r\n| Mã hoá nhanh | Mã hoá chậm |\r\n| Dùng khi kích cỡ dữ liệu lớn | Dùng khi kích cỡ dữ liệu nhỏ |\r\n| Sử dụng ít tài nguyên hơn | Sử dụng nhiều tài nguyên hơn |\r\n| Plaintext có cùng cỡ hoặc nhỏ hơn ciphertext | Plaintext có cùng cỡ hoặc lớn hơn ciphertext |</p>",
              "level": "fresher"
            },
            {
              "question": "Tấn công DDoS là gì? Làm thế nào để chặn nó?",
              "answer": "<p>Một cuộc tấn công từ chối dịch vụ phân tán là một nỗ lực độc hại nhằm phá vỡ lưu lượng truy cập bình thường của máy chủ, dịch vụ hoặc mạng được nhắm mục tiêu bằng cách áp đảo mục tiêu hoặc cơ sở hạ tầng xung quanh với lưu lượng truy cập Internet. Các cuộc tấn công DDoS đạt được hiệu quả bằng cách sử dụng nhiều hệ thống máy tính bị xâm nhập làm nguồn lưu lượng tấn công. Các yêu cầu bắt nguồn từ nhiều địa chỉ IP, có thể khiến hệ thống không hoạt động được, làm quá tải các máy chủ của nó, khiến chúng chậm lại hoặc chuyển sang chế độ ngoại tuyến hoặc ngăn tổ chức thực hiện các trách nhiệm thiết yếu của mình. \r\n\r\n<img src=\"/interview-assets/what-is-ddos-attack-and-how-to-prevent-it.jpg\" alt=\"\" />\r\n\r\nCác phương pháp được liệt kê dưới đây sẽ hỗ trợ ngăn chặn các cuộc tấn công DDOS:\r<ul><li>Tăng cường khả năng xử lý của hệ thống:</li></ul>\r<ul><li>Tối ưu hóa các thuật toán xử lý, mã nguồn của máy chủ web</li></ul>\r<ul><li>Nâng cấp hệ thống máy chủ</li></ul>\r<ul><li>Nâng cấp đường truyền và các thiết bị liên quan,</li></ul>\r<ul><li>Cài đặt đầy đủ các bản vá cho hệ điều hành và các phần mềm khác để phòng ngừa khả năng bị lỗi tràn bộ đệm, cướp quyền điều khiển,v.v…</li></ul>\r<ul><li>Hạn chế số lượng kết nối tại thiết bị tường lửa tới mức an toàn hệ thống cho phép.</li></ul>\r<ul><li>Sử dụng các tường lửa cho phép lọc nội dung thông tin (tầng ứng dụng) để ngăn chặn các kết nối nhằm tấn công hệ thống.</li></ul>\r<ul><li>Phân tích luồng tin (traffic) để phát hiện các dấu hiệu tấn công và cài đặt các tường lửa cho phép lọc nội dung thông tin (tầng ứng dụng) ngăn chặn theo các dấu hiệu đã phát hiện.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa IDS và IPS?",
              "answer": "<p><img src=\"/interview-assets/ids-vs-ips.jpg\" alt=\"\" />\r\n\r\n<em> <strong>IDS</strong> là viết tắt của Intrusion Detection System - Hệ thống Phát hiện Xâm nhập. Đây là các phần mềm hoặc công cụ giúp bạn bảo mật hệ thống và cảnh báo mỗi khi có xâm nhập. IDS thường là một phần của các hệ thống bảo mật hoặc phần mềm khác, đi kèm với nhiệm vụ bảo vệ hệ thống thông tin.\r\n\r\n</em> <strong>IPS</strong> (Intrusion Prevention System) là Hệ thống Ngăn chặn Xâm nhập. Như vậy, IPS bao gồm IDS cùng hệ thống kiểm soát hoặc phản hồi. IDS không thể điều chỉnh các xâm nhập, trong khi IPS có khả năng ngăn chặn phát tán dựa vào nội dung của các xâm nhập.\r\n\r\nCả IDS và IPS đều là các hệ thống dựa trên dữ liệu những mối đe dọa đã được biết đến. IDS cần quản trị viên xem xét những mối nguy được cảnh báo, trong khi IPS có thể tự ngăn chặn các mối nguy này.</p>",
              "level": "fresher"
            },
            {
              "question": "Sniffing là gì?",
              "answer": "<p>Sniffing là một kỹ thuật để đánh giá các gói dữ liệu được phân phối qua mạng. Điều này có thể được thực hiện thông qua việc sử dụng phần mềm hoặc phần cứng chuyên dụng. Sniffing có thể được sử dụng cho nhiều mục đích khác nhau, bao gồm:\r<ul><li>Nắm bắt thông tin bí mật, chẳng hạn như mật khẩu.</li></ul>\r<ul><li>Nghe tin nhắn trò chuyện</li></ul>\r<ul><li>Theo dõi gói dữ liệu qua mạng</li></ul>\r\n\r\n<img src=\"/interview-assets/network_sniffing.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Phân biệt black box test và white box test?",
              "answer": "<p>| Black box test | White box test |\r\n|----------------|----------------|\r\n| Là phương pháp kiểm thử phần mềm trong đó cấu trúc bên trong của chương trình hoặc phần mềm được che giấu | Là phương pháp kiểm thử phần mềm trong đó người kiểm thử đã quen thuộc với cấu trúc hoặc code bên trong của phần mềm |\r\n| Người kiểm thử không cần thiết phải có kiến thức về việc mã hoá, cấu trúc bên trong của phần mềm, cũng như không yêu cầu phải biết lập trình phần mềm | Người kiểm thử phải có kiến thức nhất định về việc mã hoá, cấu trúc bên trong của chức năng, biết lập trình phần mềm |\r\n| Việc kiểm thử được tiến hành dựa vào việc kiểm thử phần mềm làm được gì, có phù hợp với yêu cầu của người dùng hay không. Các tester nhập số liệu vào phần mềm và chỉ cần xem kết quả của phần mềm và các mục tiêu kiểm tra | Việc kiểm thử được tiến hành dựa vào việc kiểm xem giải thuật, mã lệnh đã làm có đúng không |\r\n| Mức test này thường yêu cầu các tester phải viết test case đầy đủ trước khi test; khi test, đơn giản chỉ cần thực hiện theo các bước mô tả trong test case thao tác và nhập data vào, sau đó xem kết quả trả về hoặc hành vi của phần mềm, rồi so sánh với kết quả mong đọi được viết trong testcase | Mức test này thường yêu cầu các tester phải viết test case đầy đủ các nhánh trong code; khi test, sẽ set điều kiện và data để chạy vào đủ tất cả các nhánh trong giải thuật, đảm bảo thực hiện đầy đủ |</p>",
              "level": "fresher"
            },
            {
              "question": "System hardening là gì?",
              "answer": "<p>Nói chung, tăng cường hệ thống (system hardening) đề cập đến một tập hợp các công cụ và thủ tục để quản lý các lỗ hổng trong hệ thống, ứng dụng, chương trình cơ sở và các thành phần khác của tổ chức.\r\nMục tiêu của việc tăng cường hệ thống là giảm thiểu rủi ro bảo mật bằng cách giảm thiểu các cuộc tấn công tiềm ẩn và nén bề mặt tấn công của hệ thống. Các kiểu tăng cường hệ thống:\r<ul><li>Tăng cường cơ sở dữ liệu</li></ul>\r<ul><li>Tăng cường hệ điều hành</li></ul>\r<ul><li>Tăng cường ứng dụng</li></ul>\r<ul><li>Tăng cường máy chủ</li></ul>\r<ul><li>Tăng cường mạng</li></ul>\r\n\r\n<img src=\"/interview-assets/System_Hardening.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa HIDS và NIDS?",
              "answer": "<p><strong>Host-Based IDS (HIDS)</strong> chỉ làm nhiệm vụ giám sát và ghi lại log cho một máy chủ (host-system). Đây là dạng IDS với giới hạn chỉ giám sát và ghi lại toàn bộ những khả năng của host-system (nó bao gồm cả hệ điều hành và các ứng dụng cũng như toàn bộ service của máy chủ đó). Một Host-Based IDS có khả năng phát hiện các vấn đề nếu các thông tin về máy chủ đó được giám sát và ghi lại. Là thiết bị bảo mật cho phát hiện các tấn công trực tiếp tới một máy chủ.\r\n\r\n<strong>Network-Based IDS (NIDS)</strong>  sẽ kiểm tra các giao tiếp trên mạng với thời gian thực (real-time). Nó kiểm tra các giao tiếp, quét header của các gói tin, và có thể kiểm tra nội dung của các gói đó để phát hiện ra các đoạn mã nguy hiểm hay các dạng tấn công khác nhau. Một Network-Based IDS hoạt động tin cậy trong việc kiểm tra, phát hiện các dạng tấn công trên mạng, ví dụ như dựa vào băng thông (bandwidth-based) của tấn công Denied of Service (DoS).\r\n\r\n<img src=\"/interview-assets/hids_vs_nids.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Tấn công DNS là gì?",
              "answer": "<p>Tấn công DNS là một dạng tấn công mạng, trong đó tin tặc sử dụng các điểm yếu trong DNS để chuyển hướng người dùng đến các trang web độc hại và đánh cắp dữ liệu từ các máy được nhắm mục tiêu. Bởi vì hệ thống DNS là một phần quan trọng của cơ sở hạ tầng internet, nó gây ra rủi ro an ninh mạng nghiêm trọng.\r\n\r\n<img src=\"/interview-assets/DNS_attack.jpg\" alt=\"\" />\r\n\r\nCó thể tránh được những điều này bằng các biện pháp phòng ngừa sau: \r\n<em> Kiểm tra các vùng DNS trong hệ thống của bạn.\r\n</em> Đảm bảo máy chủ DNS của bạn được cập nhật.\r\n<em> Phiên bản BIND bị ẩn.\r\n</em> Việc chuyển giao giữa các khu vực nên được hạn chế.\r\n<em> Để tránh các nỗ lực nhiễm độc DNS, hãy tắt đệ quy DNS.\r\n</em> Sử dụng các máy chủ DNS được phân tách.\r<ul><li>Sử dụng dịch vụ giảm thiểu DDOS</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa mã hoá khối và mã hoá dòng?",
              "answer": "<p>Sự khác biệt chính giữa mã hoá khối (block cipher) và mã hoá dòng (stream cipher) là phép mã hoá khối biến plain-text thành cipher-text từng khối một tại một thời điểm. Mặt khác, mã hoá dòng chuyển đổi plaint-text thành cipher-text bằng cách lấy một byte của plain-text tại một thời điểm.\r\n\r\n| Block Cipher | Stream Cipher |\r\n|--------------|---------------|\r\n| Chuyển đổi plain-text thành cipher-text theo từng khối tại một thời điểm | Lấy một byte của plain-text tại một thời điểm và chuyển nó thành cipher-text |\r\n| Sử dung 64 bit hoặc nhiều hơn | Sử dụng 8 bit |\r\n| Dùng thuật toán ECB (Electronic Code Book) và CBC (Common Block Cipher) | Dùng thuật toán CFB (Cipher Feedback) anvàd OFB (Output Feedback) |\r\n| Chậm hơn so với mã hoá dòng | Nhanh hơn mã hoá khối |\r\n| Hoạt động dựa trên kỹ thuật chuyển vị như kỹ thuật hàng rào đường sắt, kỹ thuật chuyển vị cột | Hoạt động dựa trên kỹ thuật thay thế như mật mã Caesar, mật mã polygram,... |</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa spear phishing và phishing?",
              "answer": "<p>Lừa đảo (Phishing) là hình thức tấn công email phổ biến nhất trong đó kẻ tấn công lừa mọi người nhấp vào các liên kết độc hại có vẻ hợp pháp, để lấy thông tin nhạy cảm hoặc bí mật của họ bằng cách bắt chước thông tin liên lạc điện tử từ một nguồn hoặc tổ chức đáng tin cậy một cách tự động. \r\n\r\nSpear phishing là cấp độ tấn công email tiếp theo, trong đó các email được thiết kế cẩn thận để nhắm mục tiêu vào một nhóm hoặc cá nhân cụ thể và để thuyết phục họ nhấp vào một liên kết, cài đặt mã độc trên máy tính của họ. Sau khi mã độc xâm nhập vào hệ thống của họ, kẻ tấn công giành toàn quyền kiểm soát máy tính của họ và sau đó có thể lấy dữ liệu cá nhân và chuyên nghiệp có giá trị từ nạn nhân. \r\n\r\n<img src=\"/interview-assets/phishing_vs_spear_phishing.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "ARP Poisoning là gì?",
              "answer": "<p><strong>Address Resolution Protocol Poisoning</strong> là một kỹ thuật thông qua đó kẻ tấn công giả mạo thông điệp ARP trong mạng cục bộ. Trên mạng, mấy chủ (host) gửi một ARP boardcast và các máy nhận phản hồi bằng địa chỉ vật lý của nó.\r\nCách tấn công này sẽ gửi một địa chỉ vật lý không thật đến một bộ switch để nó có thể liên kết chúng với địa chỉ IP của một máy hợp lệ trên mạng qua đó kẻ tấn công có thể chiếm đoạt lưu lượng truy cập.\r\n\r\n<img src=\"/interview-assets/ARP_poisoning.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "SQL Injection là gì? Làm thế nào để ngăn chặn nó?",
              "answer": "<p>SQL Injection là một kỹ thuật lợi dụng những lỗ hổng về câu truy vấn của các ứng dụng. Được thực hiện bằng cách chèn thêm một đoạn SQL để làm sai lệnh đi câu truy vấn ban đầu, từ đó có thể khai thác dữ liệu từ cơ sở dữ liệu. SQL injection có thể cho phép những kẻ tấn công thực hiện các thao tác như một người quản trị web, trên cơ sở dữ liệu của ứng dụng.\r\n\r\n<img src=\"/interview-assets/SQL_injection.jpg\" alt=\"\" />\r\n\r\nCách ngăn chặn tấn công SQL injection:\r<ul><li>Xác minh thông tin đầu vào</li></ul>\r<ul><li>Sử dụng các câu lệnh tham số</li></ul>\r<ul><li>Phân định rõ ràng kiểu input</li></ul>\r<ul><li>Xác nhận các chuỗi input ở phía máy chủ</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa virus và worm?",
              "answer": "<p><strong>Virus</strong> máy tính là phần mềm độc hại, thường là các file thực thi có khả năng sao chép và tự truyền từ máy tính này sang máy tính khác thông qua các thiết bị truyền file. Nó có thể tự đính kèm vào một tập tin thực thi khác và chuyển qua đó.\r\n\r\n<strong>Worm</strong> (sâu máy tính) là phần mềm độc hại được thiết kế để phát tán qua internet và các mạng khác. Chúng có thể lây lan thông qua chuyển/tải tập tin đơn giản hoặc qua email. Worm có thể ảnh hưởng đến mạng máy tính bằng cách tiêu thụ băng thông và hệ thống máy tính bằng cách làm ngập bộ nhớ với các bản sao của chương trình. Không giống như virus, worm không cần tệp lưu trữ để thực thi. Chúng hoạt động độc lập trong hệ thống máy tính.</p>",
              "level": "fresher"
            },
            {
              "question": "Dạng cookie nào có thể được sử dụng trong cuộc tấn công bằng phần mềm gián điệp?",
              "answer": "<p>Tracking cookis thay vì session cookie, sẽ được sử dụng trong một cuộc tấn công phần mềm gián điệp vì nó sẽ kéo dài qua nhiều phiên thay vì chỉ một phiên.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào quyết định vị trí của việc mã hoá?",
              "answer": "<p>Chúng ta phải quyết định mã hóa cái gì và cơ chế mã hóa nên được đặt ở đâu nếu mã hóa được sử dụng để chống lại các cuộc tấn công vào hệ thống bảo mật. Mã hóa link và end-to-end là hai cách chính để đặt mã hóa.\r\n\r\n<strong>Mã hóa end-to-end</strong>, hay E2EE, là một hệ thống truyền dữ liệu an toàn, trong đó dữ liệu chỉ được mã hóa và giải mã ở các điểm cuối, bất kể nó đi qua bao nhiêu điểm ở giữa quá trình ảo. Loại mã hóa này là một kỹ thuật tuyệt vời để giao tiếp một cách an toàn và bí mật. Bởi vì không ai khác có chìa khóa để giải mã nó, không ai ở giữa sẽ có thể đọc nó.\r\n\r\n<strong>Mã hóa link</strong> là mã hóa và giải mã tất cả lưu lượng truy cập ở tất cả các điểm, không chỉ ở các điểm cuối. Tất cả dữ liệu được mã hóa khi nó di chuyển dọc theo đường truyền. Tuy nhiên, khi đến một bộ định tuyến hoặc một thiết bị trung gian khác, nó sẽ được giải mã để thiết bị trung gian có thể xác định hướng gửi tiếp theo.\r\n\r\n<img src=\"/interview-assets/encryption_function.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Virus Polymorphic là gì?",
              "answer": "<p>Khác với các loại virus thông thường luôn giữ nguyên mã lệnh trong tất cả các lần lây nhiễm (đơn hình - chỉ có duy nhất một hình), virus đa hình là virus có khả năng tự động biến đổi mã lệnh để tạo ra các dạng mã độc khác nhau (đa hình - nhiều hình) trong mỗi lần lây nhiễm. Chính vì vậy, virus đa hình có khả năng lẩn trốn một cách tinh vi trước sự truy quét của các phần mềm diệt virus. Virus đa hình thường thực hiện biến đổi mã lệnh một cách ngẫu nhiên hoặc theo một thuật toán dựa trên thời gian hay đối tượng lây nhiễm. Có nhiều loại virus đa hình khác nhau, nhưng phổ biến nhất là đa hình mã lây nhiễm và đa hình mã phá hoại.\r\n\r\n<img src=\"/interview-assets/Polymorphic_viruses.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Active Reconnaissance là gì?",
              "answer": "<p><strong>Active Reconnaissance</strong> là một kiểu tấn công máy tính trong đó kẻ xâm nhập tương tác với hệ thống mục tiêu để thu thập thông tin về các điểm yếu.\r\n\r\nChúng thường quét cổng (port) để phát hiện các cổng dễ bị tấn công, sau đó khai thác các lỗ hổng của dịch vụ được liên kết với cổng đó. Điều này có thể thực hiện bằng cách quét tự động hoặc thủ công với các công cụ như ping, traceroute hay netcat. Loại do thấm này đồi hỏi sự tượng tác giữa kẻ tấn công và hệ thống mục tiêu. Cách thức này nhanh và chính xác, nhưng có nhiều rủi ro. Vì kẻ tấn công phải tương tác với mục tiêu để lấy thông tin, nên có nhiều khả năng bị tường lửa hoặc thiết bị bảo mật mạng khác phát hiện</p>",
              "level": "fresher"
            },
            {
              "question": "Theo bạn, Forward Secrecy nghĩa là gì và nó hoạt động như thế nào?",
              "answer": "<p><em>Bí mật chuyển tiếp (Forward Secrecy)</em> là một tính năng của các giao thức thỏa thuận khóa cụ thể nhằm đảm bảo rằng các khóa phiên sẽ không bị xâm phạm ngay cả khi các bí mật dài hạn được sử dụng trong trao đổi khóa phiên bị xâm phạm.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "data-structures",
          "name": "Câu hỏi phỏng vấn Cấu Trúc Dữ Liệu",
          "description": "",
          "questions": [
            {
              "question": "Bạn có thể giải thích sự khác nhau giữa cấu trúc tập tin và cấu trúc lưu trữ?",
              "answer": "<p>Sự khác biệt chính giữa cấu trúc tập và cấu trúc lưu trữ là dựa trên không gian bộ nhớ đang được truy cập.\r\n\r\n<strong>Cấu trúc lưu trữ:</strong> Là sự biểu diễn cấu trúc dữ liệu trong bộ nhớ máy tính.\r\n\r\n<strong>Cấu trúc tập tin:</strong> Là biểu diễn cấu trúc lưu trữ trong bộ nhớ phụ/thứ cấp.</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn có thể nói sự khác biệt giữa cấu trúc dữ liệu tuyến tính và phi tuyến tính?",
              "answer": "<p>Nếu các phần tử của cấu trúc dữ liệu là một chuỗi hay danh sách tuyến tính thì nó gọi là cấu trúc dữ liệu tuyến tính. Trong khi đó, cấu trúc dữ liệu cho duyệt các phần tử không theo thứ tự nào gọi cấu trúc dữ liệu phi tuyến tính.\r\n\r\nDanh sách, ngăn xếp và hàng đợi là ví dụ của cấu trúc dữ liệu tuyến tính trong khi cây và đồ thị là cấu trúc dữ liệu phi tuyến tính.\r\n\r\n<img src=\"/interview-assets/linear-vs-non-linear.png\" alt=\"linear-vs-non-linear\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Mảng là gì?",
              "answer": "<p>Mảng là tập hợp các loại dữ liệu cùng <strong>kiểu</strong> được lưu trữ tại các vị trí bộ nhớ liền kề.\r\nĐây là cấu trúc dữ liệu đơn giản nhất mà phần tử dữ liệu có thể được truy cập ngẫu nhiên bằng cách sử dụng chỉ mục của nó.</p>",
              "level": "fresher"
            },
            {
              "question": "Mảng đa chiều là gì?",
              "answer": "<p>Mảng đa chiều là những cấu trúc dữ liệu mảng trên nhiều chiều khác nhau.\r\n\r\nĐiều này chỉ ra rằng sẽ có nhiều hơn một chỉ mục cho mỗi điểm lưu trữ. Loại cấu trúc dữ liệu này chủ yếu được sử dụng trong trường hợp dữ liệu không thể được biểu diễn hoặc lưu trữ trên mảng một chiều. Mảng đa chiều được sử dụng phổ biến nhất là mảng hai chiều.\r\n\r\nMảng hai chiều mô phỏng cấu trúc dạng bảng giúp dễ dàng lưu trữ lượng lớn dữ liệu được truy cập bằng cách sử dụng con trỏ hàng và cột.\r\n\r\n<img src=\"/interview-assets/multidimensional-array.png\" alt=\"multi-array\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Danh sách liên kết là gì?",
              "answer": "<p>Danh sách liên kết là một <strong>chuỗi tuần tự các nút</strong>, trong đó các nút được liên kết với nhau thông qua con trỏ tham chiếu. Các phần tử <strong>không được lưu trữ</strong> tại các vị trí liền kề trong bộ nhớ. Chúng được liên kết bằng cách sử dụng con trỏ để tạo thành một chuỗi. Điều này tạo thành một liên kết dạng chuỗi để lưu trữ dữ liệu. \r\n\r\nMỗi nút thường có hai phần:\r<ul><li>Trường dữ liệu</li></ul>\r<ul><li>Tham chiếu(con trỏ) đến nút kế tiếp</li></ul>\r\n\r\nNút đầu tiên trong danh sách liên kết gọi là head, nút cuối cùng gọi là tail và trỏ đến null. Null trong trường tham chiếu chỉ ra nút đó là tail. Nếu danh sách trống, head sẽ là tham chiếu null.\r\n\r\n<img src=\"/interview-assets/linked-list.png\" alt=\"linked-list\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Danh sách liên kết là tuyến tính hay phi tuyến tính?",
              "answer": "<p>Danh sách liên kết có thể được coi là cấu trúc dữ liệu tuyến tính và cả phi tuyến tính. Điều này phụ thuộc vào ứng dụng mà chúng được sử dụng.\r\n\r\nKhi danh sách liên kết được sử dụng cho truy cập, nó được coi là một cấu trúc dữ liệu tuyến tính. Khi chúng được sử dụng để lưu trữ dữ liệu, nó có thể được coi là một cấu trúc dữ liệu phi tuyến tính.</p>",
              "level": "fresher"
            },
            {
              "question": "Danh sách liên kết có hiệu quả hơn mảng?",
              "answer": "<p>1. <strong>Chèn và xoá</strong>\r<ul><li>Quá trình chèn và xoá là rất tốn kém trong mảng vì phải tạo các phần tử mới và dịch chuyển các phần tử đã có.</li></ul>\r<ul><li>Nhưng trong danh sách liên kết, các thao tác này dễ dàng hơn vì chỉ cập nhật địa chỉ hiện tại trong con trỏ tiếp theo của một nút.</li></ul>\r\n\r\n2. <strong>Cấu trúc dữ liệu động</strong>\r<ul><li>Danh sách liên kết là cấu trúc dữ liệu động có nghĩa là không cần cho kích thước ban đầu khi tạo, nó có thể mở rộng hay co lại theo thời gian bởi quá trình cấp phát hay thu hồi của bộ nhớ.</li></ul>\r<ul><li>Trong khi đó, kích thước của mảng là giới hạn về số lượng phần tử được lưu trong bộ nhớ chính.</li></ul>\r\n\r\n3. <strong>Không lãng phí bộ nhớ</strong>\r<ul><li>Vì kích thước của danh sách liên kết có thể tăng lên hoặc co lại dựa trên nhu cầu của chương trình, nên không có bộ nhớ nào bị lãng phí vì nó được cấp phát trong thời gian chạy.</li></ul>\r<ul><li>Với mảng, nếu chúng ta khai báo một mảng có kích thước 10 và chỉ lưu trữ 3 phần tử trong đó, thì không gian cho 7 phần tử sẽ bị lãng phí. Do đó, khả năng lãng phí bộ nhớ trong các mảng nhiều hơn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích trường hợp nào sử dụng danh sách liên kết và trường hợp nào sử dụng mảng?",
              "answer": "<p>Các trường hợp sử dụng danh sách liên kết tốt hơn mảng:\r<ul><li>Khi ta không biết trước chính xác số lượng phần tử.</li></ul>\r<ul><li>Khi ta biết sẽ có một lượng lớn thao tác thêm hoặc xoá.</li></ul>\r<ul><li>Số lượng thao tác truy cập ngẫu nhiên là rất ít.</li></ul>\r<ul><li>Khi muốn chèn các mục vào bất kỳ vị trí nào giữa danh sách, chẳng hạn như khi triển khai hàng đợi ưu tiên, danh sách liên kết sẽ phù hợp hơn.</li></ul>\r\n\r\nCác trường hợp dùng mảng tốt hơn danh sách liên kết:\r<ul><li>Khi cần đánh chỉ mục cho các truy cập phần tử ngẫu nhiên thường xuyên.</li></ul>\r<ul><li>Khi ta biết trước số lượng phần tử mảng để cấp phát bộ nhớ.</li></ul>\r<ul><li>Khi chúng ta cần tốc độ khi lặp lại các phần tử trong chuỗi.</li></ul>\r<ul><li>Khi cần quan tâm bộ nhớ:</li></ul>\r\n    1. Một mảng đầy sẽ tốn ít bộ nhớ hơn danh sách liên kết\r\n    2. Mỗi phần tử trong mảng chỉ biễu diễn dữ liệu trong khi mỗi nút trong danh sách liên kết phải biễu diễn thêm một hoặc nhiều con trỏ cho liên kết đến các nút khác.\r\n\r\nTóm lại, các yêu cầu về không gian, thời gian và mức độ dễ thực hiện được xem xét để quyết định cấu trúc dữ liệu nào sẽ được sử dụng cho mục đích gì.</p>",
              "level": "fresher"
            },
            {
              "question": "Danh sách liên kết đôi (DDL) là gì?",
              "answer": "<p>Đây là một loại danh sách liên kết phức tạp, trong đó một nút có hai tham chiếu:\r<ul><li>Một tham chiếu liên kết với nút tiếp theo trong chuỗi</li></ul>\r<ul><li>Một tham chiếu khác liên kết với nút trước đó.</li></ul>\r\n\r\nCấu trúc này cho phép duyệt các phần tử dữ liệu theo cả hai hướng (trái sang phải và ngược lại).\r\n\r\nCác ứng dụng của DLL là:\r<ul><li>Danh sách phát nhạc với bài hát tiếp theo và các tùy chọn điều hướng bài hát trước đó.</li></ul>\r<ul><li>Bộ nhớ cache của trình duyệt với các trang đã truy cập BACK-FORWARD</li></ul>\r<ul><li>Chức năng hoàn tác và phục hồi trên các nền tảng như word, paint, v.v., nơi bạn có thể nút undo để truy cập trang trước.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Ngăn xếp là gì",
              "answer": "<p>Ngăn xếp là một cấu trúc dữ liệu tuyến tính tuân theo cách tiếp cận LIFO (Last In First Out) để truy cập các phần tử. \r\n\r\nCác thao tác cơ bản trong ngăn xếp:\r<ul><li><em>Push</em>: thêm phần tử vào đỉnh ngăn xếp</li></ul>\r<ul><li><em>Pop</em>: lấy phần tử từ đỉnh ngăn xếp</li></ul>\r<ul><li><em>Peek</em>: lấy giá trị phần tử từ đỉnh ngăn xếp, mà không xóa nó khỏi ngăn xếp</li></ul>\r\n\r\n<img src=\"/interview-assets/stack.png\" alt=\"stack\" />\r\n\r\nCác ứng dụng của ngăn xếp:\r<ul><li>Tính các biểu thức đại số</li></ul>\r<ul><li>Quản lý bộ nhớ khi thực thi chương trình</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hàng đợi là gì",
              "answer": "<p>Hàng đợi là một cấu trúc dữ liệu tuyến tính tuân theo phương pháp FIFO (First In First Out) để truy cập các phần tử.\r\n\r\nCác thao tác cơ bản trong hàng đợi:\r<ul><li><em>enqueue</em>: thêm đối tượng vào cuối hàng đợi.</li></ul>\r<ul><li><em>dequeue</em>: lấy đối tượng ở đầu ra khỏi hàng đợi và trả về giá trị của nó.</li></ul>\r<ul><li><em>front</em>: trả về giá trị của phần tử nằm ở đầu hàng đợi mà không hủy nó.</li></ul>\r<ul><li><em>rear</em>: trả về giá trị của phần tử nằm ở cuối hàng đợi mà không hủy nó.</li></ul>\r\n\r\n<img src=\"/interview-assets/queue.png\" alt=\"queue\" />\r\n\r\nỨng dụng của hàng đợi:\r<ul><li>Dùng trong các hệ điều hành song song</li></ul>\r<ul><li>Xử lý yêu cầu trang web</li></ul>\r<ul><li>Dùng làm bộ đệm cho ứng dụng nghe nhạc</li></ul>\r<ul><li>Tác vụ CPU</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Ngăn xếp và hàng đợi khác nhau thế nào?",
              "answer": "<p>Trong ngăn xếp phần tử được thêm vào gần nhất sẽ được lấy ra đầu tiên, còn trong hàng đợi nó sẽ được lấy ra cuối cùng.\r\n\r\n<img src=\"/interview-assets/stack-vs-queue.png\" alt=\"stack-queue\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích quy trình đằng sau việc lưu trữ một biến trong bộ nhớ.",
              "answer": "<p>Một biến được lưu trữ trong bộ nhớ dựa trên dung lượng bộ nhớ cần thiết. Sau đây là các bước được thực hiện để lưu trữ một biến:\r\n\r\n1. Đầu tiên, nó chỉ định số lượng bộ nhớ cần thiết.\r\n2. Sau đó, nó được lưu trữ dựa trên cấu trúc dữ liệu đang được sử dụng.\r<ul><li>Sử dụng các khái niệm như cấp phát động đảm bảo hiệu quả cao và các đơn vị lưu trữ có thể được truy cập dựa trên các yêu cầu trong thời gian thực.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Triển khai hàng đợi bằng ngăn xếp",
              "answer": "<p>Một hàng đợi có thể triển khai bằng cách dùng <strong>hai ngăn xếp</strong>. \r\n\r\nCho hàng đợi <code>q</code> và hai ngăn xếp <code>stack1</code> và <code>stack2</code> để triển khai <code>q</code>. Ta biết ngăn xếp hỗ trợ các thao tác push, pop và peek, ta sẽ dùng các thao tác đó để mô phỏng các hoạt động của hàng đợi, enqueue và dequeue. Do đó, hàng đợi <code>q</code> có thể triển khai theo hai cách (cả hai cách đều có độ phức tạp không gian là O(n)):\r\n\r\n1. Cần nhiều chi phí chi enqueue\r\n\r\nỞ đây, phần tử cũ nhất luôn ở trên cùng của <code>stack1</code> đảm bảo hoạt động dequeue xảy ra với độ phức tạp thời gian O (1).\r\n\r\nĐể đặt phần tử vào đầu <code>stack1</code>, <code>stack2</code> được sử dụng.\r\n\r\nMã giả:\r<ul><li>Enqueue: Độ phức tạp thời gian là O(n):</li></ul>\r\n\r\n``<code>text\r\nenqueue(q, data):\r\n    While stack1 is not empty:\r\n        Push everything from stack1 to stack2.\r\n        Push data to stack1\r\n        Push everything back to stack1.\r\n</code>`<code>\r<ul><li>Dequeue: Độ phức tạp thời gian là O(1):</li></ul>\r\n\r\n</code>`<code>text\r\ndequeue(q):\r\n    If stack1 is empty then error\r\n    else\r\n        Pop an item from stack1 and return it\r\n</code>`<code>\r\n\r\n2. Cần nhiều chi phí cho dequeue\r\n\r\nỞ đây, đối với thao tác enqueue, phần tử mới được đẩy lên trên cùng của </code>stack1<code>.Thế nên, độ phức tạp thời gian hoạt động của enqueue là O(1).\r\n\r\nVới dequeue, nếu </code>stack2<code> trống, tất cả các phần tử từ </code>stack1<code> sẽ được chuyển đến </code>stack2<code> và pop phần tử trên cùng của </code>stack2<code> để lấy kết quả. Về cơ bản, đảo ngược danh sách bằng cách đẩy vào một ngăn xếp và trả về phần tử được enqueue đầu tiên. Thao tác đẩy tất cả các phần tử vào ngăn xếp mới có độ phức tạp O(n).\r\n\r\nMã giả:\r<ul><li>Enqueue: Độ phức tạp thời gian là O(1):</li></ul>\r\n\r\n</code>`<code>text\r\nenqueue(q, data):\r\n    Push data to stack1\r\n</code>`<code>\r<ul><li>Dequeue: Độ phức tạp thời gian là O(n):</li></ul>\r\n\r\n</code>`<code>text\r\ndequeue(q):\r\n    If both stacks are empty then raise error.\r\n    If stack2 is empty:\r\n        While stack1 is not empty:\r\n            push everything from stack1 to stack2.\r\n    Pop the element from stack2 and return it.\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Triển khai ngăn xếp bằng hàng đợi?",
              "answer": "<p>Một ngăn xếp có thể được triển khai bằng 2 hai hàng đợi. Một hàng đợi hỗ trợ các thao tác là enqueue và dequeue. Ta sẽ dùng chúng để tạo các thao tác push, pop.\r\n\r\nĐầu tiên ta có hai hàng đợi là <code>q1</code> và <code>q2</code>. Ngăn xếp được triển khai bởi hàng đợi theo hai cách.\r\n\r\n1. Tốn chi phí cho push:\r\n\r\nPhương thức này đảm bảo các phần tử mới được thêm vào sẽ luôn ở đằng trước của <code>q1</code>, thế nên thao tác pop sẽ là deque từ <code>q1</code>.\r\n\r\n<code>q2</code> được dùng như một hàng đợi phụ trợ để phần tử mới vào trước <code>q1</code> trong khi đảm bảo pop xảy ra ở độ phức tạp O(1).\r\n\r\nMã giả:\r<ul><li>Push phần tử vào ngăn xếp: Độ phức tạp thời gian là O(n).</li></ul>\r\n``<code>\r\npush(s, data):\r\n    Enqueue data to q2\r\n    Dequeue elements one by one from q1 and enqueue to q2.\r\n    Swap the names of q1 and q2\r\n</code>`<code>\r<ul><li>Pop phần tử khỏi ngăn xếp: Độ phức tạp thời gian là O(1).</li></ul>\r\n</code>`<code>\r\npop(s):\r\n    dequeue from q1 and return it.\r\n</code>`<code>\r\n\r\n2. Tốn chi phí cho pop:\r\n\r\nTrong hoạt động push, phần tử được enqueue vào hàng đợi </code>q1<code>.\r\n\r\nTrong hoạt động pop, tất cả các phần tử từ </code>q1<code> ngoại trừ phần tử còn lại cuối cùng, được đẩy sang </code>q2<code> nếu nó trống. Phần tử cuối cùng còn lại đó của </code>q1<code> được dequeue và trả về.\r\n\r\nMã giả:\r<ul><li>Push phần tử vào ngăn xếp: Độ phức tạp thời gian là O(1).</li></ul>\r\n</code>`<code>\r\npush(s,data):\r\n    Enqueue data to q1\r\n</code>`<code>\r<ul><li>Pop phần tử khỏi ngăn xếp: Độ phức tạp thời gian là O(n).</li></ul>\r\n</code>`<code>\r\npop(s):\r\n    Step1: Dequeue every elements except the last element from q1 and enqueue to q2.\r\n    Step2: Dequeue the last item of q1, the dequeued item is stored in result variable.\r\n    Step3: Swap the names of q1 and q2 (for getting updated data after dequeue)\r\n    Step4: Return the result.\r\n</code>``\r\n\r\n## Câu hỏi phỏng vấn cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Hashmap trong Java là gì?",
              "answer": "<p>HashMap trong Java là một bảng băm dựa trên việc thực hiện Java's Map interface. Map là một tập hợp các cặp key-value. Nó ánh xạ các key tới các value.\r\n\r\nNói đơn giản hơn thì HashMap về cơ bản chỉ định các unique key cho các value tương ứng có thể được truy xuất tại bất kỳ điểm nào.</p>",
              "level": "fresher"
            },
            {
              "question": "Yêu cầu đối với một đối tượng được sử dụng làm khóa hoặc giá trị trong HashMap là gì?",
              "answer": "<p>Đối tượng khoá hay giá trị được dùng trong hashmap phải triển khai phương thức <code>equals()</code> và <code>hashcode()</code>.\r\n\r\nPhương thức <code>hashcode()</code> được dùng khi thêm một đối tượng khoá vào map, còn <code>equals()</code> được dùng khi truy cập dữ liệu từ map.</p>",
              "level": "fresher"
            },
            {
              "question": "Xử lý xung đột trong HashMap với Java?",
              "answer": "<p>Lớp <code>java.util.HashMap</code> trong Java sử dụng phương pháp chuỗi để xử lý xung đột. Trong chuỗi, nếu giá trị mới có khoá trùng với giá trị đã thêm vào, thì các giá trị này được lưu trữ trong danh sách liên kết ở bucket của khoá dưới dạng chuỗi cùng với giá trị hiện có.\r\n\r\nTrong trường hợp tệ nhất, tất cả các khoá đều có cùng hashcode, nó sẽ trả về bảng băm giống như là một danh sách liên kết. Trong trường hợp này, việc tìm kiếm một giá trị sẽ mất độ phức tạp thời gian là O(n) thay vì O(1). Do đó, cần phải cẩn thận khi lựa chọn thuật toán băm.</p>",
              "level": "fresher"
            },
            {
              "question": "Độ phức tạp thời gian của thao tác get() và put() trong HashMap",
              "answer": "<p>Độ phức tạp thời gian là O(1) giả sử rằng hàm băm được sử dụng trong hashmap phân phối các phần tử một cách đồng nhất giữa các bucket.</p>",
              "level": "fresher"
            },
            {
              "question": "Cơ sở dữ liệu nào được dùng cho triển khai bộ đệm LRU?",
              "answer": "<p>Bộ đệm LRU (Least Recently Used) cho phép xác định nhanh một phần tử đã không được sử dụng trong thời gian dài, bằng cách sắp xếp các mục theo thứ tự sử dụng. Để thực hiện được điều này, hai cấu trúc dữ liệu được sử dụng: \r<ul><li><strong>Queue</strong> - Triển khai này sử dụng một danh sách liên kết đôi. Kích thước tối đa của hàng đợi dựa trên kích thước bộ đệm, bằng tổng số frame khả dụng. Các trang ít được dùng gần đây nhất sẽ ở gần với phần trước của hàng đợi trong khi các trang sử dụng nhiều gần đây nhất sẽ ở cuối hàng.</li></ul>\r<ul><li><strong>Hashmap</strong> - Hashmap lưu trữ số trang dưới dạng khóa cùng với địa chỉ của nút hàng đợi tương ứng dưới dạng giá trị.</li></ul>\r\n\r\n<img src=\"/interview-assets/LRU-cache.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Hàng đợi ưu tiên là gì?",
              "answer": "<p>Hàng đợi ưu tiên là một kiểu dữ liệu trừu tượng giống như một hàng đợi bình thường nhưng có quyền ưu tiên được gán cho các phần tử.\r\n\r\nCác phần tử có mức độ ưu tiên cao hơn được xử lý trước các phần tử có mức độ ưu tiên thấp hơn.\r\n\r\nĐể thực hiện điều này, cần có tối thiểu hai hàng đợi - một hàng cho dữ liệu và hàng còn lại để lưu trữ mức độ ưu tiên.</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể lưu trữ một khóa trùng lặp trong HashMap không?",
              "answer": "<p><strong>Không</strong>, không thể chèn các khóa trùng lặp vào HashMap. Nếu bạn cố gắng chèn bất kỳ khoá nào bằng khóa hiện có, thì giá trị cũ sẽ bị ghi đè bằng giá trị mới. Và điều này sẽ không thay đổi kích thước của HashMap.\r\n\r\nĐây là lý do tại sao phương thức <code>keySet()</code> trả về tất cả các khóa dưới dạng SET trong Java vì nó không cho phép trùng lặp.</p>",
              "level": "fresher"
            },
            {
              "question": "Cấu trúc dữ liệu cây là gì?",
              "answer": "<p>Cây là một cấu trúc dữ liệu đệ quy, phi tuyến tính bao gồm tập hợp một hoặc nhiều nút dữ liệu trong đó một nút được chỉ định là gốc và các nút còn lại được gọi là con của gốc.\r\n\r\nCây tổ chức dữ liệu theo cách phân cấp.\r\n\r\nCấu trúc dữ liệu cây được sử dụng phổ biến nhất là cây nhị phân và các biến thể của nó.\r\n\r\nMột vài ứng dụng của cây:\r\n1. Hệ thống file\r\n2. Bình luận trên mạng xã hội\r\n3. Cây gia phả\r\n\r\n<img src=\"/interview-assets/tree-data-structure.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Cây nhị phân là gì?",
              "answer": "<p>Cây nhị phân là một kiểu câu đặc biệt trong đó mỗi nút có nhiều nhất hai nút con. Cây nhị phân thường được phân chia thành ba tập con rời rạc, tức là gốc của cây, cây con bên trái và cây con bên phải. \r\n\r\n<img src=\"/interview-assets/binary-search-tree.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Số lượng nút tối đa của cây nhị phân có chiều dài k",
              "answer": "<p>Số lượng nút tối đa là 2^(k+1) - 1, với k >= 1.</p>",
              "level": "fresher"
            },
            {
              "question": "Viết hàm đệ quy tính chiều cao cây nhị phân trong Java",
              "answer": "<p>Trước hết ta tạo một lớp đại diện cho mọi nút trong cây:\r\n\r\n``<code>java\r\npublic class Node{\r\n    int data;\r\n    Node left;\r\n    Node right;\r\n}\r\n</code>`<code>\r\n\r\nHàm để tính chiều cao của cây:\r\n\r\n</code>`<code>java\r\nint heightOfBinaryTree(Node node)  \r\n    { \r\n        if (node == null) \r\n            return 0; // If node is null then height is 0 for that node.\r\n        else \r\n        { \r\n            // compute the height of each subtree\r\n            int leftHeight = heightOfBinaryTree(node.left); \r\n            int rightHeight = heightOfBinaryTree(node.right); \r\n\r\n            //use the larger among the left and right height and plus 1 (for the root)\r\n            return Math.max(leftHeight, rightHeight) + 1; \r\n        } \r\n    }\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Viết hàm Java đếm số lượng nút trong cây",
              "answer": "<p>``<code>java\r\nint countNodes(Node root)\r\n{\r\n    int count =  1;             //Root itself should be counted\r\n    if (root ==null)\r\n        return 0;\r\n    else\r\n    {\r\n        count += countNodes(root.left);\r\n        count += countNodes(root.right);\r\n        return count;\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Duyệt cây là gì?",
              "answer": "<p>Duyệt cây là quá trình đi qua tất cả nút trong cây. Từ gốc (root) là nút đầu tiên đến tất cả các nút được liên kết. Có 3 cách duyệt cây:\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Duyệt trung thứ tự:",
              "answer": "<p><ul><li>Thuật toán:</li></ul>\r<ul><li>Bước 1: Duyệt cây con bên trái, gọi InOrder(root.left)</li></ul>\r<ul><li>Bước 2: Duyệt root</li></ul>\r<ul><li>Bước 3: Duyệt cây con bên phải, gọi InOrder(root.right)</li></ul>\r<ul><li>Code Java:</li></ul>\r\n``<code>java\r\n// Print inorder traversal of given tree.\r\nvoid printInorderTraversal(Node root) \r\n{ \r\n    if (root == null) \r\n        return; \r\n\r\n    //first traverse to the left subtree\r\n    printInorderTraversal(root.left); \r\n\r\n    //then print the data of node\r\n    System.out.print(root.data + &quot; &quot;); \r\n\r\n    //then traverse to the right subtree\r\n    printInorderTraversal(root.right); \r\n}\r\n</code>``\r<ul><li>Dùng: cho tìm kiếm kiếm cây nhị phân.</li></ul>\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Duyệt tiền thứ tự:",
              "answer": "<p><ul><li>Thuật toán:</li></ul>\r<ul><li>Bước 1: Duyệt root</li></ul>\r<ul><li>Bước 2: Duyệt cây con bên trái, gọi InOrder(root.left)</li></ul>\r<ul><li>Bước 3: Duyệt cây con bên phải, gọi InOrder(root.right)</li></ul>\r<ul><li>Code Java:</li></ul>\r\n``<code>java\r\n// Print preorder traversal of given tree.\r\nvoid printPreorderTraversal(Node root) \r\n{ \r\n    if (root == null) \r\n        return; \r\n    //first print the data of node\r\n    System.out.print(root.data + &quot; &quot;); \r\n\r\n    //then traverse to the left subtree\r\n    printPreorderTraversal(root.left);                    \r\n\r\n    //then traverse to the right subtree\r\n    printPreorderTraversal(root.right); \r\n}\r\n</code>``\r<ul><li>Dùng: Để tạo bản sao cây, và cũng được sử dụng để lấy biểu thức tiền tố của cây biểu thức.</li></ul>\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Duyệt hậu thứ tự:",
              "answer": "<p><ul><li>Thuật toán:</li></ul>\r<ul><li>Bước 1: Duyệt cây con bên trái, gọi InOrder(root.left)</li></ul>\r<ul><li>Bước 2: Duyệt cây con bên phải, gọi InOrder(root.right)</li></ul>\r<ul><li>Bước 3: Duyệt root</li></ul>\r<ul><li>Code Java:</li></ul>\r\n``<code>java\r\n// Print postorder traversal of given tree.\r\nvoid printPostorderTraversal(Node root) \r\n{ \r\n    if (root == null) \r\n        return; \r\n\r\n    //first traverse to the left subtree\r\n    printPostorderTraversal(root.left);                    \r\n\r\n    //then traverse to the right subtree\r\n    printPostorderTraversal(root.right); \r\n\r\n    //then print the data of node\r\n    System.out.print(root.data + &quot; &quot;); \r\n}\r\n</code>``\r<ul><li>Dùng: Dùng để xoá cây và cũng được sử dụng để lấy biểu thức hậu tố của cây biểu thức.</li></ul>\r\n\r\nVí dụ: ta có cây nhị phân như sau:\r\n\r\n<img src=\"/interview-assets/postorder-traversal.png\" alt=\"\" />\r<ul><li>Duyệt trung thứ tự => Left, Root, Right : [4, 2, 5, 1, 3]</li></ul>\r<ul><li>Duyệt tiền thứ tự => Root, Left, Right : [1, 2, 4, 5, 3]</li></ul>\r<ul><li>Duyệt hậu thứ tự => Left, Right, Root : [4, 5, 2, 3, 1]</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cây tìm kiếm nhị phân là gì?",
              "answer": "<p>Cây tìm kiếm nhị phân (BST) là một biến thể của cấu trúc dữ liệu cây nhị phân, lưu trữ dữ liệu một cách hiệu quả, trong đó các giá trị của các nút trong cây con bên trái nhỏ hơn giá trị của nút gốc và giá trị của các nút bên phải cao hơn nút gốc.\r\n\r\nNgoài ra, từng cây con bên trái và bên phải cũng phải đảm bảo tính chất trên trong mọi trường hợp.\r\n\r\n<img src=\"/interview-assets/binary-search-tree.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Cây AVL là gì?",
              "answer": "<p>Cây AVL là cây cân bằng. Cây AVL kiểm tra chiều cao của cây con bên trái và bên phải và đảm bảo rằng sự khác biệt không quá 1. Sự khác biệt này được gọi là Hệ số Cân bằng và được tính bằng: <code>BalanceFactor = chiều cao (cây con bên trái) - chiều cao (cây con bên phải)</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "In chế độ xem bên trái của bất kỳ cây nhị phân nào",
              "answer": "<p>Ý tưởng chính để giải quyết vấn đề này là duyệt cây theo tiền thứ tự và truyền thông tin về cấp bậc cùng với nó. Nếu cấp được truy cập lần đầu tiên, thì chúng ta lưu trữ thông tin của nút hiện tại và cấp hiện tại trong hashmap. Về cơ bản, thì ta đang có được chế độ xem bên trái bằng cách quan sát đến nút đầu tiên của mọi cấp độ.\r\nKhi kết thúc quá trình duyệt, chúng ta có thể tìm ra giải pháp bằng cách duyệt qua map.\r\n\r\nHãy xem xét cây sau đây làm ví dụ để tìm chế độ xem bên trái:\r\n\r\n<img src=\"/interview-assets/left-view-binary-tree.png\" alt=\"\" />\r\n\r\nCode Java:\r\n\r\n``<code>java\r\nimport java.util.HashMap;\r\n\r\n//to store a Binary Tree node\r\nclass Node\r\n{\r\n    int data;\r\n    Node left = null, right = null;\r\n\r\n    Node(int data) {\r\n        this.data = data;\r\n    }\r\n}\r\npublic class InterviewBit\r\n{\r\n    // traverse nodes in pre-order way\r\n    public static void leftViewUtil(Node root, int level, HashMap&lt;Integer, Integer&gt; map)\r\n    {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n\r\n        // if you are visiting the level for the first time\r\n        // insert the current node and level info to the map\r\n        if (!map.containsKey(level)) {\r\n            map.put(level, root.data);\r\n        }\r\n\r\n        leftViewUtil(root.left, level + 1, map);\r\n        leftViewUtil(root.right, level + 1, map);\r\n    }\r\n\r\n    // to print left view of binary tree\r\n    public static void leftView(Node root)\r\n    {\r\n        // create an empty HashMap to store first node of each level\r\n        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\r\n\r\n        // traverse the tree and find out the first nodes of each level\r\n        leftViewUtil(root, 1, map);\r\n\r\n        // iterate through the HashMap and print the left view\r\n        for (int i = 0; i &lt;map.size(); i++) {\r\n            System.out.print(map.get(i) + &quot; &quot;);\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args)\r\n    {\r\n        Node root = new Node(4);\r\n        root.left = new Node(2);\r\n        root.right = new Node(6);\r\n        root.left.left = new Node(1);\r\n        root.left.left = new Node(3);\r\n        root.right.left = new Node(5);\r\n        root.right.right = new Node(7);\r\n        root.right.left.left = new Node(9);\r\n\r\n        leftView(root);\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cấu trúc dữ liệu đồ thị là gì?",
              "answer": "<p>Đồ thị là một loại cấu trúc dữ liệu phi tuyến tính bao gồm các đỉnh hoặc nút được kết nối bằng các cạnh hoặc liên kết để lưu trữ dữ liệu. Đồ thị có thể là có hướng hoặc vô hướng.\r\n\r\n<img src=\"/interview-assets/graph-data-structure.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Ứng dụng của đồ thị?",
              "answer": "<p>Đồ thị được sử dụng trong nhiều ứng dụng khác nhau. Một số trong số chúng như sau:\r<ul><li>Đồ thị mạng xã hội để xác định luồng thông tin trong các trang web mạng xã hội như facebook, linkedin, v.v.</li></ul>\r<ul><li>Đồ thị mạng neural trong đó các nút đại diện cho các neuron và cạnh biểu thị các khớp thần kinh giữa chúng.</li></ul>\r<ul><li>Lưới giao thông trong đó các trạm là các nút và các tuyến là các cạnh của đồ thị.</li></ul>\r<ul><li>Đồ thị tiện ích điện hoặc nước trong đó các đỉnh là điểm kết nối và cạnh là dây hoặc đường ống kết nối chúng.</li></ul>\r<ul><li>Thuật toán tìm đường đi ngắn nhất giữa hai điểm.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để biểu diễn đồ thị?",
              "answer": "<p>Ta có hai cách để biểu diễn đồ thị:\r<ul><li>Ma trận : Được sử dụng để biểu diễn dữ liệu tuần tự</li></ul>\r\n\r\n<img src=\"/interview-assets/adjacency-matrix.png\" alt=\"\" />\r<ul><li>Danh sách: Sử dụng để biểu diễn dữ liệu được liên kết</li></ul>\r\n\r\n<img src=\"/interview-assets/adjacency-list.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa cấu trúc dữ liệu cây và đồ thị",
              "answer": "<p>Cây và đồ thị được phân biệt bởi cấu trúc cây phải được kết nối và không bao giờ có thể có vòng lặp (chu trình) trong khi trong đồ thị không có hạn chế đó.\r\n\r\nCây cung cấp thông tin chi tiết về mối quan hệ giữa các nút theo hệ thống phân cấp còn đồ thị tuân theo mô hình mạng.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa BFS (Breadth First Search) và DFS (Delth First Search)",
              "answer": "<p>| BFS | DFS |\r\n|-----|-----|\r\n| Breadth First Search | Depth First Search |\r\n| Sử dụng hàng đợi | Sử dụng Ngăn xếp |\r\n| Có thể được dùng để tìm đường đi ngắn nhất trong một đồ thị không trọng số, bởi vì trong BFS, ta có thể đến một đỉnh có số cạnh tối thiểu từ một đỉnh nguồn | Ta có thể đi qua nhiều cạnh hơn để đến một đỉnh đích từ một nguồn |\r\n| Phù hợp để tìm kiếm các đỉnh gần với nguồn | Phù hợp khi có các giải pháp xa nguồn |\r\n| Xem xét tất cả đỉnh lân cận do đó không thích hợp sử dụng trong trò chơi hay câu đố | Phù hợp cho vấn đề câu đố và trò chơi. Ta đưa ra quyết định sau đó khám phá tất cả đường đi thông qua quyết định này |\r\n| Độ phức tạp thời gian O(V+E) khi dùng danh sách liền kề và O(V^2) khi dùng ma trận liền kề, trong đÓ V là đỉnh và E là cạnh | Độ phức tạp thời gian O(V+E) khi dùng danh sách liền kề và O(V^2) khi dùng ma trận liền kề, trong đÓ V là đỉnh và E là cạnh |\r\n| Đến định liền kề trước khi đến đỉnh con | Đến đỉnh con trước khi đến đỉnh liền kề |</p>",
              "level": "fresher"
            },
            {
              "question": "Khi nào sử dụng DFS tốt hơn BFS?",
              "answer": "<p>Việc sử dụng DFS hay BFS phụ thuộc nhiều vào cấu trúc của cây/đồ thị tìm kiếm, số lượng và vị trí của các giải pháp cần thiết:\r<ul><li>Nếu biết rằng giải pháp nằm gần gốc, thì BFS có thể tốt hơn.</li></ul>\r<ul><li>Nếu cây rất sâu và hiếm giải pháp, DFS sẽ mất rất nhiều thời gian, và BFS có thể nhanh hơn.</li></ul>\r<ul><li>Nếu cây rất rộng, BFS có thể cần quá nhiều bộ nhớ, vì vậy nó có thể hoàn toàn không thực tế. Ta DFS trong những trường hợp như vậy.</li></ul>\r<ul><li>Nếu có nhiều giải pháp nhưng nằm sâu trong cây, nên chọn DFS.</li></ul>\r<ul><li>Nếu cây rất sâu, ta sẽ cần hạn chế tìm kiếm với DFS.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sắp xếp tô pô trong đồ thị là gì?",
              "answer": "<p><ul><li>Sắp xếp tô pô của một đồ thị có hướng là một thứ tự sắp xếp của các đỉnh sao cho với mọi cung từ đỉnh <code>i</code> đến đỉnh <code>j</code> trong đồ thị, <code>i</code> luôn nằm trước <code>j</code>.</li></ul>\r<ul><li>Sắp xếp tô pô chỉ khả dụng với Đồ thị có hướng không tuần hoàn (DAG).</li></ul>\r<ul><li>Các ứng dụng:</li></ul>\r\n    1. Lập kế hoạch công việc từ các phụ thuộc đã cho giữa các công việc.\r\n    2. Thứ tự đánh giá ô công thức trong bảng tính\r\n    3. Thứ tự các nhiệm vụ biên dịch được thực hiện trong tạo file,\r\n    4. Tuần tự hóa dữ liệu\r\n    5. Giải quyết sự phụ thuộc ký hiệu trong trình liên kết.\r\n\r\nCode sắp xếp cấu trúc tô pô trong Java:\r\n\r\n``<code>java\r\n    // V - total vertices\r\n    // visited - boolean array to keep track of visited nodes\r\n    // graph - adjacency list.\r\n    // Main Topological Sort Function. \r\n    void topologicalSort() \r\n    { \r\n        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); \r\n  \r\n        // Mark all the vertices as not visited \r\n        boolean visited[] = new boolean[V]; \r\n        for (int j = 0; j &lt; V; j++){ \r\n            visited[j] = false; \r\n        }\r\n        // Call the util function starting from all vertices one by one \r\n        for (int i = 0; i &lt; V; i++) \r\n            if (visited[i] == false) \r\n                topologicalSortUtil(i, visited, stack); \r\n  \r\n        // Print contents of stack -&gt; result of topological sort\r\n        while (stack.empty() == false) \r\n            System.out.print(stack.pop() + &quot; &quot;); \r\n    } \r\n    \r\n    // A helper function used by topologicalSort\r\n    void topologicalSortUtil(int v, boolean visited[], \r\n                             Stack&lt;Integer&gt; stack) \r\n    { \r\n        // Mark the current node as visited. \r\n        visited[v] = true; \r\n        Integer i; \r\n  \r\n        // Recur for all the vertices adjacent to the current vertex \r\n        Iterator&lt;Integer&gt; it = graph.get(v).iterator(); \r\n        while (it.hasNext()) { \r\n            i = it.next(); \r\n            if (!visited[i]) \r\n                topologicalSortUtil(i, visited, stack); \r\n        } \r\n  \r\n        // Push current vertex to stack that saves result \r\n        stack.push(new Integer(v)); \r\n    } \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cho một bản đồ lưới 2D, m x n trong đó giá trị \"1\" đại diện cho đất và \"0\" đại diện cho nước, trả về số lượng các hòn đảo (được bao quanh bởi nước và được hình thành bằng cách kết nối các vùng đất liền kề theo 2 hướng - theo chiều dọc hoặc chiều ngang). Giả sử rằng các trường hợp ranh giới - tức là tất cả bốn cạnh của lưới đều được bao quanh bởi nước.",
              "answer": "<p>Các hạn chế:\r\n\r\n``<code>\r\nm == grid.length\r\nn == grid[i].length\r\n1 &lt;= m, n &lt;= 300\r\n</code>`<code>\r\n\r\nGiá trị của grid[i][j] có thể là </code>0<code> hoặc </code>1<code>.\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\ngrid = [\r\n    [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;0&quot;],\r\n    [&quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;],\r\n    [&quot;0&quot;, &quot;0&quot;, &quot;1&quot;, &quot;0&quot;, &quot;1&quot;],\r\n    [&quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;1&quot;, &quot;1&quot;],\r\n]\r\n</code>`<code>\r\n\r\nOutput: 3\r\n\r\nCode giải quyết trong Java:\r\n</code>`<code>java\r\nclass InterviewBit {\r\n    public int numberOfIslands(char[][] grid) {\r\n        if(grid==null || grid.length==0||grid[0].length==0)\r\n            return 0;\r\n\r\n        int m = grid.length;\r\n        int n = grid[0].length;\r\n\r\n        int count=0;\r\n        for(int i=0; i&lt;m; i++){\r\n            for(int j=0; j&lt;n; j++){\r\n                if(grid[i][j]==&#39;1&#39;){\r\n                    count++;\r\n                    mergeIslands(grid, i, j);\r\n                }\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    public void mergeIslands(char[][] grid, int i, int j){\r\n        int m=grid.length;\r\n        int n=grid[0].length;\r\n\r\n        if(i&lt;0||i&gt;=m||j&lt;0||j&gt;=n||grid[i][j]!=&#39;1&#39;)\r\n            return;\r\n\r\n        grid[i][j]=&#39;X&#39;;\r\n\r\n        mergeIslands(grid, i-1, j);\r\n        mergeIslands(grid, i+1, j);\r\n        mergeIslands(grid, i, j-1);\r\n        mergeIslands(grid, i, j+1);\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cấu trúc dữ liệu heap là gì?",
              "answer": "<p>Heap là một cấu trúc dữ liệu phi tuyến tính dựa trên một cây nhị phân hoàn chỉnh. Một cây nhị phân được cho là hoàn chỉnh nếu tất cả các cấp được lấp đầy hoàn toàn ngoại trừ cấp cuối cùng và cấp cuối cùng có tất cả các phần tử hướng về bên trái càng nhiều càng tốt. Các heap có hai loại:\r\n\r\n1. Max-Heap:\r<ul><li>Trong một Max-Heap, phần tử dữ liệu hiện diện ở nút gốc phải lớn nhất trong số tất cả các phần tử dữ liệu có trong cây.</li></ul>\r<ul><li>Thuộc tính này phải đúng một cách đệ quy cho tất cả các cây con của cây nhị phân đó.</li></ul>\r\n\r\n2. Min-Heap:\r<ul><li>Trong một Min-Heap, phần tử dữ liệu hiện diện ở nút gốc phải là nhỏ nhất trong số tất cả các phần tử dữ liệu có trong cây.</li></ul>\r<ul><li>Thuộc tính này phải đúng một cách đệ quy cho tất cả các cây con của cây nhị phân đó</li></ul></p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "design-patterns",
          "name": "Câu hỏi phỏng vấn về Design Pattern",
          "description": "",
          "questions": [
            {
              "question": "Design pattern là gì?",
              "answer": "<p>Design pattern là các giải pháp có thể tái sử dụng để giải quyết các vấn đề chung của phát triển phần mềm. Những vấn đề này bao gồm code lặp lại, các chức năng và logic dư thừa, v.v. Những vấn đề này giúp tiết kiệm đáng kể công sức và thời gian cần thiết cho các dev trong khi phát triển phần mềm. Các design pattern thường được sử dụng trong các sản phẩm phần mềm hướng đối tượng bằng cách kết hợp các phương pháp hay nhất và thúc đẩy khả năng tái sử dụng để phát triển mã mạnh mẽ. \r\n\r\n<img src=\"/interview-assets/What_are_design_patterns.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern trong Java?",
              "answer": "<p>Trong java, các pattern rất linh hoạt và dễ dàng xác định code lặp lại không mong muốn. Kiến trúc phần mềm có thể tuỳ chỉnh theo từng yêu cầu. Một vài lợi ích của sử dụng design pattern trong Java:\r<ul><li>Có thể tái sử dụng cho nhiều dự án.</li></ul>\r<ul><li>Cung cấp giải pháp mẫu cho thiết kế kiến trúc hệ thống.</li></ul>\r<ul><li>Chúng cung cấp sự minh bạch cho thiết kế phần mềm.</li></ul>\r<ul><li>Chúng là những giải pháp đã được thử nghiệm và chứng minh để phát triển phần mềm mạnh mẽ một cách dễ dàng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả một design pattern như thế nào?",
              "answer": "<p><ul><li>Xác định tên và nhóm của design pattern sẽ thuộc về.</li></ul>\r<ul><li>Mô tả vấn đề và giải pháp phù hợp.</li></ul>\r<ul><li>Tìm các biến thể và lựa chọn ngôn ngữ cho vấn đề cần giải quyết.</li></ul>\r<ul><li>Các trường hợp thời gian thực và hiệu quả của pattern này.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu design pattern?",
              "answer": "<p><ul><li><strong>Creational Pattern</strong> cung cấp các cơ chế tạo đối tượng để tăng tính linh hoạt và tái sử dụng code hiện có.</li></ul>\r<ul><li>Factory Method</li></ul>\r<ul><li>Abstract Factory</li></ul>\r<ul><li>Builder</li></ul>\r<ul><li>Prototype</li></ul>\r<ul><li>Singleton</li></ul>\r<ul><li><strong>Structural Pattern</strong> giải thích cách tập hợp các đối tượng và lớp thành các cấu trúc lớn hơn, trong khi vẫn giữ cho cấu trúc linh hoạt và hiệu quả.</li></ul>\r<ul><li>Adapter</li></ul>\r<ul><li>Bridge</li></ul>\r<ul><li>Composite</li></ul>\r<ul><li>Decorator</li></ul>\r<ul><li>Facade</li></ul>\r<ul><li>Flyweight</li></ul>\r<ul><li>Proxy</li></ul>\r<ul><li><strong>Behavioral Pattern</strong> quan tâm đến việc giao tiếp hiệu quả và phân công nhiệm vụ giữa các đối tượng.</li></ul>\r<ul><li>Chain Of Responsibility</li></ul>\r<ul><li>Command</li></ul>\r<ul><li>Iterator</li></ul>\r<ul><li>Mediator</li></ul>\r<ul><li>Memento</li></ul>\r<ul><li>Observer</li></ul>\r<ul><li>State</li></ul>\r<ul><li>Strategy</li></ul>\r<ul><li>Template Method</li></ul>\r<ul><li>Visitor</li></ul>\r\n\r\n<img src=\"/interview-assets/types_of_design_patterns_in_java.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Inversion of Control là gì?",
              "answer": "<p><strong>Inversion of Control (IoC)</strong> là một nguyên lý thiết kế trong công nghệ phần mềm trong đó các thành phần nó dựa vào để làm việc bị đảo ngược quyền điều khiển khi so sánh với lập trình hướng thủ thục truyền thống.\r\n\r\nDependency injection (DI) là một mô hình triển khai từ nguyên lý IoC, là một kỹ thuật trong lập trình trong đó một đối tượng cung cấp những phụ thuộc (dependency - là đối tượng, dịch vụ, chức năng) của đối tượng khác.\r\n\r\nVí dụ: ta có lớp <code>A</code> sử dụng lớp <code>B</code> như bên dưới:\r\n\r\n``<code>java\r\npublic class A{\r\n    private B b;\r\n    \r\n    public A(){\r\n        this.b = new B();\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nỞ đây, ta có phụ thuộc giữa lớp A và B. Nếu bạn triển khai IoC, bạn sẽ không phải dùng toán tử </code>new<code> để gán giá trị. \r\n\r\n</code>`<code>java\r\npublic class A {\r\n    private IocB b;\r\n    public A(IocB b) {\r\n        this.b = b;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nChúng ta đã dùng IoC cho việc khởi tạo đối tượng của lớp </code>B<code> cho lớp </code>IocB`.</p>",
              "level": "fresher"
            },
            {
              "question": "GoF là gì?",
              "answer": "<p><strong>Gang of Four</strong> (GOF) là 4 người đã phát minh ra khái niệm design pattern. Họ là Erich Gamma, Ralph Johnson, Richard Hel and John Vlissides. Những người này đã viết về các design pattern trong quyển sách \"Design Patterns: Elements of Reusable Object-Oriented Software\" năm 1995. Nếu không có họ, các nhà phát triển phần mềm sẽ lãng phí thời gian giải quyết các vấn đề có tính chất lặp lại thay vì tập trung vào các yêu cầu nghiệp vụ.</p>",
              "level": "fresher"
            },
            {
              "question": "Các nguyên tắc SOLID là gì?",
              "answer": "<p>Nguyên tắc SOLID là các nguyên tắc hướng đối tượng được Robert C. Martin giới thiệu trong bài báo cáo \"Design Principles and Design patterns\" năm 2000. \r\n\r\n<img src=\"/interview-assets/SOLID_principles.png\" alt=\"\" />\r<ul><li><strong>S - Single Responsibility Principle (SRP):</strong> nguyên tắc trách nhiệm đơn nhất đảm bảo tất cả lớp hay module chỉ chịu trách nhiệm cho một chức năng duy nhất. </li></ul>\r<ul><li><strong>O - Open Closed Principle (OCP):</strong> nguyên tắc đóng mở cho phép tất cả lớp đều mở cho bổ sung nhưng đóng cho chỉnh sửa. Ở đây ta cho phép mở rộng hành vi các thực thể nhưng không được chỉnh sửa code đã tồn tại.</li></ul>\r<ul><li><strong>L - Liskov Substitution Principle(LSP):</strong> nguyên tắc Liskoy nói rằng trạng thái của đối tượng có thể thay thế bằng các thể hiện con mà không ảnh hưởng đến tính đúng đắn của chương trình.</li></ul>\r<ul><li><strong>I - Interface Segregation Principle (ISP):</strong> nguyên tắc phân tách interface nêu rõ rằng có thể sử dụng nhiều interface cụ thể cho các yêu cầu của client thay vì interface chung. Client không bị buộc phải thực hiện các chức năng mà họ không yêu cầu</li></ul>\r<ul><li><strong>D - Dependency Inversion Principle:</strong> ở đây các module ở level cao nên độc lập với các module level thấp. Các module cao được xem là trừu tượng và module thấp là những triển khai cụ thể.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu nguyên tắc đóng mở như thế nào?",
              "answer": "<p>Nguyên tắc Đóng mở quy định rằng bất kỳ lớp, thành phần hoặc thực thể nào phải mở để mở rộng nhưng đóng để sửa đổi. Một lớp có thể được mở rộng thông qua kế thừa, interface, hay composition bất cứ khi nào nhận được yêu cầu mới thay vì sửa đổi code của lớp. Hãy xem xét một trường hợp trong đó chúng ta có một lớp tính diện tích của một hình vuông. Sau đó, ta nhận được yêu cầu tính diện tích hình chữ nhật. Ở đây, thay vì sửa đổi lớp ban đầu, chúng ta có thể tạo một lớp cơ sở và lớp cơ sở này có thể được mở rộng bằng lớp hình chữ nhật mới.</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern trong thư viện JDK của Java?",
              "answer": "<p><em> <strong>Decorator pattern</strong> được dùng cho các lớp <code>Wrapper</code>.\r\n</em> <strong>Singleton pattern</strong> được dùng cho các lớp <code>Calendar</code> và <code>Runtime</code>.\r\n<em> <strong>Factory pattern</strong> được dùng cho các phương thức như <code>Integer.valueOf</code> trong các lớp <code>wrapper</code>.\r\n</em> <strong>Observer pattern</strong> được dùng cho xử lý sự kiện framework như <code>awt</code>, <code>swing</code>,...</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern và design principles khác nhau như thế nào?",
              "answer": "<p><strong>Design principles (Nguyên tắc thiết kế):</strong> là những nguyên tắc được tuân theo trong khi thiết kế hệ thống phần mềm cho bất kỳ nền tảng nào hay phải sử dụng bất kỳ ngôn ngữ lập trình nào. Các nguyên tắc SOLID là các nguyên tắc thiết kế mà chúng ta tuân theo để phát triển các hệ thống phần mềm mạnh mẽ, có thể dễ dàng mở rộng. Những điều này áp dụng cho tất cả các khía cạnh của lập trình.\r\n\r\n<strong>Design pattern (Mẫu thiết kế):</strong> là các giải pháp mẫu có thể tái sử dụng cho các vấn đề thường xảy ra có thể được tùy chỉnh theo yêu cầu của vấn đề. Đây là những giải pháp đã được thực hiện tốt, được thử nghiệm đúng cách và an toàn khi sử dụng. Mô hình thiết kế Factory, mô hình Singleton, mô hình Strategy là một vài trong số các ví dụ về các mẫu thiết kế.</p>",
              "level": "fresher"
            },
            {
              "question": "Các design pattern khác các thuật toán như thế nào?",
              "answer": "<p>Cả design pattern và thuật toán đều mô tả các giải pháp điển hình cho bất kỳ vấn đề nào đã cho. Nhưng sự khác biệt chính là thuật toán xác định một tập hợp các hành động rõ ràng để đạt được mục tiêu còn design pattern cung cấp mô tả cấp cao về bất kỳ giải pháp nào. Các design pattern áp dụng cho hai vấn đề khác nhau có thể giống nhau nhưng logic thực hiện sẽ khác nhau dựa trên các yêu cầu.\r\n\r\n## Câu hỏi phỏng vấn design pattern cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Factory là gì?",
              "answer": "<p>Factory thuộc nhóm design pattern creational. Ở đây các đối tượng được tạo mà không để lộ logic của việc tạo ra cho client. Bởi vì các đối tượng tham chiếu đến interface chung.\r\n\r\nVí dụ: Ta có 3 lớp <code>Square</code>, <code>Triangle</code> và <code>Rectangle</code>. Ta sẽ sử dụng design pattern factory cho tạo đối tượng từ 3 lớp mà không để lộ logic tạo bằng cách dùng lớp <code>ShapeFactory</code>. Lớp <code>Driver</code> sẽ truyền thông tin như RECTANGLE/SQUARE/TRIANGLE đến đối tượng cần thiết. Sơ đồ UML cho trường hợp này:\r\n\r\n<img src=\"/interview-assets/Factory_Design_Pattern.png\" alt=\"\" />\r\n\r\nBây giờ ta triển khai code cho ví dụ trên:\r\n\r\n<strong>Bước 1:</strong> Tạo interface Shape\r\n\r\n``<code>java\r\n//Shape.java\r\npublic interface Shape {\r\n    void draw();\r\n}\r\n</code>`<code>\r\n\r\n<strong>Bước 2:</strong> Tạo lớp cụ thể Rectangle, Square, Triangle sử dụng triển khai interface Shape.\r\n\r\n</code>`<code>java\r\n//Rectangle.java\r\npublic class Rectangle implements Shape {\r\n    @Override\r\n    public void draw() {\r\n        System.out.println(&quot;Rectangle Drawn&quot;);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//Square.java\r\npublic class Square implements Shape {\r\n    @Override\r\n    public void draw() {\r\n        System.out.println(&quot;Square Drawn&quot;);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//Triangle.java\r\npublic class Triangle implements Shape {\r\n    @Override\r\n    public void draw() {\r\n        System.out.println(&quot;Triangle Drawn&quot;);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>Bước 3:</strong> Tạo lớp ShapeFactory và tạo một phương thức gọi là </code>getShapeInstance()<code> cho tạo đối tượng ở lớp cụ thể:\r\n\r\n</code>`<code>java\r\n//ShapeFactory.java\r\npublic class ShapeFactory {\r\n    //the method will be used to get object of required shape\r\n    public Shape getShapeInstance(String type){\r\n        if(type == null){\r\n            return null;\r\n        } \r\n        if(type.equalsIgnoreCase(&quot;TRIANGLE&quot;)){\r\n            return new Triangle();\r\n        } else if(type.equalsIgnoreCase(&quot;SQUARE&quot;)){\r\n            return new Square();\r\n        } else if(type.equalsIgnoreCase(&quot;RECTANGLE&quot;)){\r\n            return new Rectangle();\r\n        }\r\n        return null;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>Bước 4:</strong> Triển khai lớp Driver và sử dụng lớp factory để lấy đối tượng của kiểu được yêu cầu.\r\n\r\n</code>`<code>java\r\n//Driver.java\r\npublic class Driver {\r\n    public static void main(String[] args) {\r\n        ShapeFactory shapeFactory = new ShapeFactory();\r\n        //get Triangle object and call draw()\r\n        Shape triangle = shapeFactory.getShape(&quot;Triangle&quot;);\r\n        triangle.draw();\r\n        //get Rectangle object and call draw()\r\n        Shape rectangle = shapeFactory.getShape(&quot;RECTANGLE&quot;);\r\n        rectangle.draw();\r\n        //get Square object and call draw()\r\n        Shape square = shapeFactory.getShape(&quot;SQUARE&quot;);\r\n        square.draw();\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>Bước 5:</strong> Xem kết quả\r\n\r\n</code>`<code>text\r\nTriangle Drawn\r\nRectangle Drawn\r\nSquare Drawn\r\n</code>``\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Adapter là gì?",
              "answer": "<p>Thuộc nhóm design pattern structural để các đối tượng không tương thích cộng tác với nhau. Nó hành động như một wrapper giữa hai đối tượng khác nhau. Adapter nhận cuộc gọi từ một đối tượng và biến đổi chúng để đối tượng thứ hai có thể nhận.\r\n\r\nĐể dễ hiểu ta lấy ví dụ về bộ chuyển đổi từ USB sang Ethernet. Khi ta có một đầu là ethernet và đầu kia là USB, hai đầu này không tương thích nhau nên ta cần có một bộ chuyển đổi. Lớp <code>Client</code> sẽ mong đợi một số kiểu đối tượng và nó có lớp <code>Adaptee</code> có thể cung cấp tính năng tương tư nhưng bằng một interface khác. Bây giờ để cả hai giao tiếp, chúng ta có một lớp <code>Adapter</code>, <code>Client</code> yêu cầu <code>Adapter</code> sử dụng interface <code>Target</code>. Lớp <code>Adapter</code> dịch yêu cầu bằng interface <code>Adaptee</code>. <code>Client</code> nhận được kết quả mà không biết về vai trò của bộ chuyển đổi. Ta có sơ đồ lớp như bên dưới.\r\n\r\n<img src=\"/interview-assets/Class_Diagram.png\" alt=\"\" />\r\n\r\nBây giờ ta xem xét một interface <code>MediaPlayer</code> được triển khai bởi lớp <code>AudioPlayer</code>. <code>AudioPlayer</code> có thể chạy bài hát định dạng mp3. Mặt khác interface <code>AdvancedPlayer</code> được triển khai bởi lớp <code>MP4Player</code> có thể chạy định dạng mp4 và <code>WAVPlayer</code> chạy định dạng wav. Nếu ta muốn <code>AudioPlayer</code> chạy tất cả định dạng, ta phải sử dụng <code>MediaAdapter</code> để triển khai <code>MediaPlayer</code> và sử dụng đối tượng <code>AdavancedPlayer</code> cho các định dạng cần thiết. Code cho trường hợp này như sau:\r\n\r\n``<code>java\r\n//MediaPlayer.java\r\npublic interface MediaPlayer {\r\n    public void play(String format, String file);\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//AdvancedPlayer.java\r\npublic interface AdvancedPlayer { \r\n    public void playMp4(String file);\r\n    public void playWav(String file);\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//Mp4Player.java\r\npublic class Mp4Player implements AdvancedPlayer{\r\n    @Override\r\n    public void playMp4(String file) {\r\n        System.out.println(&quot;MP4 File &quot;+ file + &quot; Playing....&quot;);  \r\n    }\r\n    \r\n    @Override\r\n    public void playWav(String file) {\r\n        //do nothing\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//WAVPlayer.java\r\npublic class WAVPlayer implements AdvancedPlayer{\r\n    @Override\r\n    public void playMp4(String file) {\r\n        //do nothing\r\n    }\r\n    \r\n    @Override\r\n    public void playWav(String file) {\r\n        System.out.println(&quot;WAV File &quot;+ file + &quot; Playing....&quot;);  \r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//MediaAdapter.java\r\npublic class MediaAdapter implements MediaPlayer {\r\n    AdvancedPlayer advancedPlayer;\r\n    public MediaAdapter(String format){\r\n        if(format.equalsIgnoreCase(&quot;mp4&quot;) ){\r\n            advancedPlayer = new Mp4Player();   \r\n        }else if(format.equalsIgnoreCase(&quot;wav&quot;) ){\r\n            advancedPlayer = new WAVPlayer();   \r\n        }\r\n    }\r\n    @Override\r\n    public void play(String format, String file) {\r\n    \r\n        if(format.equalsIgnoreCase(&quot;mp4&quot;)){\r\n            advancedPlayer.playMp4(file);\r\n        }\r\n        else if(format.equalsIgnoreCase(&quot;wav&quot;)){\r\n            advancedPlayer.playWav(file);\r\n        }\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//AudioPlayer.java\r\npublic class AudioPlayer implements MediaPlayer {\r\n    MediaAdapter mediaAdapter;\r\n    @Override\r\n    public void play(String format, String file) {  \r\n        //inbuilt support to play mp3 music files\r\n        if(format.equalsIgnoreCase(&quot;mp3&quot;)){\r\n            System.out.println(&quot;MP3 file &quot; + file +&quot; Playing...&quot;);   \r\n        } \r\n        //Make use of Adapter to support different formats\r\n        else if(format.equalsIgnoreCase(&quot;wav&quot;) || format.equalsIgnoreCase(&quot;mp4&quot;)){\r\n            mediaAdapter = new MediaAdapter(format);\r\n            mediaAdapter.play(format, file);\r\n        }\r\n        else{\r\n            System.out.println(&quot;Format not supported&quot;);\r\n        }\r\n    }   \r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//Driver.java\r\npublic class Driver {\r\n    public static void main(String[] args) {\r\n        AudioPlayer audioPlayer = new AudioPlayer();\r\n        audioPlayer.play(&quot;mp3&quot;, &quot;music1.mp3&quot;);\r\n        audioPlayer.play(&quot;wav&quot;, &quot;music2.wav&quot;);\r\n        audioPlayer.play(&quot;mp4&quot;, &quot;music3.mp4&quot;);\r\n        audioPlayer.play(&quot;avi&quot;, &quot;music4.avi&quot;);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nVà đây là kết quả:\r\n\r\n</code>`<code>text\r\nMP3 file music1.mp3 Playing...\r\nWAV File music2.wav Playing...\r\nMP4 File music3.mp4 Playing...\r\nFormat not supported\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Proxy là gì?",
              "answer": "<p>Proxy thuộc nhóm structural, dùng ddeer biểu diễn một chức năng cho các lớp khác. Pattern này cho phép chúng ta tạo một vật thay thế cho một đối tượng khác, vật này được gọi là đối tượng proxy. Giúp kiểm soát quyền truy cập vào đối tượng ban đầu và cho phép thực hiện nhiều tác vụ trước hoặc sau khi yêu cầu đến đối tượng ban đầu.\r\n\r\n<img src=\"/interview-assets/Proxy_Design_Pattern.png\" alt=\"\" />\r\n\r\nNhư hình ở trên, ta có interface <code>ServiceInterface</code> cho các thao tác. Interface này được triển khai bởi lớp <code>Service</code> và <code>Proxy</code>. Lớp <code>Service</code> chứa logic nghiệp vụ hữu ích và lớp <code>Proxy</code> chứa tham chiếu trỏ đến đối tượng <code>service</code>. Sau khi proxy hoàn thành quá trình lazy initialization, logging, caching,.. yêu cầu sẽ được truyền đến đối tượng service. Và cuối cùng, ta có client làm việc với service và proxy bằng cách dùng interface.</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Bridge là gì?",
              "answer": "<p>Cũng thuộc nhóm structural design pattern giúp chia một lớp lớn thành một 2 hệ thống phân cấp lớp - trừu tượng và triển khai. Các hệ thống phân cấp này là độc lập và được dùng bất cứ khi nào cần tách sự trừu tượng khỏi triển khai. Điều này gọi là Bridge pattern bởi vì nó hành động như một cây cầu giữa lớp trừu tường và lớp triển khai. Trong pattern này, lớp trừu tượng và lớp triển khai có thể được chỉnh sửa độc lập mà không ảnh hưởng lẫn nhau.\r\n\r\n<img src=\"/interview-assets/Bridge_design_pattern.png\" alt=\"\" />\r\n\r\nTrong hình trên ta có 4 thành phần chính trong pattern này là:\r<ul><li><strong>Abstraction</strong> – Đây là cốt lỗi của pattern, nó bao gồm một tham chiếu đến cho Implementer.</li></ul>\r<ul><li><strong>Refined Abstraction</strong> – là mở rộng của abstraction nó lấy chi tiết yêu cầu và ẩn chúng với implementers.</li></ul>\r<ul><li><strong>Implementer</strong> – là interface cho các lớp implementation.</li></ul>\r<ul><li><strong>Concrete Implementation</strong> – Đây là các lớp triển khai cụ thể triển khai interface Implementer.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Một số trường hợp mà chúng ta thích các lớp trừu tượng hơn các interface trong Java?",
              "answer": "<p>Cả lớp trừu tượng và interface trong Java đều tuân theo nguyên tắc code cho interface thay vì implementation. Nguyên tắc này đảm bảo rằng tính linh hoạt được thêm vào code để giải quyết các yêu cầu động. Một số gợi ý để quyết định nên thích cái nào hơn:\r<ul><li>Java chỉ cho phép mở rộng một lớp và triển khai nhiều interface. Nếu chúng ta mở rộng một lớp thì ta không thể mở rộng các lớp khác. Trong trường hợp này, tốt hơn là triển khai interface ở bất cứ nơi đâu có thể và chỉ kế thừa các lớp cho những lớp quan trọng.</li></ul>\r<ul><li>Interface được dùng để biểu diễn hành vi của lớp. Java cho phép triển khai nhiều interface đó là lý do tại sao ta có thể dùng interface để giúp lớp có nhiều hành vi cùng lúc.</li></ul>\r<ul><li>Lớp trừu tượng nhanh hơn interface. Chúng có thể dùng cho các ứng dụng xem trọng thời gian.</li></ul>\r<ul><li>Trong trường hợp có các hành vi chung trên hệ thống phân cấp kế thừa, chúng có thể được mã hóa tại một nơi trong các lớp trừu tượng. Interface và lớp trừu tượng cũng có thể được sử dụng cùng nhau để định nghĩa một hàm trong interface và một chức năng trong lớp trừu tượng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Chain of Responsibility là gì? Trong trường hợp nào thì áp dụng pattern này?",
              "answer": "<p>Chain of Responsibility thuộc nhóm behavioural design pattern để truyền yêu cầu theo một chuỗi xử lý. Bất cứ khi nào nhận được yêu cầu, trình xử lý quyết định xử lý yêu cầu hay truyền nó cho trình xử lý kế tiếp trong chuỗi. Nó được dùng để kết nối mềm trong đó yêu cầu của client được chuyển qua một chuỗi đối tượng xử lý.\r\n\r\n<img src=\"/interview-assets/Chain_of_Responsibility_pattern.png\" alt=\"\" />\r\n\r\nTrong ảnh trên nó có 3 thành phần chính là:\r<ul><li><strong>Client</strong>: điểm gửi yêu cầu gốc và thành phần truy cập trình xử lý để xử lý yêu cầu.</li></ul>\r<ul><li><strong>Handler</strong>: có thể là lớp hay interface để nhận yêu cầu và gửi nó đến chuỗi xử lý. Handler này được biết như là trình xử lý đầu tiên trong chuỗi.</li></ul>\r<ul><li><strong>Concrete Handlers</strong>: là những trình xử lý yêu cầu thực tế theo thứ tự tuần tự.</li></ul>\r\n\r\nỨng dụng của CoR:\r<ul><li>Bất cứ khi nào ta muốn tách người gửi và người nhận yêu cầu.</li></ul>\r<ul><li>Bất cứ khi nào ta muốn nhiều đối tượng xử lý một yêu cầu trong thời gian chạy.</li></ul>\r<ul><li>Bất cứ khi nào ta không muốn chỉ định rõ ràng các trình xử lý trong mã.</li></ul>\r<ul><li>Bất cứ khi nào ta muốn đưa ra một yêu cầu đến một số đối tượng mà không chỉ định rõ ràng các trình xử lý.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Design Pattern Decorator là gì?",
              "answer": "<p>Thuộc nhóm structural design pattern cho phép người dùng thêm tính năng vào đối tượng đã tồn tại mà không phải chỉnh sửa cấu trúc của nó. Pattern này tạo một lớp gọi là decorator hành động như một <em>wrapper</em>, bọc đối tượng đã tồn tại bằng cách giữ nguyên đặc trưng của các phương thức lớp. Pattern này sử dụng lớp trừu tượng và itnerface với composition để triển khai wrapper. Chúng chủ yếu được sử dụng để áp dụng SRP (Nguyên tắc Trách nhiệm Đơn lẻ) khi ya phân chia các chức năng thành các lớp với các mối quan tâm duy nhất. Pattern này có cấu trúc tương tự như CoR ở trên. Các bước triển khai decorator:\r<ul><li>Tạo một interface và lớp cụ thể triển khai interface này.</li></ul>\r<ul><li>Tạo lớp trừu tượng decorator để triển khai interface trên.</li></ul>\r<ul><li>Tạo lớp decorator cụ thể mở rộng từ lớp trừu tượng ở trên.</li></ul>\r<ul><li>Sử dụng lớp decorator cụ thể để thêm tính năng cho đối tượng interface và xác minh kết quả.</li></ul>\r\n\r\nTa làm thử ví dụ để dễ hiểu. Ở đây ta tạo interface <code>Shape</code> và các lớp cụ thể của nó <code>Rectangle</code> và <code>Triangle</code> để triển khai interface này. Ta sẽ tạo lớp trừu tượng là <code>ShapeDecorator</code> để triển khai interface <code>Shape</code>. Sau đó ta tạo <code>RedColorDecorator</code> mở rộng từ <code>ShapeDecorator</code>. Ta sẽ sử dụng decorator này cho các triển khai tính năng.\r\n\r\n<img src=\"/interview-assets/Decorator_Design_Pattern.png\" alt=\"\" />\r<ul><li>Tạo interface Shape:</li></ul>\r\n\r\n``<code>java\r\n// Shape.java\r\npublic interface Shape {\r\n    void draw();\r\n}\r\n</code>`<code>\r<ul><li>Tạo lớp cụ thể Rectangle và Triangle để triển khai interface trên</li></ul>\r\n\r\n</code>`<code>java\r\n// Rectangle.java\r\npublic class Rectangle implements Shape {\r\n    // Overriding the draw method\r\n    @Override public void draw()\r\n    {\r\n        System.out.println(&quot;Rectangle Drawn...&quot;);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n// Triangle.java\r\npublic class Triangle implements Shape {\r\n    // Overriding the draw method\r\n    @Override public void draw()\r\n    {\r\n        System.out.println(&quot;Triangle Drawn...&quot;);\r\n    }\r\n}\r\n</code>`<code>\r<ul><li>Tạo lớp trừu tượng ShapeDecorator triển khai interface Shape:</li></ul>\r\n\r\n</code>`<code>java\r\n// ShapeDecorator.java\r\npublic abstract class ShapeDecorator implements Shape {\r\n    protected Shape shapeDecorated;\r\n    public ShapeDecorator(Shape shapeDecorated)\r\n    {\r\n        this.shapeDecorated = shapeDecorated;\r\n    }\r\n    public void draw() { \r\n        shapeDecorated.draw(); \r\n    }\r\n}\r\n</code>`<code>\r<ul><li>Tạo RedColorDecorator mở rộng rừ lớp ShapeDecorator:</li></ul>\r\n\r\n</code>`<code>java\r\n// RedColorDecorator.java\r\npublic class RedColorDecorator extends ShapeDecorator {\r\n    public RedColorDecorator(Shape shapeDecorated)\r\n    {\r\n        super(shapeDecorated);\r\n    }\r\n    @Override \r\n    public void draw()\r\n    {\r\n        shapeDecorated.draw();\r\n        setRedBorder(shapeDecorated);\r\n    }\r\n    private void setRedBorder(Shape shapeDecorated)\r\n    {\r\n        System.out.println(&quot;Red color border added...&quot;);\r\n    }\r\n}\r\n</code>`<code>\r<ul><li>Triển khai lớp Driver cho demo:</li></ul>\r\n\r\n</code>`<code>java\r\n// Driver.java\r\npublic class Driver {\r\n    // Main driver method\r\n    public static void main(String[] args)\r\n    {\r\n    \r\n        Shape triangle = new Triangle();\r\n        Shape redTriangle\r\n            = new RedColorDecorator(new Triangle());\r\n        Shape redRectangle = new RedColorDecorator(new Rectangle());\r\n        // Draw normal triangle\r\n        triangle.draw();\r\n        System.out.println(&quot;.........&quot;);\r\n        // make the triangle red\r\n        redTriangle.draw();\r\n        System.out.println(&quot;.........&quot;);\r\n        // make the rectangle red\r\n        redRectangle.draw();\r\n        System.out.println(&quot;.........&quot;);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nXác minh kết quả ở output:\r\n\r\n</code>`<code>text\r\n  Triangle Drawn...\r\n   .........\r\n   Triangle Drawn...\r\n   Red color border added...\r\n   .........\r\n   Rectangle Drawn...\r\n   Red color border added...\r\n   .........\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Command là gì?",
              "answer": "<p>Thuộc nhóm behavioural design pattern dùng để truyền đổi một yêu cầu thành một đối tượng độc lập bao gồm các chi tiết của yêu cầu đó. Pattern này là một data-driven pattern vì ta sử dụng thông tin về yêu cầu bằng cách bọc nó dưới dạng một đối tượng và chuyển đến đối tượng invoker dưới dạng một command. Đối tượng invoker kiểm tra đối tượng có thể xử lý command và truyền cho nó để thực thi.\r\n\r\n<img src=\"/interview-assets/Command_pattern.png\" alt=\"\" />\r\n\r\nTa thấy client gọi đến invoker để thực thi command. Ta có interface Command hành động như một sự trừu tượng hóa đối với các lớp cụ thể bên dưới.\r\n\r\nLấy ví dụ với điều khiển từ xa chỉ có một nút bấm. Sử dụng nút này ta sẽ điều khiển hành vi của hai đối tượng là radio và tubelight. Lệnh điều khiển sẽ được triển khai bằng cách dùng command pattern.\r<ul><li>Tạo interface Command:</li></ul>\r\n\r\n``<code>java\r\n// Command Interface\r\ninterface Command\r\n{\r\n    public void execute();\r\n}\r\n</code>`<code>\r<ul><li>Tạo lớp tubelight và lớp commands của nó được mở rộng từ interface trên.</li></ul>\r\n\r\n</code>`<code>java\r\n// Tubelight class\r\nclass TubeLight\r\n{\r\n    public void lightOn(){\r\n        System.out.println(&quot;TubeLight on...&quot;);\r\n    }\r\n    public void lightOff(){\r\n        System.out.println(&quot;TubeLight off...&quot;);\r\n    }\r\n}\r\n// Command class to turn on the tubelight\r\nclass TubeLightOnCommand implements Command\r\n{\r\n    TubeLight tubeLight;\r\n    // The constructor is passed the light it\r\n    // is going to control.\r\n    public TubeLightOnCommand(TubeLight tubeLight){\r\n        this.tubeLight = tubeLight;\r\n    }\r\n    public void execute(){\r\n        tubeLight.lightOn();\r\n    }\r\n}\r\n// Command class to turn off the tubelight\r\nclass TubeLightOffCommand implements Command\r\n{\r\n    TubeLight tubeLight;\r\n    public TubeLightOffCommand(TubeLight tubeLight) {\r\n        this.tubeLight = tubeLight;\r\n    }\r\n    public void execute() {\r\n        tubeLight.lightOff();\r\n    }\r\n}\r\n</code>`<code>\r<ul><li>Tạo lớp Radio tương tự</li></ul>\r\n\r\n</code>`<code>java\r\n// Radio class\r\nclass Radio\r\n{\r\n    public void radioOn()\r\n    {\r\n        System.out.println(&quot;Radio on ...&quot;);\r\n    }\r\n    public void radioOff()\r\n    {\r\n        System.out.println(&quot;Radio off...&quot;);\r\n    }\r\n    public void setVolume(int volumeLevel)\r\n    {\r\n        // code to set the volume\r\n        System.out.println(&quot;Radio volume set to &quot; + volumeLevel);\r\n    }\r\n}\r\n// Command class to turn on the radio\r\nclass RadioOnCommand implements Command\r\n{\r\n    Radio radio;\r\n    public RadioOnCommand(Radio radio)\r\n    {\r\n        this.radio = radio;\r\n    }\r\n    public void execute()\r\n    {\r\n        radio.radioOn();\r\n    }\r\n}\r\n// Command class to set the volume of the radio\r\nclass RadioVolumeCommand implements Command\r\n{\r\n    Radio radio;\r\n    int volumeLevel;\r\n    public RadioVolumeCommand(Radio radio, int volumeLevel)\r\n    {\r\n        this.radio = radio;\r\n        this.volumeLevel=volumeLevel;\r\n    }\r\n    public void execute()\r\n    {\r\n        radio.setVolume(volumeLevel);\r\n    }\r\n}\r\n</code>`<code>\r<ul><li>Tạo lớp RemoteControl chỉ có một nút và khi click thực thi chức năng ấy.</li></ul>\r\n\r\n</code>`<code>java\r\n// remote control with one button \r\nclass RemoteControl{\r\n    Command button; // only one button\r\n    public RemoteControl(){}\r\n    public void setCommand(Command command){\r\n        // set the command the remote will\r\n        // execute\r\n        button = command;\r\n    }\r\n    public void pressButton(){\r\n        // execute the command on click (call) of the button\r\n        button.execute();\r\n    }\r\n}\r\n</code>`<code>\r<ul><li>Tạo lớp Driver triển khai pattern. Ở đây, đầu tiên chúng ta sẽ bật tubelight bằng lần click đầu tiên của nút, ở lần click tiếp theo, chúng ta sẽ bật radio, sau đó chúng ta sẽ đặt âm lượng của radio thành 4 và sau đó chúng ta sẽ tubelight.</li></ul>\r\n\r\n</code>`<code>java\r\n// Driver class\r\npublic class Driver\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n            RemoteControl remote = new RemoteControl();\r\n            TubeLight tubeLight = new TubeLight();\r\n            Radio radio = new Radio();\r\n            // Turn on Tubelight\r\n            remote.setCommand(new TubeLightOnCommand(tubeLight));\r\n            remote.pressButton();\r\n            //Turn on Radio\r\n            remote.setCommand(new RadioOnCommand(radio));\r\n            remote.pressButton();\r\n            //Turn off Radio\r\n            remote.setCommand(new RadioVolumeCommand(radio,4));\r\n            remote.pressButton();\r\n            // Turn off Tubelight\r\n            remote.setCommand(new TubeLightOffCommand(tubeLight));\r\n            remote.pressButton();\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>text\r\nTubeLight on...\r\nRadio on ...\r\nRadio volume set to 4\r\nTubeLight off...\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Observer là gì?",
              "answer": "<p>Observer thuộc nhóm behavioural design pattern được dùng cho xác định một hay nhiều phụ thuộc giữa các đối tượng. Nó hữu ích khi bạn muốn thông báo bất kỳ thay đổi nào trong trạng thái đối tượng. Trong pattern này, khi trạng thái của một đối tượng thay đổi, tất cả đối tượng phụ thuộc sẽ nhận được thông báo tự động. Đối tượng có trạng thái được quan tâm gọi là Subject trong khi các phụ thuộc gọi là OBservers. Trong java ta có thể triển khai pattern này bằng cách dùng lớp <code>java.util.Observable</code> và interface <code>java.util.Observer</code>. \r\n\r\n<img src=\"/interview-assets/Observer_design_pattern.png\" alt=\"\" />\r\n\r\n3 thành phần chính:\r<ul><li><strong>Subject</strong> - có thể là interface hoặc lớp trừu tượng định nghĩa các hoạt động cho gắn (<code>registerObserver()</code>) và tách observers (<code>removeObserver()</code>) từ subject.</li></ul>\r<ul><li><strong>Concrete Subject</strong> - là lớp cụ thể của Subject. Nó duy trì trạng thái đối tượng và bất cứ khi nào xảy ra thay đổi trạng thái, observer sẽ được thông báo bằng cách dùng phương thức <code>notifyObservers()</code>.</li></ul>\r<ul><li><strong>Observer</strong> - là interface hoặc lớp trừu tượng xác định hoạt động để thông báo cho đối tượng này (<code>update()</code>)</li></ul>\r\n\r\nVí dụ thực tế của pattern này là Facebook hay Twitter, mỗi khi ai đó cập nhật trạng thái, tất cả follower sẽ nhận được thông báo.</p>",
              "level": "fresher"
            },
            {
              "question": "Vấn đề mà pattern Builder giải quyết là gì?",
              "answer": "<p>Builder thuộc nhóm creatonal design pattern giúp xây dựng một đối tượng phức tạp theo từng bước. Pattern cho phép tạo các biểu diễn khác nhau của đối tượng trên cùng logic khởi tạo. Nó giúp tạp các lớp bất biến có một tập hợp thuộc tính rất lớn. Ở các design pattern như Factory và Abstract Factory, ta gặp phải các vấn đề sau nếu đối tượng chứa rất nhiều thuộc tính:\r<ul><li>Khi lượng tham số ở hàm khởi tạo là quá lớn, chương trình sẽ gặp lỗi khi chuyển từ client và lớp factory theo một thứ tự cụ thế. Sẽ trở nên khó khi duy trì thứ tự của các tham số có kiểu giống hệt nhau.</li></ul>\r<ul><li>Có một số thuộc tính là tuỳ chọn nhưng ta buộc phải gửi tất cả và để chúng ở dạng null.</li></ul>\r<ul><li>Khi việc tạo đối tượng trở nên phức tạp do có nhiều thuộc tính, độ phức tạp của lớp sẽ trở nên khó hiểu.</li></ul>\r\n\r\nCác vấn đề trên có thể giải quyết bằng cách sử dụng constructor với một tham số yêu cầu. Nhưng điều này lại gây ra vấn đề khi các tham số mới được thêm vào như một phần của yêu cầu mới. Nó sẽ dẫn đến mẫu thuẫn, đó là lúc cần đến Bulder.\r\n\r\nPattern này giải quyết vấn đề về một số lượng lớn các thuộc tính tùy chọn và trạng thái không nhất quán bằng cách cung cấp cách xây dựng một đối tượng theo từng bước và trả về đối tượng cuối cùng bằng cách sử dụng một phương thức khác.\r\n\r\nCác bước thực hiện:\r<ul><li>Tạo một lớp tĩnh lồng nhau, sao chép tất cả tham số từ lớp bên ngoài. Lớp lồng này được gọi là builder.</li></ul>\r<ul><li>Quy ước đặt tên phải tuân theo khi đặt tên cho lớp builder này. Ví dụ nếu tên lớp là <code>Interview</code> thì tên của builder sẽ là <code>InterverBuilder</code>.</li></ul>\r<ul><li>Lớp builder phải có một hàm khởi tạo công khai vói tất cả thuộc tính là tham số.</li></ul>\r<ul><li>Lớp builder nên có phương thức để thiết lập các tham số tùy chọn và trả về cùng một đối tượng builder khi thiết lập các giá trị này.</li></ul>\r<ul><li>Cuối cùng là một phương thức <code>build()</code> trong lớp builder trả về đối tượng mà client cần. Điều này yêu cầu một constructor riêng tư trong lớp lấy builder làm tham số.</li></ul>\r\n\r\nSau đây là ví dụ về triển khai builder. Ta có lớp <code>User</code> và ta sẽ xây dựng lớp <code>UserBuilder</code> để tạo đối tượng cho lớp <code>User</code>.\r\n\r\n``<code>java\r\nclass User \r\n{\r\n    //All final attributes\r\n    private final String firstName; // required\r\n    private final String lastName; // required\r\n    private final int age; // required\r\n    private final String phoneNbr; // optional\r\n    private final String address; // optional\r\n    private final String nationality; //optional\r\n\r\n    private User(UserBuilder builder) {\r\n        this.firstName = builder.firstName;\r\n        this.lastName = builder.lastName;\r\n        this.age = builder.age;\r\n        this.phoneNbr = builder.phoneNbr;\r\n        this.address = builder.address;\r\n        this.nationality = builder.nationality;\r\n    }\r\n\r\n    //Setters are not provided to make it immutable\r\n    public String getFirstName() {\r\n        return firstName;\r\n    }\r\n    public String getLastName() {\r\n        return lastName;\r\n    }\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n    public String getPhoneNbr() {\r\n        return phoneNbr;\r\n    }\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n    public String getNationality() {\r\n        return nationality;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return &quot;User: &quot;+this.firstName+&quot; &quot;+this.lastName+&quot;, &quot;+this.age+&quot;, &quot;+this.nationality+&quot;, &quot;+this.phoneNbr+&quot;, &quot;+this.address;\r\n    }\r\n\r\n    public static class UserBuilder \r\n    {\r\n        private final String firstName;\r\n        private final String lastName;\r\n        private int age;\r\n        private String phoneNbr;\r\n        private String address;\r\n        private String nationality;\r\n\r\n        public UserBuilder(String firstName, String lastName) {\r\n            this.firstName = firstName;\r\n            this.lastName = lastName;\r\n        }\r\n        public UserBuilder age(int age) {\r\n            this.age = age;\r\n            return this;\r\n        }\r\n        public UserBuilder phoneNbr(String phoneNbr) {\r\n            this.phoneNbr = phoneNbr;\r\n            return this;\r\n        }\r\n        public UserBuilder address(String address) {\r\n            this.address = address;\r\n            return this;\r\n        }\r\n        public UserBuilder nationality(String nationality) {\r\n            this.nationality = nationality;\r\n            return this;\r\n        }\r\n        // method to return the constructed object\r\n        public User build() {\r\n            User user =  new User(this);\r\n            validateUserObject(user);\r\n            return user;\r\n        }\r\n        private void validateUserObject(User user) {\r\n            //Validate of the object does not break anything\r\n        }\r\n    }\r\n}\r\npublic class Driver{\r\n    public static void main(String[] args) {\r\n        User firstUser = new User.UserBuilder(&quot;Harry&quot;, &quot;Potter&quot;)\r\n        .age(30)\r\n        .phoneNbr(&quot;1234567&quot;)\r\n        .address(&quot;221B Baker Street - London&quot;)\r\n        .build();\r\n        \r\n        System.out.println(firstUser);\r\n        \r\n        User secondUser = new User.UserBuilder(&quot;Ron&quot;, &quot;Weasley&quot;)\r\n        .age(32)\r\n        .phoneNbr(&quot;5655&quot;)\r\n        //no address\r\n        .build();\r\n        \r\n        System.out.println(secondUser);\r\n        \r\n        User thirdUser = new User.UserBuilder(&quot;Hermoine&quot;, &quot;Granger&quot;).age(20).nationality(&quot;English&quot;)\r\n        //No age\r\n        //No phone\r\n        //no address\r\n        .build();\r\n        \r\n        System.out.println(thirdUser);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>text\r\nUser: Harry Potter, 30, null, 1234567, 221B Baker Street - London\r\nUser: Ron Weasley, 32, null, 5655, null\r\nUser: Hermoine Granger, 20, English, null, null\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hãy xem xét tình huống mà bạn đang viết các lớp để cung cấp dữ liệu thị trường và đột nhiên ta chuyển sang nhà cung cấp khác hoặc là chuyến hướng đến Direct Exchange Feed. Bạn sẽ tiếp cận vấn đề này như thế nào để thiết kế hệ thống?",
              "answer": "<p>Ta có thể làm bằng cách dùng một interface là <code>MarketData</code> sẽ bao gồm các phương thức mà khách hàng yêu cầu. <code>MarketData</code> nên có một <code>MarketDataProvider</code> làm phần phụ thuộc bằng cách sử dụng Dependency Injection. Điều này đảm bảo rằng ngay cả khi nhà cung cấp thay đổi, dữ liệu thị trường sẽ không bị ảnh hưởng.</p>",
              "level": "fresher"
            },
            {
              "question": "Null Object pattern là gì?",
              "answer": "<p>Trong pattern này, một đối tượng null được sử dụng để thay thế việc kiểm tra xác thực một thực thể đối tượng là null hay không. Đối tượng Null này có mối quan hệ “không làm gì cả” và chúng có thể được sử dụng để cung cấp hành vi mặc định nếu dữ liệu không có sẵn.</p>",
              "level": "fresher"
            },
            {
              "question": "MVC là gì?",
              "answer": "<p>MVC là viết tắt của Model-View-Controller. Pattern này tách ứng dụng thành ba phần:\r<ul><li>Model - Biểu diễn đối tượng của dữ liệu. Nó cũng bao gồm logic cho cập nhật controller khi dữ liệu thay đổi.</li></ul>\r<ul><li>View - Biểu diễn trực quan của dữ liệu ở model.</li></ul>\r<ul><li>Controller - Đây là interface giữa Model và View bằng cách điều khiển luồng dữ liệu trong model và cập nhật view bất cứ khi nào model thay đổi. Nó đảm bảo rằng model và view độc lập.</li></ul>\r\n\r\n<img src=\"/interview-assets/MVC_design_pattern.png\" alt=\"\" />\r\n\r\nẢnh trên đại diện cho luồng yêu cầu xảy ra trong MVC. Đầu tiên, trình duyệt (client) gửi yêu cầu đến một trang cho controller của server. Controlelr gọi model lấy dữ liệu và gửi phản hồi. Phản hồi sau đó được gửi đến view để hiển thị. Chế độ view sẽ gửi đến client để hiển thị.</p>",
              "level": "fresher"
            },
            {
              "question": "Các thành phần trong Composite Entity?",
              "answer": "<p>Composite Entity là một pattern thiết kế phần mềm Java EE, nó được dùng để mô hình hoá, biểu diễn và quản lý một tập hợp các đối tượng liên tục có liên quan với nhau thay vì biểu diễn chúng dưới dạng các hạt thực thể chi tiết riêng lẻ và còn một hạt thực thể composite biểu thị một đồ thị của các đối tượng.\r\n\r\nComposite Entity Pattern đại diện cho một biểu đồ của các đối tượng. Khi được cập nhật, nó sẽ cập nhật cho tất cả các đối tượng có trong biểu đồ đó. Nó chủ yêu được sử dụng trong Enterprise JavaBeans (EJB).\r\n\r\nCó 4 thành phần chính trong Composite Entity là:\r<ul><li><strong>Composite Entity</strong> - Hạt thực thể chính có thể có một đối tượng hạt thô để tồn tại lâu dài.</li></ul>\r<ul><li><strong>Coarse-Grained Object</strong> - chứa các đối tượng phụ thuộc với vòng đời của chúng và lần lượt quản lý vòng đời của các đối tượng phụ thuộc.</li></ul>\r<ul><li><strong>Dependent Object</strong> - Đối tượng này phụ thuộc vào đối tượng thô trong suốt vòng đời tồn tại.</li></ul>\r<ul><li><strong>Strategies</strong> - đại diện cho cách triển khai thực thể composite.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Lợi thế của dùng prototype so với dùng toán tử new là gì?",
              "answer": "<p>Design pattern Prototype được sử dụng để tạo các đối tượng trùng lặp dựa trên prototype của đối tượng đã có bằng cách sử dụng nhân bản. Việc làm này có tác động tích cực đến hiệu suất tạo đối tượng. Việc tạo các đối tượng bằng cách sử dụng từ khóa <code>new</code> đòi hỏi nhiều tài nguyên và là một quá trình nặng nề ảnh hưởng đến hiệu suất. Do đó, prototype có lợi hơn so với đối tượng được tạo bằng từ khóa <code>new</code> về hiệu suất.</p>",
              "level": "fresher"
            },
            {
              "question": "Thread-safe với Singleton trong Java?",
              "answer": "<p>Một lớp thread-safe singleton được tạo để giúp khởi tạo đối tượng trong môi trường đa luồng. Nó có thể thực hiện bằng nhiều cách:\r<ul><li><strong>Sử dụng Enum:</strong> Enum là cách đơn giản nhất để tạo một lớp thread-safe singleton trong Java vì nó hỗ trợ đồng bộ do chính Java thực hiện. </li></ul>\r\n\r\n``<code>java\r\npublic enum ThreadSafeSingleton{\r\n    SINGLETON<em>INSTANCE;\r\n    public void display(){\r\n        System.out.println(&quot;Thread-safe singleton Display&quot;);\r\n    }\r\n}\r\n// The Singleton class methods can be invoked as below\r\nThreadSafeSingleton.SINGLETON</em>INSTANCE.show();\r\n</code>`<code>\r<ul><li><strong>Sử dụng trường static:</strong> Thread-safe singleton còn có thể được tạo bằng cách tạo thực thể tại thời điểm tải lớp. Điều này được thực hiện bằng cách sử dụng trường static vì Classloader đảm bảo rằng các thực thể được khởi tạo trong quá trình tải lớp sẽ không hiển thị cho đến khi nó được tạo đầy đủ. </li></ul>\r\n\r\n</code>`<code>java\r\npublic class ThreadSafeSingleton{\r\n    private static final ThreadSafeSingleton INSTANCE = new ThreadSafeSingleton();\r\n    private ThreadSafeSingleton(){ }\r\n    public static ThreadSafeSingleton getInstance(){\r\n        return INSTANCE;\r\n    }\r\n    public void display(){\r\n        System.out.println(&quot;Thread-safe Singleon&quot;);\r\n    }\r\n}\r\nThreadSafeSingleton.getInstance().display();\r\n</code>`<code>\r\n\r\nNhưng nhược điểm của cách này là việc khởi tạo không thể thực hiện theo cách lazy và phương thức </code>getInstance()<code> được gọi trước khi bất kỳ client nào có thể gọi.\r<ul><li><strong>Sử dụng từ khoá synchronized:</strong> Ta có thể dùng từ khoá synchronized trên phương thức </code>getInstance()<code> như bên dưới:</li></ul>\r<ul><li>Trong cách này, ta có thể thực hiện lazy initialization, và vì ta dùng từ khoá synchronized nên đối tượng được khởi tạo là thread-safe.</li></ul>\r<ul><li>Vấn đề duy nhất là toàn bộ phương thức này điều là đồng bộ, hiệu suất sẽ bị ảnh hưởng khi có đa luồng.</li></ul>\r\n\r\n</code>`<code>java\r\npublic class ThreadSafeSingleton\r\n{\r\n    // Creating private instance to make it accessible only by getInstance() method\r\n    private static ThreadSafeSingleton instance;\r\n    private ThreadSafeSingleton()\r\n    {\r\n    // Making constructor private so that objects cant be initialized outside the class\r\n    }\r\n    //synchronized getInstance method\r\n    synchronized public static ThreadSafeSingleton getInstance(){\r\n    if (this.instance == null)\r\n    {\r\n        // if instance is null, initialize\r\n        this.instance = new ThreadSafeSingleton();\r\n    }\r\n    return this.instance;\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Double-check locking:</strong> Ở đây, chúng ta sẽ sử dụng một khối code synchronized  trong phương thức </code>getInstance<code> thay vì làm cho toàn bộ phương thức. Điều này đảm bảo rằng chỉ một số ít luồng phải chờ lần đầu tiên do đó không ảnh hưởng đến hiệu suất.</li></ul>\r\n\r\n</code>`<code>java\r\npublic class ThreadSafeSingleton {\r\n    // Creating private instance to make it accessible only by getInstance() method\r\n    private static ThreadSafeSingleton instance;\r\n    private ThreadSafeSingleton(){\r\n    // Making constructor private so that objects cant be initialized outside the class\r\n    }\r\n    public static ThreadSafeSingleton getInstance(){\r\n    if (instance == null){\r\n        //synchronized block of code\r\n        synchronized (ThreadSafeSingleton.class){\r\n        if(instance==null)\r\n        {\r\n            // initialize only if instance is null\r\n            instance = new ThreadSafeSingleton();\r\n        }\r\n        }\r\n    }\r\n    return instance;\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Điều gì sẽ xảy ra nếu chúng ta không có một phương thức synchronized để trả về thực thể Singleton trong môi trường đa luồng?",
              "answer": "<p>Trong môi trường đa luồng, nếu chúng ta có một phương thức không được đồng bộ hóa để trả về các trường hợp, thì có khả năng phương thức đó có thể tạo nhiều hơn một đối tượng. Hãy xem xét rằng chúng ta có 2 luồng và cả hai đều nhập điều kiện để kiểm tra xem thực thể đã tồn tại hay chưa. Cả hai luồng sẽ thấy rằng thực thể chưa được tạo và do đó cả hai sẽ tạo các thực thể lớp. Điều này đi ngược lại nguyên tắc của pattern Singleton. Do đó, trong môi trường đa luồng, nên sử dụng kiểm tra đồng bộ.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "network",
          "name": "Mạng máy tính",
          "description": "",
          "questions": [
            {
              "question": "Mạng máy tính được phân loại như thế nào?",
              "answer": "<p>Các loại mạng có thể được phân loại và phân chia dựa trên khu vực phân bố của chúng. Sơ đồ dưới đây sẽ giúp hiểu nhanh hơn:\r\n\r\n<img src=\"/interview-assets/Network_Types.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về các loại mạng?",
              "answer": "<p>| Loại | Mô tả |\r\n|------|-------|\r\n| PAN (Personal Area Network) | Các thiết bị kết nối và giao tiếp trong phạm vi người dùng (như kết nối bluetooth) |\r\n| LAN (Local Area Network) | Mạng thuộc sở hữu tư nhân như trong một văn phòng, nhà máy,...\r\n| MAN (Metropolotan Area Network) | Được kết nối trên khu vực toàn thành phố vd như hệ thống TV cable |\r\n| WAN (Wide Area Network) | Nó trải dài trên một khu vực địa lý rộng lớn, thường là một quốc gia hoặc lục địa. Internet là mạng WAN lớn nhất |\r\n| GAN (Global Area Network) | Còn được gọi là internet, kết nối toàn cầu thông qua vệ tinh. |</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về LAN?",
              "answer": "<p>Mạng LAN được sử dụng rộng rãi để kết nối máy tính/laptop và thiết bị điện tử tiêu dùng cho phép chúng chia sẻ tài nguyên (ví dụ: máy in, máy fax) và trao đổi thông tin. Khi mạng LAN được sử dụng bởi các công ty hoặc tổ chức, chúng được gọi là mạng doanh nghiệp. Có hai loại mạng LAN khác nhau, tức là mạng LAN không dây (không có dây, khi sử dụng Wi-Fi) và mạng LAN có dây (sử dụng bằng cáp LAN). Ngày nay, mạng LAN không dây rất phổ biến ở những nơi khó lắp đặt dây. Các sơ đồ dưới đây giải thích cả mạng LAN không dây và có dây.\r\n\r\n<img src=\"/interview-assets/LAN_(Local_Area_Network).png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "VPN là gì?",
              "answer": "<p>VPN hay Virtual Private Network là một mạng WAN riêng tư được xây dựng trên internet. Nó cho phép tạo một đường hầm bảo mật (secured tunnel) giữa hai mạng khác nhau sử dụng internet. Bằng cách dùng VPN, một client có thể kết nối từ xa tới mạng của tổ chức. So đồ dưới đây cho thấy một mạng WAN của tổ chức ở Úc sử dụng VPN:\r\n\r\n<img src=\"/interview-assets/VPN_(Virtual_Private_Network).png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Lợi ích của VPN?",
              "answer": "<p><ul><li>VPN được sử dụng để kết nối từ xa các văn phòng ở các vị trí địa lý khác nhau, nó rẻ hơn khi so sánh với kết nối WAN.</li></ul>\r<ul><li>VPN được sử dụng cho các giao dịch an toàn và truyền dữ liệu bí mật giữa nhiều văn phòng đặt tại các vị trí địa lý khác nhau.</li></ul>\r<ul><li>VPN giữ cho thông tin của tổ chức được bảo mật trước mọi mối đe dọa hoặc sự xâm nhập tiềm ẩn bằng cách sử dụng ảo hóa.</li></ul>\r<ul><li>VPN mã hóa lưu lượng truy cập internet và che giấu danh tính trực tuyến.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các loại VPN khác nhau?",
              "answer": "<p><ul><li><strong>Access VPN</strong> được dùng để cung cấp kết nối cho người dùng di động từ xa và thiết bị viễn thông. Nó phục vụ như một sự thay thế cho kết nối dial-up hay ISDN (Integrated Services Digital Network). Nó là một giải pháp chi phí thấp và cung cấp một loạt kết nối.</li></ul>\r<ul><li><strong>Site-to-Site VPN</strong> hay Router-to-Router VPN thường được dùng bởi các công ty lớn có các chi nhánh ở các địa điểm khác nhau để kết nối mạng cho các văn phòng ở các địa điểm khác nhau. Nó có hai kiểu phụ là:</li></ul>\r<ul><li><strong>Intranet VPN</strong>: hữu ích khi kết nối các văn phòng từ xa trên các khu vực địa lý khác nhau bằng cơ sở hạ tầng chung (kết nối internet và server) với các chnh sách hỗ trợ như mạng WAN riêng tư.</li></ul>\r<ul><li><strong>Extranet VPN</strong> sử dụng cơ sở hạ tầng chung qua mạng intranet, nhà cung cấp, khách hàng, đối tác, các thực thể khác và các kết nối đến chúng bằng kết nối chuyên dụng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Nodes và links là gì?",
              "answer": "<p><strong>Node</strong> tạm dịch là nút, bất kỳ thiết bị giao tiếp nào trong mạng đều được gọi là nút. Một nút là một điểm giao nhau trong mạng. Nó có thể gửi/nhận dữ liệu và thông tin trong mạng. Ví dụ một nút có thể là máy tính, laptop, máy in, máy fax,...\r\n\r\n<strong>Link</strong> tạm dịch là liên kết, đề cập đến khả năng kết nối giữa hai nút trong mạng. Nó bao gồm kiểu kết nối không dây và có dây giữa các nút và giao thức được sử dụng để chúng có thể giao tiếp lẫn nhau.\r\n\r\n<img src=\"/interview-assets/Nodes_and_Links.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Cấu trúc liên kết mạng là gì?",
              "answer": "<p>Cấu trúc liên kết mạng là một bố trí vật lý của mạng, kết nối các nút khác nhau bằng các liên kết. Nó mô tả kết nối giữa các máy tính, thiết bị, cáp, v.v.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu cấu trúc liên kết mạng khác nhau?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Địa chỉ IPv4 là gì? Các lớp của IPv4?",
              "answer": "<p>Một địa chỉ IP là địa chỉ 32-bit của một nút trong mạng. Một địa chỉ IPv4 có 4 octet, mỗi octet là 8-bit với mỗi số có giá trị lên đến 255.\r\n\r\nCác lớp IPv4 được phân biệt dựa trên số lượng máy chủ mà nó hỗ trợ trên mạng. Có năm loại lớp IPv4 và dựa trên octet đầu tiên của địa chỉ IP được phân loại là Lớp A, B, C, D hoặc E.\r\n\r\n| Lớp IPv4 | Địa chỉ bắt đầu | Địa chỉ kết thúc | Sử dụng |\r\n|----------|-----------------|------------------|---------|\r\n| A | 0.0.0.0 | 127.255.255.255 | Dùng cho mạng lớn |\r\n| B | 128.0.0.0 | 191.255.255.255 | Dùng cho mạng cỡ vừa |\r\n| C | 192.0.0.0 | 223.255.255.255 | Dùng cho mạng LAN |\r\n| D | 224.0.0.0 | 239.255.255.255 | Dành riêng cho nhiều người |\r\n| E | 240.0.0.0 | 255.255.255.254 | Nghiên cứu và R&D |</p>",
              "level": "fresher"
            },
            {
              "question": "Địa chỉ IP riêng tư và đặc biệt?",
              "answer": "<p><strong>Địa chỉ riêng tư:</strong> Đối với mỗi lớp, có các IP cụ thể được dành riêng cho mục đích sử dụng riêng. Không thể sử dụng địa chỉ IP này cho các thiết bị trên Internet vì chúng không thể định tuyến được.\r\n\r\n| Lớp IPv4 | Địa chỉ bắt đầu | Địa chỉ kết thúc |\r\n|----------|-----------------|------------------|\r\n| A | 10.0.0.0 | 10.255.255.255 |\r\n| B | 172.16.0.0 | 172.31.255.255 |\r\n| B | 192.168.0.0 | 192.168.255.255 |\r\n\r\n<strong>Địa chỉ đặc biệt:</strong> Dải IP từ 127.0.0.1 đến 127.255.255.255 là địa chỉ kiểm tra mạng còn được gọi là địa chỉ loopback hay địa chỉ IP đặc biệt.\r\n\r\n## Câu hỏi phỏng vấn mạng máy tính cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả mô hình OSI?",
              "answer": "<p><strong>Open System Interconnections (OSI)</strong> là kiến trúc mạng dựa trên chuẩn ISO. Được gọi là mô hình OSI, nó giải quyết việc kết nối các hệ thống mở để giao tiếp với các hệ thống khác.\r\n\r\nMô hình OSI có 7 tầng. Các nguyên tắc dùng cho mỗi tầng có thể tổng hợp như sau:\r<ul><li>Tạo một tầng mới nếu cần một sự trừu tượng khác.</li></ul>\r<ul><li>Mỗi tầng phải có chức năng được xác định rõ ràng.</li></ul>\r<ul><li>Chức năng của mỗi tầng được chọn dựa trên các giao thức chuẩn hoá quốc tế.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các tầng trong mô hình OSI là gì?",
              "answer": "<p><img src=\"/interview-assets/Layers_of_OSI_Model.png\" alt=\"\" />\r\n\r\n| Tầng | Đơn vị | Mô tả |\r\n|------|--------|-------|\r\n| 1.Physical | Bit | Tầng vật lý định nghĩa các đặc tính vật lý của mạng chẳng hạn như kết nối, cấp điện áp và thời gian. |\r\n| 2.Data Link | Frame | Các tầng liên kết dữ liệu định dạng các thông điệp vào một khung dữ liệu(Frame), và thêm vào đó một tiêu đề (header) chứa các địa chỉ phần cứng nơi nhận và địa chỉ nguồn của nó. Tiêu đề này chịu trách nhiệm cho việc tìm kiếm các thiết bị đích tiếp theo trên một mạng cục bộ. |\r\n| 3.Network | Package | Tầng này cung cấp địa chỉ logic mà router sẽ sử dụng để xác định đường đi đến đích.Trong hầu hết các trường hợp, địa chỉ logic ở đây có nghĩa là các địa chỉ IP (bao gồm nguồn & địa chỉ IP đích). |\r\n| 4.Transport | TPDU  | Tầng này duy trì kiểm soát luồng của dữ liệu, thực hiện kiểm tra lỗi và khôi phục dữ liệu giữa các thiết bị. Ví dụ phổ biến nhất của tầng này là Transmission Control Protocol (TCP) và User Datagram Protocol (UDP). |\r\n| 5.Session | SPDU | Nhiệm vụ của tầng này là thiết lập, duy trì và kết thúc giao tiếp với các thiết bị nhận. |\r\n| 6.Presentation | PPDU | Tầng này đảm bảo việc trình bày dữ liệu, mà các thông tin liên lạc qua tầng này nằm trong các hình thức thích hợp đối với người nhận. Nói chung, nó hoạt động như một dịch giả của mạng. Ví dụ, bạn muốn gửi một email và tầng trình bày sẽ định dạng dữ liệu của bạn sang định dạng email. Hoặc bạn muốn gửi ảnh cho bạn bè của bạn, nó sẽ định dạng dữ liệu của bạn vào các định dạng GIF, JPG hoặc PNG. |\r\n| 7.Application | APDU | Đây là tầng gần gũi nhất với người dùng cuối. Nó cung cấp giao diện giữa các ứng dụng với các tầng phía dưới. Nhưng chú ý rằng các chương trình bạn đang sử dụng (như trình duyệt web - IE, Firefox hay Opera ...) không thuộc về tầng Application.Telnet, FTP, client email (SMTP), HyperText Transfer Protocol (HTTP) là những ví dụ của tầng Application. |</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả mô hình TCP/IP?",
              "answer": "<p>Nó là một phiên bản nén của mô hình OSI chỉ có 4 tầng. Được phát triển bởi Bộ Quốc phòng Hoa Kỳ (DoD) vào những năm 1980. Tên của mô hình này dựa trên 2 giao thức tiêu chuẩn được sử dụng, đó là TCP (Transmission Control Protocol) và IP (Internet Protocol).</p>",
              "level": "fresher"
            },
            {
              "question": "Các tầng trong mô hình TCP/IP là gì?",
              "answer": "<p><img src=\"/interview-assets/Layers_of_TCP_IP.png\" alt=\"\" />\r\n\r\n| Tầng | Mô tả |\r\n|------|-------|\r\n| 1.Link | Là sự kết hợp giữa tầng Vật lý và tầng liên kết dữ liệu của mô hình OSI. Chịu trách nhiệm truyền dữ liệu giữa hai thiết bị trong cùng một mạng. Tại đây, các gói dữ liệu được đóng vào khung (gọi là Frame) và được định tuyến đi đến đích đã được chỉ định ban đầu. |\r\n| 2.Internet | Gần giống như tầng mạng của mô hình OSI. Tại đây, nó cũng được định nghĩa là một giao thức chịu trách nhiệm truyền tải dữ liệu một cách logic trong mạng. Các phân đoạn dữ liệu (segment) sẽ được đóng gói (Packets) với kích thước mỗi gói phù hợp với mạng chuyển mạch mà nó dùng để truyền dữ liệu. Lúc này, các gói tin được chèn thêm phần Header chứa thông tin của tầng mạng và tiếp tục được chuyển đến tầng tiếp theo. Các giao thức chính trong tầng là IP, ICMP và ARP. |\r\n| 3.Transport | Chức năng chính của tầng 3 là xử lý vấn đề giao tiếp giữa các máy chủ trong cùng một mạng hoặc khác mạng được kết nối với nhau thông qua bộ định tuyến. Tại đây dữ liệu sẽ được phân đoạn, mỗi đoạn sẽ không bằng nhau nhưng kích thước phải nhỏ hơn 64KB. Cấu trúc đầy đủ của một phân đoạn lúc này là Header chứa thông tin điều khiển và sau đó là dữ liệu. |\r\n| 4.Application | Đây là tầng giao tiếp trên cùng của mô hình. Đúng với tên gọi, tầng này đảm nhận vai trò giao tiếp dữ liệu giữa 2 máy khác nhau thông qua các dịch vụ mạng khác nhau (trình duyệt web, chat, gửi email, một số giao thức trao đổi dữ liệu: SMTP, SSH, FTP,...). Dữ liệu khi đến đây sẽ được định dạng theo kiểu Byte nối Byte, cùng với đó là các thông tin định tuyến giúp xác định đường đi đúng của một gói tin. |</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt của mô hình OSI và mô hình TCP/IP?",
              "answer": "<p><img src=\"/interview-assets/OSI_Vs_TCP_IP.png\" alt=\"\" />\r\n\r\n| Mô hình OSI | Mô hình TCP/IP |\r\n|-------------|----------------|\r\n| Kiến trúc 7 tầng | Kiến trúc 4 tầng | \r\n| Có ranh giới và chức năng cố định cho mỗi lớp | Kiến trúc linh hoạt không có ranh giới nghiêm ngặt giữa các lớp |\r\n| Độ tin cậy thấp | Độ tin cậy cao |\r\n| Tiếp cận các tầng theo chiều dọc | Tiếp cận các tầng theo chiều ngang |</p>",
              "level": "fresher"
            },
            {
              "question": "Giao thức HTTP và HTTPS là gì?",
              "answer": "<p>HTTP là viết tắt của HyperText Transfer Protocol, giao thức truyền tải siêu văn bản, nó xác định một tập hợp quy tắc và chuẩn để truyền tải dữ liệu trên World Wide Web (WWW). Nó giúp trình duyệt web và web server có thể giao tiếp. Nó là \"stateless protocol\" trong đó mỗi lệnh là độc lập với các lệnh trước đó. HTTP là giao thức ở tầng ứng dụng xây dựng trên TCP. Cổng mặc định của nó là 80.\r\n\r\nCòn HTTPS là viết tắt của từ HyperText Transfer Protocol Secure. Nó là phiên bản bảo mật và nâng cao của HTTP. Cùng với HTTP, giao thức SSL/TLC được dùng cho bảo mật. Nó mã hóa dữ liệu truyền tải nhằm gia tăng bảo mật giữa Web sever đến các trình duyệt web. Nó sử dụng cổng mặc định là 443.</p>",
              "level": "fresher"
            },
            {
              "question": "Giao thức SMTP là gì?",
              "answer": "<p>SMTP là viết tắt của Simple Mail Transfer Protocol. SMTP tập hợp các quy tắc giao tiếp giữa các server. Tập quy tắc này giúp phần mềm gửi nhận mail trên internet. Nó hỗ trợ phương thức End-to-End và Store-and-Forward. Nó luôn luôn hoạt động trên cổng 25.\r\n\r\n<img src=\"/interview-assets/SMTP_Protocol.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "DNS là gì?",
              "answer": "<p>DNS là viết tắt của cụm từ Domain Name System, mang ý nghĩa đầy đủ là hệ thống phân giải tên miền. Hiểu một cách ngắn gọn nhất, DNS cơ bản là một hệ thống chuyển đổi các tên miền website mà chúng ta đang sử dụng, ở dạng www.tenmien.com sang một địa chỉ IP dạng số tương ứng với tên miền đó và ngược lại.</p>",
              "level": "fresher"
            },
            {
              "question": "Công dụng của router là gì và nó khác với gateway như thế nào?",
              "answer": "<p>Bộ định tuyến (router) là một thiết bị mạng được sử dụng để kết nối hai hoặc nhiều phân đoạn mạng. Nó định hướng lưu lượng trong mạng. Nó chuyển thông tin và dữ liệu như trang web, email, hình ảnh, video, v.v. từ nguồn đến đích dưới dạng các gói tin. Nó hoạt động ở tầng netwwork. \r\n\r\nCác cổng (gateway) cũng được sử dụng để định tuyến và điều tiết lưu lượng mạng nhưng chúng cũng có thể gửi dữ liệu giữa hai mạng khác nhau trong khi một bộ định tuyến chỉ có thể gửi dữ liệu đến các mạng tương tự.</p>",
              "level": "fresher"
            },
            {
              "question": "Giao thức TCP là gì?",
              "answer": "<p>TCP là viết tắt của cụm từ Transmission Control Protocol, tức là giao thức điều khiển truyền nhận. Giao thức này đóng vai trò kiểm tra và đảm bảo sự chuyển giao thông tin từ nơi nguồn tới nơi nhận một cách an toàn và đúng thứ tự.\r\n\r\nHơn nữa, giao thức TCP đảm bảo không xảy ra sự chậm trễ trong đường truyền làm ảnh hưởng đến chất lượng gói tin. Bên cạnh đó, TCP là giao thức hướng kết nối, nghĩa là phải thiết lập kết nối trước khi truyền dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Giao thức UDP là gì?",
              "answer": "<p>UDP là viết tắt của cụm từ User Datagram Protocol. UDP là một phần của bộ giao thức Internet được sử dụng bởi các chương trình chạy trên các máy tính khác nhau trên mạng. Không giống như TCP/IP, UDP được sử dụng để gửi các gói tin ngắn gọi là datagram, cho phép truyền nhanh hơn. Tuy nhiên, UDP không cung cấp kiểm tra lỗi nên không đảm bảo toàn vẹn dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "So sánh TCP và UDP?",
              "answer": "<p>| TCP | UDP |\r\n|-----|-----|\r\n| Giao thức hướng kết nối | Giao thức không kết nối |\r\n| Độ tin cậy cao | Độ tin cậy thấp |\r\n| Truyền tải chậm | Truyền tải nhanh |\r\n| Thứ tự gói tin có thể được giữ nguyên hoặc được sắp xếp lại | Thứ  tự gói tin không cố định và độc lập với nhau |\r\n| Sử dụng mô hình bắt tay ba bước cho thiết lập | Thiết lập đơn giản không cần bắt tay |\r\n| Gói tin nặng nề | Gói tin nhẹ nhàng |\r\n| Hỗ trợ cơ chế kiểm lỗi | Không có cơ chế kiểm lỗi |\r\n| Các giao thức như HTTP, FTP, Telnet, SMTP sử dụng TCP | Các giao thức DNS, RTP, BOOTP, RIP, SNMP sử dụng UDP |\r\n\r\n<img src=\"/interview-assets/TCP_Vs_UDP.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giao thức ICMP là gì?",
              "answer": "<p>ICMP được viết tắt bởi cụm từ Internet Control Message Protocol. Có thể hiểu một cách đơn giản giao thức ICMP là một giao thức của gói Internet Protocol hay còn được gọi là giao thức điều khiển truyền tin qua mạng Internet. ICMP thuộc tầng vận chuyển (Transport Layer).\r\n\r\nGiao thức này được sử dụng để thông báo các lỗi có thể xảy ra trong quá trình truyền tin của các gói dữ liệu qua mạng. Chúng còn được sử dụng để thăm dò cũng như quản lý quá trình hoạt động của mạng Internet. Cổng mặc định của nó là 7.</p>",
              "level": "fresher"
            },
            {
              "question": "Giao thức DHCP là gì?",
              "answer": "<p>DHCP (Dynamic Host Configuration Protocol hay Giao thức cấu hình host động) là một giao thức được sử dụng để cung cấp quản lý nhanh chóng, tự động và tập trung cho việc phân phối địa chỉ IP trong mạng. DHCP cũng được sử dụng để cấu hình đúng subnet mask, cổng mặc định và thông tin về DNS server trên thiết bị. Cổng mặc định của nó là 67.</p>",
              "level": "fresher"
            },
            {
              "question": "Giao thức ARP là gì?",
              "answer": "<p>ARP (Address Resolution Protocol) là giao thức mạng được dùng để tìm địa chỉ phần cứng (địa chỉ MAC) của thiết bị từ một địa chỉ IP. Nó được sử dụng khi một thiết bị muốn giao tiếp với các thiết bị khác trên mạng cục bộ (ví dụ trên mạng Ethernet mà yêu cầu địa chỉ vật lý trước khi gửi packets). Thiết bị gửi sử dụng ARP để dịch địa chỉ IP sang địa chỉ MAC. Thiết bị sẽ gửi một request ARP có chứa địa chỉ IP của thiết bị nhận. Tất cả thiết bị trên mạng cục bộ sẽ thấy thông điệp này, nhưng chỉ thiết bị có địa chỉ IP chứa trong request mới phản hồi lại với thông điệp chứa địa chỉ MAC của nó. Thiết bị gửi khi đó sẽ có đủ thông tin để gửi packet tới thiết bị nhận.\r\n\r\n<img src=\"/interview-assets/ARP_Protocol.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giao thức FTP là gì?",
              "answer": "<p>FTP - File Transfer Protocol (Giao thức truyền tải tập tin) được dùng trong việc trao đổi dữ liệu trong mạng thông qua giao thức TCP/IP, thường hoạt động trên 2 cổng là 20 và 21. Với giao thức này, các máy client trong mạng có thể truy cập đến máy chủ FTP để gửi hoặc lấy dữ liệu. Điểm nổi bật là người dùng có thể truy cập vào máy chủ FTP để truyền và nhận dữ liệu dù đang ở xa.</p>",
              "level": "fresher"
            },
            {
              "question": "Địa chỉ MAC là gì?",
              "answer": "<p>Địa chỉ MAC là viết tắt của Media Access Control. Nó là một dãy 48-bit hoặc 64-bit duy nhất của phần cứng máy tính. Nó còn được gọi là địa chỉ vật lý nhúng với NIC (Network Interface Card) được sử dụng ở tầng Data Link. NIC (card mạng) là một thiết bị phần cứng được cài đặt trên máy tính để nó có thể được kết nối với internet.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa địa chỉ IP và địa chỉ MAC?",
              "answer": "<p>| MAC | IP |\r\n|-----|----|\r\n| 6 hoặc 8 byte dạng thập lục phân | IPv4 hoặc IPv6 |\r\n| Được nhúng với NIC | Nó được lấy từ mạng | \r\n| Địa chỉ vật lý | Địa chỉ logic |\r\n| Hoạt động ở tầng Data Link | Hoạt động ở tầng Network |\r\n| Giúp định danh thiết bị | Giúp định danh thiết bị kết nối trong mạng |</p>",
              "level": "fresher"
            },
            {
              "question": "Subnet là gì?",
              "answer": "<p>Subnet (mạng con) là một mạng bên trong một mạng khác được tạo bởi quá trình gọi là chia mạng con (subnetting) giúp phân chia một mạng thành các mạng con. Nó được sử dụng để có hiệu quả định tuyến cao hơn và nâng cao tính bảo mật của mạng. Nó làm giảm thời gian trích xuất địa chỉ máy chủ từ bảng định tuyến.\r\n\r\n<img src=\"/interview-assets/Subnet.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "So sánh Hub với Switch?",
              "answer": "<p>| Hub | Switch |\r\n|-----|--------|\r\n| Hoạt động ở tầng Physical | Hoạt động ở tầng Data Link |\r\n| Chế độ truyền tải Half-Duplex | Chế độ truyền tải Full-Duplex |\r\n| Các thiết bị Ethernet có thể được kết nối | Các thiết bị LAN có thể được kết nối |\r\n| Ít phức tạp, rẻ, kém thông minh | Thông minh và hiệu quả |\r\n| Không có phần mềm hỗ trợ admin | Hỗ trợ phần mềm admin |\r\n| Tốc độ nhỏ hơn 100MBPS | Hỗ trợ tốc độ cao GBPS |\r\n| Kém hiệu quả hơn vì không có cách nào để tránh xung đột khi nhiều nút gửi các gói tin cùng một lúc | Hiệu quả hơn vì có thể tránh hoặc giảm xung đột so với Hub |</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa ipconfig và ifconfig?",
              "answer": "<p>| ipconfig | ifconfig |\r\n|----------|----------|\r\n| Internet Protocol Configuration | Interface Configuration |\r\n| Lệnh trong hệ điều hành Microsoft để xem và cấu hình interface mạng | Lệnh dùng trong MAC, Unix để xem cấu hình interface mạng |\r\n\r\nCả hai đều được sử dụng để lấy thông tin tổng hợp TCP/IP và cho phép thay đổi cài đặt DHCP và DNS</p>",
              "level": "fresher"
            },
            {
              "question": "Tường lửa là gì?",
              "answer": "<p>Tường lửa là một hệ thống an ninh mạng được sử dụng để giám sát lưu lượng đến và đi đồng thời chặn các lưu lượng không mong muốn dựa trên các chính sách bảo mật của tường lửa. Nó hoạt động như một bức tường giữa internet (mạng công cộng) và các thiết bị mạng (mạng riêng). Nó có thể là thiết bị phần cứng hay chương trình phần mềm hoặc kết hợp cả hai. Nó bổ sung một lớp bảo mật cho mạng.\r\n\r\n<img src=\"/interview-assets/Firewall.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Unicasting, Anycasting, Multicasting và Broadcasting là gì?",
              "answer": "<p><ul><li><strong>Unicasting:</strong> Nếu thông điệp được gửi cho một nút đơn từ một nguồn được gọi là Unicasting. Đây là cách phổ biến để thiết lập kết nối trong mạng.</li></ul>\r<ul><li><strong>Anycasting:</strong> Nếu thông điệp được gửi đến bất kỳ nút nào từ nguồn được gọi là anycasting. Nó chủ yếu được dùng để lấy nội dung từ bất kỳ server nào trong CDS (Content Delivery System).</li></ul>\r<ul><li><strong>Multicasting:</strong> nếu thông điệp được gửi đến mạng con của một nút từ nguồn nó được gọi là multicasting. Nó được dùng để gửi cùng dữ liệu đến nhiều người nhận.</li></ul>\r<ul><li><strong>Broadcasting:</strong> nếu thông điệp được gửi cho tất cả nút trong mạng từ một nguồn nó được gọi là broadcasting. DHCP và ARP là mạng cục bộ dùng broadcasting.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Điều gì xảy ra khi nhập google.com trên trình duyệt web?",
              "answer": "<p>1. Trước tiên, kiểm tra bộ đệm trình duyệt trước nếu nội dung đã có ở bộ đệm thì hiển thị nó.\r\n2. Nếu không, trình duyệt kiểm tra IP hoặc URL ở bộ đệm (trình duyệt hoặc HĐH) nếu không, yêu cầu hệ điều hành thực hiện tra cứu DNS bằng UDP để lấy địa chỉ IP tương ứng với URL từ DNS để thiết lập kết nối TCP mới.\r\n3. Kết nối TCP mới được thiết lập giữa trình duyệt và server sử dụng bắt tay ba bước.\r\n4. Yêu cầu HTTP được gửi đến server sử dụng kết nối TCP.\r\n5. Web server xử lý yêu cầu HTTP và gửi phản hồi.\r\n6. Trình duyệt xử lý phản hổi HTTP được gửi từ server và đóng kết nối TCP hoặc sử dụng lại trong tương lai.\r\n7. Nếu dữ liệu phản hồi có thể lưu vào bộ đệm thì trình duyệt sẽ lưu vào bộ đệm giống nhau.\r\n8. Trình duyệt decode phản hồi và hiển thị nội dung.\r\n\r\n<img src=\"/interview-assets/google.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "oops",
          "name": "Lập trình hướng đối tượng",
          "description": "",
          "questions": [
            {
              "question": "Thuật ngữ OOP có nghĩa là gì?",
              "answer": "<p>OOP đề cập đến Lập trình hướng đối tượng. Đó là mô hình lập trình được xác định bằng cách sử dụng các đối tượng. Các đối tượng có thể được coi là các thể hiện trong thế giới thực của các thực thể như lớp, có một số đặc điểm và hành vi</p>",
              "level": "middle"
            },
            {
              "question": "Tại sao cần OOP?",
              "answer": "<p>Có nhiều lý do khiến OOP hầu hết được ưa thích, nhưng quan trọng nhất trong số đó là:\r<ul><li>OOP giúp người dùng hiểu phần mềm một cách dễ dàng, mặc dù họ không biết cách triển khai thực tế.</li></ul>\r<ul><li>Với OOP, khả năng đọc, hiểu và khả năng bảo trì của code tăng lên gấp nhiều lần.</li></ul>\r<ul><li>Ngay cả những phần mềm rất lớn cũng có thể được viết và quản lý dễ dàng bằng OOP.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Một số ngôn ngữ lập trình hướng đối tượng",
              "answer": "<p>Các ngôn ngữ lập trình sử dụng và tuân theo mô hình lập trình hướng đối tượng hoặc OOP, được gọi là ngôn ngữ lập trình hướng đối tượng. Một số ngôn ngữ lập trình hướng đối tượng chính bao gồm:\r<ul><li>Java</li></ul>\r<ul><li>C++</li></ul>\r<ul><li>Javascript</li></ul>\r<ul><li>Python</li></ul>\r<ul><li>PHP</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Một số mô hình lập trình khác ngoài OOP là gì?",
              "answer": "<p>Mô hình lập trình đề cập đến phương pháp phân loại ngôn ngữ lập trình dựa trên các tính năng của chúng. Chủ yếu có hai loại Mô hình lập trình:\r<ul><li>Mô hình lập trình mệnh lệnh</li></ul>\r<ul><li>Mô hình lập trình khai báo</li></ul>\r\n\r\nBây giờ, các mô hình này có thể được phân loại thêm dựa trên:\r\n\r\n1. <strong>Mô hình lập trình mệnh lệnh</strong>: Lập trình mệnh lệnh tập trung vào CÁCH thực thi logic chương trình và định nghĩa luồng điều khiển là các câu lệnh thay đổi trạng thái chương trình. Điều này có thể được phân loại thêm là:\r\n\r\n    a) <em>Mô hình lập trình hướng thủ tục</em>: Lập trình theo thủ tục xác định các bước mà một chương trình phải thực hiện để đạt được trạng thái mong muốn, thường được đọc theo thứ tự từ trên xuống dưới.\r\n    \r\n    b) <em>Lập trình hướng đối tượng hoặc OOP</em>: Lập trình hướng đối tượng (OOP) tổ chức các chương trình dưới dạng các đối tượng, chứa một số thuộc tính và có một số hành vi.\r\n    \r\n    c) <em>Lập trình song song</em>: Mô hình lập trình song song chia một nhiệm vụ thành các nhiệm vụ con và tập trung vào việc thực hiện chúng đồng thời cùng một lúc.\r\n\r\n2. <strong>Mô hình lập trình khai báo</strong>: Lập trình khai báo tập trung vào CÁI GÌ để thực thi và định nghĩa logic chương trình, nhưng không phải là một luồng điều khiển chi tiết. Mô hình khai báo có thể được phân loại thêm thành:\r\n\r\n    a) <em>Mô hình lập trình logic</em>: Mô hình lập trình logic dựa trên logic hình thức, đề cập đến một tập hợp các câu diễn đạt các dữ kiện và quy tắc về cách giải quyết một vấn đề\r\n\r\n    b) <em>Mô hình lập trình chức năng</em>: Mô hình lập trình chức năng là mô hình lập trình trong đó các chương trình được xây dựng bằng cách áp dụng và soạn thảo các hàm.\r\n    \r\n    c) <em>Mô hình lập trình cơ sở dữ liệu</em>: Mô hình lập trình cơ sở dữ liệu được sử dụng để quản lý dữ liệu và thông tin có cấu trúc như trường, bản ghi và file.\r\n\r\n<img src=\"/interview-assets/programming-paradigms.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Lập trình có cấu trúc nghĩa là gì?",
              "answer": "<p>Lập trình có cấu trúc đề cập đến phương pháp lập trình bao gồm một luồng điều khiển hoàn toàn có cấu trúc. Ở đây cấu trúc đề cập đến một khối, chứa một tập hợp các quy tắc và có một luồng điều khiển cuối cùng, chẳng hạn như (if/then/else), (while và for), cấu trúc khối và chương trình con.\r\n\r\nGần như tất cả các mô hình lập trình đều bao gồm Lập trình có cấu trúc, bao gồm cả mô hình OOP.</p>",
              "level": "middle"
            },
            {
              "question": "Các tính năng chính của OOP?",
              "answer": "<p>OOP hoặc Lập trình hướng đối tượng chủ yếu bao gồm bốn tính năng dưới đây và đảm bảo rằng bạn không bỏ lỡ bất kỳ tính năng nào sau đây:\r<ul><li>Tính kế thừa</li></ul>\r<ul><li>Tính đóng gói</li></ul>\r<ul><li>Tính đa hình</li></ul>\r<ul><li>Tính trừu tượng</li></ul>\r\n\r\n<img src=\"/interview-assets/oops-features.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Lợi ích của sử dụng OOP?",
              "answer": "<p><ul><li>OOP rất hữu ích trong việc giải quyết các vấn đề ở mức độ rất phức tạp.</li></ul>\r<ul><li>Các chương trình có độ phức tạp cao có thể được tạo, xử lý và bảo trì dễ dàng bằng cách sử dụng lập trình hướng đối tượng.</li></ul>\r<ul><li>OOP, thúc đẩy việc tái sử dụng code, do đó giảm bớt sự dư thừa.</li></ul>\r<ul><li>OOP cũng giúp ẩn những chi tiết không cần thiết với sự trợ giúp của tính trừu tượng .</li></ul>\r<ul><li>OOP, dựa trên cách tiếp cận từ dưới lên, không giống như mô hình lập trình cấu trúc, sử dụng cách tiếp cận từ trên xuống.</li></ul>\r<ul><li>Tính đa hình cung cấp rất nhiều tính linh hoạt trong các OOP.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Tại sao OOP lại phổ biến như vậy?",
              "answer": "<p>Mô hình lập trình OOP được coi là một phong cách lập trình tốt hơn. Nó không chỉ giúp dễ dàng viết một đoạn code phức tạp mà còn cho phép người dùng xử lý và duy trì chúng một cách dễ dàng. Không chỉ vậy, các tính năng chính của OOP - Trừu tượng hóa, Đóng gói, Kế thừa và Đa hình, giúp lập trình viên dễ dàng giải quyết các tình huống phức tạp. Do đó, OOP rất phổ biến.</p>",
              "level": "middle"
            },
            {
              "question": "Lớp là gì?",
              "answer": "<p>Một lớp có thể được hiểu là một khuôn mẫu hoặc một bản thiết kế, chứa một số giá trị, được gọi là thuộc tính và một số bộ quy tắc, được gọi là hành vi hoặc chức năng. Vì vậy, khi một đối tượng được tạo, nó sẽ tự động lấy thuộc tính và phương thức đã được định nghĩa trong lớp.\r\n\r\nDo đó, về cơ bản lớp là một khuôn mẫu hoặc bản thiết kế cho các đối tượng. Ngoài ra, người ta có thể tạo bao nhiêu đối tượng tùy thích dựa trên một lớp.\r\n\r\nVí dụ: đầu tiên, mẫu của một chiếc ô tô được tạo. Sau đó, nhiều chiếc xe được tạo ra dựa trên mẫu đó.</p>",
              "level": "middle"
            },
            {
              "question": "Đối tượng là gì?",
              "answer": "<p>Một đối tượng đề cập đến thực thể của lớp, bao gồm toàn bộ các thuộc tính và phương thức được xác định trong lớp mẫu. Trong thực tế, một đối tượng là một thực thể thực tương tác với người dùng trong khi lớp là bản thiết kế cho đối tượng đó. Vì vậy, các đối tượng tiêu thụ không gian và có một số hành vi đặc trưng.</p>",
              "level": "middle"
            },
            {
              "question": "Tính đóng gói là gì?",
              "answer": "<p><img src=\"/interview-assets/encapsulation.png\" alt=\"\" />\r\n\r\nNgười ta có thể hình dung đóng gói là phương pháp đưa mọi thứ cần thiết để thực hiện công việc vào bên trong một viên thuốc và trình bày viên thuốc đó cho người dùng. Điều đó có nghĩa là bằng đóng gói, tất cả các dữ liệu và phương thức cần thiết được liên kết với nhau và tất cả các chi tiết không cần thiết được ẩn đối với người dùng bình thường. Vì vậy, đóng gói là quá trình liên kết các thuộc tính và các phương thức của một chương trình với nhau để thực hiện một công việc cụ thể, mà không để lộ các chi tiết không cần thiết.\r\n\r\nĐóng gói có thể được xác định theo hai cách:\r\n\r\n1. <strong>Data hiding</strong>: đóng gói là quá trình ẩn thông tin không mong muốn, hạn chế các truy cập đến thuộc tính của đối tượng.\r\n2. <strong>Data binding</strong>: là quá trình liên kết các thuộc tính và các phương thức với nhau như một tổng thể.</p>",
              "level": "middle"
            },
            {
              "question": "Tính đa hình là gì?",
              "answer": "<p>Đa hình đề cập đến một thứ có thể có nhiều hình dạng.\r\n\r\n<img src=\"/interview-assets/polymorphism.png\" alt=\"\" />\r\n\r\nTrong OOP, Đa hình đề cập đến quá trình mà một số code, dữ liệu, phương thức hoặc đối tượng hoạt động khác nhau trong các trường hợp hoặc ngữ cảnh khác nhau. Đa hình thời gian biên dịch và đa hình thời gian chạy là hai loại đa hình trong các ngôn ngữ OOP.</p>",
              "level": "middle"
            },
            {
              "question": "Sự khác nhau giữa đa hình thời gian biên dịch và đa hình thời gian chạy?",
              "answer": "<p><img src=\"/interview-assets/types_of_polymorphism.png\" alt=\"\" />\r\n\r\n<strong>Compile Time Polymorphism</strong>: còn gọi là đa hình tĩnh, đề cập đến kiểu đa hình xảy khi khi biên dịch. Có nghĩa là trình biên dịch quyết định hình dạng hoặc giá trị nào được thực thể sử dụng.\r\n\r\n``<code>java\r\n// In this program, we will see how multiple functions are created with the same name, \r\n// but the compiler decides which function to call easily at the compile time itself.\r\nclass CompileTimePolymorphism{\r\n    // 1st method with name add\r\n    public int add(int x, int y){ \r\n        return x+y;\r\n    }\r\n    // 2nd method with name add\r\n    public int add(int x, int y, int z){\r\n        return x+y+z;\r\n    }\r\n    // 3rd method with name add\r\n    public int add(double x, int y){ \r\n        return (int)x+y;\r\n    }\r\n    // 4th method with name add\r\n    public int add(int x, double y){ \r\n        return x+(int)y;\r\n    }\r\n}\r\nclass Test{\r\n    public static void main(String[] args){\r\n        CompileTimePolymorphism demo=new CompileTimePolymorphism();\r\n        // In the below statement, the Compiler looks at the argument types and decides to call method 1\r\n        System.out.println(demo.add(2,3));\r\n        // Similarly, in the below statement, the compiler calls method 2\r\n        System.out.println(demo.add(2,3,4));\r\n        // Similarly, in the below statement, the compiler calls method 4\r\n        System.out.println(demo.add(2,3.4));\r\n        // Similarly, in the below statement, the compiler calls method 3\r\n        System.out.println(demo.add(2.5,3)); \r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, có bốn phiên bản của các phương thức </code>add()<code>. Phương thức đầu tiên nhận hai tham số trong khi phương thức thứ hai nhận ba tham số. Đối với phương pháp thứ ba và thứ tư, có sự thay đổi thứ tự của các tham số. Trình biên dịch xem xét dấu hiệu của phương thức và quyết định phương thức nào sẽ gọi cho một lệnh gọi cụ thể tại thời điểm biên dịch.\r\n\r\n<strong>Runtime Polymorphism</strong>: còn gọi là đa hình động, đề cập đến kiểu đa hình xảy khi khi đang chạy. Điều đó có nghĩa là nó không thể được quyết định bởi trình biên dịch. Do đó, hình dạng hoặc giá trị nào phải được thực hiện tùy thuộc vào quá trình thực thi.\r\n\r\n</code>`<code>java\r\nclass AnyVehicle{\r\n    public void move(){\r\n        System.out.println(“Any vehicle should move!!”);\r\n    }\r\n}\r\nclass Bike extends AnyVehicle{\r\n    public void move(){\r\n        System.out.println(“Bike can move too!!”);\r\n    }\r\n}\r\nclass Test{\r\n    public static void main(String[] args){\r\n        AnyVehicle vehicle = new Bike();\r\n        // In the above statement, as you can see, the object vehicle is of type AnyVehicle\r\n        // But the output of the below statement will be “Bike can move too!!”, \r\n        // because the actual implementation of object ‘vehicle’ is decided during runtime vehicle.move();\r\n        vehicle = new AnyVehicle();\r\n        // Now, the output of the below statement will be “Any vehicle should move!!”, \r\n        vehicle.move();\r\n    }\r\n}\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "C++ hỗ trợ đa hình thế nào?",
              "answer": "<p>C++ là ngôn ngữ lập trình hướng đối tượng và hỗ trợ đa hình rất tốt:\r<ul><li>Compile Time Polymorphism: C ++ hỗ trợ tính đa hình thời gian biên dịch với sự trợ giúp của các tính năng như mẫu, nạp chồng hàm và các tham số mặc định.</li></ul>\r<ul><li>Runtime Polymorphism: C ++ hỗ trợ tính đa hình Runtime với sự trợ giúp của các tính năng như hàm ảo. Các hàm ảo có hình dạng của các hàm dựa trên loại đối tượng trong tham chiếu và được giải quyết trong thời gian chạy.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Kế thừa là gì?",
              "answer": "<p>Thuật ngữ \"kế thừa\" có nghĩa là \"nhận được một số phẩm chất hoặc hành vi từ cha mẹ cho con cái.\" Trong lập trình hướng đối tượng, kế thừa là cơ chế mà một đối tượng hoặc lớp (được gọi là con) được tạo ra bằng cách sử dụng định nghĩa của một đối tượng hoặc lớp khác (được gọi là cha). Kế thừa không chỉ giúp giữ cho việc triển khai đơn giản hơn mà còn giúp tạo điều kiện sử dụng lại code.</p>",
              "level": "middle"
            },
            {
              "question": "Trừu tượng là gì?",
              "answer": "<p>Nếu bạn là người dùng và bạn có một vấn đề, bạn không muốn biết các thành phần của phần mềm hoạt động như thế nào hoặc nó được tạo ra như thế nào. Bạn chỉ muốn biết cách phần mềm giải quyết vấn đề của bạn. Trừu tượng hóa là phương pháp che giấu những chi tiết không cần thiết khỏi những cái cần thiết. Đây là một trong những tính năng chính của OOP.\r\n\r\nVí dụ như một chiếc xe. Bạn chỉ cần biết cách chạy chiếc xe đó, còn nó gồm những bộ phận, động cơ có mấy xi lanh thì không cần quan tâm. Điều này được gọi là trừu tượng.</p>",
              "level": "middle"
            },
            {
              "question": "Một lớp chiếm bao nhiêu bộ nhớ?",
              "answer": "<p>Lớp không chứa bất kỳ bộ nhớ nào. Nó là một bản thiết kế để cái đối tượng dựa vào nó mà tạo. Chỉ khi đối tượng được tạo, nó mới thực sự tạo các thuộc tính và phương thức và mới tốn bộ nhớ.</p>",
              "level": "middle"
            },
            {
              "question": "Có phải lúc nào cũng cần tạo các đối tượng từ lớp không?",
              "answer": "<p>Không. Một đối tượng chỉ được tạo nếu lớp cơ sở có các phương thức động. Nhưng nếu lớp có các phương thức tĩnh, thì các đối tượng không cần phải được tạo. Bạn có thể gọi phương thức lớp trực tiếp trong trường hợp này, bằng cách sử dụng tên lớp.</p>",
              "level": "middle"
            },
            {
              "question": "Constructor là gì?",
              "answer": "<p>Cóntructor hay hàm khởi tạo là một phương thức đặc biệt có tên giống như tên lớp. Hàm khởi tạo dùng cho mục đích đặc biệt là khởi tạo đối tượng. Ví dụ: ta có lớp tên là <code>MyClass</code>, khi bạn khởi tạo lớp này, bạn truyền cú pháp:\r\n\r\n``<code>java\r\nMyClass myClassObject = new MyClass();\r\n</code>`<code>\r\n\r\nỞ đây, phương thức được gọi sau từ khoá </code>new<code> là </code>MyClass()<code> là hàm khởi tạo của lớp này.  Điều này giúp khởi tạo thuộc tính và các phương thức để gán chúng cho đối tượng </code>myClassObject`. \r\n\r\n<img src=\"/interview-assets/constructor.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Các kiểu constructor trong C++?",
              "answer": "<p>Các constructor có các phân loại phổ biến như sau:\r<ul><li><strong>Default Constructor</strong>: Hàm khởi tạo mặc định không nhận bất kỳ tham số nào.</li></ul>\r\n\r\n``<code>cpp\r\nclass ABC\r\n{\r\n    int x;\r\n        \r\n    ABC()\r\n    {\r\n        x = 0;\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Parameterized constructor</strong>: hàm khởi tạo này nhận về một hay nhiều tham số.</li></ul>\r\n\r\n</code>`<code>cpp\r\nclass ABC\r\n{\r\n    int x;\r\n        \r\n    ABC(int y)\r\n    {\r\n        x = y;\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Copy constructor</strong>: là một hàm thành viên khởi tạo một đối tượng bằng cách sử dụng một đối tượng khác của cùng một lớp.</li></ul>\r\n\r\n</code>`<code>cpp\r\nclass ABC\r\n{\r\n    int x;\r\n        \r\n    ABC(int y)\r\n    {\r\n        x = y;\r\n    }\r\n    // Copy constructor\r\n    ABC(ABC abc)\r\n    {\r\n        x = abc.x;\r\n    }\r\n}\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Copy Constructor là gì?",
              "answer": "<p>Copy Constructor hay hàm khởi tạo sao chép, có mục đích là sao chép một đối tượng sang một đối tượng khác. Điều đó có nghĩa là một phương thức khởi tạo sao chép sẽ sao chép một đối tượng và các giá trị của nó, vào một đối tượng khác, với điều kiện là cả hai đối tượng đều thuộc cùng một lớp.</p>",
              "level": "middle"
            },
            {
              "question": "Destructor là gì?",
              "answer": "<p>Trái ngược với các hàm khởi tạo, khởi tạo các đối tượng và chỉ định không gian cho chúng, các Hàm hủy cũng là các phương thức đặc biệt. Nhưng hàm hủy giải phóng tài nguyên và bộ nhớ được sử dụng bởi một đối tượng. Bộ hủy được tự động gọi khi một đối tượng đang bị hủy.</p>",
              "level": "middle"
            },
            {
              "question": "Có phải lớp và cấu trúc giống nhau?",
              "answer": "<p>Không, lớp và cấu trúc không giống nhau. Mặc dù chúng có vẻ giống nhau, nhưng chúng có những điểm khác biệt khiến chúng trở nên khác biệt. Ví dụ, cấu trúc được lưu trong bộ nhớ stack, trong khi lớp được lưu trong bộ nhớ heap. Ngoài ra, tính trừu tượng hóa dữ liệu không thể có trong cấu trúc, nhưng với lớp, tính trừu tượng được sử dụng chủ yếu.</p>",
              "level": "middle"
            },
            {
              "question": "Giải thích về tính kế thừa?",
              "answer": "<p>Kế thừa là một trong những đặc điểm chính của lập trình hướng đối tượng, theo đó một thực thể kế thừa một số đặc điểm và hành vi của một thực thể khác và biến chúng thành của riêng mình. Kế thừa giúp cải thiện và tạo điều kiện sử dụng lại code.\r\n\r\nTa sẽ giải thích bằng một ví dụ dễ hiểu. Ta có ba phương tiện khác nhau - xe hơi, xe tải hoặc xe buýt. Ba loại này hoàn toàn khác nhau với những đặc điểm và hành vi cụ thể của riêng chúng. Nhưng ở cả ba, bạn sẽ tìm thấy một số yếu tố chung, như vô lăng, chân ga, ly hợp, phanh, v.v. Mặc dù những yếu tố này được sử dụng trên các loại xe khác nhau, chúng vẫn có những đặc điểm chung của tất cả các loại xe. Điều này đạt được nhờ vào sự kế thừa. Xe hơi, xe tải và xe buýt đều được thừa hưởng các tính năng như vô lăng, chân ga, ly hợp, phanh, v.v. và sử dụng chúng như của riêng mình. Do đó, chúng không phải tạo các thành phần này từ đầu, nhờ thế tạo điều kiện sử dụng lại code.\r\n\r\n<img src=\"/interview-assets/inheritance-with-ex.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Có bất kỳ hạn chế nào của kế thừa không?",
              "answer": "<p>Vâng, với nhiều quyền lực hơn đi kèm với nhiều phức tạp hơn. Kế thừa là một tính năng rất mạnh trong OOP, nhưng nó cũng có một số hạn chế. Kế thừa cần thêm thời gian để xử lý, vì nó cần điều hướng qua nhiều lớp để triển khai. Ngoài ra, các lớp liên quan đến Kế thừa - lớp cơ sở và lớp con, được kết hợp rất chặt chẽ với nhau. Vì vậy, nếu một người cần thực hiện một số thay đổi, họ có thể cần thực hiện các thay đổi lồng nhau trong cả hai lớp. Kế thừa cũng có thể phức tạp để thực hiện. Vì nếu không được triển khai chính xác, có thể dẫn đến lỗi không mong muốn hoặc kết quả đầu ra không chính xác.</p>",
              "level": "middle"
            },
            {
              "question": "Các kiểu kế thừa khác nhau?",
              "answer": "<p><ul><li>Đơn kế thừa (Single inheritance)</li></ul>\r<ul><li>Đa kế thừa (Multiple inheritance)</li></ul>\r<ul><li>Kế thừa đa cấp (Multi-level inheritance)</li></ul>\r<ul><li>Kế thừa phân cấp (Hierarchical inheritance)</li></ul>\r<ul><li>Siêu kế thừa (Hybrid inheritance)</li></ul>\r\n\r\n<img src=\"/interview-assets/types_of_inheritance.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Lớp con là gì?",
              "answer": "<p>Lớp con là một phần của Kế thừa. Lớp con là một thực thể, được kế thừa từ một lớp khác.</p>",
              "level": "middle"
            },
            {
              "question": "Lớp cha là gì?",
              "answer": "<p>Lớp cha  là một phần của Kế thừa. Lớp cha là một thực thể, cho phép các lớp con kế thừa từ chính nó. \r\n\r\n<img src=\"/interview-assets/superclass.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Interface là gì?",
              "answer": "<p>Interface đề cập đến một loại lớp đặc biệt, chứa các phương thức, nhưng không phải là định nghĩa của chúng. Chỉ cho phép khai báo các phương thức bên trong một interface. Bạn không thể tạo các đối tượng bằng cách dùng interface. Thay vào đó, bạn cần triển khai interface đó và xác định các phương pháp để triển khai chúng.</p>",
              "level": "middle"
            },
            {
              "question": "Đa hình tĩnh là gì?",
              "answer": "<p>Còn gọi là đa hình thời gian biên dịch. Đa hình tĩnh là tính năng mà một đối tượng được liên kết với hàm hoặc toán tử tương ứng dựa trên các giá trị trong thời gian biên dịch. Đa hình thời gian tĩnh hoặc thời gian biên dịch có thể đạt được thông qua nạp chồng phương thức hoặc nạp chồng toán tử.</p>",
              "level": "middle"
            },
            {
              "question": "Đa hình động là gì?",
              "answer": "<p>Còn gọi là đa hình thời gian chạy, theo đó việc triển khai thực sự của hàm được quyết định trong thời gian chạy hoặc thực thi. Tính đa hình động hoặc thời gian chạy có thể đạt được với sự trợ giúp của ghi đè phương thức.</p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa nạp chồng và ghi đè?",
              "answer": "<p>Nạp chồng là một tính năng đa hình thời gian biên dịch, trong đó một thực thể có nhiều triển khai có cùng tên. Ví dụ, nạp chồng phương thức và nạp chồng toán tử.\r\n\r\nTrong khi ghi đè là một tính năng đa hình thời gian chạy trong đó một thực thể có cùng tên, nhưng việc triển khai của nó thay đổi trong quá trình thực thi. Ví dụ, ghi đè phương thức.</p>",
              "level": "middle"
            },
            {
              "question": "Quá trình trừu tượng hóa dữ liệu được thực hiện như thế nào?",
              "answer": "<p>Sự trừu tượng hóa dữ liệu được thực hiện với sự trợ giúp của các phương thức trừu tượng hoặc các lớp trừu tượng.</p>",
              "level": "middle"
            },
            {
              "question": "Lớp trừu tượng là gì?",
              "answer": "<p>Một lớp trừu tượng là một lớp đặc biệt chứa các phương thức trừu tượng. Đặc trưng của lớp trừu tượng là các phương thức trừu tượng bên trong nó không được thực thi mà chỉ được khai báo. Do đó, khi một lớp con kế thừa lớp trừu tượng và cần sử dụng các phương thức trừu tượng của nó, chúng cần phải định nghĩa và triển khai chúng.</p>",
              "level": "middle"
            },
            {
              "question": "Một lớp trừu tượng khác với một interface như thế nào?",
              "answer": "<p>Interface và lớp trừu tượng đều là những kiểu lớp đặc biệt chỉ chứa phần khai báo các phương thức chứ không chứa phần thực thi của chúng. Nhưng interface hoàn toàn khác với một lớp trừu tượng. Sự khác biệt chính của cả hai là, khi một interface được triển khai, lớp con phải xác định tất cả các phương thức của nó và cung cấp cách triển khai của nó. Trong khi đó khi một lớp trừu tượng được kế thừa, lớp con không cần cung cấp định nghĩa về phương thức trừu tượng của nó, cho đến khi lớp con sử dụng nó.\r\n\r\nNgoài ra, một lớp trừu tượng có thể chứa các phương thức trừu tượng cũng như các phương thức không trừu tượng.</p>",
              "level": "middle"
            },
            {
              "question": "Các chỉ định truy cập là gì và ý nghĩa của chúng?",
              "answer": "<p>Các chỉ định truy cập là một loại từ khóa đặc biệt, được sử dụng để kiểm soát hoặc chỉ định khả năng truy cập của các thực thể như lớp, phương thức, v.v. Một số từ chỉ định truy cập hoặc công cụ sửa đổi truy cập bao gồm \"private\", \"public\", v.v… Các chỉ định truy cập này cũng đóng một vai trò rất quan trọng trong việc đạt được tính đóng gói - một trong những tính năng chính của OOP.</p>",
              "level": "middle"
            },
            {
              "question": "Ngoại lệ là gì?",
              "answer": "<p>Một ngoại lệ có thể được coi là một sự kiện đặc biệt, xuất hiện trong quá trình thực hiện một chương trình trong thời gian chạy, khiến việc thực thi bị tạm dừng. Lý do cho ngoại lệ chủ yếu là do một vị trí trong chương trình, nơi người dùng muốn làm điều gì đó mà chương trình không được chỉ định, chẳng hạn như đầu vào không mong muốn.</p>",
              "level": "middle"
            },
            {
              "question": "Xử lý ngoại lệ như thế nào?",
              "answer": "<p>Không ai muốn phần mềm của mình bị lỗi hoặc gặp sự cố. Các trường hợp ngoại lệ là lý do chính dẫn đến lỗi phần mềm. Các ngoại lệ có thể được xử lý trước trong chương trình và ngăn việc thực thi dừng lại. Đây được gọi là xử lý ngoại lệ.\r\n\r\nVì vậy, xử lý ngoại lệ là cơ chế xác định các trạng thái không mong muốn mà chương trình có thể có và xác định các kết quả mong muốn của các trạng thái đó.\r\n\r\n<strong>Try-catch</strong> là phương pháp phổ biến nhất được sử dụng để xử lý các ngoại lệ trong chương trình</p>",
              "level": "middle"
            },
            {
              "question": "Garbage collection trong OOP là gì?",
              "answer": "<p>Lập trình hướng đối tượng xoay quanh các thực thể như các đối tượng. Mỗi đối tượng sử dụng bộ nhớ và có thể có nhiều đối tượng của một lớp. Vì vậy, nếu các đối tượng này và dữ liệu của chúng không được xử lý đúng cách, thì nó có thể dẫn đến một số lỗi liên quan đến bộ nhớ và hệ thống có thể bị lỗi.\r\n\r\nBộ dọn gác - garbage collection - đề cập đến cơ chế xử lý bộ nhớ trong chương trình. Thông qua việc thu gom rác, bộ nhớ không mong muốn sẽ được giải phóng bằng cách loại bỏ các đối tượng không còn cần thiết.</p>",
              "level": "middle"
            },
            {
              "question": "Có thể chạy ứng dụng Java mà không triển khai các khái niệm OOP?",
              "answer": "<p>Không. Các ứng dụng Java dựa trên các mô hình lập trình hướng đối tượng hoặc khái niệm OOP, do đó chúng không thể được triển khai nếu không có nó.\r\n\r\nTuy nhiên, mặt khác, C ++ có thể được thực hiện mà không cần OOP, vì nó cũng hỗ trợ mô hình lập trình cấu trúc giống C.</p>",
              "level": "middle"
            }
          ]
        },
        {
          "id": "os",
          "name": "Câu hỏi phỏng vấn hệ điều hành",
          "description": "",
          "questions": [
            {
              "question": "Tại sao hệ điều hành quan trọng?",
              "answer": "<p>Hệ điều hành là phần thiết yếu và quan trọng nhất của máy tính mà không có nó thì máy tính gần như là vô dụng. Nó kích hoạt một giao diện hoặc hoạt động giống như một liên kết để tương tác giữa phần mềm máy tính được cài đặt trên hệ điều hành và người dùng. Đồng thời giúp giao tiếp với phần cứng và duy trì sự cân bằng giữa phần cứng và CPU. Nó cũng cung cấp các dịch vụ cho người dùng và một nền tảng cho các chương trình chạy trên đó. Nó thực hiện tất cả các tác vụ chung mà ứng dụng yêu cầu.</p>",
              "level": "fresher"
            },
            {
              "question": "Mục đích chính của hệ điều hành là gì? Các loại hệ điều hành khác nhau là gì?",
              "answer": "<p>Mục đích chính của HĐH là thực thi các chương trình của người dùng và giúp người dùng hiểu và tương tác với máy tính cũng như chạy các ứng dụng dễ dàng hơn. Nó được thiết kế đặc biệt để đảm bảo rằng hệ thống máy tính hoạt động tốt hơn bằng cách quản lý tất cả các hoạt động tính toán. Nó cũng quản lý bộ nhớ máy tính, các tiến trình và hoạt động của tất cả phần cứng và phần mềm.\r\n\r\nCác loại hệ điều hành:\r<ul><li>Batched OS (Payroll System, Transactions Process, ...)</li></ul>\r<ul><li>Multi-Programmed OS (Windows OS, UNIX OS, ...)</li></ul>\r<ul><li>Timesharing OS (Multics, ...)</li></ul>\r<ul><li>Distributed OS (LOCUS, ...)</li></ul>\r<ul><li>Real-Time OS (PSOS, VRTX, ...)</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Lợi ích của hệ thống đa xử lý?",
              "answer": "<p>Hệ thống đa xử lý là một loại hệ thống bao gồm hai hoặc nhiều CPU. Nó liên quan đến việc xử lý các chương trình máy tính khác nhau cùng một lúc, bởi hệ thống máy tính này có hai hoặc nhiều CPU đang chia sẻ một bộ nhớ duy nhất.\r\n\r\nLợi ích:\r<ul><li>Các hệ thống như vậy ngày nay được sử dụng rộng rãi để cải thiện hiệu suất trong các hệ thống đang chạy nhiều chương trình đồng thời.</li></ul>\r<ul><li>Bằng cách tăng số lượng bộ xử lý, số lượng tác vụ lớn hơn có thể được hoàn thành trong thời gian ngắn.</li></ul>\r<ul><li>Nó còn gia tăng đáng kể về thông lượng cũng như hiệu quả về chi phí vì tất cả các bộ xử lý đều chia sẻ cùng một nguồn tài nguyên.</li></ul>\r<ul><li>Cuối cùng là cải thiện độ tin cậy của hệ thống máy tính.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cấu trúc RAID trong hệ điều hành là gì?",
              "answer": "<p>RAID (Redundant Arrays of Independent Disks) là một phương pháp được dùng để lưu trữ dữ liệu trên nhiều đĩa cứng do đó có thể xem nó là một công nghệ lưu trữ dữ liệu ảo hoá để kết hợp nhiều đĩa cứng. Nhằm mụuc đích là cân bằng, bảo vệ dữ liệu, cải thiện hiệu suất hệ thống, không gian lưu trữ, v.v. \r\n\r\nNó được dùng để cải thiện toàn bộ hiệu suất và độ tin cậy của bộ lưu trữ dữ liệu. Nó còn tăng không gian lưu trữ của hệ thống nhằm mục đích chính là dự phòng dữ liệu để tránh thất thoát.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "GUI là gì?",
              "answer": "<p>GUI (Graphical User Interface) về cơ bản là một loại giao diện người dùng cho phép người dùng sử dụng đồ họa để tương tác với hệ điều hành. GUI được tạo ra vì nó thân thiện với người dùng hơn, ít phức tạp hơn và dễ hiểu hơn là một giao diện dòng lệnh. Mục tiêu chính của nó là tăng hiệu quả và dễ sử dụng. Thay vì phải ghi nhớ các lệnh, người dùng có thể chỉ cần click vào một nút để thực hiện công việc một cách đơn giản. Ví dụ về GUI bao gồm Microsoft Windows, macOS, v.v.</p>",
              "level": "fresher"
            },
            {
              "question": "Pipe là gì và khi nào sử dụng?",
              "answer": "<p>Pipe - đường ống - nói chung là một kết nối giữa hai hoặc nhiều tiến trình có liên quan đến nhau. Nó là một cơ chế được sử dụng để giao tiếp giữa các tiến trình bằng cách truyền tin nhắn. Người ta có thể dễ dàng gửi thông tin chẳng hạn như đầu ra của một tiến trình chương trình đến một tiến trình chương trình khác bằng cách sử dụng một đường ống. Nó có thể được sử dụng khi hai tiến trình muốn giao tiếp một chiều, tức là giao tiếp giữa các tiến trình (IPC).</p>",
              "level": "fresher"
            },
            {
              "question": "Các loại hoạt động khác nhau có thể có trên semaphore là gì?",
              "answer": "<p>Có hai hoạt động có thể là :\r<ul><li>Wait()</li></ul>\r<ul><li>Signal()</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Chương trình bootstrap trong hệ điều hành là gì?",
              "answer": "<p>Nó là một chương trình khởi tạo hệ điều hành trong quá trình khởi động, tức là dòng code đầu tiên được thực thi bất cứ khi nào hệ thống máy tính khởi động. Hệ điều hành được tải thông qua một tiến trình khởi động hoặc chương trình thường được gọi là booting. Nhìn chung hệ điều hành chỉ phụ thuộc vào chương trình bootstrap để thực hiện và hoạt động chính xác. Nó được lưu trữ đầy đủ trong các khối khởi động tại một vị trí cố định trên đĩa. Nó cũng định vị nhân (kernel) và tải nó vào bộ nhớ chính, sau đó chương trình bắt đầu thực thi.\r\n\r\n<img src=\"/interview-assets/boostrap_program_in_os.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Demand Paging là gì?",
              "answer": "<p>Demand paging (tạm dịch: phân trang theo yêu cầu) là một phương pháp tải các trang vào bộ nhớ theo yêu cầu. Phương pháp này chủ yếu được sử dụng trong bộ nhớ ảo. Trong đó, một trang chỉ được đưa vào bộ nhớ khi một vị trí trên trang cụ thể đó được tham chiếu trong quá trình thực thi. Các bước sau thường được tuân theo: \r<ul><li>Truy cập trang.</li></ul>\r<ul><li>Nếu trang đó hợp lệ (có trong bộ nhớ) các tiến trình của lệnh sẽ diễn ra bình thường</li></ul>\r<ul><li>Nếy là không hợp lệ, thì xảy ra <strong>page-fault trap</strong>.</li></ul>\r<ul><li>Kiểm tra nếu tham chiếu bộ là hợp lệ tham chiếu đến một vùng ở bộ nhớ phụ. Nếu không, tiến trình sẽ bị chấm dứt (<strong>truy cập bộ nhớ bất hợp pháp</strong>). Ngược lại, ta có trang trong trang được yêu cầu.</li></ul>\r<ul><li>Lên lịch hoạt động của đĩa để đọc trang mong muốn vào bộ nhớ chính.</li></ul>\r<ul><li>Khởi động lại lệnh đã bị gián đoạn bởi trap của hệ điều hành.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "RTOS là gì?",
              "answer": "<p>Real Time Operating System (RTOS) là một hệ điều hành được sử dụng cho các ứng thời gian thực. Nó hoạt động tốt hơn nhiều đối với các tác vụ cần được thực thi trong thời gian ngắn. Nó cũng xử lý các quá trình thực thi, giám sát và kiểm soát tất cả. Nó cũng chiếm ít bộ nhớ hơn và tiêu thụ ít tài nguyên hơn. \r\n\r\nCác loại RTOS:\r<ul><li>Hard Real-Time</li></ul>\r<ul><li>Firm Real-Time</li></ul>\r<ul><li>Soft Real-Time</li></ul>\r\n\r\n<img src=\"/interview-assets/RTOS.png\" alt=\"\" />\r\n\r\nRTOS được sử dụng trong Hệ thống kiểm soát không lưu, Hệ thống chống bó phanh và Máy tạo nhịp tim.</p>",
              "level": "fresher"
            },
            {
              "question": "Đồng bộ hoá tiến trình là gì?",
              "answer": "<p>Đồng bộ hóa tiến trình về cơ bản là một cách để điều phối các tiến trình sử dụng tài nguyên hoặc dữ liệu được chia sẻ. Điều cần thiết là đảm bảo thực hiện đồng bộ các tiến trình hợp tác để duy trì tính nhất quán của dữ liệu. Mục đích chính của nó là chia sẻ tài nguyên mà không có bất kỳ sự can thiệp nào bằng cách sử dụng loại trừ lẫn nhau. Có hai loại đồng bộ hóa tiến trình:\r<ul><li>Tiến trình độc lập</li></ul>\r<ul><li>Tiến trình hợp tác</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "IPC là gì? Các cơ chế IPC khác nhau?",
              "answer": "<p>IPC (Interprocess Communication) là một cơ chế yêu cầu sử dụng các tài nguyên như bộ nhớ được chia sẻ giữa các tiến trình hoặc luồng. Với IPC, hệ điều hành cho phép các tiến trình khác nhau giao tiếp với nhau. Nó được sử dụng để trao đổi dữ liệu giữa nhiều luồng trong một hoặc nhiều chương trình hoặc tiến trình. Trong cơ chế này, các tiến trình khác nhau có thể giao tiếp với nhau dưới sự chấp thuận của HĐH.\r\n\r\nCác cơ chế IPC khác nhau:\r<ul><li>Pipes</li></ul>\r<ul><li>Message Queuing</li></ul>\r<ul><li>Semaphores</li></ul>\r<ul><li>Socket</li></ul>\r<ul><li>Shared Memory</li></ul>\r<ul><li>Signals</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa bộ nhớ chính và bộ nhớ phụ?",
              "answer": "<p><strong>Bộ nhớ chính:</strong> bộ nhớ chính trong máy tính là RAM (Random Access Memory). Nó còn được gọi là bộ nhớ chính hoặc bộ nhớ đọc-ghi hoặc bộ nhớ trong. Các chương trình và dữ liệu mà CPU yêu cầu trong quá trình thực thi được lưu trữ trong bộ nhớ này.\r\n<strong>Bộ nhớ phụ:</strong> bộ nhớ phụ trong máy tính là thiết bị lưu trữ có thể lưu trữ dữ liệu và chương trình. Nó còn được gọi là bộ nhớ ngoài hoặc bộ nhớ bổ sung hoặc bộ nhớ dự phòng hoặc bộ nhớ phụ. Các thiết bị lưu trữ như vậy có khả năng lưu trữ dữ liệu kích cỡ lớn. Thiết bị lưu trữ có thể là ổ cứng, ổ USB flash, CD, v.v.\r\n\r\n| Bộ nhớ chính | Bộ nhớ phụ |\r\n|--------------|------------|\r\n|Dữ liệu được truy cập trực tiếp bởi đơn vị xử lý | Đầu tiên, dữ liệu được chuyển đến bộ nhớ chính và sau đó được chuyển đến đơn vị xử lý |\r\n| Có thể ổn định hoặc không ổn định | Luôn là ổn định |\r\n| Tốn nhiều chi phí hơn bộ nhớ phụ | Tốn ít chi phí hơn |\r\n| Dữ liệu chỉ được lưu trữ tạm thời | Dữ liệu được lưu trữ dài lâu |\r\n| Có thể mất dữ liệu khi sập nguồn | Dữ liệu không thể mất nếu sập nguồn |\r\n| Nhanh hơn bộ nhớ phụ và lưu dữ liệu đang được máy tính sử dụng | Chậm hơn nếu so với bộ nhớ chính và lưu nhiều kiểu định dạng dữ liệu |\r\n| Truy cập bằng dữ liệu | Truy cập bằng kênh I/O |</p>",
              "level": "fresher"
            },
            {
              "question": "Overlay trong hệ điều hành là gì?",
              "answer": "<p>Overlay về cơ bản là một phương pháp lập trình chia các tiến trình thành các phần để các lệnh quan trọng và cần thiết có thể được lưu vào bộ nhớ. Nó không cần bất kỳ loại hỗ trợ nào từ hệ điều hành. Nó có thể chạy các chương trình có kích thước lớn hơn bộ nhớ vật lý bằng cách chỉ giữ lại các dữ liệu và câu lệnh quan trọng có thể cần thiết tại bất kỳ thời điểm nào.</p>",
              "level": "fresher"
            },
            {
              "question": "Các hệ điều hành nổi tiếng?",
              "answer": "<p><em> MS-Windows\r\n</em> Ubuntu\r\n<em> Mac OS\r\n</em> Fedora\r\n<em> Solaris\r\n</em> Free BSD\r\n<em> Chrome OS\r\n</em> CentOS\r\n<em> Debian\r\n</em> Android\r\n\r\n## Câu hỏi phỏng vấn hệ điều hành cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Bộ nhớ ảo là gì?",
              "answer": "<p>Là một kỹ thuật quản lý bộ nhớ được thực hiện bởi hệ điều hành. Bộ nhớ ảo cho phép lập trình viên sử dụng nhiều bộ nhớ cho các chương trình hơn bộ nhớ vật lý có sẵn. Nếu bộ nhớ vật lý là 4GB và bộ nhớ ảo là 16 GB, lập trình viên có thể sử dụng bộ nhớ ảo 16 GB để thực hiện chương trình. Sử dụng bộ nhớ ảo, ta có thể thực thi các chương trình phức tạp đòi hỏi nhiều bộ nhớ hơn bộ nhớ vật lý.\r\n\r\nBộ nhớ ảo có thể quản lý theo hai cách phổ biến là phân trang (paging) và phân đoạn (segmentation).\r\n\r\n<img src=\"/interview-assets/virtual_memory.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Luồng trong hệ điều hành là gì?",
              "answer": "<p>Luồng (thread) là một đơn vị cơ bản trong CPU, nó là một dòng điều khiển trong một tiến trình, nó có thể thực hiện nhiều tác vụ tại một thời điểm. Nó bao gồm:\r<ul><li>ID của luồng</li></ul>\r<ul><li>Bộ đếm chương trình</li></ul>\r<ul><li>Ngăn xếp</li></ul>\r<ul><li>Tập thanh ghi trong tiến trình.</li></ul>\r\n\r\nNó giúp giao tiếp hiệu quả hơn và cho phép sử dụng kiến trúc đa xử lý ở quy mô lớn hơn và hiệu quả cao hơn, đồng thời giảm thời gian cần thiết trong chuyển đổi ngữ cảnh. Nó cung cấp một cách để cải thiện và tăng hiệu suất của các ứng dụng bằng song song (paralle). Các luồng đôi khi được gọi là tiến trình <strong>nhẹ</strong> vì nó có ngăn xếp riêng nhưng có thể truy cập dữ liệu chung.\r\n\r\nNhiều luồng chạy trong một tiến trình chia sẻ với nhau đoạn mã, đoạn dữ liệu và các tài nguyên hệ thống như tín hiệu, file,...\r\n\r\n<img src=\"/interview-assets/thread_in_os.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Tiến trình là gì? Các trạng thái tiến trình khác nhau?",
              "answer": "<p>Tiến trình về cơ bản là một chương trình hiện đang được thực thi. Chức năng chính của hệ điều hành là quản lý và xử lý tất cả các tiến trình này. Khi một chương trình được tải vào bộ nhớ và trở thành tiến trình nó có thể được chia thành bốn phần: heap, text, stack và data. Có hai loại tiến trình:\r\n1. Tiến trình hệ điều hành\r\n2. Tiến trình người dùng\r\n\r\n<img src=\"/interview-assets/states_of_process.png\" alt=\"\" />\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "FCFS nghĩa là gì?",
              "answer": "<p>FCFS (First Come First Serve) là một loại thuật toán định thời hệ điều hành thực thi các tiến trình theo thứ tự mà các tiến trình đến. Nói cách đơn giản, tiến trình nào đến trước sẽ được thực thi trước. Nó không có tính ưu tiên. Định thời FCFS có thể gây ra vấn đề chết đói nếu thời gian của tiến trình đầu tiên là lâu nhất trong số tất cả các tiến trình. Nó được coi là thuật toán định thời hệ điều hành dễ nhất và đơn giản nhất so với các thuật toán khác. Việc thực hiện FCFS thường được quản lý với sự trợ giúp của hàng đợi FIFO (First In First Out).</p>",
              "level": "fresher"
            },
            {
              "question": "Reentrancy là gì?",
              "answer": "<p>Reentrant là một chức năng trong đó các client khác nhau có thể sử dụng và chia sẻ một bản sao của một chương trình trong một khoảng thời gian tương tự. Khái niệm này thường được liên kết với code hệ điều hành và không liên quan đến đồng thời. Nó có hai chức năng chính:\r<ul><li>Mã chương trình không thể tự thay đổi hoặc chỉnh sửa.</li></ul>\r<ul><li>Dữ liệu cục bộ cho mọi tiến trình client cần được lưu trữ trong các đĩa khác nhau.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Thuật toán định thời là gì? Các loại thuật toán định thời?",
              "answer": "<p>Thuật toán định thời được sử dụng để cải thiện hiệu quả sử dụng CPU và cung cấp thời gian chờ tối thiểu cho các tác vụ. Nó chỉ đơn giản là giải quyết vấn đề quyết định yêu cầu nào trong số các yêu cầu còn tồn đọng sẽ được phân bổ tài nguyên. Mục đích chính của nó là giảm nạn đói tài nguyên và đảm bảo sự công bằng giữa các bên đang sử dụng tài nguyên. Nói cách đơn giản, nó được sử dụng để phân bổ tài nguyên giữa các nhiệm vụ cạnh tranh khác nhau.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa phân trang và phân đoạn?",
              "answer": "<p><strong>Phân trang:</strong> nói chung là một kỹ thuật quản lý bộ nhớ cho phép hệ điều hành truy xuất các tiến trình từ bộ nhớ phụ vào bộ nhớ chính. Nó là một kỹ thuật phân bổ không liền kề để phân chia mỗi tiến trình dưới dạng các trang.\r\n\r\n<strong>Phân đoạn:</strong> nói chung là một kỹ thuật quản lý bộ nhớ bằng cách chia các tiến trình thành các mô-đun và các phần có kích thước khác nhau. Các thành phần và mô-đun này được gọi là các phân đoạn có thể được phân bổ cho tiến trình.\r\n\r\n| Phân trang | Phân đoạn |\r\n|------------|-----------|\r\n| Là vô hình với lập trình viên | Lập trình viên có thể thấy |\r\n| Kích thước trang là cố định | Kích thước đoạn không cố định |\r\n| Thủ tục và dữ liệu không thể tách biệt trong phân trang | Thủ tục và dữ liệu có thể tách biệt trong phân đoạn |\r\n| Nó cho phép tổng số không gian bộ nhớ ảo vượt qua bộ nhớ vật lý | Nó cho phép tất cả các chương trình, dữ liệu và code chia thành các không gian địa chỉ độc lập |\r\n| Khả dụng với hầu hết CPU và MMU | Khả dụng với Window Server có hỗ trợ khả năng tương thích ngược, trong khi Linuxx hạn chế hỗ trợ | \r\n| Truy cập dữ liệu nhanh hơn so với phân đoạn | Chậm hơn so với phân trang |\r\n| Hệ điều hành cần duy trì một frame | Hệ điều hành cần một danh sách đen của bộ nhớ chính |\r\n| Phân mảnh bên trong | Phân mảnh bên ngoài |\r\n| Kích thước trang được quyết định bởi bộ nhớ khả dụng | Kích thước đoạn được quyết định bởi người dùng |</p>",
              "level": "fresher"
            },
            {
              "question": "Thrashing trong hệ điều hành là gì?",
              "answer": "<p>Thrashing xảy ra khi không có đủ bộ nhớ để lưu trữ các bộ làm việc của tất cả các chương trình đang hoạt động.\r\n\r\nNó thường là một tình huống trong đó CPU thực hiện công việc kém hiệu quả hơn. Nó dành nhiều thời gian cho các hoạt động hoán đổi hoặc phân trang hơn là thực thi. Bằng cách đánh giá mức độ sử dụng CPU, một hệ thống có thể phát hiện ra thrashing. Nó xảy ra khi tiến trình không có đủ trang do đó tỷ lệ lỗi trang tăng lên. Nó ức chế nhiều tiến trình xử lý ở cấp độ ứng dụng khiến hiệu suất máy tính giảm hoặc sập.</p>",
              "level": "fresher"
            },
            {
              "question": "Đối tượng chính trong Đa chương trình là gì?",
              "answer": "<p>Đa chương trình (multiprogramming) đề cập đến khả năng thực thi nhiều hơn một chương trình trên một bộ xử lý duy nhất. Kỹ thuật này được giới thiệu để khắc phục tình trạng CPU và bộ nhớ hoạt động kém hiệu quả. Nói một cách dễ hiểu, nó là sự phối hợp thực hiện đồng thời nhiều chương trình khác nhau trên một bộ xử lý (CPU). Mục tiêu chính của đa chương trình là luôn có ít nhất một tiến trình chạy mọi thời điểm. Nó cải thiện việc sử dụng CPU vì nó tổ chức nhiều công việc trong đó CPU luôn có một công việc để thực thi. \r\n\r\n<img src=\"/interview-assets/multiprogramming.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Nhóm bất đối xứng là gì?",
              "answer": "<p>Asymmetric Clustering, tạm dịch nhóm bất đối xứng là một hệ thống trong đó một máy trong số tất cả các máy ở chế độ dự phòng nóng (hot standby) trong khi tất cả các máy còn lại chạy các ứng dụng khác nhau. Nói đơn giản hơn là nó sử dụng toàn bộ tài nguyên cứng do đó nó là một hệ thống đáng tin cậy so với những hệ thống khác.\r\n\r\n<img src=\"/interview-assets/asymmetric_cluttering.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa đa nhiệm và đa tiến trình là gì?",
              "answer": "<p><strong>Đa nhiệm (multitasking)</strong> là khi một CPU duy nhất thực hiện một số tác vụ (chương trình, quy trình, tác vụ, luồng) cùng một lúc. Để thực hiện đa nhiệm, CPU chuyển đổi giữa các nhiệm vụ rất thường xuyên để người dùng có thể tương tác với từng chương trình cùng một lúc.\r\n\r\n<img src=\"/interview-assets/multitasking-os.png\" alt=\"\" />\r\n\r\n<strong>Đa tiến trình (multiprocessing):</strong> Nó là một hệ thống cho phép nhiều bộ xử lý khác nhau trong máy tính xử lý đồng thời hai hoặc nhiều phần khác nhau của cùng một chương trình. Nó được sử dụng để hoàn thành nhiều công việc hơn trong một khoảng thời gian ngắn hơn.\r\n\r\n<img src=\"/interview-assets/multiprocessing.png\" alt=\"\" />\r\n\r\n| Đa nhiệm | Đa tiến trình |\r\n|----------|---------------|\r\n| Thực hiện nhiều tác vụ cùng lúc bằng một bộ xử lý duy nhất | Thực hiện nhiều tác vụ cùng lúc bằng nhiều bộ xử lý |\r\n| Số lượng CPU là một | Nhiều hơn một CPU |\r\n| Tiết kiệm hơn | Ít tiết kiệm |\r\n| Kém hiệu quả hơn đa tiến trình | Hiệu quả hơn đa nhiệm |\r\n| Cho phép chuyển đổi nhanh các tác vụ khác nhau | Cho phép xử lý mượt mà nhiều tiến trình cùng lúc |\r\n| Yêu cầu nhiều thời gian hơn so với đa tiến trình | Ít thời gian hơn so với đa nhiệm |</p>",
              "level": "fresher"
            },
            {
              "question": "Socket trong hệ điều hành là gì?",
              "answer": "<p>Socket trong hệ điều hành thường được coi là endpoint cho IPC (Interprocess Communication). Ở đây, endpoint được gọi là sự kết hợp của địa chỉ IP và số cổng (port). Sockets được sử dụng để giúp các nhà phát triển phần mềm dễ dàng tạo các chương trình hỗ trợ mạng. Nó cũng cho phép giao tiếp hoặc trao đổi thông tin giữa hai tiến trình khác nhau trên cùng một máy hoặc nhiều máy. Nó chủ yếu được sử dụng trong các hệ thống dựa trên mô hình client-server.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về tiến trình thây ma?",
              "answer": "<p>Tiến trình thây ma (zombie process) đề cập đến tiến trình không tồn tại, về cơ bản là một tiến trình đã kết thúc hoặc hoàn thành nhưng toàn bộ khối điều khiển tiến trình không được dọn sạch khỏi bộ nhớ chính vì nó vẫn có một mục trong bảng tiến trình để báo cáo cho tiến trình cha của nó. Nó không tiêu thụ bất kỳ tài nguyên nào và đã chết, nhưng nó vẫn tồn tại. Nó cũng cho thấy rằng tài nguyên được nắm giữ bởi tiến trình và không được giải phóng.</p>",
              "level": "fresher"
            },
            {
              "question": "Kết thúc hàng loạt là gì?",
              "answer": "<p>Kết thúc hàng loạt (cascading termination) là sự kết thúc tiến trình trong đó nếu tiến trình cha đang thoát hoặc kết thúc thì tiến trình con cũng sẽ bị chấm dứt. Nó không cho phép tiến trình con tiếp tục xử lý khi tiến trình cha của nó đã kết thúc. Nó thường được khởi tạo bằng hệ điều hành.</p>",
              "level": "fresher"
            },
            {
              "question": "Starvation và aging trong hệ điều hành là gì?",
              "answer": "<p><strong>Starvation</strong>: là vấn đề thường xảy ra khi một tiến trình không thể nhận được các tài nguyên cần thiết mà nó cần để tiến trình thực thi trong một khoảng thời gian dài. Trong điều kiện này, các tiến trình có mức độ ưu tiên thấp bị chặn và chỉ các tiến trình có mức độ ưu tiên cao mới tiếp tục hoàn thành, vì thế các tiến trình có mức độ ưu tiên thấp bị thiếu tài nguyên. \r\n\r\n<strong>Aging</strong>: là một kỹ thuật được sử dụng để khắc phục vấn đề <em>starvation</em>. Nó đơn giản là tăng mức độ ưu tiên của các tiến trình chờ tài nguyên trong hệ thống trong một khoảng thời gian dài. Nó được coi là kỹ thuật tốt nhất để giải quyết vấn đề starvation vì nó thêm một yếu tố aging vào mức độ ưu tiên của mọi yêu cầu của các tiến trình khác nhau về tài nguyên. Nó cũng đảm bảo rằng các công việc hoặc tiến trình cấp thấp hoàn thành việc thực thi của chúng.</p>",
              "level": "fresher"
            },
            {
              "question": "Semaphore là gì trong hệ điều hành?",
              "answer": "<p>Semaphore là một cơ chế báo hiệu. Nó chỉ chứa một giá trị nguyên dương. Được sử dụng để giải quyết vấn đề hoặc sự cố của các phần quan trọng trong quá trình đồng bộ hóa bằng cách sử dụng hai hoạt động cơ bản, là <code>wait()</code> và <code>signal()</code>.\r\n\r\nCó hai loại semaphore là:\r\n<em> Binary Semaphore\r\n</em> Counting Semaphore\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Kernel là gì? Chức năng chính của nó?",
              "answer": "<p>Kernel là một chương trình máy tính điều khiển mọi thứ khác, nó là hạt nhân - trái tim của hệ điều hành! Bất cứ điều gì xảy ra trên máy tính đều đi qua nó. Đó là chương trình cốt lõi trong hệ điều hành, cũng là chương trình đầu tiên tải sau khi bộ nạp khởi động. Sau đó, nó thực hiện tất cả các cuộc nói chuyện giữa phần cứng và phần mềm hoặc ứng dụng. Vì vậy, nếu bạn khởi chạy một chương trình, giao diện người dùng sẽ gửi yêu cầu tới Kernel. Kernel sau đó gửi yêu cầu tới CPU, Bộ nhớ để gán sức mạnh xử lý, bộ nhớ và những thứ khác để ứng dụng có thể chạy trơn tru ở giao diện người dùng.\r\n\r\n<img src=\"/interview-assets/kernel-os.png\" alt=\"\" />\r\n\r\nChức năng chính của Kernel:\r\n<em> Nó chịu trách nhiệm quản lý tất cả các tài nguyên máy tính như CPU, bộ nhớ, file, tiến trình, v.v.\r\n</em> Nó tạo điều kiện hoặc khởi tạo sự tương tác giữa các thành phần của phần cứng và phần mềm.\r\n<em> Nó quản lý bộ nhớ RAM để tất cả các tiến trình và chương trình đang chạy có thể hoạt động hiệu quả.\r\n</em> Nó cũng kiểm soát và quản lý tất cả các tác vụ chính của HĐH cũng như quản lý việc truy cập và sử dụng các thiết bị ngoại vi khác nhau được kết nối với máy tính.\r<ul><li>Nó lên kế hoạch cho công việc được thực hiện bởi CPU để công việc của mỗi người dùng được thực thi một cách hiệu quả nhất có thể.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu Kernel khác nhau?",
              "answer": "<p><ul><li>Monolithic Kernel</li></ul>\r<ul><li>MicroKernel</li></ul>\r<ul><li>Hybrid Kernel </li></ul>\r<ul><li>Nano Kernel</li></ul>\r<ul><li>Exo Kernel</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa MircoKernel và Monolithic Kernel?",
              "answer": "<p><strong>MicroKernel:</strong> là lượng phần mềm gần như tối thiểu có thể cung cấp các cơ chế cần thiết để triển khai một hệ điều hành.\r\nVd: QNX, Mac OS X, K42,...\r\n\r\n<strong>Monolithic Kernel:</strong> là một kiến trúc hệ điều hành hỗ trợ tất cả các tính năng cơ bản của các thành phần máy tính như quản lý tài nguyên, bộ nhớ, file, v.v.\r\nVd: Solaris, DOS, Linux, ...\r\n\r\n<img src=\"/interview-assets/monolithic_and_microkernel.png\" alt=\"\" />\r\n\r\n| MicroKernel | Monolithic Kernel |\r\n|-------------|-------------------|\r\n| Dịch vụ kernel và dịch vụ người dùng ở các không gian địa chỉ khác nhau | Dịch vụ kernel và dịch vụ người dùng ở cùng không gian địa chỉ |\r\n| Kích cỡ nhỏ | Kích cỡ lớn |\r\n| Dễ mở rộng | Khó mở rộng |\r\n| Khi dịch vụ hỏng, nó ảnh hưởng đến hoạt động của microkernel | Khi dịch vụ hỏng, toàn bộ hệ thống sẽ hỏng trên monolithic kernel |\r\n| Sử dụng message queue để giao tiếp giữa các inter-process | Sử dụng signal và socket để giao tiếp giữa các inter-process |</p>",
              "level": "fresher"
            },
            {
              "question": "SMP là gì?",
              "answer": "<p>SMP (Symmetric Multiprocessing) đề cập đến kiến trúc máy tính trong đó việc xử lý các chương trình được thực hiện bởi nhiều bộ xử lý chia sẻ một hệ điều hành và bộ nhớ chung. SMP rất cần thiết nếu bạn muốn tận dụng phần cứng đa xử lý. Nó cho phép bất kỳ bộ xử lý nào hoạt động trên bất kỳ tác vụ nào bất kể dữ liệu hoặc tài nguyên cho tác vụ cụ thể đó nằm ở đâu trong bộ nhớ. Các hệ thống này đáng tin cậy hơn các hệ thống một bộ xử lý.</p>",
              "level": "fresher"
            },
            {
              "question": "Hệ thống chia sẻ thời gian là gì?",
              "answer": "<p>Nó là một hệ thống cho phép nhiều người dùng truy cập vào các tài nguyên của một hệ thống cụ thể ở nhiều vị trí. Nói cách đơn giản, nó thực hiện nhiều tác vụ trên một bộ xử lý hoặc CPU. Như tên cho thấy, nó có nghĩa là chia sẻ thời gian vào nhiều thời điểm trong một số tiến trình. Nó cũng cho phép những người dùng khác nhau từ các địa điểm khác nhau sử dụng một hệ thống máy tính cụ thể cùng một lúc, do đó nó được coi là một trong những loại hệ điều hành quan trọng.</p>",
              "level": "fresher"
            },
            {
              "question": "Context Switching là gì?",
              "answer": "<p>Context switching về cơ bản là một quá trình lưu ngữ cảnh của một tiến trình và tải ngữ cảnh của một tiến trình khác. Đây là một trong những biện pháp hiệu quả về chi phí và tiết kiệm thời gian được thực hiện bởi CPU vì nó cho phép nhiều tiến trình chia sẻ một CPU. Vì vậy, nó được coi là một phần quan trọng của HĐH hiện đại. Kỹ thuật này được OS sử dụng để chuyển một tiến trình từ trạng thái này sang trạng thái khác, tức là từ trạng thái <strong>running</strong> sang trạng thái <strong>ready</strong>. Nó cũng cho phép một CPU duy nhất xử lý và kiểm soát nhiều tiến trình hoặc luồng khác nhau mà thậm chí không cần thêm tài nguyên.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Kernel và hệ điều hành?",
              "answer": "<p><strong>Kernel:</strong> là một chương trình hệ thống điều khiển tất cả chương trình đang chạy trên máy tính. Kernel là cầu nối giữa phần cứng và phần mềm trong hệ thống.\r\n<strong>OS:</strong> là chương trình máy tính cung cấp một giao diện người dùng để có thể thực hiện các thao tác trên máy tính một cách dễ dàng.\r\n\r\n<img src=\"/interview-assets/kernel_oS.png\" alt=\"\" />\r\n\r\n| Kernel | OS |\r\n|--------|----|\r\n| Nó là thành phần phần trung tâm của hệ điều hành | Nó là một phần mềm hệ thống |\r\n| Có nhiệm vụ chuyển đổi lệnh người dùng thành lệnh máy tính | Có nhiệm vụ quản lý tài nguyên hệ thống |\r\n| Là interface giữa phần cứng và ứng dụng | Là interface giữa phần cứng và người dùng |\r\n| Thực hiện các chức năng như quản lý tiến trình, file, thiết bị, giao tiếp I/O | Thực hiện các chức năng như bảo mật dữ liệu, file, điều khiển truy cập người dùng, duy trì chính sách hệ thống,... |\r\n| Có kiểu là MicroKernel, Monolithic Kernel | Có kiểu là Single và Multiprogramming batch systems, Distributed OS, Real-time OS |</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa tiến trình và luồng?",
              "answer": "<p><strong>Tiến trình (process):</strong> là chương trình đang được thực thi hiện tại bởi một hay nhiều luồng. Nó là rất quan trọng trong các hệ điều hành hiện đại.\r\n\r\n<strong>Luồng (thread):</strong> là đường dẫn thực thi bao gồm id của luồng, bộ đếm chương trình, ngăn xếp và tập thanh ghi trong tiến trình.\r\n\r\n<img src=\"/interview-assets/Process_and_Thread.png\" alt=\"\" />\r\n\r\n| Tiến trình | Luồng |\r\n|------------|-------|\r\n| Là chương trình đang được thực thi | Là thành phần của tiến trình, là đơn vị thực thi nhỏ nhất |\r\n| Có không gian bộ nhớ riêng | Dùng bộ nhớ của tiến trình |\r\n| Khó để tạo tiến trình | Dễ dàng tạo luồng |\r\n| Yêu cầu nhiều tài nguyên | Yêu cầu ít tài nguyên |\r\n| Mất thời gian để tạo và huỷ | Ít tốn thời gian cho tạo và huỷ |\r\n| Thường chạy trong không gian bộ nhớ riêng biệt | Thường chạy trong không gian bộ nhớ chung |\r\n| Không chia sẻ dữ liệu | Chia sẻ dữ liệu với nhau |\r\n| Có thể được chia trong đa luồng | Không thể chia |</p>",
              "level": "fresher"
            },
            {
              "question": "Các thành phần khác nhau của tiến trình?",
              "answer": "<p>Nó có 4 thành phần như sau:\r\n\r\n<img src=\"/interview-assets/OS_Process.png\" alt=\"\" />\r\n\r\n<em> <strong>Stack</strong>: dùng cho biến cục bộ và trả về địa chỉ.\r\n</em> <strong>Heap</strong>: dùng cho cấp phát bộ nhớ động.\r\n<em> <strong>Data</strong>: dùng cho lưu trữ biến toàn cục và biến tĩnh.\r\n</em> <strong>Text</strong>: bao gồm code chương trình đã biên dịch.</p>",
              "level": "fresher"
            },
            {
              "question": "Deadlock trong hệ điều hành là gì?",
              "answer": "<p>Trong môi trường đa chương, nhiều tiến trình có thể cạnh tranh một số tài nguyên giới hạn. Một tiến trình yêu cầu tài nguyên, nếu tài nguyên không có sẵn tại thời điểm đó, tiến trình đi vào trạng thái chờ. Tiến trình chờ có thể không bao giờ chuyển trạng thái vì tài nguyên chúng yêu cầu bị giữ bởi những tiến trình chờ khác. Trường hợp này gọi là deadlock (khoá chết)\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Belady’s Anomaly nghĩa là gì?",
              "answer": "<p>Trong hệ điều hành, dữ liệu tiến trình được tải theo các phần có kích thước cố định và mỗi phần được gọi là một trang. Bộ xử lý tải các trang này trong các phần bộ nhớ có kích thước cố định được gọi là frame. Nghịch lý Belady (Belady’s Anomaly) là một hiện tượng mà nếu chúng ta tăng số lượng frame trong bộ nhớ, thì số lỗi trang cũng tăng lên. Nó thường được xuất hiện khi ta sử dụng thuật toán thay thế trang FIFO (First in First out).</p>",
              "level": "fresher"
            },
            {
              "question": "Spooling trong hệ điều hành là gì?",
              "answer": "<p>Spooling là viết tắt của Simultaneous peripheral operations online. Spool là một loại bộ đệm chứa các công việc cho một thiết bị cho đến khi thiết bị sẵn sàng chấp nhận công việc. Spooling coi đĩa là một bộ đệm khổng lồ có thể lưu trữ nhiều công việc cho thiết bị cho đến khi các thiết bị đầu ra sẵn sàng chấp nhận chúng.\r\n\r\nTrong spooling, I/O của một công việc bị chồng chéo với tính toán của một công việc khác. Ví dụ, bộ đệm tại một thời điểm có thể đọc đầu vào của một công việc, đồng thời, nó cũng có thể in đầu ra của một công việc khác. Spooling tăng hiệu suất của hệ thống bằng cách tăng tốc độ làm việc của các thiết bị. Nó tự nhiên dẫn đến đa chương trình.</p>",
              "level": "fresher"
            }
          ]
        }
      ]
    },
    {
      "id": "mobile",
      "name": "Mobile Development",
      "icon": "phone_iphone",
      "color": "#00bcd4",
      "subcategories": [
        {
          "id": "android",
          "name": "Câu hỏi phỏng vấn Android",
          "description": "",
          "questions": [
            {
              "question": "Android là gì?",
              "answer": "<p>Android là một hệ điều hành nguồn mở được sử dụng trên các thiết bị di động, như điện thoại di động và máy tính bảng. Ứng dụng Android thực thi trong tiến trình  của nó và của Dalvik Virtual Machine (DVM) hoặc Android RunTime (ART).</p>",
              "level": "fresher"
            },
            {
              "question": "Kiến trúc của Android?",
              "answer": "<p>Kiến trúc của Android gồm các tầng khác nhau trong Android Stack. Nó bao gồm hệ điều hành, middleware và ứng dụng. Mỗi tầng trong kiến trúc Android cung cấp các dịch vụ khác nhau cho tầng ngay trên nó. \r\n\r\n5 tầng trong Android:\r\n\r\n<em> <strong>Linux Kernel</strong> - Nó chịu trách nhiệm về trình điều khiển thiết bị, quản lý thiết bị, quản lý bộ nhớ, quản lý nguồn và truy cập tài nguyên.\r\n</em> <strong>Libraries</strong> - là tập hợp các bộ thư viện mã nguồn mở như WebKit, thư viện libc, thư viện cho mở phát nhạc hay video, cơ sở dữ liệu SQLite cho chia sẻ dữ liệu và bộ nhớ ứng dụng, thư viện SSL cho bảo mật internet.\r\n<em> <strong>Android Runtime</strong> - đây là thư viện lõi cùng với DVM (Dalvik Virtual Machine) hoặc ART(Android RunTime) giúp chạy ứng dụng Android. DVM được tối ưu hoá cho các thiết bị di đông, nó cung cấp hiệu suất nhanh và tiêu tốn ít bộ nhớ hơn. Thay thế DVM, ARM được giới thiệu để thực thi các ứng dụng Android từ phiên bản Android lollipop 5.0 (API 21). \r\n</em> <strong>Android Framework</strong> - nó bao gồm Android APIs như  UI (User Interface), nguồn tài nguyên, tài nguyên, nhà cung cấp nội dung (dữ liệu), vị trí, điện thoại và trình quản lý package. Nó cung cấp các giao diện và lớp để phát triển các ứng dụng Android. \r<ul><li><strong>Android Applications</strong> - Các ứng dụng như trang chủ, trò chơi, danh bạ, cài đặt, trình duyệt, v.v. sử dụng Android Framework, để sử dụng Android runtime và libraries.</li></ul>\r\n\r\n<img src=\"/interview-assets/Android_Architecture.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các ngôn ngữ sử dụng cho Android?",
              "answer": "<p>Các ngôn ngữ lập trình phổ biến dùng cho phát triển ứng dụng Android là:\r\n1. <strong>Java</strong>: Được phát hành năm 1995 bởi Sun Microsystems, Java là ngôn ngữ then chốt của Android. Bộ công cụ phát triển phần mềm Android SDK (Software Development Kit) sử dụng Java như ngôn ngữ nền tảng cho các ứng dụng Android. Khá là dễ dàng để sử dụng Java, đặc biệt là trong Android Studio IDE dùng phát triển các ứng dụng dành cho Android.\r\n2. <strong>Koltin</strong>: Kotlin được phát triển để giải quyết một vài vấn đề tồn tại trong Java. Theo đa số những người ủng hộ việc sử dụng Kotlin, thì syntax của nó đơn giản và gọn hơn, vì thế rất ít xảy ra việc dòng code rườm rà, dài dòng. Điều này có tác dụng giúp cho người viết tập trung trong việc giải quyết các vấn đề hơn là cố để xoay sở với những câu lệnh dài dòng phức tạp. Bên cạnh đó, bạn còn có thể kết hợp Kotlin và Java cùng nhau ở trong cùng một dự án, khai thác hết thế mạnh của cả 2 ngôn ngữ.\r\n3. <strong>C#:</strong> C# là ngôn ngữ lập trình rất nổi tiếng của Microsoft. Với sự hỗ trợ của framework Xamarin, bạn có thể xây dựng ứng dụng Android bằng C#. Xamarin là một framework đa nền tảng, cho phép bạn phát phiển ứng dụng iOS, Android, Windows.\r\n4. <strong>C++:</strong> C++ là ngôn ngữ lập trình mạnh trong việc xây dựng các ứng dụng di động dành riêng cho android và cho windows. đây là ngôn ngữ dành cho lập trình cấp thấp và cũng là ngôn ngữ được các nhà phát triển ứng dụng trên thiết bị di động.\r\n5. <strong>Python</strong>: Python dù không được hệ điều hành Android hỗ trợ những vẫn được sử dụng trong việc tạo ra các apps trên python rồi chuyển thành apk để chạy trên thiết bị android.\r\n\r\nBên cạnh đó bạn cũng có thể dùng các framework như Flutter (ngôn ngữ Dart) hay React Native (ngôn ngữ JavaScript) để lập trình với Android.</p>",
              "level": "fresher"
            },
            {
              "question": "Một activity là gì?",
              "answer": "<p>Activity trong Android là một màn hình đơn để biểu diễn GUI (Graphical User Interface) cho người dùng có thể tương tác và thực hiện một số hành động.\r\n\r\nVí dụ: trang bắt đầu của Facebook là nơi để nhập email/số điện thoại và mật khẩu để đăng nhập, nó là một activity.</p>",
              "level": "fresher"
            },
            {
              "question": "Service trong Android là gì?",
              "answer": "<p>Service là một thành phần ứng dụng chạy ở chế độ nền có thể thực hiện các hoạt động lâu dài, nó không cung cấp một giao diện người dùng. Một service có thể chạy liên tục trong nền ngay cả khi ứng dụng bị đóng hay người dùng chuyển sang ứng dụng khác.</p>",
              "level": "fresher"
            },
            {
              "question": "Phân biệt Activity và Service?",
              "answer": "<p>Activity có thể bị dừng hoặc kết thúc bất cứ khi nào bởi người dùng. Ngược lại, service được thiết kế để chạy ngầm, nên chúng có thể hoạt động độc lập.\r\n\r\nPhần lớn các service chạy liên tục không quan tâm có hay không có activity nào đang thực hiện không.\r\n\r\n| Activity | Service |\r\n|-|-|\r\n| Được thiết kế để chạy ở trền nền | Được thiết kế để chạy nền, nhưng cũng có thể chạy ở trên nền | \r\n| Cần sử dụng giao diện người dùng | Không nhất thiết phải dùng giao diện người dùng |\r\n| Phụ thuộc | Độc lập |</p>",
              "level": "fresher"
            },
            {
              "question": "Google Android SDK là gì?",
              "answer": "<p>Google Android SDK là một bộ công cụ được các nhà phát triển sử dụng để viết ứng dụng trên các thiết bị hỗ trợ Android. Các công cụ trong Android SDK bao gồm:\r<ul><li>Android Emulator - Trình giả lập Android là ứng dụng phần mềm mô phỏng thiết bị Android trên máy tính để bạn có thể kiểm tra ứng dụng trên nhiều loại thiết bị và các cấp Android API mà không cần từng thiết bị vật lý.</li></ul>\r<ul><li>DDMS (Dalvik Debug Monitoring Services) - Đây là một công cụ debug từ bộ phát triển phần mềm Android (SDK), cung cấp các dịch vụ như tạo thông báo, giả mạo cuộc gọi, chụp ảnh màn hình, v.v.</li></ul>\r<ul><li>ADB (Android Debug Bridge) - Đây là một công cụ dòng lệnh được sử dụng để cho phép và kiểm soát giao tiếp với phiên bản giả lập.</li></ul>\r<ul><li>AAPT (Android Asset Packaging Tool) - Đây là một công cụ xây dựng cung cấp cho các nhà phát triển khả năng xem, tạo và cập nhật các kho lưu trữ tương thích với ZIP (zip, jar và apk).</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách dùng bundle trong Android?",
              "answer": "<p>Các bundle được sử dụng để chuyển dữ liệu cần thiết giữa các activity khác nhau của Android. Chúng giống như HashMap có thể nhận các kiểu dữ liệu thông thường. Đoạn code dưới đây hiển thị cách chuyển một phần dữ liệu bằng cách sử dụng bundle:\r\n\r\n``<code>java\r\nBundle b=new Bundle();\r\nb.putString(&quot;Email&quot;,&quot;abc@xyz.com&quot;);\r\ni.putExtras(b); // where i is intent\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Adapter trong Android là gì?",
              "answer": "<p>Một adapter trong Android giống như một cây cầu giữa AdapterView và dữ liệu cơ bản cho view. Adapter giữ dữ liệu và gửi nó cho AdapterView, view có thể lấy dữ liệu từ AdapterView và hiển thị dữ liệu cho các view khác như SpinnerView, ListView, GridView,...\r\n\r\n<img src=\"/interview-assets/adapter.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "AAPT là gì?",
              "answer": "<p>AAPT là viết tắt của Android Asset Packaging Tool. Đây là một công cụ xây dựng cung cấp cho các nhà phát triển khả năng xem, tạo và cập nhật các kho lưu trữ tương thích với ZIP (zip, jar và apk). Nó phân tích cú pháp, lập chỉ mục và biên dịch các tài nguyên thành định dạng nhị phân được tối ưu hóa cho nền tảng Android.</p>",
              "level": "fresher"
            },
            {
              "question": "Điểm phát sóng Wi-Fi di động là gì?",
              "answer": "<p>Điểm truy cập Wi-Fi di động cho phép bạn chia sẻ kết nối Internet di động của mình với các thiết bị không dây khác. Ví dụ: sử dụng điện thoại Android làm điểm phát sóng Wi-Fi, bạn có thể sử dụng máy tính xách tay của mình để kết nối internet bằng điểm truy cập đó.</p>",
              "level": "fresher"
            },
            {
              "question": "ADB là gì?",
              "answer": "<p>ADB (Android Debug Bridge) là một công cụ dòng lệnh được sử dụng để cho phép và kiểm soát giao tiếp với một phiên bản giả lập. Nó cung cấp tính năng cho các nhà phát triển thực thi các lệnh shell từ xa để chạy các ứng dụng trên trình giả lập.</p>",
              "level": "fresher"
            },
            {
              "question": "DDMS là gì?",
              "answer": "<p>DDMS (Dalvik Debug Monitor Server) là công cụ gỡ lỗi trên nền tảng Android. Nó cung cấp các tính năng như:\r<ul><li>Chụp ảnh màn hình</li></ul>\r<ul><li>Theo dõi lưu lượng mạng</li></ul>\r<ul><li>Cuộc gọi giả mạo SMS</li></ul>\r<ul><li>Giả mạo dữ liệu vị trí</li></ul>\r<ul><li>Logcat</li></ul>\r<ul><li>Thông tin thread và heap</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "AIDL là gì?",
              "answer": "<p>AIDL - Android Interface Definition Language là một cách cho phép bạn có thể định nghĩa một cách mà cả client và server (1 ứng dụng đóng vai trò là server cho các ứng dụng khác đóng vai trò là client có thể truy cập tới) có thể giao tiếng với nhau thông qua Interprocess communication (IPC). Thông thường, trong Android một process (tiến trình) không thể trực tiếp truy cập vào bộ nhớ của một tiến trình khác. Vì vậy để có thể các tiến trình có thể giao tiếp với nhau, chúng cần phân tách các đối tượng thành dạng nguyên thủy (primitive) mà hệ thống có thể hiểu được.\r\n\r\nCác kiểu dữ liệu được hỗ trợ trong AIDL là:\r<ul><li>String</li></ul>\r<ul><li>List</li></ul>\r<ul><li>Map</li></ul>\r<ul><li>CharSequence</li></ul>\r<ul><li>Kiểu dữ liệu Java (int, long, char, and boolean)</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Vòng đời của Android Activity?",
              "answer": "<p><ul><li><code>onCreate()</code>: được gọi khi activity được tạo. Nó được dùng để tạo view và dữ liệu từ bundles.</li></ul>\r<ul><li><code>onStart()</code>: được gọi khi activity được hiển thị với người dùng. Nó có thể thành công bằng <code>onResume()</code> nếu activity xuất hiện trên nền hoặc <code>onStop()</code> bị ẩn.</li></ul>\r<ul><li><code>onResume()</code>: nó được gọi khi activity được chạy để tương tác với người dùng.</li></ul>\r<ul><li><code>onPause()</code>: nó được gọi khi activity được chạy trong nền nhưng chưa dừng hoàn toàn.</li></ul>\r<ul><li><code>onStop()</code>: được gọi khi activity không còn hiển thị với người dùng.</li></ul>\r<ul><li><code>onDestroy()</code>: được gọi khi một activity bị huỷ hay kết thúc.</li></ul>\r<ul><li><code>onRestart()</code>: được gọi khi một activity đã dừng, nhằm mục đích khởi động lại nó.</li></ul>\r\n\r\n<img src=\"/interview-assets/Life_Cycle_of_Android.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Cảm biến trong Android?",
              "answer": "<p>Các thiết bị sử dụng hệ điều hành Android có một bộ sưu tập các cảm biến tích hợp bên trong, chúng đo các thông số nhất định như chuyển động, định hướng và nhiều thông số khác thông qua độ chính xác cao của chúng. Các cảm biến có thể là cả phần cứng và phần mềm dựa trên tự nhiên. Có ba loại cảm biến nổi bật trong các thiết bị Android. Chúng là:\r<ul><li>Cảm biến vị trí: Nó được sử dụng để đo vị trí thực của thiết bị Android. Bao gồm cảm biến định hướng và từ kế.</li></ul>\r<ul><li>Cảm biến chuyển động: Các cảm biến này bao gồm trọng lực, hoạt động quay và cảm biến gia tốc đo chuyển động quay của thiết bị hoặc gia tốc, v.v.</li></ul>\r<ul><li>Cảm biến môi trường: Nó bao gồm các cảm biến đo nhiệt độ, độ ẩm, áp suất và các yếu tố môi trường khác.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các loại dialog trong Android?",
              "answer": "<p>Android hỗ trợ 4 loại dialog:\r<ul><li>AlertDialog:</li></ul>\r<ul><li>Hỗ trợ từ 0-3 button, cùng với danh sách các mục chọn như checkbox hay radio button.</li></ul>\r<ul><li>Nó được sử dụng khi bạn muốn hỏi người dùng về việc đưa ra quyết định có hoặc không để phản hồi lại bất kỳ hành động cụ thể nào do người dùng thực hiện, bằng cách tiếp tục hoạt động tương tự và không thay đổi màn hình.</li></ul>\r<ul><li>DatePickerDialog:</li></ul>\r<ul><li>Dùng cho chọn ngày tháng </li></ul>\r<ul><li>TimePickerDialog:</li></ul>\r<ul><li>Dùng chọn chọn thời gian</li></ul>\r<ul><li>ProgressDialog:</li></ul>\r<ul><li>Là mở rộng của AlertDialog với thanh hiển thị quá trình. Nó còn hỗ trợ các button bổ sung.</li></ul>\r<ul><li>Lớp này không được dùng nữa trong API level 26 vì nó ngăn người dùng tương tác với ứng dụng. Thay vào đó, chúng ta có thể sử dụng ProgressBar, có thể được nhúng vào giao diện người dùng trong ứng dụng của bạn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "File AndroidManifest.xml là gì?",
              "answer": "<p>File AndroidManifest.xml bao gồm thông tin về ứng dụng mà hệ điều hành Android phải biết trước khi thực thi code.\r\n\r\nFile này rất cần thiết trong mọi ứng dụng Android. Nó được khai báo trong thư mục root. File này thực hiện một số tác vụ như:\r<ul><li>Cung cấp tên duy nhất cho package java.</li></ul>\r<ul><li>Mô tả các thành phần khác nhau của ứng dụng như activity, service,...</li></ul>\r<ul><li>Xác định các lớp sẽ triển khai các thành phần này.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Intent là gì?",
              "answer": "<p>Intent là một đối tượng thông báo dùng cho yêu cầu một hành động từ một thành phần khác của ứng dụng. Nó có thể được dùng cho các hành động như gửi SMS, gửi email, hiển thị web page.\r\n\r\nNó hiển thị thông báo tin nhắn cho người dùng khi các thiết bị Android cho phép. Nó cảnh báo người dùng khi một trạng thái cụ thể xảy ra. Có hai loại intent trong Android.\r<ul><li>Implicit Intent - dùng cho gọi các thành phần hệ thống.</li></ul>\r<ul><li>Explicit Intent - dùng cho gọi các lớp activity.</li></ul>\r\n\r\n<img src=\"/interview-assets/Types_Of_Intents.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa lớp, file và activity trong Android?",
              "answer": "<p><ul><li>Class là một hình thức biên dịch của file <code>.java</code> để Android sử dụng tạo ra các file <code>.apk</code>.</li></ul>\r<ul><li>File là một khối thông tin hoặc tài nguyên dùng cho lưu trữ thông tin.</li></ul>\r<ul><li>Activity là một màn hình đơn biểu diễn GUI để người dùng có thể giao tiếp theo để thực hiện điều gì đó như gọi điện, xem mail,...</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Toast là gì?",
              "answer": "<p>Toast là một thông báo hiện trên màn hình. Nó được sử dụng để hiển thị thông báo về trạng thái của hoạt động do người dùng bắt đầu và chỉ bao gồm khoảng không gian cần thiết cho thông báo trong khi activity hiện tại của người dùng vẫn hiển thị và tương tác.\r\n\r\nToast tự động hiện và mờ dần, và nó không thể giao tiếp. Cú pháp:\r\n\r\n``<code>java\r\nToast.makeText(ProjectActivity.this, &quot;Your message here&quot;, Toast.LENGTH_LONG).show();\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Context là gì?",
              "answer": "<p>Context là một interface chứa thông tin toàn cục về môi trường ứng dụng. Đây là một lớp trừu tượng được triển khai bởi hệ thống Android. Nó cho phép truy cập đến các tài nguyên và các lớp ứng dụng cụ thể, cũng như gọi đến các tác vụ trên mức ứng dụng như khởi chạy các activity, gửi và nhận intents, v.v..\r\n\r\n<img src=\"/interview-assets/Types_Of_Context.png\" alt=\"\" />\r\n\r\n<strong>Activity Context</strong> là mọi màn hình đều có một activity. Nó gắn liền với vòng đời của activity. Được dùng cho context hiện tại. Phương thức gọi Activity Context là <code>getContext()</code>.\r\n\r\nMột số trường hợp dùng Activity Context:\r<ul><li>Người dùng đang tạo một đối tượng có vòng đời được gắn với một activity.</li></ul>\r<ul><li>Bất cứ khi nào bên trong một activity cho UI liên quan đến các hoạt động như toast, dialog,...</li></ul>\r\n\r\n<strong>Application Context</strong> gắn liền với vòng đời của ứng dụng. Về cơ bản, nó là một thực thể singleton và có thể được truy cập thông qua <code>getApplicationContext()</code>. Một số trường hợp sử dụng của Application Context là:\r<ul><li>Khi tạo một đối tượng singleton</li></ul>\r<ul><li>Dùng với các thư viện cần thiết trong một activity.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Implicit và Explicit Intent?",
              "answer": "<p><strong>Explicit Intent:</strong> là nơi bạn thông báo cho hệ thống về activity nào sẽ xử lý intent này. Ở đây thành phần đích được xác định trực tiếp trong intent. \r\n\r\nVí dụ:\r\n\r\n``<code>java\r\nIntent i = new Intent(this, Activitytwo.class); #ActivityTwo is the target component\r\ni.putExtra(&quot;Value1&quot;,&quot;This is ActivityTwo&quot;); \r\ni.putExtra(&quot;Value2&quot;,&quot;This Value two for ActivityTwo&quot;); \r\nstartactivity(i);\r\n</code>`<code>\r\n\r\n<strong>Implicit Intent:</strong> cho phép bạn khai báo hành động muốn thực hiện. Hệ thống Android sẽ kiểm tra thành phần nào được đăng ký để xử lý hành động cụ thể đó dựa trên dữ liệu intent. Ở đây thành phần mục tiêu không được xác định trong intent.\r\n\r\nVí dụ:\r\n\r\n</code>`<code>java\r\nIntent i = new Intent(ACTION_VIEW,Uri.parse(&quot;http://www.interview bit.com&quot;)); \r\nstartActivity(i);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "ANR trong Android là gì?",
              "answer": "<p>ANR (Application is Not Responding) là một dialog xuất hiện khi ứng dụng không phản hồi. Dialog này xuất hiện bất cứ khi nào luồng chính trong ứng dụng không phản hồi suốt một khoảng thời gian dài với các điều khiện sau:\r<ul><li>Không có phản hồi nào với sự kiện input sau 5s.</li></ul>\r<ul><li>Một broadcase receiver không hoàn thành thực thi trong 10s.</li></ul>\r\n\r\nCác cách để tránh ANR:\r<ul><li>Một ứng dụng phải thực hiện cơ sở dữ liệu hoặc các hoạt động mạng trong các luồng riêng biệt để tránh ANR.</li></ul>\r<ul><li>Đối với các ứng dụng chuyên sâu về tác vụ nền, bạn có thể giảm bớt áp lực từ luồng UI bằng cách sử dụng <code>IntentService</code>.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các vấn đề kỹ thuật cần làm khi ứng dụng thường xuyên gặp sự cố?",
              "answer": "<p><strong>Kiểm tra khả năng tương thích:</strong>\r\n\r\nKhông thể kiểm tra một ứng dụng cho tất cả các loại thiết bị và hệ điều hành. Có thể có một ứng dụng không tương thích với hệ điều hành của bạn.\r\n\r\n<strong>Quản lý bộ nhớ:</strong>\r<ul><li>Một số ứng dụng chạy hoàn hảo trên một thiết bị di động nhưng có thể gặp sự cố trên các thiết bị khác. Đây là lúc xem xét khả năng xử lý, quản lý bộ nhớ và tốc độ CPU.</li></ul>\r<ul><li>Vì dung lượng bộ nhớ trên thiết bị di động có hạn, bạn có thể giải phóng dung lượng bộ nhớ để ứng dụng hoạt động bình thường.</li></ul>\r<ul><li>Nếu một ứng dụng thường xuyên gặp sự cố, bạn có thể xóa dữ liệu của ứng dụng, điều này sẽ xóa bộ nhớ đệm của ứng dụng đó và cho phép một số dung lượng trống trên thiết bị của bạn và có thể tăng hiệu suất của ứng dụng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích các chế độ khởi chạy khác nhau trong Android?",
              "answer": "<p><strong>Standard (dạng chuẩn)</strong>\r<ul><li>Chế độ khởi chạy này tạo thực thể mới của một activity trong tác vụ mà nó bắt nguồn.</li></ul>\r<ul><li>Có thể tạo nhiều thực thể cho cùng một activity.</li></ul>\r\nVí dụ: giả sử ngăn xếp hiện tại của chúng ta là A -> B -> C. Bây giờ, nếu chúng ta khởi chạy lại activity B với chế độ khởi chạy \"standard\", thì ngăn xếp mới sẽ là A -> B -> C -> B\r\n\r\n<strong>SingleTop:</strong>\r<ul><li>Chế độ này tương tự như Standard ngoại trừ việc nếu tồn tại thực thển trước của activity trên đầu ngăn xếp, thì thực thể mới sẽ không được tạo.</li></ul>\r<ul><li>Nhưng intent sẽ được gửi đến thực thể hiện có của activity.</li></ul>\r\nVí dụ: giả sử ngăn xếp hiện tại của chúng ta là A -> B -> C. Bây giờ, nếu chúng ta khởi chạy lại activity B với chế độ khởi chạy \"singleTop\", thì ngăn xếp mới sẽ là A -> B -> C -> B.\r<ul><li>Hãy xem xét một ví dụ khác, trong đó ngăn xếp hiện tại là A -> B -> C. Bây giờ, nếu chúng ta khởi chạy lại activity C với chế độ khởi chạy \"singleTop\", thì ngăn xếp sẽ vẫn như cũ, tức là A -> B -> C. Intent sẽ được chuyển đến phương thức <code>onNewIntent()</code></li></ul>\r\n\r\n<strong>SingleTask:</strong>\r<ul><li>Chế độ khởi chạy này sẽ tạo một tác vụ mới và đẩy một thực thể mới cho tác vụ gốc.</li></ul>\r<ul><li>Ví dụ: giả sử ngăn xếp hiện tại của chúng ta là A -> B -> C -> D. Bây giờ, nếu chúng ta khởi chạy lại activity B với chế độ khởi chạy \"singleTask\", thì ngăn xếp mới sẽ là A -> B. Đây, một lệnh gọi lại đã được nhận trên thực thể cũ và các activity C và D bị phá hủy.</li></ul>\r\n\r\n<strong>SingleInstance:</strong>\r<ul><li>Chế độ  này tương tự như SingleTask. Nhưng hệ thống không hỗ trợ khởi chạy bất kỳ activity mới nào trong cùng một tác vụ.</li></ul>\r<ul><li>Trong tình huống mà activity mới được khởi chạy, nó sẽ được khởi chạy trong một tác riêng biệt.</li></ul>\r<ul><li>Ví dụ: Giả sử ngăn xếp hiện tại của chúng ta là A -> B -> C. Bây giờ, nếu chúng ta khởi chạy activity D với chế độ khởi chạy \"singleInstance\", thì sẽ có hai ngăn xếp:</li></ul>\r<ul><li>A -> B -> C</li></ul>\r<ul><li>D, </li></ul>\r<ul><li>Nếu bạn gọi activity E, thì nó sẽ được thêm vào ngăn xếp đầu tiên.</li></ul>\r<ul><li>A -> B -> C -> E</li></ul>\r<ul><li>D</li></ul>\r\nMột lần nữa nếu bạn gọi activity là D, thì nó sẽ gọi cùng activity từ ngăn xếp thứ 2 và chuyển intent cho <code>onNewIntent()</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Container trong Android?",
              "answer": "<p>Các container chứa các đối tượng và widget với nhau, dựa trên những đối tượng cụ thể nào được yêu cầu và cách sắp xếp cụ thể nào là cần thiết. Container có thể chứa label, button, input hoặc thậm chí container con,... Ví dụ: nếu bạn muốn form có các trường ở bên trái và label ở bên phải, bạn sẽ cần một container. Nếu bạn muốn các button OK và Cancel nằm bên dưới phần còn lại của form, bên cạnh nhau và nằm ở phía bên phải của màn hình, bạn sẽ cần một container. Nếu bạn có nhiều widget, bạn sẽ cần một container có phần tử gốc để đặt các widget bên trong.\r\n\r\nAndroid cung cấp một bộ tập hợp các lớp view đóng vai trò là container cho các view. Các lớp container này được gọi là layout, được định nghĩa dưới dạng file XML mà code của chúng ta không thể thay đổi trong quá trình thực thi. Các trình quản lý layout do Android SDK cung cấp là <code>LinearLayout</code>, <code>RelativeLayout</code>, <code>FrameLayout</code>, <code>AbsoluteLayout</code>, <code>GridLayout</code> và <code>TableLayout</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Vai trò của Dalvik trong phát triển Android?",
              "answer": "<p>Dalvik hoạt động như một máy ảo và nó chịu trách nhiệm chạy mọi ứng dụng Android. Nhờ Dalvik, một thiết bị sẽ có khả năng thực thi nhiều phiên bản của máy ảo một cách hiệu quả thông qua việc quản lý bộ nhớ tốt hơn.\r\n\r\n## Câu hỏi phỏng vấn Android cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Broadcast receivers là gì?",
              "answer": "<p>Một broadcast receiver là một cơ chế được dùng để lắng nghe sự kiện ở level hệ thống như SMS, cuộc gọi,... bằng ứng dụng host. Nó được triển khai như một lớp con của lớp <code>BroadcastReceiver</code> và mỗi thông báo được broadcast như một đối tượng intent.\r\n\r\n``<code>java\r\npublic class MyReceiver extends BroadcastReceiver \r\n{\r\n    public void onReceive(context,intent){}\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cấu trúc thư mục khi tạo ứng dụng Android?",
              "answer": "<p><strong>App:</strong>\r\n\r\nNó mô tả các đặc điểm cơ bản của ứng dụng và xác định từng thành phần của nó.\r\n\r\n<strong>java:</strong>\r<ul><li>Nó bao gồm các file mã nguồn <code>.java</code> hoặc <code>.kt</code> (dùng Kotlin) của dự án. Theo mặc định nó chứa file <code>MainActivity.java</code> hoặc <code>MainActivity.kt</code>.</li></ul>\r<ul><li>Bạn tạo tất cả activity với file mở rộng <code>.java</code> hoặc <code>.kt</code> và nó cũng bao gồm code của ứng dụng.</li></ul>\r\n\r\n<strong>res:</strong>\r<ul><li>Nó dùng cho lưu trữ giá trị cho tài nguyên được sử dụng trong các dự án Android khác nhau bao gồm các tính năng về màu sắc, kiểu dáng, kích thước,...</li></ul>\r<ul><li>Bao gồm các file xml như styles.xml, strings.xml, colors.xml,...</li></ul>\r\n\r\n<strong>Scripts:</strong>\r\n\r\nLà file tự động tạo bao gồm compileSdkVersion, buildToolsVersion, minSdkVersion, targetSdkVersion, applicationId, versionCode, và versionName. Ví dụ, build.gradle là một file script trong thư mục root, xác định cấu hình xây dựng sẽ được triển khai cho tất cả module trong dự án của bạn.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Serializable và Parcelable?",
              "answer": "<p>Trong phát triển ứng dụng, thông thường nó cần chuyển dữ liệu từ activity này sang activity khác. Dữ liệu này cần được thêm vào một đối tượng intent tương ứng. Một số hành động bổ sung được yêu cầu để làm cho dữ liệu phù hợp để chuyển. Để làm được điều đó, đối tượng phải có thể được serializable hoặc parcelable.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Cơ sở dữ liệu nào được sử dụng trong Android?",
              "answer": "<p>SQLite là cơ sở dữ liệu quan hệ mã nguồn mở được sử dụng trong Android. SQLite engine là serverless và độc lập. Thay vì đi theo mối quan hệ client-server như các RDBSM khác, SQLite engine dễ dàng tích hợp với ứng dụng. Thư viện có thể được gọi động và nó có thể sử dụng các lệnh gọi hàm đơn giản để giảm độ trễ khi truy cập cơ sở dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Service và Thread?",
              "answer": "<p>| Service | Thread |\r\n|-|-|\r\n| Service là một thành phần ứng dụng tạo điều kiện cho ứng dụng chạy nền theo trình tự thực hiện các thao tác lâu dài mà không có sự tương tác với người dùng | Một thread là một đơn vị thực thi đồng thời |\r\n| Nó để lộ các chức năng đến ứng dụng khác bằng cách gọi Context.bindService() | Google mang lại các trình xử lý và vòng lặp vào thread |\r\n| Khi ứng dụng bị huỷ, service không bị huỷ | Khi ứng dụng bị huỷ, thread bị huỷ |</p>",
              "level": "fresher"
            },
            {
              "question": "Content Provider là gì?",
              "answer": "<p>Content provider là một block xây dựng chính của ứng dụng Android, quản lý quyền truy cập để tạo repository dữ liệu trung tâm. Nó hoạt động như một interface tiêu chuẩn kết nối dữ liệu trong một tiến trình với code chạy trong một tiến trình khác. Vì vậy, nó có thể được dùng để chia sẻ dữ liệu giữa các ứng dụng khác nhau.\r\n\r\nChúng có trách nhiệm đóng gói dữ liệu và cung cấP cơ chế cho bảo mật dữ liệu. Nó được triển khai như một lớp con của lớp ContentProvider và phải triển khai một tập APIs để khởi động ứng dụng khác cho thực hiện giao dịch.\r\n\r\n``<code>java\r\npublic class MyContentprovider extends ContentProvider \r\n{\r\n    public void onCreate(){}\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Ý nghĩa của file .dex?",
              "answer": "<p>Các chương trình Android được DVM biên dịch thành file <code>.dex</code> (Dalvik Executable file), sau đó được nén thành file <code>.apk</code> trên thiết bị. Các file <code>.dex</code> được tạo bằng cách dịch các ứng dụng đã biên dịch được viết bằng java. <code>.dex</code> là định dạng được tối ưu hóa để lưu trữ hiệu quả và thực thi có thể ánh xạ bộ nhớ.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa compileSdkVersion và targetSdkVersion?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Các lớp Java liên quan đến cảm biến trong Android?",
              "answer": "<p>Cảm biến Android API cung cấp nhiều lớp và interface dùng cho cảm biến trên Android. Các lớp và interface quan trọng cho các API cảm biến như sau:\r<ul><li><strong>Lớp Sensor:</strong> giúp bạn tạo một thực thể của cảm biến cụ thể. Nó cung cấp phương thức để xác định khả năng của cảm biến.</li></ul>\r<ul><li><strong>Lớp SensorManager:</strong> lớp này được sử dụng để tạo một thực thể của dịch vụ cảm biến. Nó cung cấp các phương thức để truy cập và liệt kê các cảm biến, đăng ký và hủy đăng ký các trình nghe cảm biến, ...</li></ul>\r<ul><li><strong>Lớp SensorEvent:</strong> lớp Java này dùng cho tạo đối tượng cảm biến sự kiện. Nó cung cấp thông tin về sự kiện cảm biến bao gồm dữ liệu cảm biến (dạng raw), độ chính xác của dữ liệu, loại cảm biến, thời gian của sự kiện, ...</li></ul>\r<ul><li><strong>Interface SensorEventListener:</strong> interface được dùng để tạo hai phương thức callback để nhận thông báo sự kiện cảm biến khi giá trị hoặc độ chính xác cảm biến thay đổi. Hai phướng thức đó là:</li></ul>\r<ul><li><code>void onAccuracyChanged(Sensor sensor, int accuracy)</code> được gọi khi độ chính xác cảm biến thay đổi.</li></ul>\r<ul><li><code>void onSensorChanged(SensorEvent event)</code> được gọi khi giá trị cảm biến thay đổi.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "JobScheduler là gì?",
              "answer": "<p>JobScheduler API được dùng cho lên lịch các công việc khác nhau dựa trên framework được thực thi trong tiến trình riêng của ứng dụng. Nó cho phép ứng dụng của bạn thực hiện các tác vụ đã cho trong khi vẫn cân nhắc đến pin thiết bị và chi phí cho kiểm soát thời gian.\r\n\r\nJobScheduler hỗ trợ lập lịch hàng loạt công việc. Hệ thống android có thể kết hợp các công việc để giảm mức tiêu thụ pin.\r\n\r\nJobManager tự động xử lý tình trạng không đáng tin cậy của mạng để giúp việc xử lý tải lên dễ dàng hơn.\r\n\r\nCác ví dụ về sử dụng JobScheduler:\r<ul><li>Tác vụ cần được thực hiện khi thiết bị được kết nối với nguồn điện.</li></ul>\r<ul><li>Tác vụ yêu cầu kết nối Wi-Fi hoặc truy cập mạng.</li></ul>\r<ul><li>Tác vụ chạy thường xuyên mà thời gian không quan trọng.</li></ul></p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "ios",
          "name": "Câu hỏi phỏng vấn iOS",
          "description": "",
          "questions": [
            {
              "question": "Giải thích kiến trúc iOS?",
              "answer": "<p>iOS hoạt động theo cấu trúc lớp. Kiến trúc iOS bao gồm bốn lớp, mỗi lớp cung cấp một framework lập trình để tạo các ứng dụng hoạt động trên phần cứng. Giao tiếp sẽ được tăng cường bởi các lớp giữa lớp ứng dụng và lớp phần cứng. Lớp cấp thấp hơn cung cấp các dịch vụ mà tất cả các ứng dụng yêu cầu, trong khi lớp cấp cao cung cấp các dịch vụ liên quan đến đồ họa và giao diện.\r\n\r\n<img src=\"/interview-assets/Architecture_of_iOS.png\" alt=\"\" />\r<ul><li><strong>Lớp core OS:</strong> nằm ngay trên đầu phần cứng thiết bị và là lớp dưới cùng của kiến trúc hệ điều hành iPhone. Ngoài các dịch vụ hệ điều hành cơ bản, chẳng hạn như quản lý bộ nhớ, xử lý hệ thống file và luồng, lớp này còn cung cấp mạng cấp thấp, quyền truy cập vào các phụ kiện bên ngoài,...</li></ul>\r<ul><li><strong>Lớp dịch vụ:</strong> Mục đích của nó là thiết kế các dịch vụ mà lớp trên hoặc người dùng yêu cầu. Các tính năng thiết yếu của nó là các đối tượng khối, Grand Central Dispatch, mua hàng trong ứng dụng và lưu trữ iCloud. Lớp dịch vụ đã được củng cố bằng cách bổ sung tính năng ARC Automatic Reference Counting.</li></ul>\r<ul><li><strong>Lớp Media:</strong> xử lý media như video, âm thanh, hình ảnh,... Lớp media cho phép ta sử dụng tất cả công nghệ đồ hoạ, âm thanh, hình ảnh của hệ thống.</li></ul>\r<ul><li><strong>Lớp Cocoa Touch:</strong> còn biết đến là lớp ứng dụng. Đây là nơi mà các framework được tạo ra khi các ứng dụng được xây dựng. Ngoài ra, nó có chức năng như giao diện để người dùng iOS làm việc với hệ điều hành. Điều này bao gồm khả năng cảm ứng và chuyển động.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính trong iOS?",
              "answer": "<p>Thuộc tính cơ bản là các giá trị được liên kết với một class, struct hay enum. Nó có thể là một biến con, một phần của đối tượng khác.\r\n\r\nVí dụ:\r\n\r\n``<code>swift\r\nstruct Icecream  \r\n{ \r\n    var flavor: String = &quot;&quot;\r\n} \r\nvar choco = Icecream() \r\nchoco.flavor = &quot;Chocolate Icecream&quot;\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta tạo một cấu trúc gọi là </code>Icecream<code>. Một trong những thuộc tính của nó được gọi là </code>flavor`, có giá trị ban đầu là một chuỗi trống.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn có thể giải thích sự khác biệt giữa các thuộc tính atomic và nonatomic không?",
              "answer": "<p><strong>Thuộc tính atomic:</strong> Nó là thuộc tính mặc định và đảm bảo một giá trị hợp lệ sẽ được trả về từ getter hoặc được thiết lập bởi setter. Điều này đảm bảo rằng chỉ một luồng có thể truy cập getter/setter của một thuộc tính nhất định tại một thời điểm và tất cả các luồng khác phải đợi cho đến khi luồng đầu tiên giải phóng getter/setter. Mặc dù luồng an toàn, nhưng nó không nhanh, vì nó đảm bảo rằng quá trình được hoàn thành hoàn toàn.\r\n\r\n<strong>Thuộc tính nonatomic:</strong> Với thuộc tính này, nhiều luồng có thể truy cập vào phương thức getter/setter của một thuộc tính nhất định cùng một lúc, do đó có khả năng tồn tại sự không nhất quán giữa các giá trị. Chúng đi kèm với quyền truy cập nâng cao, nhưng không đảm bảo về giá trị trả về.</p>",
              "level": "fresher"
            },
            {
              "question": "Các trạng thái khác nhau của ứng dụng iOS?",
              "answer": "<p>Trong quá trình thực thi, ứng dụng iOS trải qua một loạt trạng thái. Mỗi trạng thái này được coi là trạng thái vòng đời của ứng dụng. Dưới đây là năm trạng thái có thể xảy ra đối với ứng dụng iOS:\r\n\r\n<img src=\"/interview-assets/ios_application_states.png\" alt=\"\" />\r<ul><li><strong>Not running:</strong> ở trạng thái này, ứng dụng đã không được khởi chạy hoặc đã bị đóng bởi hệ thống.</li></ul>\r<ul><li><strong>Inactive:</strong> một trạng thái không hoạt động ngắn xảy ra khi ứng dụng đang rời khỏi hoặc đang ở trạng thái hoạt động. Mặc dù chạy ở chế độ đã hiển thị, nó vẫn chưa sẵn sàng để chấp nhận đầu vào hoặc sự kiện từ người dùng. Điều này có nghĩa là ứng dụng vẫn không hoạt động tại thời điểm này.</li></ul>\r<ul><li><strong>Active:</strong> trạng thái này cho biết rằng ứng dụng đang được hiển thị và nhận các sự kiện. Đây là chế độ bình thường cho các ứng dụng và Giao diện người dùng có thể truy cập được.</li></ul>\r<ul><li><strong>Background:</strong> trong trạng thái này, giao diện người dùng của ứng dụng bị ẩn, nhưng nó vẫn tiếp tục chạy trong nền của hệ thống iOS. Các ứng dụng thường vượt qua trạng thái này trước khi bị đình chỉ.</li></ul>\r<ul><li><strong>Suspended:</strong> Trong trường hợp này, ứng dụng đang ở chế độ nền nhưng không chạy code. Trong điều kiện bộ nhớ thấp, hệ thống có thể xóa các ứng dụng ở trạng thái bị treo mà không cần cảnh báo.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Trách nhiệm của nhà phát triển iOS?",
              "answer": "<p>Nhà phát triển iOS là một lập trình viên hoặc kỹ sư phần mềm, người thiết kế và phát triển các ứng dụng chạy iOS của Apple trên thiết bị iOS. Tốt nhất, nhà phát triển iOS phải có kỹ năng trong hai ngôn ngữ lập trình, là Objective-C và Swift.\r\n\r\nTrách nhiệm của nhà phát triển iOS:\r<ul><li>Code sạch sẽ, hiệu quả cho các ứng dụng iOS.</li></ul>\r<ul><li>Đảm bảo code an toàn bằng cách thực hiện khắc phục sự cố và sửa lỗi cho các ứng dụng.</li></ul>\r<ul><li>Việc phát triển và triển khai các tính năng ứng dụng nâng cao cũng như duy trì và cải tiến các tính năng hiện có.</li></ul>\r<ul><li>Phát triển các giải pháp sáng tạo để đáp ứng nhu cầu kinh doanh của khách hàng.</li></ul>\r<ul><li>Hỗ trợ tất cả các khía cạnh của phát triển ứng dụng, bao gồm thiết kế, thử nghiệm, phát hành và hỗ trợ.</li></ul>\r<ul><li>Khám phá, đánh giá và triển khai các công nghệ mới liên tục để tối đa hóa hiệu quả phát triển.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Android và iOS?",
              "answer": "<p><strong>Android</strong>: Đây là hệ điều hành di động dành cho các thiết bị Android do Google LLC cung cấp và tập trung vào các thiết bị di động có màn hình cảm ứng như điện thoại thông minh và máy tính bảng. Một số ngôn ngữ lập trình đã được sử dụng trong quá trình phát triển của nó, bao gồm C, Java, C++ và các ngôn ngữ khác.\r\n\r\n<strong>iOS</strong>: Đây là hệ điều hành dành cho các thiết bị của Apple do Apple cung cấp và nó được coi là hệ điều hành di động phổ biến thứ hai trên toàn cầu sau Android. Nó chủ yếu được thiết kế cho các thiết bị di động của Apple như iPhone, iPod Touch, v.v. Một số ngôn ngữ lập trình đã được sử dụng trong quá trình phát triển của nó, bao gồm Objective-C, Swift, C++ và các ngôn ngữ khác.\r\n\r\n| Android | iOS |\r\n|-|-|\r\n| Hệ điều hành di động cho thiết bị Android được cung cấp bởi Google LLC | Hệ điều hành cho thiết bị Apple được cung cấp bởi tập đoàn Apple |\r\n| Dành cho smartphone và máy tính bảng | Dành cho iPhone, iPod và iPad |\r\n| Chủ yếu dùng Java, C, C++ | Chủ yếu dùng Swift, Objective-C, C/C++ |\r\n| Google Chrome là trình duyệt mặc định | Safari là trình duyệt mặc định |\r\n| Hiệu suất giảm theo thời gian | Hiệu suất bảo toàn theo thời gian |\r\n| Mã nguồn mở, có thể chỉnh sửa tuỳ ý thay đổi hệ điều hành. Dẫn đến bảo mật kém | Mã nguồn đóng, các nhà phát triển không thể chỉnh sửa code trên thiết bị, giúp iOS bảo mật và khó hack hơn |</p>",
              "level": "fresher"
            },
            {
              "question": "Deep linking trong iOS là gì?",
              "answer": "<p>Deep linking là các liên kết đưa người dùng trực tiếp đến một ứng dụng thay vì trang web hoặc cửa hàng bằng cách sử dụng URI (Uniform Resource Identifier) hoặc các universal links. URI là một phương pháp phổ biến để có deep linking, nhưng từ iOS 9, Apple đã thêm Universal Link thay cho URI. \r\n\r\nDeep linking không chỉ liên quan đến việc tạo liên kết có thể click để mở ứng dụng của bạn mà còn là liên kết thông minh điều hướng đến tài nguyên mà bạn mong muốn. Người dùng được dẫn thẳng đến các vị trí trong ứng dụng bằng cách sử dụng các liên kết này, điều này giúp họ tiết kiệm thời gian và nỗ lực tự tìm kiếm các trang đó, do đó cải thiện trải nghiệm người dùng của họ rất nhiều.\r\n\r\nVí dụ: Nếu bạn dùng URL: <code>fb://</code>, bạn sẽ mở ứng dụng Facebook. Nhưng nếu dùng <code>fb://profile/33138223345</code> bạn sẽ mở thông tin người dùng trên ứng dụng Facebook.\r\n\r\n<img src=\"/interview-assets/deep_linking_in_iOS.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích GCD trong iOS?",
              "answer": "<p>Grand Central Dispatch (GCD) là một API cấp thấp cho phép người dùng chạy đồng thời nhiều tác vụ được luồng quản lý trong nền. GCD là một giải pháp của Apple để thực hiện tính đồng thời (concurrency) và song song (parallelism) trong ứng dụng iOS, thế nên nhiều tác vụ có thể chạy trong nền mà không ảnh hưởng gì đến luồng chính. Nó được giới thiệu trong iOS4 để tránh tiến trình dài dòng của việc thực hiện nối tiếp các tác vụ.</p>",
              "level": "fresher"
            },
            {
              "question": "ARC là gì?",
              "answer": "<p>Trong ngôn ngữ Swift, ARC (Automatic Reference Counting) được dùng cho quản lý bộ nhớ ứng dụng. Nó khởi tạo và xác định tài nguyên hệ thống, do đó giải phóng bộ nhớ dành cho một thực thể lớp khi nó không còn cần đến nữa. ARC theo dõi có bao nhiêu thuộc tính, hằng số và biến hiện đang tham chiếu đến mỗi thực thể lớp. Khi có ít nhất một tham chiếu hoạt động tới một thực thể, ARC sẽ giải phóng thực thể đó. Việc sử dụng các khái niệm ARC là một phần thiết yếu của quá trình phát triển iOS.\r\n\r\nChức năng ARC:\r<ul><li>ARC tạo một thực thể lớp mới bằng <code>init()</code> và cấp phát một phần của bộ nhớ cho lưu trữ thông tin.</li></ul>\r<ul><li>Bộ nhớ lưu trữ thông tin về kiểu và giá trị của nó.</li></ul>\r<ul><li>Khi thực thể lớp không còn cần nữa, ARC sẽ tự động giải phóng bộ nhớ bằng lệnh gọi <code>deinit()</code>.</li></ul>\r<ul><li>Bằng cách theo dõi tham chiếu đến thuộc tính, hằng, biến của lớp, ARC đảm bảo <code>deinit()</code> chỉ thực hiện trên các thực thể khôgn còn dùng nữa.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Cocoa và Cocoa Touch?",
              "answer": "<p>Cocoa và Cocoa Touch là hai trong số các framework được sử dụng rộng rãi của Apple được sử dụng để xây dựng các ứng dụng. Tuy nhiên, chúng khác nhau theo những cách sau:\r\n\r\n| Cocoa | Cocoa Touch |\r\n|-|-|\r\n| Framework cho xây dựng ứng dụng chạy trên Mac OS | Framework cho xây dựng ựng dụng chạy trên iPhone hay iPad |\r\n| Framework như Foundation và AppKit được kết hợp vào Cocoa | Cocoa Touch là sự kết hợp của các framework như Foundation và UIKit được tích hợp vào Cocoa Touch |\r\n| Các lớp Cocoa sử dụng tiền tố NS (được sử dụng cho tất cả các lớp và hằng số trong framework Cocoa), như NSTextField, NSWindow | Mặt khác, các lớp Cocoa Touch sử dụng tiền tố UI (được sử dụng cho tất cả các lớp và hằng số trong framework Cacoa Touch) (như UITextField và UIWindow) |</p>",
              "level": "fresher"
            },
            {
              "question": "Các ngôn ngữ lập trình dùng cho phát triển iOS?",
              "answer": "<p><ul><li>HTML5</li></ul>\r<ul><li>.NET</li></ul>\r<ul><li>C</li></ul>\r<ul><li>C++</li></ul>\r<ul><li>Swift</li></ul>\r<ul><li>Javascript</li></ul>\r<ul><li>Objective-C</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Framework được sử dụng để xây dựng giao diện ứng dụng cho iOS là gì?",
              "answer": "<p>Trái ngược với framework Foundation định nghĩa các lớp, giao thức và hàm để phát triển cả iOS và OS X. UIKit được thiết kế đặc biệt để phát triển giao diện iOS. Trong iOS, giao diện người dùng và cơ sở hạ tầng đồ họa của ứng dụng được phát triển bằng UIKit. Nó bao gồm:\r<ul><li>Xử lý sự kiện (xử lý các cử chỉ khác nhau như cử chỉ nhập liệu, cử chỉ nhấn nút, cử chỉ đa chạm, ...)</li></ul>\r<ul><li>Cấu trúc ứng dụng (Quản lý sự tương tác giữa hệ thống và người dùng)</li></ul>\r<ul><li>Giao diện người dùng (Cung cấp các tương tác của người dùng, khả năng chia sẻ văn bản và nội dung, chọn hình ảnh, chỉnh sửa video, in tệp,...)</li></ul>\r<ul><li>Đồ họa, vẽ và in ấn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các cách để thực hiện đồng thời trong iOS?",
              "answer": "<p>Concurrency có nghĩa là \"chạy nhiều tác vụ đồng thời\". Concurrency cho phép thiết bị iOS xử lý các tác vụ nền (chẳng hạn như tải xuống hoặc xử lý dữ liệu) trong khi vẫn duy trì giao diện người dùng. Trong iOS, bạn có thể quản lý các tác vụ đồng thời bằng cách sử dụng Grand Central Dispatch (GCD) và Operations (chính thức được gọi là NSOperation). Để thực hiện được sự đồng thời, iOS cung cấp ba cách như sau:\r\n<em> <strong>Dispatch queues:</strong> Chúng được sử dụng để quản lý các tác vụ theo thứ tự vào trước ra trước (FIFO) và thực thi các tác vụ một cách tuần tự hoặc đồng thời. Đây là một cách dễ dàng để xử lý các tác vụ bất đồng bộ (không xảy ra cùng lúc) và đồng thời trong ứng dụng của bạn.\r\n</em> <strong>Thread:</strong> Một chuỗi instructions độc lập có thể được thực thi riêng biệt với code khác trong một chương trình. Thông qua các luồng, người ta có thể thực thi nhiều đường dẫn code đồng thời trong một ứng dụng duy nhất. Có một luồng đặc biệt hữu ích khi bạn cần thực hiện một tác vụ dài mà không ảnh hưởng đến việc thực hiện phần còn lại của chương trình.\r<ul><li><strong>Operation Queues</strong>: Các đối tượng operation queue được gọi theo mức độ ưu tiên và mức độ sẵn sàng của chúng. Về cơ bản, Operation queue là sự trừu tượng hóa cấp cao của mô hình hàng đợi, được xây dựng trên GCD (Grand Central Dispatch). Do đó, có thể thực thi các tác vụ đồng thời, giống như GCD, nhưng theo cách hướng đối tượng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa App ID và Bundle ID?",
              "answer": "<p><ul><li><strong>Bundle ID</strong>: Chúng là định danh duy nhất của các ứng dụng trong hệ sinh thái của Apple. Nói cách khác, không có hai ứng dụng nào có thể có cùng định danh. Bundle ID được sử dụng cho cả ứng dụng OS X và iOS, và có thể được sử dụng để nhận dạng các bản cập nhật ứng dụng.</li></ul>\r\n    Ví dụ:\r\n    Nếu tên miền của tổ chức của ta là scaler.com và ta tạo một ứng dụng có tên là Edge, bạn có thể chỉ định chuỗi <code>com.scaler.edge</code> làm Bundle ID của ứng dụng.\r<ul><li><strong>App ID</strong>: Chuỗi này xác định duy nhất một hoặc nhiều ứng dụng từ cùng một nhóm phát triển. Có hai thành phần trong chuỗi, Team ID và Bundle ID, được phân tách bằng dấu chấm (.). Apple cung cấp Team ID để xác định một nhóm phát triển cụ thể, trong khi các nhà phát triển cung cấp Bundle ID để xác định một ứng dụng hoặc một bộ sưu tập ứng dụng.</li></ul>\r\n    Ví dụ:\r\n    <strong>ABCDE12345.com.scaler.edge</strong>\r\n    Trong ví dụ trên, <code>ABCDE12345</code> là Team ID và <code>com.scaler.edge</code> là Bundle ID .</p>",
              "level": "fresher"
            },
            {
              "question": "Framework SpriteKit và SceneKit trong phát triển game?",
              "answer": "<p><strong>SpriteKit</strong>: Framework này được thiết kế để giúp các nhà phát triển trò chơi dễ dàng và nhanh chóng hơn trong việc tạo các nội dung/đối tượng hoạt hình 2D trong các trò chơi thông thường. Với nó, bạn có thể vẽ các hình dạng, hạt, văn bản, hình ảnh và video theo hai chiều.\r\n\r\n<strong>SceneKit</strong>: Đây là một framework iOS kế thừa từ OS X, giúp tạo đồ họa 3D. Với SceneKit, bạn có thể tạo các cảnh và hiệu ứng hoạt hình 3D cho các trò chơi và ứng dụng iOS của mình.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa từ khoá assign và retain?",
              "answer": "<p><ul><li><strong>Assign</strong>: một tham chiếu được tạo từ đối tượng này sang đối tượng khác mà không làm tăng số lượng lưu giữ của nguồn (theo dõi có bao nhiêu đối tượng đang \"giữ\" đối tượng khác). Nó không sao chép hoặc giữ lại giá trị mà chỉ định trực tiếp cho biến thực thể.</li></ul>\r\n\r\n``<code>swift\r\nif (object != object) \r\n{  \r\n    [object release];  \r\n    object = nil;  \r\n    object = object;  \r\n}\r\n</code>`<code>\r\n\r\nỞ đây, Assign sẽ tạo ra một setter trực tiếp gán giá trị cho biến thực thể, thay vì sao chép hoặc giữ lại nó.\r<ul><li><strong>Retain:</strong> Sử dụng phương pháp này, bạn tạo một tham chiếu từ đối tượng này sang đối tượng khác và tăng số lượng giữ lại của đối tượng nguồn.</li></ul>\r\n\r\n</code>`<code>swift\r\nif (object != object) \r\n{   \r\n    [object release]; \r\n    object = nil;   \r\n    object = [object retain];   \r\n}\r\n</code>``\r\n\r\nThông điệp retain ngăn một đối tượng được phân bổ cho đến khi bạn sử dụng xong.\r\n\r\n## Câu hỏi phỏng vấn iOS cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Objective-C trong iOS?",
              "answer": "<p>Kể từ những năm 1990, Objective-C đã được Apple sử dụng như một ngôn ngữ lập trình hướng đối tượng. Ngôn ngữ này kết hợp những ưu điểm của hai ngôn ngữ trước đó - C và Smalltalk. Là một tập mở rộng của C, nó cung cấp chức năng hướng đối tượng và một môi trường runtime động.\r\n\r\n<img src=\"/interview-assets/Objective-C_in_OS.png\" alt=\"\" />\r\n\r\n<strong>Tính năng</strong>\r<ul><li>Biên dịch khá nhanh và hoạt động mềm mại</li></ul>\r<ul><li>Obj-C tương thích với cả C và C++</li></ul>\r<ul><li>Hỗ trợ Runtime</li></ul>\r<ul><li>Làm việc tốt với các Foundation APIs</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu dữ liệu phổ biến trong Objective-C?",
              "answer": "<p><em> <strong>BOOL</strong>: biểu diễn giá trị Boolean tức là true hoặc false. Cả từ khoác <em>Bool và BOOL đều hợp lệ.\r\n    Ví dụ:\r\n\r\n    ``<code>mm\r\n    </em>Bool flag = 0;\r\n    BOOL secondflag = 1;\r\n    </code>`<code>\r\n</em> <strong>NSInteger</strong>: biểu diễn số nguyên.\r\n    Ví dụ:\r\n    \r\n    </code>`<code>mm\r\n    typedef long NSInteger;\r\n    typedef int NSInteger;\r\n    </code>`<code>\r\n\r\n<em> <strong>NSUInteger</strong>: biểu diễn số nguyên không dấu.\r\n    Ví dụ:\r\n\r\n    </code>`<code>mm\r\n    typedef unsigned long NSUInteger; \r\n    typedef unsigned int NSUInteger;\r\n    </code>`<code>\r\n\r\n</em> <strong>NSString</strong>: biểu diễn chuỗi.\r\n    Ví dụ:\r\n    \r\n    </code>`<code>mm\r\n    NSString *greeting = @&quot;Hello&quot;;\r\n    </code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Swift trong iOS?",
              "answer": "<p>Swift là ngôn ngữ lập trình phát triển nhanh nhất hiện nay, do Apple tạo ra. Với lợi thế đáng kể so với Objective-C, Swift giữ vị trí dẫn đầu trong việc phát triển iOS. Đây là một ngôn ngữ hoàn toàn mới được tạo ra đặc biệt để phát triển phần mềm cho các hệ điều hành của Apple. Vì Swift triển khai tất cả các tính năng của các ngôn ngữ hiện đại khác, bạn có thể tìm thấy kiểu tự suy, tùy chọn, generics và các hàm bậc cao hơn. Nó tương thích với macOS, iOS, watchOS và tvOS.\r\n\r\n<img src=\"/interview-assets/Swift_in_iOS.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các tính năng nổi bật của Swift?",
              "answer": "<p>Ngôn ngữ lập trình Swift đang được thiết kế để các nhà phát triển có thể viết các chương trình chính xác và bảo trì chúng một cách dễ dàng. Nó cung cấp các tính năng sau:\r<ul><li><strong>An toàn:</strong> Swift đem về một cách hiệu quả để viết chương trình. Kiểm tra code trước khi nó được sử dụng trong sản xuất là rất quan trọng. Apple Swift loại bỏ bất kỳ code không an toàn nào trước khi nó được sử dụng trong quá trình sản xuất.</li></ul>\r<ul><li><strong>Cú pháp đơn giản:</strong> Cú pháp của Swift rất đơn giản và dễ sử dụng, giống như các nhà phát triển mong đợi. Các tính năng cú pháp của Swift cho phép bạn viết code tường minh hơn.</li></ul>\r<ul><li><strong>Tính dễ đọc:</strong> Swift có cú pháp đơn giản, dễ đọc và dễ viết hơn. Các nhà phát triển viết code Swift dễ dàng hơn vì nó giống với tiếng Anh thuần túy hơn, cho phép họ dành ít thời gian hơn để tìm kiếm mã có vấn đề.</li></ul>\r<ul><li><strong>Hỗ trợ đa dạng:</strong> Swift hoàn toàn tương thích với iOS, macOS, tvOS, watchOS, Linux và nhiều nền tảng khác. Điều này có nghĩa là bạn có thể phát triển phần mềm tương thích với tất cả các hệ điều hành.</li></ul>\r<ul><li><strong>Mã nguồn mở:</strong> Swift được phát triển tại <em>swift.org</em>, một framework mã nguồn mở. Để Swift trở thành một ngôn ngữ lập trình xác định, công nghệ này phải được mở cho tất cả mọi người. Swift hỗ trợ tất cả các nền tảng của Apple và giúp lập trình dễ dàng hơn, nhanh hơn và an toàn hơn.</li></ul>\r<ul><li><strong>Tương thích với Objective C:</strong> Swift có khả năng tương thích hoàn toàn với Objective-C. Swift cho phép các lập trình viên nhập các framework từ Objective-C bằng cú pháp Swift. Lập trình viên có thể sử dụng các thư viện và lớp Objective-C bên trong code Swift.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "NSError trong Swift?",
              "answer": "<p>Thông tin về điều kiện lỗi được đóng gói trong đối tượng NSError theo cách có thể mở rộng và hướng đối tượng. Đối tượng NSError bao gồm ba thuộc tính cơ bản: miền lỗi được xác định trước (được biểu thị dưới dạng chuỗi), mã lỗi dành riêng cho miền và từ điển thông tin người dùng chứa thông tin dành riêng cho ứng dụng.\r\n\r\n``<code>swift\r\nNSString <em>domain = @&quot;com.MyCompany.MyApplication.ErrorDomain&quot;;\r\n\r\nNSString </em>desc = NSLocalizedString(@&quot;Unable to complete the process&quot;, @&quot;&quot;);\r\n\r\nNSDictionary <em>userInfo = @{ NSLocalizedDescriptionKey : desc };\r\n\r\nNSError </em>error = [NSError errorWithDomain:domain code:-101 userInfo:userInfo];\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Enum trong Swift?",
              "answer": "<p>Thuật ngữ enum đề cập đến một kiểu dữ liệu do người dùng xác định bao gồm một tập hợp các giá trị liên quan cho phép bạn làm việc với các giá trị đó trong code của mình theo cách an toàn về kiểu. Một kiểu dữ liệu enum được xác định bởi từ khóa enum.\r\n\r\nCú pháp\r\n\r\n``<code>swift\r\nenum enum_name  \r\n{    \r\n// enumeration values are described here \r\n}\r\n</code>`<code>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>swift\r\nenum MonthsofaYear \r\n{    \r\ncase January \r\ncase Februrary \r\n… \r\ncase December \r\n}\r\n</code>`<code>\r\n\r\nCác giá trị được xác định trong một enum </code>MonthsofaYear<code> như </code>January<code>, </code>Februrary<code> cho đến </code>December<code> là các trường hợp liệt kê của nó. Các trường hợp liệt kê mới có thể được thêm bằng cách sử dụng từ khóa </code>case<code>. Bạn có thể đặt nhiều </code>case<code> trên một dòng, được phân tách bằng dấu phẩy như sau:\r\n\r\n</code>`<code>swift\r\nenum MonthsofaYear\r\n{\r\n   case January, February,....,December\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính lazy trong iOS?",
              "answer": "<p>Thuộc tính lazy là thuộc tính có giá trị ban đầu không được tính cho đến lần đầu tiên chúng được sử dụng. Bao gồm từ khóa <code>lazy</code> trước khi khai báo thuộc tính được lưu trữ để cho biết nó là lazy. Điều này cho phép bạn trì hoãn việc khởi tạo các thuộc tính được lưu trữ. Đây có thể là một cách tuyệt vời để đơn giản hóa code của bạn và giảm bớt công việc không cần thiết. Khi một đoạn code nặng nề và không có khả năng nhất quán, thì biến lazy có thể là một giải pháp tuyệt vời.\r\n\r\n``<code>swift\r\nclass Person { \r\n    var name: String\r\n    lazy var personalizdgreeting : String = {  \r\n        return &quot;HelloScala \\(self.name)!&quot; \r\n    }()\r\n    init(name: String) { \r\n        self.name = name \r\n    } \r\n}\r\n</code>`<code>\r\n\r\nNhư đã trình bày ở trên, chúng ta không chắc chắn về giá trị </code>personalizdgreeting` nên có. Để biết chính xác, chúng ta cần đợi cho đến khi đối tượng này được khởi tạo.</p>",
              "level": "fresher"
            },
            {
              "question": "Generic trong Swift?",
              "answer": "<p>Một tính năng chính của Swift là generic và phần lớn thư viện chuẩn của Swift được viết bằng code generic. Ví dụ: kiểu 'Array' và 'Dictionary' của Swift tạo thành các tập hợp generic. Code generic cho phép bạn tạo các hàm và kiểu linh hoạt, có thể tái sử dụng hoạt động với bất kỳ kiểu dữ liệu nào. Bạn có thể tạo code không quá cụ thể về các kiểu dữ liệu cơ bản, dẫn đến code sạch hơn.\r\n\r\n``<code>swift\r\nfunc Swapping(x: inout Int, y: inout Int)  \r\n{    \r\n    let temp = x \r\n    x = y \r\n    y = temp \r\n} \r\nvar num1 = 10 \r\nvar num2 = 50 \r\nprint(&quot;Before Swapping: \\(num1) and \\(num2)&quot;) \r\nSwapping(x: &amp;num1, y: &amp;num2) \r\nprint(&quot;After Swapping: \\(num1) and \\(num2)&quot;)\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nBefore Swapping: 10 and 50 \r\nAfter Swapping: 50 and 10\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, chúng ta đã định nghĩa một hàm </code>Swapping()` để hoán đổi các số nguyên. Nó nhận hai tham số x và y kiểu int. Như đã thấy trong đầu ra, các giá trị của x và y được trao đổi sau khi hoán đổi.</p>",
              "level": "fresher"
            },
            {
              "question": "Dictionary trong Swift?",
              "answer": "<p>Swift định nghĩa dictionary là một tập hợp các mục không có thứ tự. Nó lưu trữ các mục theo cặp key-value. Dictionary sử dụng một định danh duy nhất được gọi là khóa (key) để lưu trữ một giá trị (value) được liên kết mà sau này có thể được tham chiếu và truy xuất thông qua cùng một khóa.\r\n\r\nCú pháp:\r\n\r\n``<code>swift\r\nvar Dict_name = [KeyType: ValueType]() \r\n</code>`<code>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>swift\r\nvar examresult= [&quot;Rahul&quot;: &quot;79&quot;, &quot;Aditya&quot;: &quot;86&quot;, &quot;Aditi&quot;: &quot;67&quot;] \r\nprint(examresult) \r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>swift\r\n[&quot;Rahul&quot;: &quot;79&quot;, &quot;Aditya&quot;: &quot;86&quot;, &quot;Aditi&quot;: &quot;67&quot;] \r\n</code>`<code>\r\n\r\nTrong ví dụ trên ta tạo một dictionary là </code>examresult<code>. Với\r<ul><li>Khoá là </code>Rahul<code>, </code>Aditya<code>, </code>Aditi<code>.</li></ul>\r<ul><li>Giá trị là </code>79<code>, </code>86<code>, </code>67`.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các design pattern được dùng trong iOS?",
              "answer": "<p>Design pattern là giải pháp cho một vấn đề cụ thể mà bạn có thể gặp phải khi thiết kế kiến trúc của ứng dụng. Chúng là các mẫu được thiết kế để giúp bạn viết code dễ dàng hơn và có thể tái sử dụng nhiều hơn. Sau đây là một số design pattern có thể được sử dụng trong iOS:\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Framework JSON nào được hỗ trợ trong iOS?",
              "answer": "<p>iOS hỗ trợ framework SBJson. Con người và máy tính đều có thể dễ dàng đọc và ghi công cụ định dạng trao đổi dữ liệu này. Xử lý JSON được đơn giản hóa với các API linh hoạt của SBJson và kiểm soát bổ sung.</p>",
              "level": "fresher"
            },
            {
              "question": "iBeacons trong iOS?",
              "answer": "<p>iBeacon, công nghệ không dây Bluetooth năng lượng thấp mới của Apple, cho phép iPhone và người dùng iOS khác nhận thông tin và dịch vụ dựa trên vị trí trên điện thoại thông minh. IBeacons là những thiết bị phát không dây, nhỏ, truyền tín hiệu đến các thiết bị thông minh gần đó thông qua công nghệ năng lượng thấp Bluetooth.\r\n\r\n<img src=\"/interview-assets/iBeacons_in_iOS.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa KVC và KVO trong Swift?",
              "answer": "<p><ul><li><strong>KVC (Key-Value Coding):</strong> Nó cho phép các thuộc tính của đối tượng được truy cập trong thời gian chạy bằng cách sử dụng các chuỗi thay vì biết tên thuộc tính một cách tĩnh trong quá trình phát triển.</li></ul>\r<ul><li><strong>KVO (Key-Value Observing):</strong> Trong Objective-C và Swift, KVO là một trong những phương pháp để quan sát các thay đổi trạng thái chương trình. Nếu một đối tượng có các biến cá thể, KVO cho phép các đối tượng khác quan sát những thay đổi đối với các biến đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "TDD là gì?",
              "answer": "<p>Các nhà phát triển phần mềm có thể sử dụng testing-driven development (TDD) trong quá trình phát triển phần mềm. Trong TDD, các nhà phát triển lập kế hoạch các tính năng của phần mềm mà họ muốn tạo và sau đó viết các trường hợp kiểm thử cho từng tính năng trước khi triển khai nó. Thông qua testing-driven development, chúng ta có thể hiểu rõ hơn về cả chất lượng của việc triển khai (nó có hoạt động không) và chất lượng của thiết kế (nó có được cấu trúc tốt không).\r\n\r\n<img src=\"/interview-assets/TDD.png\" alt=\"\" />\r\n\r\nLúc đầu, trường hợp thử nghiệm sẽ thất bại vì code chưa được triển khai và điều này thường được gọi là <em>giai đoạn đỏ</em>. Sau đó, code được viết để đảm bảo rằng trường hợp thử nghiệm vượt qua và không phá vỡ bất kỳ thành phần nào hoặc trường hợp thử nghiệm hiện tại, được gọi là <em>giai đoạn xanh</em>. Sau đó, nhà phát triển cấu trúc lại việc triển khai code bằng cách làm sạch và bảo trì codebase, cũng như tối ưu hóa hiệu quả. Quá trình này sau đó nên được lặp lại mỗi khi một trường hợp thử nghiệm mới được thêm vào.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích các hàm completion handler?",
              "answer": "<p>Completion handler về cơ bản là các hàm được truyền dưới dạng tham số cho các hàm khác. Chúng được dùng cho xử lý các phản hồi của tác vụ bất đồng bộ vì chúng ta không biết khi nào chúng sẽ kết thức. Completion handler thông báo cho ứng dụng khi một hoạt động, chẳng hạn như lệnh gọi API, đã được hoàn thành. Chương trình được thông báo rằng bước tiếp theo cần được thực hiện.\r\n\r\n<strong>Ví dụ</strong>\r\n\r\nTa tạo một lớp gọi là <code>CompletionHandler</code> có một phương thức là <code>count</code> để đếm từ 0 đến 50. Sau khi đến 25 (giá trị ngẫu nhiên), nó sẽ tạo một yêu cầu mạng đến <code>https://scaler.com</code>. Sau khi mỗi yêu cầu hoàn thành ta in <code>Received response</code>.\r\n\r\n``<code>swift\r\nclass CompletionHandler {\r\n    func count() {\r\n        for i in 0...50 {\r\n            if i == 25 {\r\n                if let url = URL(string: &quot;https://scaler.com&quot;) {\r\n                    URLSession.shared.dataTask(with: url) { (data, response, error) in\r\n                        print(&quot;Received response&quot;)\r\n                    }.resume()\r\n                }\r\n            }     \r\n            print(&quot;I = &quot;, i)\r\n        }\r\n    }\r\n}\r\nlet newInstance = CompletionHandler()\r\nnewInstance.count()\r\n</code>`<code>\r\n\r\nBạn sẽ thấy tất cả các số được in ra trong bảng điều khiển ngay sau khi code chạy, nhưng </code>Received response` sẽ chỉ được in sau khi tất cả các số khác đã được in.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa strong, weak, readonly và copy?",
              "answer": "<p><ul><li><strong>Strong</strong>: Thuộc tính này duy trì một tham chiếu đến thuộc tính trong suốt thời gian tồn tại của một đối tượng. Khi bạn khai báo <code>strong</code>, bạn có ý định \"sở hữu\" đối tượng mà bạn đang tham chiếu. Dữ liệu bạn gán cho thuộc tính này sẽ không bị hủy miễn là bạn hoặc bất kỳ đối tượng nào khác tham chiếu <code>strong</code> đến thuộc tính này.</li></ul>\r<ul><li><strong>Weak</strong>: Có nghĩa là đối tượng nên được giữ trong bộ nhớ miễn là ai đó trỏ strong vào nó và bạn không cần kiểm soát thời gian tồn tại của nó.</li></ul>\r<ul><li><strong>Read-only</strong>: Thuộc tính của một đối tượng có thể được xác định ban đầu, nhưng nó không thể được thay đổi hoặc sửa đổi.</li></ul>\r<ul><li><strong>Copy</strong>: Thuộc tính này là một thay thế cho <code>strong</code>. Thay cho việc chiếm quyền sở hữu một đối tượng hiện tại, nó tạo ra một bản sao của bất kỳ thứ gì bạn gán cho thuộc tính, sau đó có quyền sở hữu bản sao đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Dynamic dispatch là gì?",
              "answer": "<p>Nói một cách dễ hiểu, dynamic dispatch có nghĩa là chương trình quyết định trong thời gian chạy việc triển khai một phương thức hoặc hàm cụ thể nào mà nó cần gọi. Trong trường hợp lớp con ghi đè một phương thức của lớp cha của nó, dynamic dispatch sẽ xác định xem nên gọi triển khai phương thức của lớp con hay của lớp cha.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích lệnh @dynamic và @synthesize trong Objective-C?",
              "answer": "<p><ul><li><strong>@synthesize</strong>: Lệnh này tạo ra các phương thức getter và setter trong thuộc tính và hoạt động cùng với lệnh @dynamic. Theo mặc định, @synthesize tạo một biến có cùng tên với đối tượng đích của set/get như được minh họa trong ví dụ dưới đây.</li></ul>\r<ul><li>Ví dụ 1: </li></ul>\r\n    ``<code>mm\r\n    @property (nonatomic, retain) NSButton <em>someButton;\r\n    ...\r\n    @synthesize someButton;\r\n    </code>`<code>\r<ul><li>Ví dụ 2:</li></ul>\r\n    </code>`<code>mm\r\n    @property (nonatomic, retain) NSButton </em>someButton;\r\n    ...\r\n    @synthesize someButton= _homeButton;\r\n    </code>`<code>\r<ul><li><strong>@dynamic</strong>: Điều này cho trình biên dịch biết rằng các phương thức getter và setter không được triển khai trong chính lớp đó, mà ở những nơi khác (như lớp cha hoặc chúng sẽ có sẵn trong thời gian chạy).</li></ul>\r<ul><li>Ví dụ:</li></ul>\r\n    </code>`<code>mm\r\n    @property (nonatomic, retain) IBOutlet NSButton *someButton;\r\n    ...\r\n    @dynamic someButton;\r\n    </code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách triển khai storage và persistence trong iOS?",
              "answer": "<p>Persistence có nghĩa là lưu trữ dữ liệu trên đĩa để có thể truy xuất dữ liệu mà không bị thay đổi trong lần mở ứng dụng tiếp theo. Từ đơn giản đến phức tạp, có các phương pháp sau để lưu trữ dữ liệu:\r<ul><li>Các cấu trúc dữ liệu như mảng, tập hợp, dictionary và các cấu trúc dữ liệu khác là những cấu trúc hoàn hảo để lưu trữ dữ liệu ngay lập tức.</li></ul>\r<ul><li><code>NSUserDefaults</code> và <code>Keychains</code> đều là kho lưu trữ key-value đơn giản. <code>NSUserDefaults</code> thì không an toàn, trong khi Keychains bảo mật hơn.</li></ul>\r<ul><li>File hoặc disk storage là một cách để lưu trữ dữ liệu (được tuần tự hóa hoặc không) đến đĩa bằng <code>NSFileManager</code>.</li></ul>\r<ul><li>Cơ sở dữ liệu quan hệ, chẳng hạn như SQLite, rất tốt để triển khai các cơ chế truy vấn phức tạp</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tác vụ đồng bộ và bất đồng bộ trong iOS?",
              "answer": "<p>iOS của Apple hỗ trợ cả tác vụ đồng bộ và bất đồng bộ. Trong các hoạt động đồng bộ, các tác vụ được thực hiện lần lượt. Do đó, các tác vụ khác phải đợi cho đến khi hoàn thành tác vụ trước rồi mới tiếp tục. Các tác vụ bất đồng bộ chạy đồng thời trong nền. Nếu các tác vụ nền được hoàn thành, bạn sẽ được thông báo. Lập trình bất đồng bộ cho phép bạn xử lý nhiều yêu cầu cùng một lúc, vì vậy bạn có thể hoàn thành nhiều tác vụ hơn trong một khoảng thời gian ngắn hơn.\r\n\r\n<img src=\"/interview-assets/synchronous_and_asynchronous_tasks_in_iOS.png\" alt=\"\" />\r\n\r\nHình trên chỉ ra rằng các tác vụ đồng bộ cần nhiều thời gian hơn để hoàn thành, tức là 45 giây, khi mỗi tác vụ được thực hiện một lần. Mặt khác, các tác vụ bất đồng bộ sẽ mất ít thời gian hơn để hoàn thành, tức là 20 giây khi chúng chạy đồng thời.\r\n\r\nCông việc bất đồng bộ có thể được xử lý bằng thư viện của bên thứ ba. Một vài ví dụ nổi bật là Promise(PromiseKit), RxSwift và ReactiveCocoa.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "java",
          "name": "Câu hỏi phỏng vấn Java",
          "description": "",
          "questions": [
            {
              "question": "Java có phải nền tảng độc lập không?",
              "answer": "<p>Java là một ngôn ngữ độc lập với nền tảng vì mã nguồn của Java có thể chạy trên nhiều hệ điều hành. Các chương trình Java có thể chạy trên bất kỳ máy nào hoặc hệ điều hành không cần cài đặt bất kỳ phần mềm đặc biệt nào. Mặc dù JVM cần phải có mặt trong máy. Mã Java biên dịch thành bytecode (file .class), độc lập với nền tảng. Chúng tôi có thể chạy mã bytecode này trên Windows, Linux, Mac OS,....</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao nói Java không phải ngôn ngữ thuần đối tượng?",
              "answer": "<p>Java hỗ trợ kiểu dữ liệu nguyên thuỷ byte, boolean, char, short, int, float, long, và double, do đó nó không phải là ngôn ngữ thuần đối tượng.</p>",
              "level": "fresher"
            },
            {
              "question": "Con trỏ trong Java?",
              "answer": "<p>Con trỏ là một khái niệm khá phức tạp đối với những người mới bắt đầu. Java tập trung vào sự đơn giản cho code nên việc sử dụng con trỏ có thể khiến nó trở nên phức tạp hơn. Đồng thời, tính bảo mật cũng bị ảnh hưởng nếu con trỏ được sử dụng vì người dùng có thể truy cập trực tiếp vào bộ nhớ với sự trợ giúp của con trỏ.\r\n\r\nDo đó, một mức trừu tượng nhất định được cung cấp bằng cách không bao gồm các con trỏ trong Java. Hơn nữa, việc sử dụng con trỏ có thể làm cho tiến trình thu gom rác khá chậm và sai sót. Java sử dụng các tham chiếu vì chúng không thể thao tác được, không giống như con trỏ.</p>",
              "level": "fresher"
            },
            {
              "question": "Biến toàn cục và biến cục bộ trong Java?",
              "answer": "<p><strong>Biến toàn cục (instance variables)</strong> là các biến có thể được truy cập bởi tất cả phương thức trong lớp. Chúng được khai báo bên ngoài phương thức và bên trong lớp. Các biến này mô tả thuộc tính của một đối tượng, chúng được tạo khi một đối tượng được tạo bằng việc sử dụng từ khóa “new” và sẽ bị phá hủy khi đối tượng bị phá hủy.\r\n\r\nTất cả các đối tượng của lớp sẽ có bản sao các biến để sử dụng. Nếu bất kỳ thay đổi nào được thực hiện trên các biến này, chỉ có đối tượng đó bị tác động, các đối tượng cùng lớp khác sẽ không ảnh hưởng.\r\n\r\n``<code>java\r\nclass Athlete {\r\n    public String athleteName;\r\n    public double athleteSpeed;\r\n    public int athleteAge;\r\n}\r\n</code>`<code>\r\n\r\n<strong>Biến cục bộ (local variables)</strong> là các biến được khai báo trong các phương thức, hàm contructor hoặc trong các khối (</code>{}<code>). Việc sử dụng biến bị hạn chế trong phạm vi khối. Bất cứ khi nào một biến cục bộ được khai báo bên trong một phương thức, các phương thức lớp khác không biết gì về sự tồn tại của nó.\r\n\r\n</code>`<code>java\r\npublic void athlete() {\r\n    String athleteName;\r\n    double athleteSpeed;\r\n    int athleteAge;\r\n}\r\n</code>``\r\n\r\n<img src=\"/interview-assets/instance_vs_local_variable.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Đóng gói dữ liệu là gì?",
              "answer": "<p><ul><li>Đóng gói dữ liệu là một khái niệm trong lập trình hướng đối tượng để ẩn các thuộc tính dữ liệu và hành vi của chúng trong một đơn vị duy nhất.</li></ul>\r<ul><li>Nó giúp các nhà phát triển tuân theo module trong khi phát triển phần mềm bằng cách đảm bảo rằng mỗi đối tượng độc lập với các đối tượng khác bằng cách có các phương thức, thuộc tính và chức năng riêng của nó.</li></ul>\r<ul><li>Nó được sử dụng để bảo mật các thuộc tính riêng tư của một đối tượng và do đó phục vụ mục đích ẩn dữ liệu.</li></ul>\r\n\r\n<img src=\"/interview-assets/data_encapsulation.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "JIT compiler là gì?",
              "answer": "<p>JIT là viết tắt của Just-In-Time, được dùng để cải thiện hiệu suất khi biên dịch. Nó thực hiện nhiệm vụ biên dịch các phần của bytecode có chức năng giống nhau cùng lúc, do đó giảm lượng thời gian biên dịch để chạy code.\r\n\r\nTrình biên dịch (compiler) là nơi dịch mã nguồn thành mã máy tính có thể hiểu. Nhưng JIT đặc biệt vì:\r<ul><li>Mã nguồn (.java) được chuyển thành bytecode (.class) xảy ra ở trình biên dịch javac.</li></ul>\r<ul><li>Sau đó file <code>.class</code> được tải bởi JVM và sự trợ giúp của trình thông dịch(interpreter), nó được chuyển thành mã máy tính có thể hiểu.</li></ul>\r<ul><li>Trình biên dịch JIT là một phần của JVM. Khi JIT khởi động, JVM phân tích phương thức gọi trong file <code>.class</code> và biên dịch chúng để có được code thuần và hiệu quả hơn. Nó cũng đảm bảo phương thức gọi ưu tiên được tối ưu hoá.</li></ul>\r<ul><li>Sau khi bước trên hoàn thành, JVM thực thi code tối ưu trực tiếp thay vì thông dịch lần nữa. Điều này tăng hiệu suất và tốc độ thực thi.</li></ul>\r\n\r\n<img src=\"/interview-assets/JIT_Compiler.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biết giữa phương thức equals() và toán tử == trong Java?",
              "answer": "<p>| equals() | == |\r\n|-|-|\r\n| Phương thức khai báo trong lớp, đối tượng | Toán tử nhị phân trong Java |\r\n| Dùng cho kiếm tra so sánh bằng nội dung giữa hai đối tượng theo logic nghiệp vụ cụ thể | Dùng để so sánh địa chỉ (hoặc tham chiếu), tức là kiểm tra xem cả hai đối tượng có trỏ đến cùng một vị trí bộ nhớ hay không |\r\n\r\n<em>Lưu ý</em>\r<ul><li>Trong trường hợp phương thức <code>equals</code> không được ghi đè trong một lớp, thì lớp đó sử dụng cách triển khai mặc định của phương thức <code>equals</code> gần với lớp cha nhất.</li></ul>\r<ul><li>Lớp <code>object</code> được coi là lớp cha của tất cả các lớp java. Việc triển khai phương thức <code>equals</code> trong lớp object sử dụng toán tử <code>==</code> để so sánh hai đối tượng. Việc triển khai mặc định này có thể được ghi đè theo logic nghiệp vụ.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Dùng vòng lặp trong Java thế nào?",
              "answer": "<p><ul><li>Vòng lặp For:</li></ul>\r\n\r\n``<code>java\r\nfor(;;)\r\n{\r\n    // Business logic\r\n    // Any break logic\r\n}\r\n</code>`<code>\r<ul><li>Vòng lặp While:</li></ul>\r\n\r\n</code>`<code>java\r\nwhile(true) {\r\n    // Business logic\r\n    // Any break logic\r\n}\r\n</code>`<code>\r<ul><li>Vòng lặp do-while:</li></ul>\r\n\r\n</code>`<code>java\r\ndo {\r\n    // Business logic\r\n    // Any break logic\r\n} while(true);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích khái niệm constructor overloading?",
              "answer": "<p>Nạp chồng hàm khởi tạo (constructor overloading) là quá trình tạo nhiều hàm khởi tạo có cùng tên nhưng khác các tham số trong lớp. Tùy thuộc vào số lượng tham số và kiểu tương ứng của chúng, việc phân biệt các loại constructor khác nhau được thực hiện bởi trình biên dịch.\r\n\r\n``<code>java\r\nclass Hospital {\r\n    int variable1, variable2;\r\n    double variable3;\r\n    public Hospital(int doctors, int nurses) {\r\n        variable1 = doctors;\r\n        variable2 = nurses;\r\n    }\r\n    public Hospital(int doctors) {\r\n        variable1 = doctors;\r\n    }\r\n    public Hospital(double salaries) {\r\n        variable3 = salaries\r\n    }\r\n}\r\n</code>``\r\n\r\n<img src=\"/interview-assets/constructor_overloading_java.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Nạp chồng phương thức và ghi đè phương thức trong Java?",
              "answer": "<p>Trong Java, việc <strong>nạp chồng phương thức (overloading)</strong> được thực hiện bằng cách đưa các phương thức khác nhau vào cùng một lớp có cùng tên. Tuy nhiên, tất cả các hàm khác nhau về số lượng hoặc kiểu tham số. Nó diễn ra bên trong một lớp và nâng cao khả năng đọc của chương trình.\r\n\r\nSự khác biệt duy nhất trong kiểu trả về của phương thức không thúc đẩy quá trình nạp chồng phương thức. Ví dụ sau đây sẽ cung cấp cho bạn một bức tranh rõ ràng về nó.\r\n\r\n``<code>java\r\nclass OverloadingHelp {\r\n    public int findarea (int l, int b) {\r\n        int var1;\r\n        var1 = l <em> b;\r\n        return var1;\r\n    }\r\n    public int findarea (int l, int b, int h) {\r\n        int var2;\r\n        var2 = l </em> b <em> h;\r\n        return var2;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<img src=\"/interview-assets/method_overloading.png\" alt=\"\" />\r\n\r\nCả hai hàm có cùng tên nhưng khác nhau về số lượng tham số. Phương pháp đầu tiên tính diện tích hình chữ nhật, trong khi phương pháp thứ hai tính diện tích hình hộp chữ nhật.\r\n\r\n<strong>Ghi đè phương thức (override)</strong> là khái niệm trong đó hai phương thức giống nhau hiện diện trong hai lớp khác nhau, trong đó có mối quan hệ kế thừa. Có thể thực hiện một phương thức cụ thể (đã có trong lớp cơ sở) cho lớp dẫn xuất bằng cách sử dụng ghi đè phương thức.\r\n\r\nHãy xem ví dụ này:\r\n\r\n</code>`<code>java\r\nclass HumanBeing {\r\n    public int walk (int distance, int time) {\r\n        int speed = distance / time;\r\n        return speed;\r\n    }\r\n}\r\nclass Athlete extends HumanBeing {\r\n    public int walk(int distance, int time) {\r\n        int speed = distance / time;\r\n        speed = speed </em> 2;\r\n        return speed;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<img src=\"/interview-assets/method_overriding.png\" alt=\"\" />\r\n\r\nCả hai phương thức lớp đều có tên </code>walk<code> và các tham số: </code>distance<code> và </code>time<code> giống nhau. Nếu phương thức lớp dẫn xuất được gọi, thì phương thức </code>walk` của lớp cơ sở sẽ bị ghi đè bởi phương thức của lớp dẫn xuất.</p>",
              "level": "fresher"
            },
            {
              "question": "Một try có thể có nhiều catch trong Java?",
              "answer": "<p>Có, nhiều khối catch có thể tồn tại nhưng các phương pháp tiếp cận cụ thể nên ưu tiên hơn cách tiếp cận chung vì khi khối đầu tiên thoả mãn điều kiện catch mới được thực thi. Ví dụ:\r\n\r\n``<code>java\r\npublic class MultipleCatch {\r\n    public static void main(String args[]) {\r\n        try {\r\n            int n = 1000, x = 0;\r\n            int arr[] = new int[n];\r\n            for (int i = 0; i &lt;= n; i++) {\r\n                arr[i] = i / x;\r\n            }\r\n        }\r\n        catch (ArrayIndexOutOfBoundsException exception) {\r\n            System.out.println(&quot;1st block = ArrayIndexOutOfBoundsException&quot;);\r\n        }\r\n        catch (ArithmeticException exception) {\r\n            System.out.println(&quot;2nd block = ArithmeticException&quot;);\r\n        }\r\n        catch (Exception exception) {\r\n            System.out.println(&quot;3rd block = Exception&quot;);\r\n        }\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nỞ đây khối catch thứ hai sẽ được thực thi vì phép chia bởi </code>0(i/x)`. Trong trường hợp x lớn 0 thì khối catch đầu tiên sẽ thực thi vì vòng lặp chạy đến khi i = n và chỉ số mảng đến n-1.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích từ khoá final trong biến, phương thức và lớp?",
              "answer": "<p>Trong Java, từ khoá <code>final</code> được dùng cho xác định một thứ gì đó là một hằng và không thể chỉnh sửa nữa.\r<ul><li>biến <code>final</code>:</li></ul>\r<ul><li>Khi một biến được khai báo là final trong Java, giá trị không thể chỉnh sửa sau khi gán.</li></ul>\r<ul><li>Nếu không có bất kỳ giá trị nào được gán cho biến, nó có thể được gán bằng constructor của lớp.</li></ul>\r<ul><li>phương thức <code>final</code>:</li></ul>\r<ul><li>Một phương thức được khai báo là final nó sẽ không thể bị ghi đè bởi lớp con của nó.</li></ul>\r<ul><li>Một constructor không thể là final vì nếu một lớp được kế thừa thì constructor cũng kế thừa theo. Do đó, khi đánh dấu constructor là final, Java sẽ trả về lỗi - <code>modifier final not allowed here</code></li></ul>\r<ul><li>lớp <code>final</code>:</li></ul>\r<ul><li>Một lớp được khai báo là final thì không có bất kỳ lớp nào có thể kế thừa lớp đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các từ khoá final, finally và finalize là giống nhau?",
              "answer": "<p><strong>Final:</strong> dùng cho các lớp, biến hoặc phương thức. Việc kế thừa một lớp final hay ghi đè một phương thức final sẽ bị hạn chế bởi việc sử dụng từ khoá final. Giá trị biến trở thành hằng sau khi dùng từ khoá final. Ví dụ:\r\n\r\n``<code>java\r\nfinal int a=100;\r\na = 0;  // error\r\n</code>`<code>\r\n\r\n<strong>Finally:</strong> Nó là khối hiện diện trong chương trình nơi tất cả code được viết bên trong nó được thực thi kể cả việc xử lý ngoại lệ. Ví dụ:\r\n\r\n</code>`<code>java\r\ntry {\r\n    int variable = 5;\r\n}\r\ncatch (Exception exception) {\r\n    System.out.println(&quot;Exception occurred&quot;);\r\n}\r\nfinally {\r\n    System.out.println(&quot;Execution of finally block&quot;);\r\n}\r\n</code>`<code>\r\n\r\n<strong>Finalize:</strong> Trước khi thu gom rác của một đối tượng, phương thức finalize được gọi để hoạt động dọn dẹp được thực hiện. Ví dụ:\r\n\r\n</code>`<code>java\r\npublic static void main(String[] args) {\r\n    String example = new String(&quot;InterviewBit&quot;);\r\n    example = null;\r\n    System.gc(); // Garbage collector called\r\n}\r\npublic void finalize() {\r\n    // Finalize called\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Khi nào dùng từ khoá super?",
              "answer": "<p>Từ khoá <code>super</code> được dùng để truy cập các trường ẩn và ghi đề phương thức hoặc thuộc tính của lớp cha.\r\nNó dùng trong các trường hợp sau:\r<ul><li>Truy cập dữ liệu thành viên của lớp cha khi tên thành viên của lớp cha và lớp con giống nhau.</li></ul>\r<ul><li>Để gọi phương thức khởi tạo tham số và mặc định của lớp cha bên trong lớp con.</li></ul>\r<ul><li>Truy cập phương thức lớp cha khi lớp con ghi đè chúng.</li></ul>\r\n\r\nVí dụ:\r\n\r\n``<code>java\r\npublic class Parent{\r\n    protected int num = 1;\r\n    \r\n    Parent(){\r\n        System.out.println(&quot;Parent class default constructor.&quot;);\r\n    }\r\n    \r\n    Parent(String x){\r\n        System.out.println(&quot;Parent class parameterised constructor.&quot;);\r\n    }\r\n    \r\n    public void foo(){\r\n        System.out.println(&quot;Parent class foo!&quot;);\r\n    }\r\n}\r\n   \r\npublic class Child extends Parent{\r\n    private int num = 2;\r\n    \r\n    Child(){\r\n        System.out.println(&quot;Child class default Constructor&quot;);\r\n        \r\n        super();    // to call default parent constructor\r\n        super(&quot;Call Parent&quot;);    // to call parameterised constructor.\r\n    }\r\n    \r\n    void printNum(){\r\n        System.out.println(num);\r\n        System.out.println(super.num); //prints the value of num of parent class\r\n    }\r\n    \r\n    @Override\r\n    public void foo(){\r\n        System.out.println(&quot;Parent class foo!&quot;);\r\n        super.foo();    //Calls foo method of Parent class inside the Overriden foo method of Child class.\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các cách tạo đối tượng trong Java?",
              "answer": "<p><ul><li>Sử dụng từ khoá new:</li></ul>\r\n\r\n``<code>java\r\nclass ObjectCreationExample{\r\n\tString Owner;\r\n}\r\npublic class MainClass {\r\n\tpublic static void main(String[] args) {\r\n\t\t// Here we are creating Object of JBT using new keyword\r\n\t\tObjectCreationExample obj = new ObjectCreationExample();\r\n\t}\r\n}\r\n</code>`<code>\r<ul><li>Sử dụng reflection:</li></ul>\r\n\r\n</code>`<code>java\r\nclass CreateObjectClass {\r\n\tstatic int j = 10;\r\n\tCreateObjectClass() {\r\n\t\ti = j++;\r\n\t}\r\n\tint i;\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn &quot;Value of i :&quot; + i;\r\n\t}\r\n}\r\n\r\nclass MainClass {\r\n\tpublic static void main(String[] args) {\r\n\t\ttry {\r\n\t\t\tClass cls = Class.forName(&quot;CreateObjectClass&quot;);\r\n\t\t\tCreateObjectClass obj = (CreateObjectClass) cls.newInstance();\r\n\t\t\tCreateObjectClass obj1 = (CreateObjectClass) cls.newInstance();\r\n\t\t\tSystem.out.println(obj);\r\n\t\t\tSystem.out.println(obj1);\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (InstantiationException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (IllegalAccessException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n}\r\n</code>`<code>\r<ul><li>Sử dụng clone:</li></ul>\r\n\r\n</code>`<code>java\r\n class CreateObjectWithClone implements Cloneable {\r\n\t@Override\r\n\tprotected Object clone() throws CloneNotSupportedException {\r\n\t\treturn super.clone();\r\n\t}\r\n\tint i;\r\n\tstatic int j = 10;\r\n\tCreateObjectWithClone() {\r\n\t\ti = j++;\r\n\t}\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn &quot;Value of i :&quot; + i;\r\n\t}\r\n}\r\n\r\nclass MainClass {\r\n\tpublic static void main(String[] args) {\r\n\t\tCreateObjectWithClone obj1 = new CreateObjectWithClone();\r\n\t\tSystem.out.println(obj1);\r\n\t\ttry {\r\n\t\t\tCreateObjectWithClone obj2 = (CreateObjectWithClone) obj1.clone();\r\n\t\t\tSystem.out.println(obj2);\r\n\t\t} catch (CloneNotSupportedException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n}\r\n</code>`<code>\r<ul><li>Sử dụng ClassLoader:</li></ul>\r\n\r\n</code>`<code>java\r\nclass CreateObjectWithClassLoader {\r\n\tstatic int j = 10;\r\n\tCreateObjectWithClassLoader() {\r\n\t\ti = j++;\r\n\t}\r\n\tint i;\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn &quot;Value of i :&quot; + i;\r\n\t}\r\n}\r\n\r\npublic class MainClass {\r\n\tpublic static void main(String[] args) {\r\n\t\tCreateObjectWithClassLoader obj = null;\r\n\t\ttry {\r\n\t\t\tobj = (CreateObjectWithClassLoader) new MainClass().getClass()\r\n\t\t\t\t\t.getClassLoader().loadClass(&quot;CreateObjectWithClassLoader&quot;).newInstance();\r\n        // Fully qualified classname should be used.\r\n\t\t} catch (InstantiationException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (IllegalAccessException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\tSystem.out.println(obj);\r\n\t}\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể ghi đè phương thức tĩnh?",
              "answer": "<p>Không! Việc khai báo các phương thức tĩnh có cùng một đặc trưng có thể được thực hiện trong lớp con nhưng tính đa hình thời gian chạy không thể diễn ra trong những trường hợp như vậy.\r\n\r\nGhi đè hoặc đa hình động xảy ra trong thời gian chạy, nhưng các phương thức tĩnh được tải và tra cứu thời gian biên dịch một cách tĩnh. Do đó, các phương thức này không thể bị ghi đè.</p>",
              "level": "fresher"
            },
            {
              "question": "Đối tượng chính của bộ dọn rác?",
              "answer": "<p>Mục tiêu chính của quá trình này là giải phóng không gian bộ nhớ bị chiếm bởi các đối tượng không cần thiết và không thể truy cập trong quá trình thực thi chương trình Java bằng cách xóa các đối tượng không thể truy cập đó.\r\n\r\nĐiều này đảm bảo rằng tài nguyên bộ nhớ được sử dụng hiệu quả, nhưng nó không đảm bảo rằng sẽ có đủ bộ nhớ để thực thi chương trình.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa bộ nhớ Heap và Stack?",
              "answer": "<p><strong>Heap</strong>\r\n\r\nKhông gian Java Heap được sử dụng bởi java runtime để cấp phát bộ nhớ cho các đối tượng và các lớp JRE. Bất cứ khi nào chúng ta tạo bất kỳ đối tượng nào, đối tượng đó luôn được tạo trong không gian Heap.\r\n\r\nGarbage Collection chạy trên bộ nhớ heap để giải phóng bộ nhớ được sử dụng bởi các đối tượng không có bất kỳ tham chiếu nào. Bất kỳ đối tượng nào được tạo trong không gian heap đều có quyền truy cập toàn cục và có thể được tham chiếu từ bất kỳ đâu của ứng dụng.\r\n\r\n<strong>Stack</strong>\r\n\r\nStack trong java là một phần bộ nhớ chứa các phương thức, biến cục bộ và biến tham chiếu. Các biến cục bộ được tạo trong stack.\r\n\r\nBộ nhớ stack luôn được tham chiếu theo trật tự LIFO (Last-In-First-Out). Bất cứ khi nào một phương thức được gọi, một khối mới sẽ được tạo trong bộ nhớ ngăn xếp để phương thức này lưu giữ các giá trị nguyên thủy cục bộ và tham chiếu đến các đối tượng khác trong phương thức.\r\n\r\nNgay sau khi phương thức kết thúc, khối sẽ không được sử dụng và có sẵn cho phương thức tiếp theo. Kích thước bộ nhớ stack nhỏ hơn rất nhiều so với bộ nhớ heap.\r\n\r\n<strong>Sự khác biệt</strong>\r\n\r\n| Stack | Heap |\r\n|-|-|\r\n| Dùng cho từng bộ phận mỗi khi thực thi một luồng | Ứng dụng thực sử dụng Heap trong thời gian chạy |\r\n| Phụ thuộc vào hệ điều hành và thường nhỏ hơn Heap | Không có giới hạn cụ thể |\r\n| Lưu trữ biến nguyên thuỷ và tham chiếu đến đối tượng được tạo trong Heap | Tất cả đối tượng được tạo đều được lưu ở đây |\r\n| Truy cập sử dụng hệ thống cấp phát bộ nhớ LIFO (Last-in First-out) | Bộ nhớ này được truy cập thông qua các kỹ thuật quản lý bộ nhớ phức tạp bao gồm Young Generation, Old hoặc Tenured Generation, và Permanent Generation |\r\n| Chỉ tồn tại khi phương thức đang chạy | Tồn tại xuyên suốt quá trình chạy ứng dụng |\r\n| Nhanh hơn so với heap | Chậm hơn so với stack |\r\n| Bộ nhớ này được tự động cấp phát và giải phóng khi một phương thức được gọi và trả về tương ứng | Không gian heap được cấp phát khi các đối tượng mới được tạo và giải phóng bởi Garbage Collector khi chúng không còn được tham chiếu |</p>",
              "level": "fresher"
            },
            {
              "question": "Ngoài khía cạnh bảo mật, những lý do đằng sau việc làm cho chuỗi bất biến trong Java là gì?",
              "answer": "<p>Một chuỗi sẽ thành bất biến vì những lý do sau đây:\r<ul><li><strong>String Pool:</strong> Các nhà thiết kế Java đã nhận thấy được rằng trong thực tế kiểu dữ liệu Strung được sử dụng chủ yếu bởi các lập trình viên và nhà phát triển. Vì vậy, họ muốn tối ưu hoá nó bằng cách đưa ra khái niệm String Pool (một vùng lưu trữ trong Java Heap) để lưu trữ các chuỗi ký tự. Họ dự định giảm đối tượng String tạm thời với sự trợ giúp của tính năng chia sẻ. Một lớp bất biến là cần thiết để tạo điều kiện chia sẻ. Việc chia sẻ cấu trúc có thể thay đổi giữa hai bên không xác định là không thể. Do đó, chuỗi trong Java bất biến giúp thực thi khái niệm String Pool.</li></ul>\r\n\r\n<img src=\"/interview-assets/string_pool.png\" alt=\"\" />\r<ul><li><strong>Đa luồng:</strong> Sự an toàn của các luồng liên quan đến các đối tượng String là một khía cạnh quan trọng trong Java. Không cần đồng bộ hóa bên ngoài nếu các đối tượng String là bất biến. Do đó, một mã code rõ ràng hơn có thể được viết để chia sẻ các đối tượng String trên các luồng khác nhau. Quá trình phức tạp của đồng thời được hỗ trợ bởi phương pháp này.</li></ul>\r<ul><li><strong>Collections:</strong> Trong trường hợp Hash Table và Hash Maps, keys sẽ là một đối tượng String. Nếu các đối tượng String không phải là bất biến, thì nó có thể được sửa đổi trong khoảng thời gian nó nằm trong HashMaps. Do đó, không thể truy xuất dữ liệu mong muốn. Những sự thay đổi như vậy tiềm ẩn rất nhiều rủi ro. Vì vậy, sẽ an toàn hơn nếu làm cho chuỗi bất biến.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa String, StringBuffer và StringBuilder?",
              "answer": "<p><ul><li><strong>Khu vực lưu trữ:</strong> Với String, String Pool đóng vai trò là khu vực lưu trữ. Đối với StringBuilder và StringBuffer, bộ nhớ heap là vùng lưu trữ.</li></ul>\r<ul><li><strong>Tính thay đổi:</strong> Một String là bất biến, trong khi cả StringBuilder và StringBuffer đều có thể thay đổi.</li></ul>\r<ul><li><strong>Hiệu quả:</strong> Khá chậm để làm việc với một String. Tuy nhiên, StringBuilder là nhanh nhất trong việc thực hiện các hoạt động. Tốc độ của StringBuffer hơn String và nhỏ hơn StringBuilder. (Ví dụ: thêm một ký tự là nhanh nhất trong StringBuilder và rất chậm trong String vì cần có bộ nhớ mới cho chuỗi mới với ký tự được nối.)</li></ul>\r<ul><li><strong>Thread-safe:</strong> Trong trường hợp môi trường luồng, StringBuilder và StringBuffer được sử dụng trong khi một String không được sử dụng. Tuy nhiên, StringBuilder phù hợp với môi trường có một luồng duy nhất và StringBuffer phù hợp với đa luồng.</li></ul>\r\n\r\n``<code>java\r\n// String\r\nString first = &quot;InterviewBit&quot;;\r\nString second = new String(&quot;InterviewBit&quot;);\r\n// StringBuffer\r\nStringBuffer third = new StringBuffer(&quot;InterviewBit&quot;);\r\n// StringBuilder\r\nStringBuilder fourth = new StringBuilder(&quot;InterviewBit&quot;);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sử dụng các thuộc tính có liên quan làm nổi bật sự khác biệt giữa các interface và các lớp trừu tượng?",
              "answer": "<p><ul><li><strong>Phương thức khả dụng:</strong> chỉ phương thức trừu tượng là khả dụng trong interface, trong khi đó các phương thức không phải trừu tượng vẫn có thể có trong lớp trừu tượng.</li></ul>\r<ul><li><strong>Kiểu biến:</strong> biến static và final chỉ có thể khai báo trong interface, các biến trong lớp trừu tượng không thể là hai kiểu trên.</li></ul>\r<ul><li><strong>Kế thừa:</strong> đa kế thừa được hỗ trợ trong interface, trong khi các lớp trừu tượng không khuyến khích đa kế thừa.</li></ul>\r<ul><li><strong>Truy cập dữ liệu thành viên:</strong> mặc định, dữ liệu thành viên của interface là công khai, ngược lại dữ liệu thành viên của lớp trừu tượng là riêng tư.</li></ul>\r<ul><li><strong>Triển khai:</strong> với lớp trừu tượng có thể triển khai interface dễ dàng, nhưng không thể làm ngược lại.</li></ul>\r\n\r\nVí dụ lớp trừu tượng:\r\n\r\n``<code>java\r\npublic abstract class Athlete {\r\n    public abstract void walk()\r\n}\r\n</code>`<code>\r\n\r\nVí dụ interface:\r\n\r\n</code>`<code>java\r\npublic interface Walkable {\r\n    void walk();\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Trong Java, có thể ghi đè phương thức static cũng như phương thức private không?",
              "answer": "<p>Không. Các phương thức static không liên quan đến các đối tượng và các phương thức này thuộc cấp độ lớp. Trong trường hợp của một lớp con, một phương thức static có ký hiệu phương thức giống hệt như của lớp cha có thể tồn tại mà không gây ra bất kỳ lỗi biên dịch nào.\r\n\r\nHiện tượng được đề cập ở đây thường được gọi là phương thức ẩn, và việc ghi đè chắc chắn là không thể. Việc ghi đè phương thức private là không thể xảy ra được vì khả năng hiển thị của phương thức private chỉ bị hạn chế ở lớp cha. Do đó, chỉ có thể tạo điều kiện cho việc ẩn và không thể ghi đè.</p>",
              "level": "fresher"
            },
            {
              "question": "HashSet khác TreeSet như thế nào?",
              "answer": "<p>Mặc dù cả HashSet và TreeSet đều không được đồng bộ hóa và đảm bảo rằng không trùng nhưng có một số thuộc tính phân biệt HashSet với TreeSet.\r<ul><li><strong>Triển khai</strong>: với HashSet, bảng băm được dùng cho lưu trữ phần tử không theo thứ tự. Tuy nhiên, TreeSet dùng cây đỏ đen (red-black tree) cho lưu trữ phần tử theo thứ tự.</li></ul>\r<ul><li><strong>Hiệu suất/Độ phức tạp</strong>: Với thêm, xem và xoá phần tử độ phức tạp thời gian là <code>O(1)</code> cho HashSet. Độ phức tạp thời gian cho hiệu suất tương tự như bit lớn nhất cho TreeSet và bằng <code>O(logn)</code>. Tổng thể hiệu suất HashSet nhanh hơn so với TreeSet.</li></ul>\r<ul><li><strong>Phương thức</strong>: <code>hashCode()</code> và <code>equals()</code> là phương thức dùng cho HashSet để so sánh giữa các đối tượng. Còn TreeSet dùng các phương thức <code>compareTo()</code> và <code>compare()</code> để so sánh đối tượng.</li></ul>\r<ul><li><strong>Kiểu đối tượng</strong>: Các đối tượng không đồng nhất và null có thể được lưu trữ với sự trợ giúp của HashSet. Trong trường hợp TreeSet, <strong>runtime exception</strong> xảy ra trong khi chèn các đối tượng không đồng nhất hoặc đối tượng null.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao mảng ký tự được ưu tiên hơn chuỗi để lưu trữ thông tin bí mật?",
              "answer": "<p>Trong Java, một chuỗi về cơ bản là bất biến, tức là không thể sửa đổi. Sau khi khai báo, nó tiếp tục ở trong string pool miễn là nó không bị loại bỏ dưới dạng rác. Nói cách khác, một chuỗi nằm trong phần heap của bộ nhớ trong một khoảng thời gian không được kiểm soát và không xác định sau khi quá trình xử lý giá trị chuỗi được thực hiện.\r\n\r\nDo đó, thông tin quan trọng có thể bị đánh cắp để thực hiện các hoạt động có hại của hacker nếu chúng bị chúng truy cập bất hợp pháp vào bộ nhớ. Những rủi ro như vậy có thể được loại bỏ bằng cách sử dụng các đối tượng hoặc cấu trúc có thể thay đổi được như mảng ký tự để lưu trữ bất kỳ biến nào. Sau khi công việc của biến mảng ký tự được thực hiện, biến có thể được cấu hình để trống ngay lập tức. Do đó, nó giúp tiết kiệm bộ nhớ heap và cũng không tạo cơ hội cho hacker trích xuất dữ liệu quan trọng.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt của JVM, JRE và JDK?",
              "answer": "<p>| JDK | JRE | JVM |\r\n|-|-|-|\r\n| Java Development Kit | Java Runtime Enviroment | Java Virtual Machine |\r\n| JDK là một bộ phát triển phần mềm hoàn chỉnh để phát triển các ứng dụng Java. Nó bao gồm JRE, JavaDoc, trình biên dịch, trình gỡ lỗi,... | JRE là một gói phần mềm cung cấp các thư viện lớp Java, JVM và tất cả các thành phần cần thiết để chạy các ứng dụng Java | JVM là một máy ảo, phụ thuộc vào nền tảng, bao gồm 3 thông số kỹ thuật - tài liệu mô tả các yêu cầu triển khai JVM, chương trình máy tính đáp ứng các yêu cầu JVM và đối tượng thực thể để thực thi bytecode Java và cung cấp môi trường thời gian chạy để thực thi |\r\n| JDK chủ yếu được sử dụng để phát triển và thực thi code | JRE chủ yếu được sử dụng để tạo môi trường để thực thi code | JVM cung cấp thông số kỹ thuật cho tất cả các triển khai cho JRE |\r\n| JDK cung cấp các công cụ như trình biên dịch, trình gỡ lỗi, v.v. để phát triển code | JRE cung cấp các thư viện và lớp theo yêu cầu của JVM để chạy chương trình | JVM không bao gồm bất kỳ công cụ nào, nhưng thay vào đó, nó cung cấp đặc điểm kỹ thuật để triển khai |\r\n| JDK = JRE + công cụ phát triển | JRE = JVM + thư viện thực thi ứng dụng | JVM = môi trường thực thi bytecode Java |\r\n\r\n<img src=\"/interview-assets/jdk.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa HashMap và HashTable trong Java?",
              "answer": "<p>| HashMap | HashTable |\r\n|-|-|\r\n| HashMap không được đồng bộ hóa do đó nó tốt hơn cho các ứng dụng không phân luồng | HashTable được đồng bộ hóa và do đó nó phù hợp với các ứng dụng phân luồng |\r\n| Chỉ cho phép một khóa null nhưng bất kỳ giá trị nào cũng có thể null | Không cho phép null trong cả khóa hoặc giá trị |\r\n| Hỗ trợ chèn theo thứ tự bằng cách sử dụng LinkedHashMap lớp con của nó | Chèn theo thứ tự không được đảm bảo trong HashTable |</p>",
              "level": "fresher"
            },
            {
              "question": "Reflection trong Java?",
              "answer": "<p>Thuật ngữ <code>reflection</code> được sử dụng để mô tả khả năng kiểm tra của một code trên code khác của chính nó hoặc của hệ thống của nó và sửa đổi nó trong thời gian chạy.\r\n\r\nHãy xem xét một ví dụ trong đó chúng ta có một đối tượng không xác định kiểu và chúng ta có một phương thức <code>fooBar()</code> mà chúng ta cần gọi trên đối tượng. Hệ thống static typing của Java không cho phép gọi phương thức này trừ khi kiểu đối tượng được biết trước. \r\nĐiều này có thể thực hiện được bằng cách sử dụng reflection, cho phép code quét đối tượng và xác định xem nó có bất kỳ phương thức nào được gọi là <code>fooBar()</code> hay không và chỉ gọi phương thức nếu cần.\r\n\r\n``<code>java\r\nMethod methodOfFoo = fooObject.getClass().getMethod(&quot;fooBar&quot;, null);\r\nmethodOfFoo.invoke(fooObject, null);\r\n</code>`<code>\r\n\r\nSử dụng reflection có các hạn chế sau:\r<ul><li>Tốc độ - Các lệnh gọi phương thức do reflection chậm hơn khoảng ba lần so với các lệnh gọi phương thức trực tiếp.</li></ul>\r<ul><li>An toàn kiểu - Khi một phương thức được gọi nhầm qua tham chiếu của nó bằng cách sử dụng reflection, thì lệnh gọi không thành công trong thời gian chạy vì nó không được phát hiện tại thời gian biên dịch.</li></ul>\r<ul><li>Truy xuất nguồn gốc - Bất cứ khi nào một phương pháp reflection không thành công, rất khó tìm ra nguyên nhân gốc rễ của lỗi này. Người ta phải đi sâu vào phương thức log như </code>invoke()<code> và </code>proxy()` để xác định nguyên nhân gốc rễ.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các cách sử dụng luồng?",
              "answer": "<p><ul><li><strong>Kế thừa từ lớp Thread</strong></li></ul>\r\n\r\n``<code>java\r\nclass InterviewBitThreadExample extends Thread{  \r\n    public void run(){  \r\n        System.out.println(&quot;Thread runs...&quot;);  \r\n    }  \r\n    public static void main(String args[]){  \r\n        InterviewBitThreadExample ib = new InterviewBitThreadExample();  \r\n        ib.start();  \r\n    }  \r\n}\r\n</code>`<code>\r<ul><li><strong>Triển khai interface Runnable</strong></li></ul>\r\n\r\n</code>`<code>java\r\nclass InterviewBitThreadExample implements Runnable{  \r\n    public void run(){  \r\n        System.out.println(&quot;Thread runs...&quot;);  \r\n    }  \r\n    public static void main(String args[]){  \r\n        Thread ib = new Thread(new InterviewBitThreadExample()); \r\n        ib.start();  \r\n    }  \r\n}\r\n</code>`<code>\r<ul><li>Việc triển khai một luồng bằng phương thức của interface Runnable được ưu tiên và thuận lợi hơn vì Java không hỗ trợ kế thừa nhiều lớp.</li></ul>\r<ul><li>Phương thức </code>start()<code> được sử dụng để tạo một call stack riêng biệt để thực thi luồng. Khi call stack được tạo, JVM gọi phương thức </code>run()` để thực thi luồng trong call stack đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa constructor và phương thức của lớp?",
              "answer": "<p>| Constructor | Method |\r\n|-|-|\r\n| Contrustor dùng cho khởi tạo trạng thái đối tượng | Phương thức dùng để lộ hành vi của đối tượng |\r\n| Constructor không có kiểu trả về | Phương thức nên có kiểu trả về, trong trường hợp không trả về thứ gì, sẽ trả về kiểu void |\r\n| Dùng cho gọi nội bộ | Dùng cho gọi đối tượng bên ngoài |\r\n| Nếu constructor không được xác định, constructor mặc định sẽ được cung cấp bởi trình biên dịch Java | Nếu phương thức không được xác định, trình biên dịch không cung cấp gì cả |\r\n| Tên constructor là tên lớp | Tên phương thức có thể là bất cứ tên nào |\r\n| Không thể là final vì bất cứ khi nào lớp được kế thừa thì constructor cũng sẽ được kế thừa. Cố đánh sẽ trả về lỗi <code>modifier final not allowed here</code> | Phương thức có thể là final để không bị ghi đè ở lớp con |\r\n| Biến final có thể ở trong construcor để áp dụng lên toàn lớp và đối tượng của nó | Biến final nếu được tạo trong phương thức đảm bảo rằng biến không thể bị thay đổi trong phạm vị phương thức đó |</p>",
              "level": "fresher"
            },
            {
              "question": "Truyền giá trị và truyền tham chiếu trong Java?",
              "answer": "<p>Java luôn hoạt động \"truyền giá trị\", không có gì được gọi là \"truyền qua tham chiếu\" trong Java. Tuy nhiên, khi đối tượng được truyền trong bất kỳ phương thức nào, địa chỉ của giá trị sẽ được truyền do bản chất của việc xử lý đối tượng trong Java. Khi một đối tượng được truyền, một bản sao của tham chiếu sẽ được tạo bởi Java và nó được chuyển cho phương thức. Các đối tượng trỏ đến cùng một vị trí bộ nhớ. 2 trường hợp có thể xảy ra bên trong phương thức:\r<ul><li><strong>Trường hợp 1 - Khi đối tượng được trỏ đến một vị trí khác:</strong> Trong trường hợp này, các thay đổi được thực hiện đối với đối tượng đó không được phản ánh lên đối tượng ban đầu trước khi nó được chuyển tới phương thức vì tham chiếu trỏ đến vị trí khác.</li></ul>\r\n\r\n``<code>java\r\nclass InterviewBitTest{\r\n    int num;\r\n    InterviewBitTest(int x){ \r\n        num = x; \r\n    }\r\n    InterviewBitTest(){ \r\n        num = 0; \r\n    }\r\n}\r\nclass Driver {\r\n    public static void main(String[] args)\r\n    {\r\n        //create a reference\r\n        InterviewBitTest ibTestObj = new InterviewBitTest(20);\r\n        //Pass the reference to updateObject Method\r\n        updateObject(ibTestObj);\r\n        //After the updateObject is executed, check for the value of num in the object.\r\n        System.out.println(ibTestObj.num);\r\n    }\r\n    public static void updateObject(InterviewBitTest ibObj)\r\n    {\r\n        // Point the object to new reference\r\n        ibObj = new InterviewBitTest();\r\n        // Update the value \r\n        ibObj.num = 50;\r\n    }\r\n}\r\n// Output: 20\r\n</code>`<code>\r<ul><li><strong>Trường hợp 2 - Khi tham chiếu đối tượng không được sửa đổi:</strong> Trong trường hợp này, vì chúng ta có bản sao của tham chiếu đối tượng chính trỏ đến cùng một vị trí bộ nhớ, bất kỳ thay đổi nào trong nội dung của đối tượng sẽ được phản ánh trong đối tượng ban đầu.</li></ul>\r\n\r\n</code>`<code>java\r\nclass InterviewBitTest{\r\n    int num;\r\n    InterviewBitTest(int x){ \r\n        num = x; \r\n    }\r\n    InterviewBitTest(){ \r\n        num = 0; \r\n    }\r\n}\r\nclass Driver{\r\n    public static void main(String[] args)\r\n    {\r\n        //create a reference\r\n        InterviewBitTest ibTestObj = new InterviewBitTest(20);\r\n        //Pass the reference to updateObject Method\r\n        updateObject(ibTestObj);\r\n        //After the updateObject is executed, check for the value of num in the object.\r\n        System.out.println(ibTestObj.num);\r\n    }\r\n    public static void updateObject(InterviewBitTest ibObj)\r\n    {\r\n        // no changes are made to point the ibObj to new location\r\n        // Update the value of num\r\n        ibObj.num = 50;\r\n    }\r\n}\r\n// Output: 50\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giữa String và StringBuffer cái nào nên được ưu tiên hơn khi có rất nhiều cập nhật cần được thực hiện trong dữ liệu?",
              "answer": "<p>Về bản chất StringBuffer là động và có thể thay đổi trong khi String là bất biến. Mỗi lần cập nhật/sửa đổi String sẽ tạo ra một String mới do đó làm quá tải String Pool với các đối tượng không cần thiết. Do đó, trong trường hợp có nhiều bản cập nhật, người ta luôn ưu tiên sử dụng StringBuffer vì nó sẽ giảm chi phí tạo nhiều đối tượng String trong String Pool.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa biến transient và volatile trong Java?",
              "answer": "<p><strong>Transient</strong>: Bộ chỉnh sửa transient báo cho hệ thống con loại trừ các trường khi serialize một thực thể của lớp. Đối tượng sau đó được deserialized, trường sẽ được khởi tạo thành giá trị mặc định; tức là null cho một kiểu tham chiếu và 0 hoặc false cho một kiểu nguyên thủy.\r\n\r\n``<code>java\r\npublic transient int limit = 55;   // will not persist\r\npublic int b;   // will persist\r\n</code>`<code>\r\n\r\n<strong>Volatile</strong>: Bộ chỉnh sửa volatile cho JVM biết rằng việc ghi vào trường phải luôn được chuyển đồng bộ vào bộ nhớ và các lần đọc của trường phải luôn được đọc từ bộ nhớ. Điều này có nghĩa là các trường được đánh dấu là volatile có thể được truy cập và cập nhật một cách an toàn trong một ứng dụng đa luồng mà không cần sử dụng đồng bộ hóa dựa trên thư viện chuẩn.\r\n\r\n</code>`<code>java\r\npublic class MyRunnable implements Runnable {\r\n    private volatile boolean active;\r\n    public void run() {\r\n        active = true;\r\n        while (active) {    \r\n        }\r\n    }\r\n    public void stop() {\r\n        active = false;  \r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hệ thống phân cấp của lớp Java Exception?",
              "answer": "<p>Ngoại lệ (exception) là một sự kiện lỗi có thể xảy ra trong quá trình thực thi một chương trình và làm gián đoạn quy trình bình thường của nó.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Error và Exception?",
              "answer": "<p>| Error | Exception |\r\n|-|-|\r\n| Xảy ra do thiếu tài nguyên hệ thống | Xảy ra do code |\r\n| Không thể phục hồi | Có thể phục hồi |\r\n| Không thể xử lý bằng code | Có thể xử lý bằng <code>try</code>, <code>catch</code> và <code>throw</code> |\r\n| Khi lỗi được phát hiện, chương trình sẽ kết thúc bất thường | Khi ngoại lệ được phát hiện, nó có thể được xử lý bằng <code>throw</code> và <code>catch</code> tương ứng |\r\n| Là kiểu không được kiểm tra | Có thể là kiểu kiểm tra và không được kiểm tra |\r\n| Được khai báo trong <code>java.lang.Error</code>| Được khai báo trong <code>java.lang.Exception</code> |\r\n| OutOfMemory, StackOverFlow | Checked Exceptions: NoSuchMethod, ClassNotFound.Unchecked Exceptions: NullPointer, IndexOutOfBounds |</p>",
              "level": "fresher"
            },
            {
              "question": "Cách thực hiện Object Cloning trong Java?",
              "answer": "<p>Object Cloning là quá trình tạo ra một bản sao chính xác của bất kỳ đối tượng nào. Để thực hiện điều này, một lớp java phải triển khai interface <code>Cloneable</code> của package <code>java.lang</code> và ghi đè phương thức <code>clone()</code> được cung cấp bởi lớp Object theo cú pháp của nó là:\r\n\r\n``<code>java\r\nprotected Object clone() throws CloneNotSupportedException {\r\n    return (Object)super.clone();\r\n}\r\n</code>`<code>\r\n\r\nTrong trường hợp Cloneable không được triển khai và chỉ có phương thức bị ghi đè thì Java trả về lỗi </code>CloneNotSupportedException`.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để một ngoại lệ lan truyền trong code?",
              "answer": "<p>Khi một ngoại lệ xảy ra, trước tiên nó tìm kiếm để xác định vị trí khối <code>catch</code> phù hợp. Trong trường hợp, khối <code>catch</code> phù hợp được định vị, thì khối đó sẽ được thực thi. Ngược lại, ngoại lệ truyền thông qua phương thức callstack và đi vào phương thức caller, nơi quá trình <code>catch</code> phù hợp được thực hiện. Sự lan truyền này xảy ra cho đến khi tìm thấy khối <code>catch</code> phù hợp. Nếu không tìm thấy kết quả phù hợp, thì chương trình sẽ bị kết thúc trong phương thức <code>main</code>.\r\n\r\n<img src=\"/interview-assets/java_stack.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Có bắt buộc sử dụng catch sau try không?",
              "answer": "<p>Không, không nhất thiết khối <code>catch</code> phải hiện diện sau khối <code>try</code>. Khối <code>try</code> nên được theo sau bởi khối <code>catch</code> hoặc khối <code>finally</code>. Nếu khả năng ngoại lệ nhiều hơn, thì chúng nên được khai báo bằng mệnh đề <code>throw</code> của phương thức.</p>",
              "level": "fresher"
            },
            {
              "question": "Liệu khối finally có được thực thi khi câu lệnh return được viết ở cuối khối try và khối catch ở như dưới đây không?",
              "answer": "<p>``<code>java\r\npublic int someMethod(int i) {\r\n    try {\r\n        //some statement\r\n        return 1;\r\n    } catch(Exception e) {\r\n        //some statement\r\n        return 999;\r\n    } finally {\r\n        //finally block statements\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nKhối </code>finally<code> sẽ được thực thi bất kể ngoại lệ hay không. Trường hợp duy nhất mà khối </code>finally<code> không được thực thi là khi nó gặp phương thức </code>System.exit()` ở bất kỳ đâu trong khối try/catch.</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể gọi một constructor của một lớp bên trong một constructor khác không?",
              "answer": "<p>Có, khái niệm này có thể được gọi là chuỗi constructor và có thể thực hiện được bằng cách sử dụng <code>this()</code>.\r\n\r\n<img src=\"/interview-assets/constructor_chaining_in_Java.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các vị trí bộ nhớ liền nhau thường được sử dụng để lưu trữ các giá trị thực tế trong một mảng nhưng không phải trong ArrayList. Giải thích?",
              "answer": "<p>Trong trường hợp của ArrayList, việc lưu trữ dữ liệu dưới dạng các kiểu dữ liệu nguyên thủy (như int, float, ...) là không thể. Các thành viên/đối tượng dữ liệu có trong ArrayList có tham chiếu đến các đối tượng nằm ở các vị trí khác nhau trong bộ nhớ. Do đó, việc lưu trữ các đối tượng thực tế hoặc các kiểu dữ liệu không nguyên thủy (như Integer, Double,...) diễn ra ở các vị trí bộ nhớ khác nhau.\r\n\r\n<img src=\"/interview-assets/sorting_of_objects_in_arraylist.png\" alt=\"\" />\r\n\r\nTuy nhiên, điều tương tự không áp dụng cho các mảng. Đối tượng hoặc giá trị kiểu nguyên thủy có thể được lưu trữ trong mảng ở các vị trí bộ nhớ liền nhau, do đó mọi phần tử không yêu cầu bất kỳ tham chiếu nào đến phần tử tiếp theo.\r\n\r\n<img src=\"/interview-assets/sorting_of_values_in_array.png\" alt=\"\" />\r\n\r\n## Câu hỏi phỏng vấn Java cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Mặc dù kế thừa là một khái niệm OOPs phổ biến, nhưng nó kém lợi thế hơn so với composition. Giải thích?",
              "answer": "<p>Kế thừa chậm hơn composition trong các trường hợp sau:\r<ul><li>Đa kế thừa không thể thực hiện được trong Java. Các lớp chỉ có thể kế thừa từ một lớp cha. Trong trường hợp yêu cầu nhiều chức năng, ví dụ - để đọc và ghi thông tin vào file, thì composition sẽ được ưu tiên hơn. Người viết, cũng như các chức năng của người đọc, có thể được sử dụng bằng cách coi họ như những thành viên riêng tư.</li></ul>\r<ul><li>Composition hỗ trợ đạt được tính linh hoạt cao và ngăn chặn việc phá vỡ đóng gói.</li></ul>\r<ul><li>Unit test có thể thực hiện được với composition chứ không phải kế thừa. Khi một nhà phát triển muốn kiểm tra một lớp tạo ra một lớp khác, thì Đối tượng Mock có thể được tạo để biểu thị lớp đã compose để tạo điều kiện cho quá trình test. Kỹ thuật này không thể thực hiện được với kế thừa vì lớp dẫn xuất không thể được kiểm tra nếu không có sự trợ giúp của lớp cha trong kế thừa.</li></ul>\r<ul><li>Bản chất kết hợp lỏng lẻo của composition được ưu tiên hơn bản chất kết hợp chặt chẽ của sự kế thừa.</li></ul>\r\n\r\nHãy lấy một ví dụ:\r\n\r\n``<code>java\r\npackage comparison;\r\n\r\npublic class Top {\r\n    public int start() {\r\n        return 0;\r\n    }\r\n}\r\nclass Bottom extends Top {\r\n    public int stop() {\r\n        return 0;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên ta thực hiện kế thừa. Bây giờ khi ta chỉnh sửa lớp </code>Top<code>:\r\n\r\n</code>`<code>java\r\npublic class Top {\r\n    public int start() {\r\n        return 0;\r\n    }\r\n    public void stop() {\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nNếu việc triển khai mới của lớp Top được tuân theo, <strong>compile-time error</strong> xảy ra trong lớp Bottom. Loại trả về không tương thích cho hàm </code>Top.stop()<code>. Các thay đổi phải được thực hiện đối với lớp Top cùng hoặc Bottom cùng để đảm bảo tính tương thích. Tuy nhiên, kỹ thuật composition có thể được sử dụng để giải quyết vấn đề đã cho:\r\n\r\n</code>`<code>java\r\nclass Bottom {\r\n    Top par = new Top();\r\n    public int stop() {\r\n        par.start();\r\n        par.stop();\r\n        return 0;\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tạo chuỗi với new() khác với cách dùng ký tự như thể nào?",
              "answer": "<p>Khi một String được hình thành dưới dạng một ký tự với sự hỗ trợ của toán tử gán, nó sẽ đi vào String Pool để có thể diễn ra quá trình String Interning. Cùng một đối tượng trong heap này sẽ được tham chiếu bởi một String khác nếu nội dung giống nhau cho cả hai.\r\n\r\n``<code>java\r\npublic bool checking() {\r\n    String first = &quot;InterviewBit&quot;;\r\n    String second = &quot;InterviewBit&quot;;\r\n    if (first == second)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n</code>`<code>\r\n\r\nHàm </code>checking()<code> sẽ trả về true vì cùng nội dung được tham chiếu bởi hai biến.\r\n\r\n<img src=\"/interview-assets/string_pool_by_means_of_assignment_operator.png\" alt=\"\" />\r\n\r\nNgược lại, khi tạo chuỗi diễn ra với sự trợ giúp của toán tử </code>new()<code>, quá trình thực thi sẽ không diễn ra. Đối tượng được tạo trong bộ nhớ heap ngay cả khi có cùng một đối tượng nội dung.\r\n\r\n</code>`<code>java\r\npublic bool checking() {\r\n    String first = new String(&quot;InterviewBit&quot;);\r\n    String second = new String(&quot;InterviewBit&quot;);\r\n    if (first == second)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n</code>`<code>\r\n\r\nHàm </code>checking()` sẽ trả về false vì cùng nội dung không được tham chiếu bởi hai biến.\r\n\r\n<img src=\"/interview-assets/string_pool_by_assignment_operator.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Có thể vượt quá giới hạn bộ nhớ trong một chương trình mặc dù có bộ thu gom rác không?",
              "answer": "<p>Có, chương trình có thể hết bộ nhớ bất chấp sự hiện diện của bộ thu gom rác. Tính năng thu gom rác hỗ trợ nhận dạng và loại bỏ những đối tượng không cần thiết trong chương trình nữa, để giải phóng tài nguyên được sử dụng bởi chúng.\r\n\r\nTrong một chương trình, nếu một đối tượng không thể truy cập được, thì việc thực hiện thu gom rác sẽ diễn ra đối với đối tượng đó. Nếu dung lượng bộ nhớ cần thiết để tạo một đối tượng mới không đủ, thì bộ nhớ sẽ được giải phóng cho những đối tượng không còn trong phạm vi với sự trợ giúp của bộ thu gom rác. Chương trình bị vượt quá giới hạn bộ nhớ khi bộ nhớ được giải phóng không đủ để tạo các đối tượng mới.\r\n\r\nHơn nữa, việc cạn kiệt bộ nhớ heap diễn ra nếu các đối tượng được tạo theo cách mà chúng vẫn nằm trong phạm vi và sử dụng bộ nhớ. Nhà phát triển phải đảm bảo bỏ qua đối tượng sau khi công việc của nó hoàn thành. Mặc dù bộ thu gom rác cố gắng ở mức tốt nhất để lấy lại bộ nhớ nhiều nhất có thể, giới hạn bộ nhớ vẫn có thể bị vượt quá.\r\n\r\nHãy xem ví dụ sau:\r\n\r\n``<code>java\r\nList&lt;String&gt; example = new LinkedList&lt;String&gt;();\r\nwhile(true){\r\n    example.add(new String(&quot;Memory Limit Exceeded&quot;));\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Đồng bộ hoá trong Java?",
              "answer": "<p>Có thể thực hiện đồng thời các tiến trình khác nhau bằng cách đồng bộ hóa. Khi một tài nguyên cụ thể được chia sẻ giữa nhiều luồng, các tình huống có thể phát sinh trong đó nhiều luồng yêu cầu cùng một tài nguyên được chia sẻ.\r\n\r\nĐồng bộ hóa hỗ trợ giải quyết sự cố và tài nguyên được chia sẻ bởi một luồng duy nhất tại một thời điểm. Hãy lấy một ví dụ để hiểu rõ ràng hơn. Ví dụ: bạn có một URL và bạn phải tìm ra số lượng yêu cầu được thực hiện đối với nó. Hai yêu cầu đồng thời có thể làm cho số lượng thất thường.\r\n\r\nKhông đồng bộ hóa:\r\n\r\n``<code>java\r\npackage anonymous;\r\npublic class Counting {\r\n    private int increase<em>counter;\r\n    public int increase() {\r\n        increase</em>counter = increase<em>counter + 1;\r\n        return increase</em>counter;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<img src=\"/interview-assets/without_synchronization.png\" alt=\"\" />\r\n\r\nNếu một luồng </code>Thread1<code> đếm là 10, nó sẽ được tăng lên 1 thành 11. Đồng thời, nếu một luồng khác </code>Thread2<code> đếm là 10, thì nó cũng sẽ được tăng từ 1 lên 11. Do đó, sự không nhất quán trong các giá trị đếm xảy ra do giá trị cuối cùng dự kiến là 12 nhưng giá trị cuối cùng thực tế mà chúng tôi nhận được sẽ là 11.\r\n\r\nBây giờ, hàm </code>increase()<code> được đồng bộ hóa để không thể truy cập đồng thời.\r\n\r\nVới sự đồng bộ hóa:\r\n\r\n</code>`<code>java\r\npackage anonymous;\r\npublic class Counting {\r\n    private int increase<em>counter;\r\n    public synchronized int increase() {\r\n        increase</em>counter = increase<em>counter + 1;\r\n        return increase</em>counter;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<img src=\"/interview-assets/with_synchronization.png\" alt=\"\" />\r\n\r\nNếu một luồng </code>Thread1<code> đếm là 10, nó sẽ được tăng lên từ 1 đến 11, sau đó luồng </code>Thread2` sẽ lấy số đếm là 11, nó sẽ được tăng lên 1 thành 12. Do đó, sự nhất quán trong các giá trị số đếm diễn ra.</p>",
              "level": "fresher"
            },
            {
              "question": "Cho đoạn code bên dưới, ký hiệu ... là gì?",
              "answer": "<p>``<code>java\r\npublic void fooBarMethod(String... variables){\r\n   // method code\r\n}\r\n</code>`<code>\r<ul><li>Khả năng cung cấp ... là một tính năng được gọi là varargs (đối số biến) được giới thiệu ở Java 5.</li></ul>\r<ul><li>Hàm có ... trong ví dụ trên chỉ ra rằng nó có thể nhận nhiều đối số của chuỗi kiểu dữ liệu.</li></ul>\r<ul><li>Ví dụ: </code>fooBarMethod<code> có thể được gọi theo nhiều cách và chúng ta vẫn có thể có một phương pháp để xử lý dữ liệu như bên dưới đây:</li></ul>\r\n\r\n</code>`<code>java\r\nfooBarMethod(&quot;foo&quot;, &quot;bar&quot;);\r\nfooBarMethod(&quot;foo&quot;, &quot;bar&quot;, &quot;boo&quot;);\r\nfooBarMethod(new String[]{&quot;foo&quot;, &quot;var&quot;, &quot;boo&quot;});\r\npublic void myMethod(String... variables){\r\n    for(String variable : variables){\r\n        // business logic\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Vòng đời của luồng Java?",
              "answer": "<p><ul><li><strong>New</strong> - Khi thực thể của luồng được tạo và phương thức <code>start()</code> chưa được gọi, luồng được coi là còn sống và do đó ở trạng thái NEW.</li></ul>\r<ul><li><strong>Runnable</strong> - Khi phương thức <code>start()</code> được gọi, trước khi phương thức <code>run()</code> được gọi bởi JVM, luồng được cho là ở trạng thái RUNNABLE (sẵn sàng chạy). Trạng thái này cũng có thể được nhập từ trạng thái Waiting hoặc Sleeping của luồng.</li></ul>\r<ul><li><strong>Running</strong> - Khi phương thức <code>run()</code> được gọi và luồng bắt đầu thực thi, luồng được cho là đang ở trạng thái RUNNING.</li></ul>\r<ul><li><strong>Non-Runnable (Blocked/Waiting)</strong> - Khi luồng không thể chạy mặc dù thực tế là vẫn còn tồn tại, thì luồng được cho là ở trạng thái NON-RUNNABLE được. Lý tưởng nhất là sau một thời gian tồn tại, luồng sẽ chuyển sang trạng thái có thể chạy được.</li></ul>\r<ul><li>Một luồng được cho là ở trạng thái Blocked nếu nó muốn nhập code được đồng bộ hóa nhưng không thể thực hiện được vì một luồng khác đang hoạt động trong khối được đồng bộ hóa đó trên cùng một đối tượng. Luồng đầu tiên phải đợi cho đến khi luồng khác thoát khỏi khối được đồng bộ hóa.</li></ul>\r<ul><li>Một luồng được cho là ở trạng thái Waiting nếu nó đang đợi tín hiệu thực thi từ một luồng khác, tức là nó chờ hoạt động cho đến khi nhận được tín hiệu.</li></ul>\r<ul><li><strong>Terminated</strong> - Khi quá trình thực thi phương thức <code>run()</code> hoàn tất, luồng được cho là đi vào bước TERMINATED và được coi là không còn tồn tại.</li></ul>\r\n\r\n<img src=\"/interview-assets/java_thread_lifecycle.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Điều gì có thể cân bằng giữa việc sử dụng một mảng không có thứ tự so với việc sử dụng một mảng có thứ tự?",
              "answer": "<p><ul><li>Ưu điểm chính của việc có một mảng có thứ tự là giảm độ phức tạp thời gian tìm kiếm của <code>O(log n)</code> trong khi độ phức tạp thời gian trong một mảng không có thứ tự là <code>O(n)</code>.</li></ul>\r<ul><li>Hạn chế chính của mảng có thứ tự là thời gian chèn tăng lên của nó là <code>O(n)</code> do phần tử của nó phải được sắp xếp lại để duy trì thứ tự của mảng trong mỗi lần chèn trong khi độ phức tạp về thời gian trong mảng không có thứ tự chỉ là <code>O(1)</code>.</li></ul>\r<ul><li>Xem xét 2 điểm chính trên và tùy thuộc vào trường hợp mà nhà phát triển yêu cầu, cấu trúc dữ liệu thích hợp có thể được sử dụng để thực hiện.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Có thể import cùng một lớp hoặc package hai lần trong Java không và điều gì xảy ra với nó trong thời gian chạy?",
              "answer": "<p>Có thể import một lớp hoặc package nhiều hơn một lần, tuy nhiên, điều đó là dư thừa vì JVM tải nội bộ package hoặc lớp chỉ một lần.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Inner Class và Sub Class?",
              "answer": "<p>Lớp bên trong lồng nhau (Inner Class) có thể truy cập bất kỳ biến thực thể riêng tư nào của lớp bên ngoài. Giống như bất kỳ biến thực thể nào khác, chúng ta có thể có bộ sửa đổi truy cập là private, protected, public và default modifier.\r\n\r\n``<code>java\r\nclass Outer { \r\n    class Inner { \r\n        public void show() { \r\n            System.out.println(&quot;In a nested class method&quot;); \r\n        } \r\n    } \r\n} \r\nclass Main { \r\n    public static void main(String[] args) { \r\n        Outer.Inner in = new Outer().new Inner(); \r\n        in.show(); \r\n    } \r\n}\r\n</code>`<code>\r\n\r\nLớp con (subclass) là lớp kế thừa phương thức hoặc thuộc tính từ lớp cha.\r\n\r\n</code>`<code>java\r\nclass Car {\r\n    //...\r\n}\r\n \r\nclass HybridCar extends Car {\r\n    //...\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu tham chiếu trong Java?",
              "answer": "<p>Trong Java có 4 kiểu tham chiếu được phân biệt theo cách chúng bị thu gom rác.\r\n\r\n<em> Strong References - tham chiếu mạnh\r\n</em> Weak References - tham chiếu yếu\r\n<em> Soft References - tham chiếu mềm\r\n</em> Phantom References - tham chiếu ảo\r<ul><li><strong>Strong References:</strong> Đây là kiểu/lớp mặc định của đối tượng tham chiếu. Bất kỳ đối tượng nào có tham chiếu mạnh đang hoạt động đều không đủ điều kiện để thu gom rác. Đối tượng chỉ được thu gom khi biến được tham chiếu mạnh trỏ tới null.</li></ul>\r\n\r\n``<code>java\r\nMyClass obj = new MyClass();\r\n</code>`<code>\r<ul><li><strong>Weak References:</strong> không phải là kiểu/lớp mặc định của đối tượng tham chiếu và chúng phải được chỉ định rõ ràng khi sử dụng chúng. </li></ul>\r\n\r\n</code>`<code>java\r\n//Java Code to illustrate Weak reference \r\nimport java.lang.ref.WeakReference; \r\nclass MainClass \r\n{ \r\n    public void message() { \r\n        System.out.println(&quot;Weak References Example&quot;); \r\n    } \r\n} \r\n  \r\npublic class Example \r\n{ \r\n    public static void main(String[] args) { \r\n        // Strong Reference \r\n        MainClass g = new MainClass();    \r\n        g.message(); \r\n          \r\n        // Creating Weak Reference to MainClass-type object to which &#39;g&#39;  \r\n        // is also pointing. \r\n        WeakReference&lt;MainClass&gt; weakref = new WeakReference&lt;MainClass&gt;(g); \r\n        g = null;  \r\n        g = weakref.get();  \r\n        g.message(); \r\n    } \r\n}\r\n</code>`<code>\r<ul><li><strong>Sort References:</strong> Trong tham chiếu mềm, ngay cả khi đối tượng được giải phóng để thu gom rác thì chúng cũng không được thu thập, cho đến khi JVM cần bộ nhớ. Các đối tượng sẽ bị xóa khỏi bộ nhớ khi JVM hết bộ nhớ. Để tạo các tham chiếu như vậy, lớp </code>java.lang.ref.SoftReference<code> được sử dụng.</li></ul>\r\n\r\n</code>`<code>java\r\n//Java Code to illustrate Weak reference \r\nimport java.lang.ref.SoftReference; \r\nclass MainClass \r\n{ \r\n    public void message() { \r\n        System.out.println(&quot;Weak References Example&quot;); \r\n    } \r\n} \r\n  \r\npublic class Example \r\n{ \r\n    public static void main(String[] args) { \r\n        // Strong Reference \r\n        MainClass g = new MainClass();    \r\n        g.message(); \r\n          \r\n        // Creating Weak Reference to MainClass-type object to which &#39;g&#39;  \r\n        // is also pointing. \r\n        SoftReference&lt;MainClass&gt; softref = new SoftReference&lt;MainClass&gt;(g); \r\n        g = null;  \r\n        g = softref.get();  \r\n        g.message(); \r\n    } \r\n} \r\n</code>`<code>\r<ul><li><strong>Phantom References:</strong> Các đối tượng đang được tham chiếu bởi tham chiếu ảo đủ điều kiện để thu gom rác. Tuy nhiên, trước khi xóa chúng khỏi bộ nhớ, JVM đặt chúng vào một hàng đợi gọi là &quot;hàng đợi tham chiếu&quot;. Chúng được đặt trong một hàng đợi tham chiếu sau khi gọi phương thức </code>finalize()<code> trên chúng. Để tạo các tham chiếu như vậy, lớp </code>java.lang.ref.PhantomReference<code> được sử dụng.</li></ul>\r\n\r\n</code>`<code>java\r\n//Java Code to illustrate Weak reference \r\nimport java.lang.ref.*; \r\nclass MainClass \r\n{ \r\n    public void message() { \r\n        System.out.println(&quot;Phantom References Example&quot;); \r\n    } \r\n} \r\n  \r\npublic class Example \r\n{ \r\n    public static void main(String[] args) { \r\n        // Strong Reference \r\n        MainClass g = new MainClass();    \r\n        g.message(); \r\n          \r\n        // Creating Phantom Reference to MainClass-type object to which &#39;g&#39;  \r\n        // is also pointing. \r\n        PhantomReference&lt;MainClass&gt; phantomRef = null; \r\n        phantomRef = new PhantomReference&lt;MainClass&gt;(g,refQueue); \r\n        g = null; \r\n        g = phantomRef.get();  \r\n        g.message(); \r\n    } \r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Marker interface trong Java là gì?",
              "answer": "<p>Marker interface, còn được gọi là interface gắn thẻ là những interface không có phương thức và hằng số được xác định trong chúng. Chúng ở đó để giúp trình biên dịch và JVM lấy thông tin liên quan đến thời gian chạy liên quan đến các đối tượng.\r\n\r\nCú pháp:\r\n\r\n``<code>java\r\npublic interface Interface_Name {\r\n\r\n}\r\n</code>`<code>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>java\r\n/*<em>\r\n</em> Java program to illustrate Maker Interface \r\n<em>\r\n</em>*/\r\ninterface Marker {    }\r\n\r\nclass A implements Marker {\r\n    //do some task\r\n}\r\n\r\nclass Main {\r\n    public static void main(String[] args) {\r\n        A obj = new A();\r\n        if (obj instanceOf Marker){\r\n            // do some task\r\n        }\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích \"Double Brace Initialisation\" trong Java?",
              "answer": "<p>Đây là một phương tiện thuận tiện để khởi tạo bất kỳ tập hợp nào trong Java. Hãy xem xét ví dụ dưới đây.\r\n\r\n``<code>java\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n \r\npublic class IBDoubleBraceDemo{\r\n    public static void main(String[] args){\r\n        Set&lt;String&gt; stringSets = new HashSet&lt;String&gt;()\r\n        {\r\n            {\r\n                add(&quot;set1&quot;);\r\n                add(&quot;set2&quot;);\r\n                add(&quot;set3&quot;);\r\n            }\r\n        };\r\n    \r\n        doSomething(stringSets);\r\n    }\r\n    \r\n    private static void doSomething(Set&lt;String&gt; stringSets){\r\n        System.out.println(stringSets);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, chúng ta thấy rằng </code>stringSets<code> được khởi tạo bằng cách sử dụng cặp dấu ngoặc nhọn.\r<ul><li>Dấu ngoặc nhọn đầu tiên thực hiện nhiệm vụ tạo một lớp bên trong ẩn danh có khả năng truy cập hành vi của lớp cha. Trong ví dụ trên, chúng ta đang tạo lớp con của HashSet để nó có thể sử dụng phương thức </code>add()` của HashSet.</li></ul>\r<ul><li>Dấu ngoặc nhọn thứ hai làm tác vụ khởi tạo các thực thể.</li></ul>\r\n\r\nCần cẩn thận khi khởi tạo thông qua phương thức này vì phương pháp này liên quan đến việc tạo ra các lớp ẩn danh bên trong có thể gây ra sự cố trong quá trình thu gom rác hoặc tuần tự hóa và cũng có thể dẫn đến rò rỉ bộ nhớ.</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao nói rằng phương thức length() của lớp String không trả về kết quả chính xác?",
              "answer": "<p><ul><li>Phương thức length trả về số lượng đơn vị Unicode của Chuỗi. Chúng ta hãy hiểu đơn vị Unicode là gì và sự nhầm lẫn là gì dưới đây.</li></ul>\r<ul><li>Chúng ta biết rằng Java sử dụng UTF-16 để biểu diễn chuỗi. Với Unicode này, chúng ta cần hiểu hai thuật ngữ liên quan đến Unicode dưới đây:</li></ul>\r<ul><li>Code Point: Điều này đại diện cho một số nguyên biểu thị một ký tự trong không gian code.</li></ul>\r<ul><li>Đơn vị code: Đây là một chuỗi bit được sử dụng để mã hóa các code point. Để làm được điều này, có thể cần một hoặc nhiều đơn vị để đại diện cho một code point.</li></ul>\r<ul><li>Theo lược đồ UTF-16, các code point được chia một cách hợp lý thành 17 mặt phẳng và mặt phẳng đầu tiên được gọi là Basic Multilingual Plane (BMP). BMP có các ký tự cổ điển - U + 0000 đến U + FFFF. Các ký tự còn lại - U + 10000 đến U + 10FFFF được gọi là ký tự bổ sung vì chúng được chứa trong các mặt phẳng còn lại.</li></ul>\r<ul><li>Các code point từ mặt phẳng đầu tiên được mã hóa bằng một đơn vị code 16 bit</li></ul>\r<ul><li>Các code point từ các mặt phẳng còn lại được mã hóa bằng hai đơn vị code.</li></ul>\r\nBây giờ nếu một chuỗi chứa các ký tự bổ sung, thì hàm length sẽ tính là 2 đơn vị và kết quả của hàm <code>length()</code> sẽ không như những gì được mong đợi.\r\n\r\nNói cách khác, nếu có 1 ký tự phụ là 2 đơn vị thì độ dài của ký tự DUY NHẤT đó được coi là HAI - Hãy lưu ý sự thiếu chính xác ở đây? Theo tài liệu java, nó được mong đợi, nhưng theo logic thực, nó không chính xác.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích kết quả của đoạn code sau?",
              "answer": "<p>``<code>java\r\npublic class InterviewBit{\r\n    public static void main(String[] args)\r\n    {\r\n        System.out.println(&#39;b&#39; + &#39;i&#39; + &#39;t&#39;);\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>\"bit\"` sẽ là kết quả được in ra nếu các chữ cái được sử dụng trong dấu nháy kép (hoặc chuỗi ký tự). Nhưng câu hỏi có các ký tự chữ (dấu nháy đơn) đang được sử dụng, đó là lý do tại sao việc nối không xảy ra. Các giá trị ASCII tương ứng của mỗi ký tự sẽ được thêm vào và kết quả của tổng đó sẽ được in.\r\nGiá trị ASCII:\r<ul><li>b = 98</li></ul>\r<ul><li>i = 105</li></ul>\r<ul><li>t = 116</li></ul>\r\n98 + 105 + 116 = 319\r\n\r\nNên 319 sẽ được in.</p>",
              "level": "fresher"
            },
            {
              "question": "Các cách để tạo điều kiện cho đối tượng bị thu gom gác (GC) trong Java?",
              "answer": "<p><ul><li><strong>Cách đầu tiên:</strong> thiệt lập tham chiếu đối tượng đến null sau khi đối tượng được sử dụng.</li></ul>\r\n\r\n``<code>java\r\npublic class IBGarbageCollect {\r\n    public static void main (String [] args){\r\n        String s1 = &quot;Some String&quot;;\r\n            // s1 referencing String object - not yet eligible for GC\r\n        s1 = null; // now s1 is eligible for GC\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Cách thứ hai:</strong> Trỏ biến tham chiếu đến một đối tượng khác. Làm điều này, đối tượng mà biến tham chiếu đã tham chiếu trước đó sẽ đủ điều kiện cho GC.</li></ul>\r\n\r\n</code>`<code>java\r\npublic class IBGarbageCollect {\r\n    public static void main(String [] args){\r\n        String s1 = &quot;To Garbage Collect&quot;;\r\n        String s2 = &quot;Another Object&quot;;\r\n        System.out.println(s1); // s1 is not yet eligible for GC\r\n        s1 = s2; // Point s1 to other object pointed by s2\r\n        /<em> Here, the string object having the content  &quot;To Garbage Collect&quot; is not referred by any reference variable. Therefore, it is eligible for GC </em>/\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Cách thứ ba:</strong> Khi 2 biến tham chiếu trỏ đến các thực thể của cùng một lớp và các biến này chỉ tham chiếu đến nhau và các đối tượng được trỏ bởi 2 biến này không có bất kỳ tham chiếu nào khác, thì nó được cho là đã hình thành &quot;Island of Isolation&quot; và 2 đối tượng này đủ điều kiện để được cấp GC.</li></ul>\r\n\r\n</code>`<code>java\r\npublic class IBGarbageCollect {\r\n    IBGarbageCollect ib;    \r\n    public static void main(String [] str){\r\n        IBGarbageCollect ibgc1 = new IBGarbageCollect();\r\n        IBGarbageCollect ibgc2 = new IBGarbageCollect();\r\n        ibgc1.ib = ibgc2; //ibgc1 points to ibgc2\r\n        ibgc2.ib = ibgc1; //ibgc2 points to ibgc1\r\n        ibgc1 = null;\r\n        ibgc2 = null;\r\n        /<em> \r\n        </em> We see that ibgc1 and ibgc2 objects refer \r\n        <em> to only each other and have no valid \r\n        </em> references- these 2 objects for island of isolcation - eligible for GC\r\n        */\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "react-native",
          "name": "Câu hỏi phỏng vấn React Native",
          "description": "",
          "questions": [
            {
              "question": "Sự khác biệt giữa ReactJS và React Native?",
              "answer": "<p><ul><li>Mục đích:</li></ul>\r<ul><li>ReactJS là thư viện dùng cho xây dựng giao diện người dùng trên ứng dụng web</li></ul>\r<ul><li>React Native là framework cho tạo ứng dụng di động ở như một ứng dụng native.</li></ul>\r<ul><li>Cú pháp: cả hai đều dùng JSX nhưng React dùng cú pháp <code>&lt;div&gt;</code>, <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code> còn React Native dùng <code>&lt;view&gt;</code>, <code>&lt;text&gt;</code>,...</li></ul>\r<ul><li>Animation:</li></ul>\r<ul><li>ReactJS sử dụng CSS animation để tạo ảnh động trên ứng dụng web.</li></ul>\r<ul><li>React Native sử dụng Animated API</li></ul>\r<ul><li>Cơ chế routing:</li></ul>\r<ul><li>React dùng react-router cho chuyển hướng trang</li></ul>\r<ul><li>React Native sử dụng thư viện Navigator cho chuyển hướng trên ứng dụng di động.</li></ul>\r\n\r\n<img src=\"/interview-assets/reactjs_vs_react_native.png\" alt=\"\" />\r\n\r\n| React JS | React Native |\r\n|-|-|\r\n| Dùng cho phát triển ứng dụng web | Dùng cho phát triển ứng dụng di động |\r\n| Dùng react-router cho điều hướng trang | Dùng thư viện navigator cho điều hướng trong ứng dụng di động |\r\n| Dùng thẻ HTML | Không dùng thẻ HTML |\r\n| Cung cấp bảo mật cao | Bảo mật thấp hơn so với ReactJS |\r\n| Sử dụng virtual DOM để render trên trình duyệt | Dùng API để render cho ứng dụng di động |</p>",
              "level": "fresher"
            },
            {
              "question": "Flexbox là gì?",
              "answer": "<p>Nó là mô hình bố cục cho phép phần tử được căn chỉnh và cách đều trong container. Với flexbox ta có thể tuỳ chỉnh width và height một cách linh hoạt, tất cả bên trong container chính có thể được căn chỉnh để lấp đầy hoặc cách khoảng giữa các phần tử, điều này làm cho nó trở thành một công cụ tuyệt vời để sử dụng cho các hệ thống thiết kế reponsive.\r\n\r\n| Property | Values | Desc |\r\n|-|-|-|\r\n| flexDirection | 'column', 'row' | Dùng cho căn chỉnh phần tử theo chiều dọc hay ngang |\r\n| justifyContent | 'center','flex-start','flex-end','space-around','space-between' | Được sử dụng để xác định cách các phần tử nên được cách khoảng bên trong container |\r\n| alignItems | 'center','flex-start','flex-end','stretched' | Được sử dụng để xác định cách các phần tử nên được cách khoảng bên trong container dọc theo trục thứ cấp (ngược với flexDirection) |</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của React Native?",
              "answer": "<p><strong>Cộng đồng lớn</strong>\r\n\r\nReact Native là một Framework mã nguồn mở, nó hoàn toàn do cộng đồng thúc đẩy phát triển nên mọi vấn đề đều có thể được giải quyết bằng cách nhận trợ giúp trực tuyến từ các nhà phát triển khác.\r\n \r\n<strong>Khả năng tái sử dụng</strong>\r\n\r\nCode có thể được viết một lần và có thể được sử dụng cho cả iOS và Android, giúp duy trì và cũng như debug các ứng dụng phức tạp lớn vì không cần nhóm riêng biệt để hỗ trợ cả hai nền tảng, điều này cũng làm giảm chi phí ở mức độ lớn.\r\n \r\n<strong>Hot Reloading</strong>\r\n\r\nThói quen thông thường của dev khi code là test các thay đổi mỗi lần code được viết. Để thực hiện được, app cần phải được đóng gói lại và cài đặt hoặc trong 1 simulator hoặc một thiết bị thật sự.\r\n\r\nVới React Native, phần lớn thời gian, bạn không cần phải tổng hợp lại app mỗi lần có thay đổi. Bạn chỉ cần làm mới app trong simulator, emulator hoặc thiết bị. Thậm chí còn có một tính năng là Live Reload để tự động refresh app mỗi lần phát hiện 1 thay đổi trong code.\r\n\r\n<strong>Các plugin bổ sung của bên thứ ba</strong>\r\nNếu các module hiện có không đáp ứng yêu cầu nghiệp vụ trong React Native, chúng ta cũng có thể sử dụng các plugin của Bên thứ ba để giúp tăng tốc quá trình phát triển.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích các luồng khác nhau trong React Native?",
              "answer": "<p><img src=\"/interview-assets/Image-2.png\" alt=\"\" />\r\n\r\n<strong>React Native sử dụng 3 luồng</strong>\r<ul><li><strong>Luồng MAIN/UI</strong> - Đây là luồng chính mà ứng dụng Android/iOS của bạn đang chạy. Giao diện người dùng của ứng dụng có thể được thay đổi bởi luồng chính và có quyền truy cập vào nó.</li></ul>\r<ul><li><strong>Luồng Shadow</strong> - bố cục được tạo bởi thư viện React trong React Native.</li></ul>\r<ul><li><strong>Luồng JavaScript</strong> - code JavaScript sẽ được thực thi ở luồng này.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "defaultProps có khả dụng trong React Native không?",
              "answer": "<p>Có, nó hoạt động trong React Native tương tự như ở ReactJS.\r\n\r\n``<code>jsx\r\nimport {View, Text} from &#39;react-native&#39;;\r\n\r\nclass DefaultPropComponent extends Component {\r\n    render() {\r\n        return ( \r\n            </code><View>\r\n                <code>&lt;Text&gt;</code> \r\n                {this.props.name} \r\n                <code>&lt;/Text&gt;</code> \r\n            <code>&lt;/View&gt;\r\n        )\r\n    }\r\n}\r\nDemo.defaultProps = {\r\n   name: &#39;BOB&#39;\r\n}\r\n\r\nexport default DefaultPropComponent;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Xử lý input trong React Native?",
              "answer": "<p>TextInput là component chính cho phép người dùng nhập văn bản vào. Nó có <code>onChangeText</code> để nhận một hàm gọi mỗi khi văn bản có thay đổi, và <code>onSubmitEditing</code> để nhận một hàm gọi mỗi khi có submit.\r\n\r\n``<code>jsx\r\nimport React, { useState } from &#39;react&#39;;\r\nimport { Text, TextInput, View } from &#39;react-native&#39;;\r\n\r\nconst PizzaTranslator = () =&gt; {\r\n    const [text, setText] = useState(&#39;&#39;);\r\n    return (\r\n        &lt;View style={{padding: 10}}&gt;\r\n            &lt;TextInput\r\n                style={{height: 40}}\r\n                placeholder=&quot;Type here to translate!&quot;\r\n                onChangeText={text =&gt; setText(text)}\r\n                defaultValue={text}\r\n            /&gt;\r\n            &lt;Text style={{padding: 10, fontSize: 42}}&gt;\r\n                {text.split(&#39; &#39;).map((word) =&gt; word &amp;&amp; &#39;🍕&#39;).join(&#39; &#39;)}\r\n            &lt;/Text&gt;\r\n        &lt;/View&gt;\r\n    );\r\n}\r\n\r\nexport default PizzaTranslator;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách sử dụng state trong React Native?",
              "answer": "<p>Nó dùng cho điều khiển component. Biến dữ liệu có thể lưu trong state, và nó có thể thay đổi giá trị bất cứ lúc nào. Ví dụ\r\n\r\n``<code>jsx\r\nimport React, {Component} from &#39;react&#39;;    \r\nimport { Text, View } from &#39;react-native&#39;;\r\n\r\nexport default class App extends Component {    \r\n    state = {\r\n        myState: &#39;State of Text Component&#39;\r\n    }\r\n\r\n    updateState = () =&gt;</code> this.setState({myState: 'The state is updated'})\r\n    render() {\r\n        return (\r\n            <code>&lt;View&gt;</code>    \r\n                <code>&lt;Text onPress={this.updateState}&gt;</code> {this.state.myState} <code>&lt;/Text&gt;</code>    \r\n            <code>&lt;/View&gt;</code> \r\n        ); \r\n    } \r\n}\r\n```</p>",
              "level": "fresher"
            },
            {
              "question": "Redux trong React Native?",
              "answer": "<p>Redux là một công cụ quản lý trạng thái được dùng cho các ứng dụng JavaScript. Nó giúp toàn bộ luồng dữ liệu của ứng dụng được xử lý trong một container duy nhất không khi trạng thái trước đó vẫn tồn tại.\r\n\r\n<img src=\"/interview-assets/react-native-redux.png\" alt=\"\" />\r\n\r\n<em>Actions</em>: là khối lượng thông tin gửi dữ liệu từ ứng dụng của bạn đến store. Chúng là nguồn thông tin duy nhất cho store. Điều này có nghĩa là nếu bất kỳ thay đổi trạng thái nào là cần thiết, sẽ được thực hiện thông qua các action.\r\n\r\n<em>Reducers</em>: Các action mô tả thực tế là có điều gì đó đã xảy ra, nhưng không chỉ rõ trạng thái của ứng dụng thay đổi như thế nào để phản hồi. Đây là công việc của những reducer.\r\n\r\n<em>Store</em>: một store có thể được tạo ra với sự trợ giúp của các reducers lưu giữ toàn bộ trạng thái của ứng dụng. Cách được khuyến khích là sử dụng một store duy nhất cho toàn bộ ứng dụng, vì có nhiều store sẽ vi phạm việc sử dụng redux vốn chỉ có một store duy nhất.\r\n\r\n<em>Component</em>: đây là nơi lưu giữ giao diện người dùng của ứng dụng.</p>",
              "level": "fresher"
            },
            {
              "question": "Các hàm thời gian trong React Native?",
              "answer": "<p><ul><li><strong>setTimeout, clearTimeout</strong></li></ul>\r\n\r\nCó các yêu cầu nghiệp vụ, <code>setTimeout</code> để thực thi một mẫu code sau một khoảng thời gian chờ đợi. <code>clearTimeout</code> dùng để xoá timer lại thời gian được bắt đầu.\r\n\r\n``<code>js\r\nsetTimeout(() =&gt;</code> {\r\n    yourFunction();\r\n}, 3000);\r\n``<code>\r<ul><li><strong>setInterval, clearInterval</strong></li></ul>\r\n\r\nLà phương thức để gọi một hàm hoặc chạy code sau những khoảng thời gian cụ thể, được chỉ định trong tham số thứ hai.\r\n\r\n</code>`<code>js\r\nsetInterval(() =&gt;</code> {\r\n    console.log('Interval triggered');\r\n}, 1000);\r\n``<code>\r\n\r\nMột hàm hoặc khối code được liên kết với một khoảng thời gian sẽ thực thi cho đén khi nó bị dừng. Để dùng khoảng thời gian, ta dùng phương thức </code>clearInterval()<code>.\r<ul><li><strong>setImmediate, clearImmediate</strong></li></ul>\r\n\r\nGọi hàm thực thi sớm nhất có thể.\r\n\r\n</code>`<code>js\r\nvar immediateID = setImmediate(function);\r\n// The below code displays the alert dialog immediately.\r\nvar immediateId = setImmediate(\r\n    () =&gt;</code> {    alert('Immediate Alert');\r\n}\r\n``<code>\r\n\r\n</code>clearImmediate()<code> dùng để huỷ hành động ngay lập tức nếu nó được thiết lập bằng </code>setImmediate()<code>.\r<ul><li><strong>requestAnimationFrame, cancelAnimationFrame</strong></li></ul>\r\n\r\nLà chuẩn để thực hiện ảnh động.\r\n\r\nGọi một hàm để cập nhật ảnh động trước khi đến frame ảnh động kế tiếp.\r\n\r\n</code>`<code>js\r\nvar requestID = requestAnimationFrame(function);\r\n// The following code performs the animation.\r\nvar requestId = requestAnimationFrame(\r\n    () =&gt;</code> { // animate something}\r\n)\r\n``<code>\r\n\r\n</code>cancelAnimationFrame()<code> dùng để huỷ hàm được thiết lập bởi </code>requestAnimationFrame()`.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách debug ứng dụng React Native và các công cụ cần thiết?",
              "answer": "<p>Trong React Native, có rất nhiều cách debug khác nhau với nhiều công cụ khác nhau, do React Native chạy trên cả hai môi trường Android và iOS. \r<ul><li>Developer Menu:</li></ul>\r<ul><li>Reload: tải lại ứng dụng</li></ul>\r<ul><li>Debug JS Remotely: mở một kênh mới cho JavaScript debugger</li></ul>\r<ul><li>Enable Live Reload: làm cho ứng dụng tự động tải lại khi click vào Save</li></ul>\r<ul><li>Enable Hot Reloading: theo dõi các thay đổi được tích lũy trong một file đã thay đổi</li></ul>\r<ul><li>Toggle Inspector: chuyển đổi giao diện kiểm tra, cho phép chúng ta kiểm tra bất kỳ phần tử UI nào trên màn hình và các thuộc tính của nó, đồng thời trình bày một giao diện có các tab khác như mạng, hiển thị cho chúng ta các lệnh gọi HTTP và một tab cho hiệu suất.</li></ul>\r\n\r\n<img src=\"/interview-assets/developer-menu.png\" alt=\"\" />\r<ul><li><strong>Chrome's DevTools:</strong></li></ul>\r\n\r\nChrome có thể là công cụ đầu tiên có thể nghĩ đến để debug React Native. DevTools của Chrome chủ yếu để debug các ứng dụng web, nhưng chúng ta cũng có thể sử dụng chúng để debug React Native vì nó được hỗ trợ bởi JavaScript. Để sử dụng DevTool với React Native, trước tiên đảm bảo chúng có cùng kết nối Wifi, sau đó nhấn lệnh <code>R</code> nếu dùng MacOS, <code>Ctrl + M</code> nếu là Window/Linux. Trong menu, chọn Debug JS Remotely, nó sẻ mở ra JS Debugger mặc định.\r<ul><li><strong>React Developer Tools:</strong></li></ul>\r\n\r\nTa có thể cài đặt package react-devtoools như sau:\r\n\r\n``<code>\r\nnpm install react-devtools --save\r\n</code>`<code>\r\n\r\nReact&#39;s Developer Tool là công cụ tốt nhất cho debug trên React Native với hai lý do\r<ul><li>Nó cho phép debug component.</li></ul>\r<ul><li>Nó còn có thể debug style trong React Native. Ngoài ra còn có một phiên bản mới đi kèm với tính năng này cũng hoạt động với inspector trong developer menu. Trước đây, việc viết các style là một vấn đề và phải đợi ứng dụng tải lại để xem các thay đổi. Giờ đây, chúng ta có thể debug và triển khai các thuộc tính style và xem tác động của thay đổi ngay lập tức mà không cần tải lại ứng dụng.</li></ul>\r<ul><li><strong>React Native Debugger</strong></li></ul>\r\n\r\nKhi sử dụng Redux trong ứng dụng React Native của bạn, React Native Debugger có lẽ là trình debug phù hợp với bạn. Đây là một ứng dụng desktop hoạt động độc lập trên macOS, Windows và Linux. Nó thậm chí còn tích hợp cả Redux’s DevTools và React’s Developer Tools trong một ứng dụng, do đó bạn không phải làm việc với hai ứng dụng riêng biệt để debug.\r<ul><li><strong>React Native CLI</strong></li></ul>\r\n\r\nBạn cũng có thể sử dụng React Native CLI để debug. Nó cũng có thể được sử dụng để hiển thị loga của ứng dụng. Nhấn vào </code>react-native log-android<code> sẽ hiển thị cho bạn log của db logcat trên Android và để xem log trong iOS, bạn có thể chạy react-native log-ios và với </code>console.log<code>, bạn có thể gửi log đến terminal:\r\n\r\n</code>`<code>\r\nconsole.log(&quot;some error🛑&quot;)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Props Drilling là gì?",
              "answer": "<p>Props Drilling là một khái niệm đề cập đến quá trình truyền dữ liệu từ component cha đến component con chính xác NHƯNG ở giữa có rất nhiều component truyền props như một chuỗi.\r\n\r\n<img src=\"/interview-assets/Props_Drilling.png\" alt=\"\" />\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả kết nối mạng trong React Native?",
              "answer": "<p>React Native cung cấp fetch API cho kết nối mạng. Để lấy nội dung từ một URL, ta có thể làm như sau:\r\n\r\n``<code>js\r\nfetch(&#39;https://mywebsite.com/endpoint/&#39;, {\r\n    method: &#39;POST&#39;,\r\n    headers: {\r\n        Accept: &#39;application/json&#39;,\r\n        &#39;Content-Type&#39;: &#39;application/json&#39;\r\n    },\r\n    body: JSON.stringify({\r\n        firstParam: &#39;yourValue&#39;,\r\n        secondParam: &#39;yourOtherValue&#39;\r\n    })\r\n});\r\n</code>`<code>\r\n\r\nKết nối mạng là một hoạt động bất đồng bộ. Các phương thức fetch sẽ trả về một Promise giúp dễ dàng viết code hoạt động theo cách bất đồng bộ:\r\n\r\n</code>`<code>js\r\nconst getMoviesFromApi = () =&gt; {\r\n    return fetch(&#39;https://reactnative.dev/movies.json&#39;)\r\n        .then((response) =&gt; response.json())\r\n        .then((json) =&gt; {\r\n            return json.movies;\r\n        })\r\n        .catch((error) =&gt; {\r\n            console.error(error);\r\n        });\r\n};\r\n</code>`<code>\r\n\r\nAPI XMLHttpRequest là api sẵn có trong React Native. Ta cũng có thể sử dụng axios với frisbee với api này.\r\n\r\n</code>`<code>js\r\nvar request = new XMLHttpRequest();\r\nrequest.onreadystatechange = (e) =&gt; {\r\n    if (request.readyState !== 4) {\r\n        return;\r\n    }\r\n\r\n    if (request.status === 200) {\r\n        console.log(&#39;success&#39;, request.responseText);\r\n    } else {\r\n        console.warn(&#39;error&#39;);\r\n    }\r\n};\r\n\r\nrequest.open(&#39;GET&#39;, &#39;https://mywebsite.com/endpoint/&#39;);\r\nrequest.send();\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Liệt kê các điểm chính để tích hợp React Native trong một ứng dụng Android?",
              "answer": "<p>Các điểm chính cần lưu ý để tích hợp các React Native vào ứng dụng Android của bạn là:\r<ul><li>Thiết lập cấu trúc thư mục và phụ thuộc React Native.</li></ul>\r<ul><li>Phát triển các component React Native của bạn trong JavaScript.</li></ul>\r<ul><li>Thêm ReactRootView vào ứng dụng Android của bạn. View này sẽ đóng vai trò là container cho component React Native của bạn.</li></ul>\r<ul><li>Khởi động React Native server và chạy ứng dụng native của bạn.</li></ul>\r<ul><li>Cuối cùng, chúng ta cần xác minh việc React Native trong ứng dụng của bạn hoạt động như mong đợi.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Code React Native được xử lý như thế nào?",
              "answer": "<p><ul><li>Khi bắt đầu khởi động ứng dụng, luồng chính bắt đầu thực thi và tải JS bundles.</li></ul>\r<ul><li>Khi code JS đã được tải hoàn tất, luồng chính gửi nó vào luồng JS khác vì JS thực hiện các tính toán nặng trong một thời gian, luồng UI sẽ không phải chịu ảnh hưởng gì cả.</li></ul>\r<ul><li>Khi React bắt đầu render, Reconciler bắt đầu \"driffing\", và nó tạo một virtual DOM (layout) mới, nó gửi các thay đổi đến luồng khác. (Luồng shadow)</li></ul>\r<ul><li>Luồng shadow tính toán bố cụ và gửi tham số/đối tượng bố cục đến luồng chính. </li></ul>\r<ul><li>Vì chỉ luồng chính mới có thể hiển thị thứ gì đó trên màn hình, nên luồng shadow sẽ gửi bố cục đã tạo đến luồng chính và chỉ khi đó giao diện người dùng mới hiển thị.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Bridge trong React Native là gì?",
              "answer": "<p>Bridge là một lớp hoặc một kết nối chịu trách nhiệm gắn kết môi trường Native và JavaScript lại với nhau.\r\n\r\nSơ đồ:\r\n\r\n<img src=\"/interview-assets/bridge_in_react_native.png\" alt=\"\" />\r<ul><li>Lớp gần nhất với thiết bị mà ứng dụng chạy trên đó là Lớp Native.</li></ul>\r<ul><li>Bridge về cơ bản là một lớp truyền tải hoạt động như một kết nối giữa các module Javascript và Native, nó thực hiện công việc vận chuyển các thông báo phản hồi được tuần tự hóa bất đồng bộ từ JavaScript đến các module Native.</li></ul>\r\n\r\nVí dụ bây giờ, có một số thay đổi trạng thái xảy ra, do đó React Native sẽ cập nhật hàng loạt UI và gửi nó đến Bridge. Bridge sẽ chuyển phản hồi được tuần tự hóa này đến lớp Native, lớp này sẽ xử lý tất cả các lệnh mà nó có thể phân biệt với phản hồi được tuần tự hóa và sẽ cập nhật giao diện người dùng cho phù hợp.\r\n\r\n<strong>Nền tảng iOS</strong>\r\n\r\n<img src=\"/interview-assets/IOS_Platform.png\" alt=\"\" />\r\n\r\n<strong>Nền tảng Android</strong>\r\n\r\n<img src=\"/interview-assets/android_platform.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các component cốt lõi trong React Native?",
              "answer": "<p>Các component cốt lỗi thường được dùng trong React Native: <code>&lt;View&gt;</code>, <code>&lt;Text&gt;</code>, <code>&lt;Image&gt;</code>, <code>&lt;ScrollView&gt;</code> và <code>&lt;TextInput&gt;</code>.\r\n\r\n| React Native Component | Android View | iOS view | Web view | Mô tả |\r\n|-|-|-|-|-|\r\n| <code>&lt;View&gt;</code> | <code>&lt;ViewGroup&gt;</code> | <code>&lt;UIView&gt;</code> | <code>&lt;div&gt;</code> | Một container hỗ trợ bố cục với kiểu flexbox, một số điều khiển cảm ứng và điều khiển trợ năng |\r\n| <code>&lt;Text&gt;</code> | <code>&lt;TextView&gt;</code> | <code>&lt;UITextView&gt;</code> | <code>&lt;p&gt;</code> | Hiển thị style, lồng chuỗi văn bản hoặc xử lý sự kiện |\r\n| <code>&lt;Image&gt;</code> | <code>&lt;ImageView&gt;</code> | <code>&lt;UIImageView&gt;</code> | <code>&lt;img&gt;</code> | Hiển thị ảnh |\r\n| <code>&lt;ScrollView&gt;</code> | <code>&lt;ScrollView&gt;</code> | <code>&lt;UIScrollView&gt;</code> | <code>&lt;div&gt;</code> | Một container scroll chung có thể chứa nhiều component và view |\r\n| <code>&lt;TextInput&gt;</code> | <code>&lt;EditText&gt;</code> | <code>&lt;UITextField&gt;</code> | <code>&lt;input type=&quot;text&quot;&gt;</code> | Cho phép người dùng nhập văn bản |</p>",
              "level": "fresher"
            },
            {
              "question": "ListView trong React Native?",
              "answer": "<p>ListView là một component bao gồm danh sách các mục được hiển thị và có thể scroll theo chiều dọc.\r\n\r\n``<code>jsx\r\nexport default class MyListComponent extends Component {  \r\n    constructor() {  \r\n        super();  \r\n        const ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&gt; r1 !== r2});  \r\n        this.state = {  \r\n            dataSource: ds.cloneWithRows([&#39;Android&#39;,&#39;iOS&#39;, &#39;Java&#39;,&#39;Php&#39;, &#39;Hadoop&#39;, &#39;Sap&#39;, &#39;Python&#39;,&#39;Ajax&#39;, &#39;C++&#39;]), \r\n        };\r\n    }  \r\n    render() {  \r\n        return ( \r\n            &lt;ListView \r\n                dataSource={this.state.dataSource}  \r\n                renderRow={  \r\n                (rowData) =&gt;</code>  \r\n                <code>&lt;Text style={{fontSize: 30}}&gt;{rowData}&lt;/Text&gt;} \r\n            /&gt; \r\n        ); \r\n    }  \r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào bạn có thể viết code khác nhau cho iOS và Android trong cùng một codebase?",
              "answer": "<p>Module platform sẽ phát hiện từng nền tảng khi ứng dụng được chạy.\r\n\r\n``<code>jsx\r\nimport { Platform, Stylesheet } from &#39;react-native&#39;;\r\n\r\nconst styles = Stylesheet.create({\r\n    height: Platform.OS === &#39;IOS&#39; ? 200 : 400\r\n})\r\n</code>`<code>\r\n\r\nNgoài ra, phương thức </code>Platform.select<code> lấy một đối tượng chứa </code>Platform.OS<code> làm khóa và trả về giá trị cho nền tảng bạn hiện đang sử dụng. \r\n\r\n</code>`<code>jsx\r\nimport { Platform, StyleSheet } from &#39;react-native&#39;;\r\nconst styles = StyleSheet.create({\r\n    container: {\r\n        flex: 1,\r\n        ...Platform.select({\r\n            ios: {\r\n                backgroundColor: &#39;red&#39;,\r\n            },\r\n            android: {\r\n                backgroundColor: &#39;green&#39;,\r\n            },\r\n            default: {\r\n                // other platforms, web for example\r\n                backgroundColor: &#39;blue&#39;,\r\n            },    \r\n        }),\r\n    },\r\n});\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Touchable và cách dùng nó trong React Native?",
              "answer": "<p>Các cử chỉ chạm có thể được ghi lại bằng các component Touchable và có thể hiển thị phản hồi khi một cử chỉ được nhận dạng.\r\n\r\nTùy thuộc vào loại phản hồi bạn muốn cung cấp, mà chọn loại component Touchable.\r<ul><li>Nhìn chung, chúng ta sử dụng <code>TouchableHighlight</code> ở bất kỳ nơi nào sử dụng button hoặc link đến web. Chế độ nền của view sẽ tối đi khi người dùng nhấn nút xuống.</li></ul>\r<ul><li>Chúng ta có thể sử dụng <code>TouchableNativeFeedback</code> trên Android để hiển thị các gợn sóng phản ứng bề mặt mực phản ứng với thao tác chạm của người dùng.</li></ul>\r<ul><li><code>TouchableOpacity</code> có thể được sử dụng để cung cấp phản hồi bằng cách giảm độ mờ của button, cho phép nhìn thấy nền trong khi người dùng nhấn xuống.</li></ul>\r<ul><li>Nếu chúng ta cần xử lý một cử chỉ nhấn nhưng bạn không muốn hiển thị bất kỳ phản hồi nào, hãy sử dụng <code>TouchableWithoutFeedback</code>.</li></ul>\r\n\r\n``<code>jsx\r\nimport React, { Component } from &#39;react&#39;;\r\nimport { \r\n    Platform, \r\n    StyleSheet, \r\n    Text, \r\n    TouchableHighlight, \r\n    TouchableOpacity, \r\n    TouchableNativeFeedback, \r\n    TouchableWithoutFeedback, \r\n    View \r\n} from &#39;react-native&#39;;\r\n\r\nexport default class Touchables extends Component {\r\n    <em>onPressButton() {\r\n        alert(&#39;You tapped the button!&#39;)\r\n    }\r\n    </em>onLongPressButton() {\r\n        alert(&#39;You long-pressed the button!&#39;)\r\n    }\r\n    render() {\r\n        return (\r\n            &lt;View style={styles.container}&gt;\r\n                &lt;TouchableHighlight onPress={this._onPressButton} underlayColor=&quot;white&quot;&gt;\r\n                    &lt;View style={styles.button}&gt;\r\n                        &lt;Text style={styles.buttonText}&gt;TouchableHighlight&lt;/Text&gt;\r\n                    &lt;/View&gt;\r\n                &lt;/TouchableHighlight&gt;\r\n            &lt;/View&gt;\r\n        );\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Component FlatList là gì?",
              "answer": "<p>Component FlatList hiển thị dữ liệu có cấu trúc trong một danh dách có thể scroll. Nó hoạt động với những danh sách dữ liệu lớn và số lượng mục có thể thay đổi theo thời gian.\r\n\r\n<strong>Tính năng:</strong>\r\n\r\nFlatList chỉ hiển thị các phần tử được render hiện đang hiển thị trên màn hình, không hiển thị tất cả các phần tử của danh sách cùng một lúc.\r\n\r\n``<code>jsx\r\nimport React, { Component } from &#39;react&#39;;  \r\nimport { AppRegistry, FlatList,  \r\n   StyleSheet, Text, View,Alert } from &#39;react-native&#39;;  \r\n\r\nexport default class FlatListBasics extends Component {  \r\n    renderSeparator = () =&gt; {  \r\n        return (  \r\n            &lt;View  \r\n                style={{  \r\n                    height: 1,  \r\n                    width: &quot;100%&quot;,  \r\n                    backgroundColor: &quot;#000&quot;,  \r\n                }}  \r\n            /&gt;\r\n        );  \r\n    };  \r\n    //handling onPress action  \r\n    getListViewItem = (item) =&gt; {  \r\n        Alert.alert(item.key);  \r\n    }  \r\n \r\n    render() {  \r\n        return (  \r\n            &lt;View style={styles.container}&gt;\r\n                &lt;FlatList  \r\n                    data={[  \r\n                        {key: &#39;Android&#39;},{key: &#39;iOS&#39;}, {key: &#39;Java&#39;},{key: &#39;Swift&#39;},  \r\n                        {key: &#39;Php&#39;},{key: &#39;Hadoop&#39;},{key: &#39;Sap&#39;},  \r\n                    ]}  \r\n                    renderItem={({item}) =&gt;\r\n                        &lt;Text style={styles.item}  \r\n                                onPress={this.getListViewItem.bind(this, item)}&gt;{item.key}&lt;/Text&gt;}  \r\n                    ItemSeparatorComponent={this.renderSeparator}  \r\n                /&gt;  \r\n            &lt;/View&gt; \r\n        );  \r\n    }\r\n}  \r\nAppRegistry.registerComponent(&#39;AwesomeProject&#39;, () =&gt; FlatListBasics);  \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách định tuyến với React Navigation trong React Native?",
              "answer": "<p>Một trong những thư viện phổ biến để định tuyến và điều hướng trong ứng dụng React Native là React Navigation.\r\n\r\nThư viện này giúp giải quyết vấn đề điều hướng giữa nhiều màn hình và chia sẻ dữ liệu giữa chúng.\r\n\r\n``<code>jsx\r\nimport * as React from &#39;react&#39;;\r\nimport { NavigationContainer } from &#39;@react-navigation/native&#39;;\r\nimport { createStackNavigator } from &#39;@react-navigation/stack&#39;;\r\n\r\nconst Stack = createStackNavigator();\r\n\r\nconst MyStack = () =&gt; {\r\n    return (\r\n        &lt;NavigationContainer&gt;\r\n            &lt;Stack.Navigator&gt;\r\n            &lt;Stack.Screen\r\n                name=&quot;Home&quot;\r\n                component={HomeScreen}\r\n                options={{ title: &#39;Welcome&#39; }}\r\n            /&gt;\r\n            &lt;Stack.Screen name=&quot;Profile&quot; component={ProfileScreen} /&gt;\r\n            &lt;/Stack.Navigator&gt;\r\n        &lt;/NavigationContainer&gt;\r\n    );\r\n};\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các cách thiết kế style trong ứng dụng React Native?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích Async Storage trong React Native?",
              "answer": "<p><ul><li>Async Storage trong React Native tương đương với Local Storage trên web.</li></ul>\r<ul><li>Async Storage là một module do cộng đồng duy trì cho React Native, cung cấp một kho lưu trữ key-value bất đồng bộ, không được mã hóa. Async Storage không được chia sẻ giữa các ứng dụng: mọi ứng dụng đều có môi trường sandbox riêng và không có quyền truy cập vào dữ liệu từ ứng dụng khác</li></ul>\r\n\r\nDùng Async Storage khi:\r<ul><li>Dữ liệu không nhạy cảm liên tục trên các lần chạy ứng dụng</li></ul>\r<ul><li>Trạng thái Redux</li></ul>\r<ul><li>Trạng thái GraphQL</li></ul>\r<ul><li>Lưu trữ các biến toàn cục trên toàn ứng dụng</li></ul>\r\n\r\nKhông dùng cho:\r<ul><li>Token</li></ul>\r<ul><li>Khoá bí mật</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Nguyên nhân thực sự đằng sau các vấn đề về hiệu suất trong React Native là gì?",
              "answer": "<p>Nguyên nhân thực sự đằng sau các vấn đề về hiệu suất React Native là mỗi luồng (tức là luồng Native và JS) quá nhanh. Tắc nghẽn hiệu suất trong ứng dụng React Native xảy ra khi bạn chuyển các thành phần từ luồng này sang luồng khác một cách không cần thiết hoặc nhiều hơn mức cần thiết. Quy tắc <em>ngón tay cái</em> được dùng để tránh bất kỳ vấn đề nào liên quan đến hiệu suất trong React Native và giữ cho các lần vượt qua bridge ở mức tối thiểu.\r<ul><li>Luồng Native được xây dựng để chạy Java/Kotlin, Swift/Objective C.</li></ul>\r<ul><li>Luồng Javascript là luồng chính chạy mọi thứ từ animation dựa trên javascript đến các component giao diện người dùng khác.</li></ul>\r<ul><li>Bridge hoạt động như một điểm giao tiếp trung gian cho luồng Native và JS.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các bước để tối ưu hoá ứng dụng?",
              "answer": "<p><ul><li>Sử dụng Proguard để giảm thiểu kích cỡ ứng dụng (Nó thực hiện bằng cách tách bytecode Java (và các phụ thuộc của nó) mà ứng dụng của bạn không sử dụng).</li></ul>\r<ul><li>Tạo file APK đã giảm kích thước cho kiến trúc CPU cụ thể. Khi bạn làm như vậy, ứng dụng của bạn sẽ tự động lấy file APK liên quan với kiến trúc điện thoại cụ thể của chúng.</li></ul>\r<ul><li>Nén các hình ảnh và phần tử đồ hoạ cụ thể . Các lựa chọn khác để giảm kích cở ảnh như file APNG thay vì PNG.</li></ul>\r<ul><li>Không lưu dữ liệu JSON (raw), ta cần nén chúng và chuyển vào các đối tượng ID tĩnh.</li></ul>\r<ul><li>Tối ưu hoá thư viện native</li></ul>\r<ul><li>Tối ưu hoá số lượng thao tác state và nhớ dùng pure component và memoized khi cần.</li></ul>\r<ul><li>Sử dụng global state cho các trường hợp tệ nhật khi state thay đổi một điều khiển đơn như TextInput hay CheckBox để render trên toàn ứng dụng. Sử dụng thư viện như Redux hay Overmind.js để quản lý state với hiệu suất tốt hơn.</li></ul>\r<ul><li>Sử dụng thuộc tính key trên các danh sách mục, nó giúp React Native chọn được mục cần cập nhật khi render danh sách dữ liệu dài.</li></ul>\r<ul><li>Sử dụng <code>VirtualizedList</code>, <code>FlatList</code> và <code>SectionList</code> cho tập dữ liệu lớn.</li></ul>\r<ul><li>Xoá tất cả timer đang hoạt động nếu nó dẫn đến các vấn đề rò rỉ bộ nhớ.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách giải quyết sự cố rò rỉ bộ nhớ trong React Native?",
              "answer": "<p>Trong bộ nhớ JavaScript được quản lý tự động bởi Garbage Collector (GC). Nói tóm lại, Garbage Collector là một tiến trình nền định kỳ duyệt qua biểu đồ của các đối tượng được cấp phát và các tham chiếu của chúng. Nếu tình cờ gặp một phần của biểu đồ không được tham chiếu trực tiếp hoặc gián tiếp từ các đối tượng gốc (ví dụ: các biến trên ngăn xếp hoặc một đối tượng toàn cục như window hoặc navigator) thì toàn bộ phần đó có thể được giải phóng khỏi bộ nhớ.\r\n\r\nTrong React Native, mỗi module scope được gắn với một đối tượng gốc. Nhiều module, bao gồm cả module chính của React Native, khai báo các biến được giữ trong scope chính (ví dụ: khi bạn xác định một đối tượng bên ngoài một lớp hoặc hàm trong module JS của mình). Các biến như vậy có thể giữ lại các đối tượng khác và do đó ngăn chúng bị dọn dẹp rác.\r\n\r\n<strong>Nguyên nhân dẫn đến rò rỉ bộ nhớ</strong>\r<ul><li>Thêm timer/listener chưa phát hành trong <code>componentDidMount</code></li></ul>\r<ul><li>Rò rì closure scope.</li></ul>\r\n\r\n<strong>Cách phát hiện rò rì sự cố</strong>\r<ul><li>Trong iOS:</li></ul>\r<ul><li>Vào XCode → Product → Profile (⌘ + i)</li></ul>\r<ul><li>Sau đó, nó sẽ hiển thị cho bạn tất cả các mẫu chọn rò rỉ.</li></ul>\r<ul><li>Trong Android:</li></ul>\r<ul><li>Chạy ứng dụng React Native như bình thường</li></ul>\r<ul><li>Chạy Android Studio</li></ul>\r<ul><li>Trong menu:</li></ul>\r<ul><li>Click Tools → Android → Enable ADB Integration</li></ul>\r<ul><li>Click Tools → Android → Android Device Monitor</li></ul>\r\n    -Khi When Android Device Monitor được mở, click Monitor → Preferences</p>",
              "level": "fresher"
            },
            {
              "question": "Các cách để lưu trữ dữ liệu nhạy cảm trong React Native?",
              "answer": "<p>React Native không đi kèm với bất kỳ cách lưu trữ dữ liệu nhạy cảm nào. Tuy nhiên, đã có các giải pháp sẵn có cho nền tảng Android và iOS.\r\n\r\n<strong>iOS - Keychain Services</strong>\r\n\r\nKeychain Services cho phép bạn lưu trữ một cách an toàn các phần nhỏ thông tin nhạy cảm cho người dùng. Đây là nơi lý tưởng để lưu trữ xác thực, token, mật khẩu và bất kỳ thông tin nhạy cảm nào khác không thuộc về Async Storage.\r\n\r\n<strong>Android - Shared Preferences</strong>\r\n\r\nShared Preferences là phiên bản Android tương đương cho bộ dữ liệu key-value liên tục. Dữ liệu trong Shared Preferences không được mã hóa theo mặc định, nhưng Encrypted Shared Preferences bao bọc lớp Shared Preferences dành cho Android và tự động mã hóa các khóa và giá trị.\r\n\r\n<strong>Android - Keystore</strong>\r\n\r\nAndroid Keystore cho phép bạn lưu trữ các khóa mật mã trong một container để làm cho việc trích xuất từ thiết bị trở nên khó khăn hơn. Để sử dụng iOS Keychain Services hoặc Android Secure Shared Preferences, bạn có thể tự viết bridge hoặc sử dụng thư viện bọc chúng cho bạn và cung cấp một API thống nhất mà bạn tự chịu rủi ro. Một số thư viện cần xem xét:\r<ul><li>Expo-secure-store</li></ul>\r<ul><li>React-native-keychain</li></ul>\r<ul><li>react-native-sensitive-info, bảo mật cho iOS, nhưng dùng Android Shared Preferences</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Bảo mật mạng và SSL Pinning là gì?",
              "answer": "<p><strong>SSL là gì</strong>\r\n\r\nSSL (Secure Sockets Layer) và người kế nhiệm của nó, TLS (Secure Sockets Layer), là các giao thức để thiết lập các liên kết được xác thực và mã hóa giữa các máy tính nối mạng.\r\n\r\nSSL / TLS hoạt động bằng cách ràng buộc danh tính của các thực thể như trang web và công ty với các cặp khóa mật mã thông qua các tài liệu kỹ thuật số được gọi là chứng chỉ X.509. Mỗi cặp khóa bao gồm một khóa riêng và một khóa công khai. Khóa riêng tư được giữ an toàn và khóa công khai có thể được phân phối rộng rãi thông qua chứng chỉ.\r\n\r\n<strong>Pinning là gì</strong>\r\n\r\nPinning là một cơ chế tùy chọn có thể được sử dụng để cải thiện tính bảo mật của một dịch vụ hoặc trang web dựa trên Chứng chỉ SSL. Pinning cho phép chỉ định danh tính mật mã mà người dùng truy cập trang web/ứng dụng được chấp nhận.\r\n\r\n<strong>Tại sao cần SSL Pinning</strong>\r\n\r\nMột trong những rủi ro cố hữu đối với hệ sinh thái SSL là phát hành sai. Đây là khi chứng chỉ trái phép được cấp cho miền / máy chủ lưu trữ mà bạn kiểm soát. Điều này có thể xảy ra với cả PKI(Public Key Infrastructure) công cộng và riêng tư.\r\n\r\n<strong>Cách dùng SSL pinning với ứng dụng di động</strong>\r\n\r\nKhi các ứng dụng di động giao tiếp với máy chủ, chúng thường sử dụng SSL để bảo vệ dữ liệu được truyền khỏi bị giả mạo. Theo các triển khai SSL mặc định được sử dụng, các ứng dụng tin cậy bất kỳ máy chủ nào có chứng chỉ được cửa hàng tin cậy của Hệ điều hành tin cậy, Cửa hàng này là danh sách các tổ chức phát hành chứng chỉ được cung cấp cùng với hệ điều hành.\r\n\r\n<img src=\"/interview-assets/SSL_Pinning.png\" alt=\"\" />\r\n\r\nTuy nhiên, với tính năng SSL pinning, ứng dụng được định cấu hình để từ chối tất cả trừ một hoặc một số chứng chỉ được xác định trước, bất cứ khi nào ứng dụng kết nối với máy chủ, nó sẽ so sánh chứng chỉ máy chủ với (các) chứng chỉ đã pinning, nếu và chỉ khi chúng khớp với máy chủ. đáng tin cậy và kết nối SSL được thiết lập.</p>",
              "level": "fresher"
            },
            {
              "question": "setNativeProps là gì?",
              "answer": "<p>Đôi khi cần thực hiện các thay đổi trực tiếp đối với một component mà không sử dụng state/props để kích hoạt render lại toàn bộ cây con. Ví dụ: khi sử dụng React trong trình duyệt, đôi khi bạn cần phải sửa đổi trực tiếp nút DOM và điều này cũng đúng với các view trong ứng dụng dành cho thiết bị di động. <code>setNativeProps</code> là React Native tương đương với việc thiết lập các thuộc tính trực tiếp trên một nút DOM.\r\nSử dụng <code>setNativeProps</code> khi render thường xuyên tạo ra tắc nghẽn hiệu suất.\r\n\r\nThao tác trực tiếp sẽ không phải là công cụ mà bạn tiếp cận thường xuyên; thông thường bạn sẽ chỉ sử dụng nó để tạo animation liên tục để tránh chi phí hiển thị cấu trúc phân cấp component và điều chỉnh nhiều view. <code>setNativeProps</code> là bắt buộc và lưu trữ trạng thái trong lớp native (DOM, UIView,...) chứ không phải trong các component React của bạn, điều này làm cho code của bạn khó đọc hơn. Trước khi sử dụng, hãy thử giải quyết vấn đề của bạn với <code>setState</code> và <code>shouldComponentUpdate</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách ứng dụng React Native làm việc mượt mà với animation?",
              "answer": "<p>Lý do chính và cũng là lý do quan trọng khiến các ứng dụng native được xây dựng tốt lại hoạt động trơn tru là do tránh các thao tác tốn kém trong quá trình tương tác và animation. React Native có một hạn chế là chỉ có một luồng thực thi JS duy nhất, nhưng bạn có thể sử dụng <code>InteractionManager</code> để đảm bảo công việc dài hạn được lên lịch bắt đầu sau khi hoàn thành bất kỳ tương tác/animation nào.\r\n\r\nCác ứng dụng có thể lập lịch để chạy các tác vụ sau khi tương tác theo cách sau:\r\n\r\n``<code>jsx\r\nInteractionManager.runAfterInteractions(() =&gt; {\r\n    // ...long-running synchronous task...\r\n});\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        }
      ]
    }
  ]
}