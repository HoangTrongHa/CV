{
  "categories": [
    {
      "id": "frontend",
      "name": "Frontend Development",
      "icon": "web",
      "color": "#36e27b",
      "subcategories": [
        {
          "id": "css",
          "name": "Câu hỏi phỏng vấn CSS",
          "description": "",
          "questions": [
            {
              "question": "Mô hình hộp trong CSS là gì? Thuộc tính CSS nào là một phần của nó?",
              "answer": "<p>Các phần tử trong HTML có thể được coi là những chiếc hộp. Trong CSS, thuật ngữ \"mô hình hộp\" được dùng để nói về việc thiết kế, xây dựng bố cục.\r\n\r\nVề cơ bản mô hình hộp CSS là một chiếc hộp bao xung quanh phần tử HTML, gồm margin, border, padding và nội dung bên trong. Hình ảnh dưới đây cho thấy vị trí và mối liên hệ giữa các thành phần này.\r\n\r\n<img src=\"/interview-assets/Box_Model_in_CSS.jpg\" alt=\"\" />\r\n\r\n<em> <strong>Content</strong> - nội dung trong hộp, nơi hiển thị văn bản và hình ảnh.\r\n</em> <strong>Padding</strong> - phần khoảng trắng xung quanh nội dung.\r\n<em> <strong>Border</strong> - đường viền xung quanh nội dung và padding.\r\n</em> <strong>Margin</strong> - phần lề bên ngoài đường viền.</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của CSS?",
              "answer": "<p><ul><li>Tiết kiệm thời gian, công sức trong việc code web/xây dựng giao diện; kiểm soát dễ dàng các lỗi không đáng có trên web</li></ul>\r<ul><li>CSS cung cấp nhiều thuộc tính cụ thể hơn HTML giúp tạo ra nhiều style khác nhau và có thể áp dụng được cho nhiều loại web.</li></ul>\r<ul><li>CSS giúp tốc độ tải trang web nhanh chóng hơn, dễ dàng bảo trì, tương thích với các thiết bị di động.</li></ul>\r<ul><li>CSS thiết lập nhiều kiểu chữ khác nhau giúp website của bạn trở nên khác biệt hơn; tự động sắp xếp chữ khi chèn hình ảnh (thuộc tính shape-outsite); đặt nội dung theo các chiều khác nhau/ thay đổi chế độ viết theo mong muốn của mình (thuộc tính write-mode); có thể tạo chữ lớn ở đầu dòng (thuộc tính first-letter)…</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hạn chế của CSS?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để đưa CSS vào trang web?",
              "answer": "<p>Có nhiều cách để thêm CSS vào trang web.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Các loại selector khác nhau trong CSS?",
              "answer": "<p>CSS Selector giống như là đường đẫn, chỉ định để cho CSS biết bạn đang muốn điều chỉnh, tạo kiểu cho phần tử HTML nào vậy.\r\n\r\n<strong>Universal Selector:</strong> hoạt động như một ký tự đại diện cho tất cả phần tử trong trang. Trong ví dụ này, các style được cung cấp sẽ được áp dụng cho tất cả các phần tử trên trang.\r\n\r\n``<code>css\r<ul><li>{</li></ul>\r\n    color: \"green\";\r\n    font-size: 20px;\r\n    line-height: 25px;\r\n}\r\n</code>`<code>\r\n\r\n<strong>Element Type Selector:</strong> selector loại này ứng với một hoặc nhiều phần tử HTML cùng tên. Trong ví dụ này, các style được cung cấp sẽ được áp dụng cho tất cả các phần tử ul trên trang.\r\n\r\n</code>`<code>css\r\nul {\r\n    line-style: none;\r\n    border: solid 1px #ccc;\r\n}\r\n</code>`<code>\r\n\r\n<strong>ID Selector:</strong> selector này ứng với bất kỳ phần tử HTML nào có thuộc tính ID có cùng giá trị với giá trị của selector. Trong ví dụ này, các style được cung cấp sẽ được áp dụng cho tất cả các phần tử có ID trùng trên trang.\r\n\r\n</code>`<code>css\r\n#container {\r\n    width: 960px;\r\n    margin: 0 auto;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n<div id=\"container\"></div>\r\n</code>`<code>\r\n\r\n<strong>Class Selector:</strong> tương tự như ID Selector nhưng thay vì ứng với ID thì nó ứng với thuộc tính class. Trong ví dụ này, các style được cung cấp sẽ áp dụng cho tất cả phần tử có cùng tên lớp.\r\n\r\n</code>`<code>css\r\n.box {\r\n    padding: 10px;\r\n    margin: 10px;\r\n    width: 240px;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n<div class=\"box\"></div>\r\n</code>`<code>\r\n\r\n<strong>Descendant Combinator:</strong> giúp bạn kết hợp hai hoặc nhiều selector để có thể chỉ định phần tử cụ thể.\r\n\r\n</code>`<code>css\r\n#container .box {\r\n\tfloat: left;\r\n\tpadding-bottom: 15px;\r\n} \r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n<div id=\"container\">\r\n\t<div class=\"box\"></div>\r\n\t\r\n\t<div class=\"box-2\"></div>\r\n</div>\r\n\r\n<div class=\"box\"></div>\r\n</code>`<code>\r\n\r\nKhối khai báo này sẽ áp dụng cho tất cả các phần tử có lớp </code>box<code> nằm bên trong phần tử có ID là </code>container<code>. Cần lưu ý rằng phần tử </code>.box<code> không nhất thiết phải là phần tử con, nó có thể có một phần tử khác bao bọc </code>.box<code> và các style vẫn sẽ áp dụng.\r\n\r\n<strong>Child Combinator:</strong> selector sử dụng bộ child combinator tương tự như descendant combinator, ngoại trừ việc nó chỉ nhắm đến các phần tử con.\r\n\r\n</code>`<code>css\r\n#container> .box {\r\n\tfloat: left;\r\n\tpadding-bottom: 15px;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n<div id=\"container\">\r\n\t<div class=\"box\"></div>\r\n\t\r\n\t<div>\r\n\t\t<div class=\"box\"></div>\r\n\t</div>\r\n</div>\r\n</code>`<code>\r\n\r\nSelector sẽ ứng với tất cả phần tử có lớp </code>box<code> và là phần tử con của phần tử có id là </code>container<code>. Điều đó có nghĩa là các phần tử lớp </code>box<code> không phải là phần tử con của </code>container<code> sẽ không được áp dụng.\r\n\r\n<strong>General Sibling Combinator:</strong> selector này so với các phần tử có quan hệ anh chị em với phần tử tương ứng.\r\n\r\n</code>`<code>css\r\nh2 ~ p {\r\n\tmargin-bottom: 20px;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n<h2>Title</h2>\r\n<p>Paragraph example.</p>\r\n<p>Paragraph example.</p>\r\n<p>Paragraph example.</p>\r\n<div class=\"box\">\r\n\t<p>Paragraph example.</p>\r\n</div>\r\n</code>`<code>\r\n\r\nTrong ví dụ này, tất cả các phần tử văn bản (</code><p><code>) sẽ được áp dụng style với các quy tắc đã chỉ định, nhưng chỉ khi chúng là anh chị em của các phần tử </code><h2><code>. Có thể có các phần tử khác ở giữa </code><h2><code> và </code><p><code> và các style sẽ vẫn áp dụng.\r\n\r\n<strong>Adjacent Sibling Combinator:</strong>: selector sử dụng ký tự </code>+<code> và gần giống với General Sibling Combinator. Sự khác biệt là phần tử được nhắm phải là anh chị ruột thịt chứ không phải enh chị em chung chung.\r\n\r\n</code>`<code>css\r\np + p {\r\n\ttext-indent: 1.Sem;\r\n\tmargin-bottom: 0;\r\n}\r\n</code>`<code>\r\n</code>`<code>html\r\n<h2>Title</h2>\r\n<p>Paragraph example.</p>\r\n<p>Paragraph example.</p>\r\n<p>Paragraph example.</p>\r\n\r\n<div class=”box”>\r\n\t<p>Paragraph example.</p>\r\n\t<p>Paragraph example.</p>\r\n</div>\r\n</code>`<code>\r\n\r\nVí dụ trên sẽ chỉ áp dụng các style được chỉ định cho các phần tử văn bản ngay sau các phần tử văn bản khác. Điều này có nghĩa là phần tử văn bản đầu tiên trên một trang sẽ không nhận được các style này. Ngoài ra, nếu một phần tử khác xuất hiện giữa hai đoạn văn, thì đoạn thứ hai của cả hai sẽ không được áp dụng style.\r\n\r\n<strong>Attribute Selector:</strong> nhắm đến các phần tử dựa trên sự xuất hiện và giá trị của thuộc tính HTML. Được khai báo bằng dấu ngoặc vuông.\r\n\r\n</code>`<code>css\r\ninput [type=”text”] {\r\n\tbackground-color: #444;\r\n\twidth: 200px;\r\n}\r\n</code>`<code>\r\n</code>`<code>html\r\n<input type=\"text\">\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "CSS Preprocessor là gì? SASS vs LESS vs Stylus?",
              "answer": "<p>CSS Preprocessor là các phiên bản mở rộng của ngôn ngữ CSS (ngôn ngữ tiền xử lý CSS) được viết xử lý trước sau đó sẽ biên dịch ra các đoạn mã CSS thông thường. Nhiệm vụ của các CSS Preprocessor là giúp bạn logic hóa và cấu trúc các đoạn mã CSS, từ đó đưa CSS trở nên gần hơn với 1 ngôn ngữ lập trình. Bạn có thể viết CSS theo thứ tự rõ ràng, quản lý các biến đã được định nghĩa sẵn, có thể tự động nén tập tin CSS lại để bạn tiết kiệm dung lượng. Hiện tại có thể có rất nhiều CSS Preprocessor nhưng có phỗ biến nhất trong số đó là SASS, LESS và Stylus.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "VH/VM trong CSS là gì?",
              "answer": "<p>Đây là một đơn vị CSS được sử dụng để đo chiều cao và chiều rộng theo tỷ lệ phần trăm đối với viewport. Nó được sử dụng chủ yếu trong các kỹ thuật thiết kế reponsive. Số đo VH bằng 1/100 chiều cao của viewport. Nếu chiều cao của trình duyệt là 1000px, thì 1vh bằng 10px. Tương tự, nếu chiều rộng là 1000px, thì 1 vw bằng 10px.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa reset và normalize CSS?",
              "answer": "<p><strong>Reset CSS:</strong> nhằm mục đích xoá tất cả thiết lập style mặc định từ trình duyệt. Ví dụ như margin, padding, font-size của tất cả phần tử đó được reset lại giống nhau.\r\n\r\n<strong>Normalize CSS:</strong> nhằm mục đích làm cho các style mặc định nhất quán trên trình duyệt. Nó cũng sửa các lỗi phổ biến trên trình duyệt.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa inline, block và inline-block?",
              "answer": "<p><strong>Block</strong>: Các phần tử block luôn bắt đầu trên một dòng mới. Chúng cũng sẽ chiếm không gian trên toàn bộ hàng hay chiều rộng. Danh sách các phần tử block là <code><div></code>, <code><p></code>.\r\n\r\n<strong>Inline</strong>: Các phần tử inline không bắt đầu trên dòng mới, mà nó xuất hiện cùng dòng với các thẻ bên cạnh chúng. Ví dụ các phần tử inline là <code><span></code>, <code><strong></code> và <code><img></code>.\r\n\r\n<strong>Inline Block</strong>: Các phần tử inline-block tương tự inline, ngoại trừ chúng có thể có phần padding và margin và đặt các giá trị height và width.</p>",
              "level": "fresher"
            },
            {
              "question": "Việc kiểm tra trang web trên các trình duyệt khác nhau có quan trọng không?",
              "answer": "<p>Điều quan trọng nhất là kiểm tra một trang web trong các trình duyệt khác nhau khi bạn thiết kế lần đầu tiên hoặc khi thực hiện các thay đổi lớn. Tuy nhiên, điều quan trọng là phải lặp lại các kiểm tra này theo định kỳ, vì các trình duyệt thường xuyên có các bản cập nhật và thay đổi.</p>",
              "level": "fresher"
            },
            {
              "question": "Phần tử Pseudo và các lớp Pseudo là gì?",
              "answer": "<p><strong>Phần tử pseudo</strong> cho phép ta tạo các mục thường không tồn tại trong DOM.\r<ul><li>::before</li></ul>\r<ul><li>::after</li></ul>\r<ul><li>::first-letter</li></ul>\r<ul><li>::first-line</li></ul>\r<ul><li>::selection</li></ul>\r\n\r\nTrong ví dụ bên dưới, màu sẽ xuất hiện ở dòng đầu tiên trong đoạn văn\r\n\r\n``<code>css\r\np::first-line {\r\n\tcolor: #ffOOOO;\r\n\tfont-variant: small-caps;\r\n}\r\n</code>`<code>\r\n\r\n<strong>Lớp pseudo</strong>  chọn các phần tử thông thường nhưng trong các điều kiện nhất định như khi người dùng di chuột qua liên kết.\r<ul><li>:link</li></ul>\r<ul><li>:visited</li></ul>\r<ul><li>:hover</li></ul>\r<ul><li>:active</li></ul>\r<ul><li>:focus</li></ul>\r\n\r\nTrong ví dụ này, màu xuất hiện khi bạn di chuyển chuột qua thẻ liên kết.\r\n\r\n</code>`<code>css\r\n/<em> mouse over link </em>/\r\na:hover {\r\n\tcolor: #FFOOFF;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để chỉ định các đơn vị trong CSS? Những cách khác nhau để làm điều đó là gì?",
              "answer": "<p>Có nhiều cách khác nhau để chỉ định các đơn vị trong CSS như <code>px</code>, <code>em</code>, <code>pt</code>, phần trăm (<code>%</code>). \r<ul><li>Pixel (px) cung cấp khả năng kiểm soát chi tiết và duy trì căn chỉnh vì 1 hoặc nhiều px được đảm bảo sự sắc nét. px không phân tầng.</li></ul>\r<ul><li>em duy trì kích thước tương đối. Bạn có thể có phông chữ reponse. Em, sẽ xếp tầng 1em bằng kích thước phông chữ hiện tại của phần tử hoặc mặc định của trình duyệt. Nếu bạn để font-size thành 16px thì 1em = 16px. Thực tế phổ biến là đặt kích thước phông chữ nội dung mặc định thành 62,5% (bằng 10px).</li></ul>\r<ul><li>pt (điểm) thường được sử dụng trong in ấn. 1pt = 1/72 inch và nó là một đơn vị có kích thước cố định.</li></ul>\r<ul><li>% (phần trăm) đặt kích thước phông chữ so với kích thước phông của nội dung. Do đó, bạn phải đặt kích thước phông chữ của phần nội dung thành kích thước hợp lý.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Liệu margin-top hoặc margin-bottom có ảnh hưởng đến các phần tử inline không?",
              "answer": "<p>Không, nó không ảnh hưởng đến các phần tử inline. Các phần tử inline ở cùng dòng với nội dung của trang.</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính nào được sử dụng để thay đổi dạng phông chữ?",
              "answer": "<p>Chúng ta có thể sử dụng thuộc tính <code>font-family</code> để thực hiện được điều này. Thuộc tính font-family được sử dụng để chỉ định phông chữ nào cần được áp dụng trên phần tử DOM. Nó có thể chứa một số tên phông chữ như một phần của cơ chế “dự phòng” trong trường hợp trình duyệt không hỗ trợ phông chữ. Ví dụ, chúng ta có thể sử dụng:\r\n\r\n``<code>css\r\np {\r\n    font-family: \"Times New Roman\", Times, serif;\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta đang áp dụng thuộc tính font-family cho phần tử đoạn văn.\r<ul><li>Nó yêu cầu trình duyệt tìm kiếm phông chữ \"Times New Roman\" và áp dụng nó.</li></ul>\r<ul><li>Nếu phông chữ \"Times New Roman\" không được cài đặt hoặc hỗ trợ, thì nó sẽ yêu cầu trình duyệt sử dụng phông chữ Times.</li></ul>\r<ul><li>Nếu cả \"Times New Roman\" và \"Times\" đều không được hỗ trợ, thì nó sẽ yêu cầu trình duyệt sử dụng bất kỳ phông chữ chung nào được hỗ trợ thuộc serif.</li></ul>\r\n\r\nNếu bạn không muốn </code>font-face<code> của phần tử văn bản là phông chữ Times New Roman/ Times/serif và bạn muốn sử dụng phông chữ Arial/Helvetica/sans-serif, thì ta có thể cập nhật thuộc tính CSS của phần tử văn bản như:\r\n\r\n</code>`<code>css\r\np {\r\n    font-family: Arial, Helvetica, sans-serif;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa adaptive design và responsive design?",
              "answer": "<p>| Adaptive Design | Responsive Design |\r\n|-----------------|-------------------|\r\n| Tập trung vào thiết kế trang web dựa trên nhiều kích thước bố cục cố định | Tập trung vào việc hiển trị nội dung trên cơ sở không gian trình duyệt có sẵn |\r\n| Khi một trang web được phát triển bằng cách sử dụng thiết kế adaptive được mở trên trình duyệt máy tính để bàn, trước tiên không gian có sẵn sẽ được phát hiện và sau đó bố cục có kích thước phù hợp nhất sẽ được chọn và sử dụng để hiển thị nội dung. Thay đổi kích thước của cửa sổ trình duyệt không ảnh hưởng đến thiết kế | Khi một trang web được phát triển bằng cách sử dụng thiết kế responsive được mở trên trình duyệt trên máy tính để bàn và khi ta thay đổi kích thước cửa sổ trình duyệt, nội dung của trang web được sắp xếp động và tối ưu để phù hợp với cửa sổ |\r\n| Thông thường, các thiết kế adaptive sử dụng sáu chiều rộng màn hình tiêu chuẩn - 320px, 480px, 760px, 960px, 1200px, 1600 . Các kích thước này được phát hiện và các bố cục thích hợp được tải | Thiết kế này sử dụng các truy vấn CSS để thay đổi kiểu tùy thuộc vào thuộc tính thiết bị mục tiêu để thích ứng với các màn hình khác nhau |\r\n| Đầu tiên phải mất rất nhiều thời gian và nỗ lực để xem xét các lựa chọn và thực tế của người dùng cuối, sau đó thiết kế các giải pháp thích ứng tốt nhất có thể cho họ | Nói chung, thiết kế responsive cần ít công việc hơn để xây dựng và thiết kế các trang web linh hoạt có thể chứa nội dung từ màn hình tùy thuộc vào kích thước màn hình |\r\n| Cung cấp nhiều quyền kiểm soát thiết kế để phát triển các trang web cho các màn hình cụ thể | Không có nhiều quyền kiểm soát thiết kế được cung cấp ở đây |</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "es6",
          "name": "Câu hỏi phỏng vấn ES6",
          "description": "",
          "questions": [
            {
              "question": "Các tính năng nổi bật của ES6",
              "answer": "<p><em> Hỗ trợ các biến hằng\r\n</em> Block scope hỗ trợ cho tất cả biến, hằng, và hàm\r\n<em> Giới thiệu hàm arrow\r\n</em> Xử lý tham số mở rộng\r\n<em> Tham số mặc định\r\n</em> Các ký tự mở rộng và mẫu\r\n<em> Promise\r\n</em> Class\r\n<em> Module\r\n</em> Tập hợp\r<ul><li>Hỗ trợ map/set</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hỗ trợ hướng đối tượng trong ES6 như thế nào?",
              "answer": "<p><ul><li><strong>Classes</strong> có thể tạo lớp trong ES6. Về cơ bản, hàm lớp xây dựng một khuôn mẫu mà từ đó ta có thể tạo các đối tượng. Khi tạo một thực thế mới của lớp, phương thức constructor sẽ được gọi.</li></ul>\r<ul><li><strong>Methods</strong> phương thức tĩnh có thể được tìm thấy trong các lớp. Một phương thức tĩnh không giống như một đối tượng mà nó là một hàm được liên kết với lớp. Một phương thức tĩnh không thể được gọi từ một thực thể của lớp.</li></ul>\r\n\r\nTa hãy xem qua getter và setter nhé.\r\nĐóng gói là một khái niệm căn bản trong OOP. Dữ liệu (thuộc tính) sẽ không được truy cập trực tiếp từ bên ngoài, đây là một khía cạnh quan trọng của đóng gói. Một getter (truy cập) hay setter (chỉnh sửa) là những phương thức của thực thể đã xác định để truy cập hay chỉnh sửa một thuộc tính.\r<ul><li><strong>Tính kế thừa</strong>, các lớp cũng có thể kế thừa từ nhau. Lớp cha là lớp kế thừa và con là lớp được kế thừa từ lớp cha.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa ES5 và ES6",
              "answer": "<p>| ES5 | ES6 |\r\n|-----|-----|\r\n| Là chuẩn thứ 5 của ECMAScript được giới thiệu năm 2009 | Là chuẩn thứ 6 của ECMAScript được giới thiệu năm 2015 |\r\n| Kiểu dữ liệu nguyên thuỷ là string, boolean, number, null và undefined | Giới thiệu thêm kiểu symbol |\r\n| Chỉ có thể khai báo biến với var | Có thể dùng var, và hai cách khai báo biến mới là let và const |\r\n| Sử dụng function để khai báo hàm | Giới thiệu thêm hàm arrow |\r\n| for cho vòng lặp | Giới thiệu thêm for...of |</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa let và const?",
              "answer": "<p>Cả let và const đều có block scope. Nếu bạn sử dụng các từ khóa này để khai báo một biến, biến đó sẽ chỉ tồn tại trong block trong cùng bao quanh chúng. Nếu bạn khai báo một biến với let bên trong một block (ví dụ: nếu một điều kiện hoặc một vòng lặp for), thì nó chỉ có thể được truy cập trong block đó.\r\n\r\nCác biến được khai báo với từ khóa let có thể thay đổi, có nghĩa là giá trị của chúng có thể được thay đổi. Nó tương tự như từ khóa var, nhưng với lợi ích bổ sung là block scope. Các biến được khai báo với từ khóa const là block scope và bất biến. Khi các biến được khai báo với từ khóa const, giá trị của chúng không thể được sửa đổi hoặc gán lại.</p>",
              "level": "fresher"
            },
            {
              "question": "Thảo luận về hàm arrow",
              "answer": "<p>Trong ES6, hàm arrow là một cú pháp mới cho khai báo hàm. hàm arrow bao gồm tham số theo sau mũi tên (=>) và thân hàm.\r\n\r\n``<code>js\r\nconst function<em>name = (arg</em>1, arg<em>2, arg</em>3, ...) => {  \r\n    //body of the function  \r\n}\r\n</code>`<code>\r\n\r\nCác điều cần nhớ:\r<ul><li>Nó tiết kiệm kích cỡ code.</li></ul>\r<ul><li>Với hàm một dòng, lênh return là không bắt buộc.</li></ul>\r<ul><li>Ràng buộc ngữ cảnh.</li></ul>\r<ul><li>Với hàm một tham số, dấu ngoặc đơn là không bắt buộc.</li></ul>\r<ul><li>Không hoạt động với </code>new`.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Khi nào không nên dùng hàm arrow?",
              "answer": "<p>Không nên sử dụng hàm arrow cho các trường hợp dưới đây:\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm generator là gì?",
              "answer": "<p>Là tính năng mới được giới thiệu trong ES6. Hàm Generator trả về một đối tượng sau khi tạo nhiều giá trị theo thời gian. Ta có thể lặp qua đối tượng và trích xuất từng giá trị từ hàm một. Một hàm trả về một đối tượng được lặp đi lặp lại gọi là hàm generator. Trong ES6, cú pháp cho nó là <code>fuction<em></code> cùng từ khoá <code>yield</code> bên trong nó.\r\n\r\n``<code>js\r\nfunction </em>Numbers() {\r\n    let num = 1;\r\n    while(true) {\r\n        yield num++;\r\n    }\r\n}\r\n  \r\nvar gen = Numbers();\r\n \r\n// Loop to print the first\r\n// 5 Generated numbers\r\nfor (var i = 0; i < 5; i++) {\r\n \r\n    // Generate the next number\r\n    document.write(gen.next().value);\r\n \r\n    // New Line\r\n    document.write(\"<br>\");\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\n1\r\n2\r\n3\r\n4\r\n5\r\n</code>``\r\n\r\nGiá trị yield trở thành giá trị kế tiếp trong chuỗi tuần tự mỗi lần yield được gọi. Ngoài ra, hàm generator tính toán kết quả output của chúng theo yêu cầu, cho phép chúng biểu diễn một cách hiệu quả các chuỗi tuần tự dài hơn thậm chí là vô hạn.</p>",
              "level": "fresher"
            },
            {
              "question": "Toán tử spread trong ES6?",
              "answer": "<p>Toán tử spread có cú pháp giống với rest parameters tuy nhiên cả hai có ý nghĩa khác nhau. Rest parameters được sử dụng khi khai báo hàm, ngược lại toán tử spread được sử dụng trong các câu lệnh, biểu thức hoặc khi gọi hàm.\r\n\r\nES6 cung cấp một toán tử mới gọi là toán tử spread bao gồm ba dấu chấm (...). Spread cho phép bạn trải ra các phần tử của một đối tượng có thể lặp lại chẳng hạn như một array, map hoặc set.\r\n\r\n``<code>js\r\nlet arr1 = [4, 5, 6];  \r\n    \r\nlet arr2 = [1, 2, 3, ...arr1, 7, 8, 9, 10];  \r\n    \r\nconsole.log(arr2);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\n[ 1 2 3 4 5 6 7 8 9 10 ]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về destructuring trong ES6?",
              "answer": "<p>Destructuring được giới thiệu trong ES6 là một cách để trích xuất dữ liệu từ mảng hay đối tượng thành các biến duy nhất. Ta có thể tạo các đoạn nhỏ hơn từ đối tượng hay mảng bằng phương thức này. Ví dụ:\r\n\r\n``<code>js\r\nlet greeting = [\"Good\", \"Morning\"];\r\nlet [g1, g2] = greeting;\r\nconsole.log(g1, g2);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nGood Morning\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Promise trong ES6 là gì?",
              "answer": "<p>Lập trình bất đồng bộ là khái niệm quan trọng trong JavaScript. Các tiến trình chạy độc lập với luồng chính trong lập trình bất đồng bộ. Promise là cách tiếp cận tiện lợi để xử lý lập trình bất đồng bộ trong ES6. Callback được dùng để chủ yếu trong bất đồng bộ trước khi ES6 giới thiệu về Promise.\r\n\r\nTuy nhiên, vì callback dễ gây ra callback hell, nên hướng giải quyết cho nó là dùng promise thay thế.\r\n\r\n<strong>Callback hell</strong>\r\n\r\n``<code>js\r\nf1(function(x){\r\n    f2(x, function(y){\r\n        f3(y, function(z){ \r\n            ...\r\n        });\r\n    });\r\n}); \r\n</code>`<code>\r\n\r\n<strong>Cú pháp Promise</strong>\r\n\r\n</code>`<code>js\r\nconst promise = new Promise((resolve,reject) => {....}); \r\n</code>`<code>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nconst myPromise = new Promise((resolve, reject) => {\r\n    if (Math.random() > 0) {\r\n        resolve('Hello, I am positive number!');\r\n    }\r\n    reject(new Error('I failed some times'));\r\n})\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Rest parameter trong ES6?",
              "answer": "<p>Rest Parameters dịch theo tiếng Anh chuyên ngành công nghệ thông tin có nghĩa là tham số còn lại, điều này có nghĩa là bạn có thể khai báo một hàm với số lượng tham số không xác định, đây là một tính năng mới trong ES6 khiến Javascript ngày càng trở nên mạnh mẽ hơn.\r\n\r\n``<code>js\r\nfunction display(...args) {  \r\n    let ans = 0;  \r\n    for (let i of args) {  \r\n        ans *= i;  \r\n    }  \r\n    console.log(\"Product = \"+ans);  \r\n}  \r\n    \r\ndisplay(4, 2, 3);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nProduct = 24\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thảo luận về template literal trong ES6?",
              "answer": "<p>Temaplate Literals là một cú pháp mới dùng để khai báo biến, được thêm vào trong phiên bản ES6. Khi sử dụng cú pháp này các bạn có thể:\r<ul><li>Khai báo biến nhiều dòng một cách hết sức đơn giản. (Nếu bạn sử dụng cách truyền thống thì sẽ không thể nào khai báo được một biến mà có sử dụng ký tự xuống dòng, nhưng với template thì có thể).</li></ul>\r<ul><li>Binding biến vào trong template một cách dễ dàng.</li></ul>\r\n\r\nKý tự `<code> dùng để mở và đóng template literal. Ký hiệu dollar và dấu ngoặc nhọn \"${}\" được dùng để đặt một biến vào template literal.\r\n\r\n</code>`<code>js\r\nlet s1 = \"Good\";  \r\n  \r\nlet s2 = \"Day\";  \r\n   \r\nlet s = </code>${s1} ${s2}<code>;  \r\nconsole.log(s);\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nGood Day\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của class trong ES6?",
              "answer": "<p>Các ưu điểm của class ở ES6:\r<ul><li>Cú pháp đơn giản và ít lỗi hơn.</li></ul>\r<ul><li>Khi xây dựng một hệ phân cấp kế thừa, ES6 kết hợp cú pháp cũ và mới, làm giảm lỗi và đơn giản hoá các quy trình.</li></ul>\r<ul><li>Class trong ES6 ngăn chặn lỗi do toán tử <code>new</code>. Nếu một đối tượng không hợp lệ khởi tạo, class sẽ loại trừ vấn đề này bằng cách để constructor trả về lỗi.</li></ul>\r<ul><li>Class còn gọi một phương thức từ prototype. Với cú pháp ES6, nó dễ dùng hơn các phiên bản trước.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách tạo class trong ES6?",
              "answer": "<p>Từ khoá <code>class</code> dùng cho tạo lớp trong ES6. Ta có thể dùng biểu thức lớp hoặc khai báo lớp để tạo. Chỉ có hàm và contrustor là được cho phép trong lớp. Các thành phần này gọi chung là thuộc tính dữ liệu của lớp.\r\n\r\nConstructor trong lớp có trách nhiệm cấp phát bộ nhớ cho đối tượng của lớp. Hàm của lớp chịu trách nhiệm thực hiện các hành động trên đối tượng.\r\n\r\nCú pháp ở ES5\r\n\r\n``<code>js\r\nvar varName = new className {\r\n    // something\r\n}\r\n</code>`<code>\r\n\r\nCú pháp ở ES6\r\n\r\n</code>`<code>js\r\nclass className {\r\n    // Something\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Biểu thức lớp là gì?",
              "answer": "<p>Trong ES6, một cách khác để khai báo lớp là dùng biểu thức lớp. Giống như một biểu thức hàm, có thể có tên hoặc không. Nếu có tên, tên đó là duy nhất trong thân lớp. \r\n\r\n``<code>js\r\nvar Product = class {\r\n    constructor (num1, num2) {\r\n    this.num1 = num1;\r\n    this.num2 = num2;\r\n    }\r\n    multiplication() {\r\n    return this.num1 * this.num2;\r\n    }\r\n}\r\nconsole.log(new Product(5,8).multiplication());\r\n// expected output: 40\r\n</code>``\r\n\r\nCú pháp của một biểu thức lớp tương tự như cú pháp của một câu lệnh lớp (khai báo). Mặt khác, các biểu thức lớp cho phép bạn bỏ qua tên lớp (\"định danh ràng buộc\"), điều này không thể thực hiện được với các câu lệnh lớp. Ngoài ra, không giống như khai báo lớp, biểu thức lớp cho phép bạn khai báo lại các lớp mà không gây ra bất kỳ lỗi kiểu nào. Nó không bắt buộc phải sử dụng thuộc tính constructor. Loại lớp được tạo bằng từ khóa này sẽ luôn là \"function\".</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "html",
          "name": "Câu hỏi phỏng vấn HTML",
          "description": "",
          "questions": [
            {
              "question": "Thẻ HTML và phần tử là một?",
              "answer": "<p>Không. Phần tử (element) HTML được xác định bằng cách bắt đầu thẻ, bao gồm tất cả nội dung cho đến khi đóng thẻ. Ví dụ, <code><h1>Heading</h1></code> là một phần tử HTML, còn tag chỉ là <code><h1></code> và <code></h1></code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Thẻ và thuộc tính trong HTML là gì?",
              "answer": "<p>Thẻ là thành phần quan trọng trong HTML xác định cách nội dung sẽ được định dạng, trong khi thuộc tính đi cùng với thẻ HTML để xác định đặc trưng của phần tử HTML. Ví dụ: <code><p align=\"center\">HTML Question</p></code>, thì <code>algin</code> là thuộc tính để xác định đoạn văn bản sẽ hiển thị ở giữa.</p>",
              "level": "fresher"
            },
            {
              "question": "Phần tử void trong HTML là gì?",
              "answer": "<p>Trong HTML sẽ có các phần tử không cần thẻ đóng. Ví dụ: <code><br /></code>, <code><img /></code>, <code><hr /></code>,...</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của khoảng trắng?",
              "answer": "<p>Trong HTML, một chuỗi ký tự khoảng trắng được coi là một ký tự khoảng trắng. Vì trình duyệt thu gọn nhiều khoảng trắng thành một ký tự khoảng trắng duy nhất và điều này giúp dev thụt lề các dòng văn bản mà không phải lo lắng về nhiều khoảng trắng và duy trì tính dễ đọc và dễ hiểu của code HTML.</p>",
              "level": "fresher"
            },
            {
              "question": "HTML Entities là gì?",
              "answer": "<p>Trong HTML một vài ký tự dành riêng như <code><</code>, <code>></code>, <code>/</code>,... Để sử dụng các ký tự trong trang web, ta cần dùng các ký tự đặc biệt gọi là HTML entities. Dưới đây là một số ánh xạ giữa ký tự dành riêng và ký tự entities tương ứng sẽ được sử dụng. \r\n\r\n| Character | Entity Name | Entity Number |\r\n|-----------|-------------|---------------|\r\n| <         | <code>&lt;</code>        | <code>&#60;</code>         |\r\n| >         | <code>&gt;</code>        | <code>&#62;</code>         |\r\n| &         | <code>&amp;</code>        | <code>&#38;</code>         |</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu danh sách trong HTML?",
              "answer": "<p><img src=\"/interview-assets/Image_List.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính `class` trong HTML là gì?",
              "answer": "<p>Thuộc tính class được sử dụng để chỉ định tên lớp cho một phần tử HTML. Nhiều phần tử trong HTML có thể có cùng giá trị lớp. Ngoài ra, nó chủ yếu được sử dụng để liên kết các style được viết trong CSS.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác nhau của thuộc tính `id` và `class` trong phần tử HTML?",
              "answer": "<p>Nhiều phần tử trong HTML có thể có cùng giá trị lớp, trong khi giá trị thuộc tính id của một phần tử này không thể được liên kết với phần tử HTML khác.</p>",
              "level": "fresher"
            },
            {
              "question": "multipart/form-data là gì?",
              "answer": "<p><code>multipart/form-data</code> là một trong những giá trị của thuộc tính <code>enctype</code>. Nó được sử dụng để gửi dữ liệu file cho phía server xử lý. Các giá trị hợp lệ khác của thuộc tính <code>enctype</code> là <code>text/plain</code> and <code>application/x-www-form-urlencoded</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả cấu trúc của HTML",
              "answer": "<p>Mỗi trang web đều có các thành phần khác nhau để hiển thị nội dung dự định và một giao diện người dùng cụ thể. Tuy nhiên, có một số kiểu mẫu được chấp nhận trên toàn cầu để cấu trúc trang web, chẳng hạn như:\r<ul><li><strong><code><header></code></strong>: Lưu trữ thông tin bắt đầu về trang web.</li></ul>\r<ul><li><strong><code><footer></code></strong>: Biểu diễn phần cuối cùng của trang.</li></ul>\r<ul><li><strong><code><nav></code></strong>: Menu điều hướng của trang HTML.</li></ul>\r<ul><li><strong><code><article></code></strong>: Nó là một tập hợp thông tin.</li></ul>\r<ul><li><strong><code><section></code></strong>: Nó được sử dụng bên trong <code>article</code> để xác định cấu trúc cơ bản của một trang.</li></ul>\r<ul><li><strong><code><aside></code></strong>: Nội dung menu dọc của trang.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách để tối ưu tải tài nguyên website?",
              "answer": "<p>Để tối ưu thời gian tải web ta cần tối ưu việc tải các tài nguyên:\r<ul><li><strong>CDN hosting</strong> - CDN hoặc mạng phân phối nội dung là các server được phân phối theo địa lý để giúp giảm độ trễ.</li></ul>\r<ul><li><strong>File compression</strong> - Đây là một phương pháp giúp giảm kích thước của nội dung để giảm việc truyền dữ liệu.</li></ul>\r<ul><li><strong>File concatenation</strong> - làm giảm số lượng cuộc gọi HTTP.</li></ul>\r<ul><li><strong>Minify scripts</strong> - làm giảm kích thước tổng thể của file js và CSS</li></ul>\r<ul><li><strong>Parallel downloads</strong> - Lưu trữ nội dung trong nhiều miền phụ để vượt qua giới hạn tải xuống là 6 nội dung trên mỗi miền của tất cả các trình duyệt hiện nay. Điều này có thể được cấu hình nhưng hầu hết người dùng thông thường không bao giờ sửa đổi các cài đặt này.</li></ul>\r<ul><li><strong>Lazy Loading</strong> - Thay vì tải tất cả các nội dung cùng một lúc, các nội dung không quan trọng chỉ được tải trên khi cần thiết.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Thẻ định dạng khác nhau trong HTML",
              "answer": "<p>HTML có các thẻ định dạng khác nhau:\r\n\r\n<em> <code><b></code> - in đậm văn bản\r\n</em> <code><i></code> - in nghiêng văn bản\r\n<em> <code><em></code> - làm cho văn bản nghiêng nhưng có thêm tầm quan trọng về ngữ nghĩa\r\n</em> <code><big></code> - tăng kích cỡ chữ lên một đơn vị \r\n<em> <code><small></code>- giảm kích cỡ chữ lên một đơn vị \r\n</em> <code><sub></code> - biến văn bản thành chỉ số dưới\r\n<em> <code><sup></code> - biến văn bản thành chỉ số trên\r\n</em> <code><del></code> - hiển thị dưới dạng văn bản gạch bỏ\r\n<em> <code><strong></code> - đánh dấu văn bản là quan trọng\r\n</em> <code><mark></code> - highlights văn bản\r<ul><li><code><ins></code> - hiển thị dưới dạng văn bản đã thêm</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thể loại Doctypes khả dụng",
              "answer": "<p>Có ba thể loại Doctypes khả dung:\r<ul><li>Strict Doctype </li></ul>\r<ul><li>Transitional Doctype</li></ul>\r<ul><li>Frameset Doctype</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hãy giải thích cách hiển thị tập ký tự đang được sử dụng trong HTML?",
              "answer": "<p>Tập ký tự được xác định bởi thẻ <code><meta></code> trong phần tử <code><head></code>\r\n\r\n``<code>html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <meta charset=\"UTF-8\">\r\n        ...\r\n        ...\r\n    </head>\r\n    ...\r\n</html>\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác nhau giữa thẻ `<strong>` và `<b>`, thẻ `<em>` và `<i>`?",
              "answer": "<p>Hiệu ứng trên trang web bình thường của các thẻ <code><strong></code>, <code><b></code> và <code><em></code>, <code><i></code> là như nhau. Thẻ <code><b></code> và <code><i></code> là viết tắt của chữ in đậm và chữ nghiêng. Hai thẻ này chỉ áp dụng font chữ và thẻ in đậm <code><b></code>, chỉ thêm mực vào chữ, các thẻ này không nói lên điều gì về văn bản.\r\n\r\nTrong khi đó, các thẻ <code><strong></code> và <code><em></code> thể hiện rằng đoạn văn bản có tầm quan trọng cao và nhấn mạnh hơn so với phần còn lại của văn bản. Các thẻ này có ý nghĩa ngữ nghĩa.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "javascript",
          "name": "Câu hỏi phỏng vấn JavaScript",
          "description": "",
          "questions": [
            {
              "question": "Sự khác biệt giữa các kiểu dữ liệu trong JavaScript?",
              "answer": "<p>Trong JavaScript các kiểu dữ liệu được chia làm hai loại là kiểu nguyên thuỷ và đối tượng. Để biết kiểu dữ liệu của các biến JavaScript, ta có thể sử dụng <strong>typeof</strong>.\r\n\r\n<strong>Kiểu nguyên thuỷ</strong>\r\n\r\n<em><strong>String</strong></em> - biểu diễn một mảng ký tự hay một chuỗi. Kiểu chuỗi trong javascript có thể sử dụng một cặp dấu ngoặc kép hoặc dấu ngoặc kép đơn.\r\n\r\n``<code>js\r\n var str = \"Vivek Singh Bisht\"; //sử dụng dấu ngoặc kép\r\n var str2 = 'John Doe'; // sử dụng dấu ngoặc đơn\r\n</code>`<code>\r\n\r\n<em><strong>Number</strong></em> - biểu diễn cả số nguyên và số thực.\r\n\r\n</code>`<code>js\r\nvar x = 3; // số nguyên\r\nvar y = 3.6; // số thực\r\n</code>`<code>\r\n\r\n<em><strong>BigInt</strong></em> - kiểu dữ liệu này được sử dụng để lưu trữ các số vượt quá giới hạn của kiểu dữ liệu Number. Nó có thể lưu trữ các số nguyên lớn và được biểu diễn bằng cách thêm “n” vào một chữ số nguyên.\r\n\r\n</code>`<code>js\r\nvar bigInteger =  234567890123456789012345678901234567890;\r\n</code>`<code>\r\n\r\n<em><strong>Boolean</strong></em> - kiểu luận lý, có hai giá trị là <em>true</em> và <em>false</em>. Thường được dùng với điều kiện.\r\n\r\n</code>`<code>js\r\nvar a = 2;\r\nvar b =  3;\r\nvar c =  2;\r\n(a == b) // trả về false\r\n(a == c) // trả về true\r\n</code>`<code>\r\n\r\n<em><strong>undefined</strong></em> - khi giá trị của một biến là không xác định.\r\n\r\n</code>`<code>js\r\nvar x; // giá trị của x là undefined\r\nvar y = undefined; // ta cũng có thể gán một biến là undefined\r\n</code>`<code>\r\n\r\n<em><strong>null</strong></em> - biểu diễn giá trị null. Vì JavaScript là case-sensitive, null sẽ không giống với</code> Null<code>, </code>NULL<code>, hoặc bất kỳ biến thể khác.\r\n\r\n</code>`<code>js\r\nvar z = null;\r\n</code>`<code>\r\n\r\n<em><strong>Symbol</strong></em> - mới được giới thiệu trong ES6. Nó lưu trữ các giá trị duy nhất và ẩn danh.\r\n\r\n</code>`<code>js\r\nvar symbol1 = Symbol('symbol');\r\n</code>`<code>\r\n\r\nSử dụng </code>typeof<code> để tìm kiểu nguyên thuỷ:\r\n\r\n</code>`<code>js\r\ntypeof \"John Doe\" // Returns \"string\"\r\ntypeof 3.14 // Returns \"number\"\r\ntypeof true // Returns \"boolean\"\r\ntypeof 234567890123456789012345678901234567890n // Returns bigint\r\ntypeof undefined // Returns \"undefined\"\r\ntypeof null // Returns \"object\" (đặc trưng của JavaScript)\r\ntypeof Symbol('symbol') // Returns Symbol\r\n</code>`<code>\r\n\r\nTrong JavaScript nếu dữ liệu không phải là kiểu nguyên thuỷ thì tất cả đều là object.\r\n\r\n<strong>Object</strong> dùng để lưu trữ tập hợp dữ liệu\r\n\r\n</code>`<code>js\r\n// Tập hợp dữ liệu dạng key-value \r\n\r\nvar obj1 = {\r\n   x:  43,\r\n   y:  \"Hello world!\",\r\n   z: function(){\r\n      return this.x;\r\n   }\r\n}\r\n      \r\n// Tập hợp dữ liệu dạng danh sách\r\n      \r\nvar array1 = [5, \"Hello\", true, 4.1];  \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Hoisting trong Javascript?",
              "answer": "<p>Hoisting là một hành vi mặc định trong Javascript, nó sẽ chuyển tất cả khai báo biến và hàm lên trên cùng.\r\n\r\n<img src=\"/interview-assets/hoisting-in-js.png\" alt=\"hoisting\" />\r\n\r\nĐiều này có nghĩa là bất kể hàm và biến được khai báo ở đâu, chúng cũng sẽ đuọc chuyển lên đầu scope. Scope có thể là toàn cục hoặc cục bộ.\r\n\r\nVí dụ 1:\r\n\r\n``<code>js\r\nhoistedVariable = 3;\r\nconsole.log(hoistedVariable);\r\n// output là 3 vì biến được khởi tạo trước khi khai báo.\r\nvar hoistedVariable;\r\n</code>`<code>\r\n\r\nVí dụ 2:\r\n\r\n</code>`<code>js\r\nhoistedFunction();  \r\n// Outputs \" Hello world! \" kể cả khi hàm được khai báo sau khi gọi.\r\n\r\nfunction hoistedFunction(){ \r\n  console.log(\" Hello world! \");\r\n}\r\n</code>`<code>\r\n\r\nVí dụ 3:\r\n\r\n</code>`<code>js\r\n// Hoisting takes place in the local scope as well\r\nfunction doSomething(){\r\n  x = 33;\r\n  console.log(x);\r\n  var x;\r\n}\r\n</code>`<code>\r\n\r\n<em>Lưu ý</em>: Khai báo biến được hoisting chứ phép gán biến thì không.\r\n\r\n</code>`<code>js\r\nvar x;\r\nconsole.log(x); // Output sẽ trả về \"undefined\" vì phép gán không được hoisting\r\nx = 23;\r\n</code>`<code>\r\n\r\n<em>Lưu ý</em>: Để tránh hoisting bạn có thể dùng \"use strict\"\r\n\r\n</code>`<code>js\r\n\"use strict\";\r\nx = 23; // Báo lỗi x  chưa được khai báo\r\nvar x; \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa toán tử \"==\" và \"===\" là như thế nào?",
              "answer": "<p>Cả hai đều dùng để so sánh, nhưng \"==\" có thể dùng với bất kỳ kiểu dữ liệu nào còn \"===\" chỉ dành cho cùng kiểu.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nvar x = 2;\r\nvar y = \"2\";\r\n(x == y)  // Trả về true vì cả hai cùng giá trị\r\n\r\n(x === y) // Trả về false vì typeof x là \"number\" còn typeof y là \"string\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về ép kiểu ngầm trong JavaScript?",
              "answer": "<p>Ép kiểu ngầm trong javascript là sự chuyển đổi tự động của giá trị từ kiểu dữ liệu này sang kiểu khác. Nó xảy ra khi thực hiện một biểu thức với các kiểu dữ liệu khác nhau.\r\n\r\n<strong>Ép kiểu String</strong>\r\n\r\nÉp kiểu string xảy ra khi dùng toán tử <code>+</code>. Một số cộng với một chuỗi, kiểu số sẽ bị ép thành kiểu chuỗi.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nvar x = 3;\r\nvar y = \"3\";\r\nx + y // Returns \"33\" \r\n</code>`<code>\r\n\r\n</code>`<code>js\r\nvar x = 24;\r\nvar y = \"Hello\";\r\nx + y   // Returns \"24Hello\";\r\n</code>`<code>\r\n\r\nĐể hiểu về hai ví dụ khi ta cộng một số vào chuỗi, thì khi JavaScript thấy biểu thức </code>x+y<code> với hai kiểu khác nhau (một số và một chuỗi), nó chuyển đổi kiểu số thành chuỗi để thực hiện hành động. Sau khi chuyển đổi, cả hai biến đều là kiểu chuỗi, thao tác </code>+<code> lúc này sẽ thành phép nối chuỗi kết quả là ra chuỗi \"33\" và \"24Hello\".\r\n\r\nNgược lại, khi thực hiện phép toán </code>-<code>, thì chuỗi lại bị ép kiểu ngầm thành số. Ví dụ:\r\n\r\n</code>`<code>js\r\nvar x = 3;\r\nVar y = \"3\";\r\nx - y    //Returns 0 since the variable y (string type) is converted to a number type\r\n</code>`<code>\r\n\r\n<strong>Ép kiểu Boolean</strong>\r\n\r\nÉp kiểu boolean xảy ra khi sử dụng các toán tử logic, lệnh if hay kiểm tra vòng lặp. Để hiểu về ép kiểu logic, ta cần hiểu về giá trị <em>truthy</em> và <em>falsy</em>.\r\n\r\nGiá trị <em>truthy</em> là cái sẽ được ép kiểu thành <strong>true</strong>. Còn <em>falsy</em> sẽ được ép kiểu thành <strong>false</strong>.\r\n\r\nTất cả các giá trị ngoại trừ </code>0<code>, </code>0n<code>, </code>-0<code>, </code>\"\"<code>, </code>null<code>, </code>undefined<code>, và </code>NaN<code> thì đều là truthy.\r\n\r\nCâu lệnh If:\r\n\r\n</code>`<code>js\r\nvar x = 0;\r\nvar y = 23;\r\n        \r\nif(x) { console.log(x) }   // The code inside this block will not run since the value of x is 0(Falsy)  \r\n        \r\nif(y) { console.log(y) }    // The code inside this block will run since the value of y is 23 (Truthy)\r\n</code>`<code>\r\n\r\nToán tử Logic:\r\n\r\nToán tử logic trong javascript không giống các ngôn ngữ lập trình khác, <strong>nó không trả về true hay false, mà nó trả về một toán hạng</strong>.\r\n\r\nOR ( || ) - Nếu giá trị đầu tiên là truthy, giá trị đầu tiên sẽ được trả về, ngược lại thì nó trả về giá trị thứ hai.\r\n\r\nAND ( && ) - Nếu hai giá trị đều là truthy, giá trị thứ hai sẽ được trả về. Nếu giá trị đầu là falsy sẽ trả về giá trị đầu hoặc giá trị hai là falsy sẽ trả về giá trị hai.\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nvar x = 220;\r\nvar y = \"Hello\";\r\nvar z = undefined;\r\n        \r\nx | | y    // Returns 220 since the first value is truthy\r\n        \r\nx | | z   // Returns 220 since the first value is truthy\r\n        \r\nx && y    // Returns \"Hello\" since both the values are truthy\r\n        \r\ny && z   // Returns undefined since the second value is falsy\r\n        \r\nif( x && y ){ \r\n  console.log(\"Code runs\" ); // This block runs because x && y returns \"Hello\" (Truthy)\r\n}   \r\n        \r\nif( x || z ){\r\n  console.log(\"Code runs\");  // This block runs because x || y returns 220(Truthy)\r\n}\r\n</code>`<code>\r\n\r\n<strong>Ép kiểu dấu bằng</strong>\r\n\r\nXảy ra khi thực hiện phép \"==\". Nhớ lại thì phép <strong>\"==\" được dùng để so sánh hai giá trị khác kiểu</strong>.\r\n\r\nThực tế khi sử dụng \"==\" một ép kiểu ngầm đã xảy ra, chuyển đổi tất cả toán hạng về cùng kiểu và so sánh chúng.\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nvar a = 12;\r\nvar b = \"12\";\r\na == b // Returns true because both 'a' and 'b' are converted to the same type and then compared. Hence the operands are equal.\r\n</code>`<code>\r\n\r\nÉp kiểu ngầm không xảy ra khi dùng \"===\". \r\n\r\n</code>`<code>js\r\nvar a = 226;\r\nvar b = \"226\";\r\n\r\na === b // Returns false because coercion does not take place and the  operands are of different types. Hence they are not equal.\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "JavaScript là ngôn ngữ kiểu tĩnh hay kiểu động?",
              "answer": "<p>JavaScript là ngôn ngữ kiểu động. Trong ngôn ngữ kiểu động, kiểu dữ liệu của biến được kiểm tra trong khi đang chạy chương trình ngược lại với kiểu tĩnh, nơi kiểu dữ liệu của biến được kiểm tra khi biên dịch.\r\n\r\n<img src=\"/interview-assets/static_vs_dynamic_typing.png\" alt=\"\" />\r\n\r\nVì Javascript là ngôn ngữ kiểu động, nên một biến có thể giữ bất kỳ kiểu dữ liệu nào. Ví dụ:\r\n\r\n``<code>js\r\nvar a = 23;\r\nvar a = \"Hello World!\";\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính NaN trong JavaScript là gì?",
              "answer": "<p>Thuộc tính NaN biểu diễn một giá trị <strong>Not-a-Number</strong>. Nó biểu thị một giá trị không phải là số.\r\n\r\n<code>typeof</code> của NaN trả về <code>Number</code>. Muốn kiểm tra một giá trị có phải NaN không, có thể dùng hàm <code>isNaN()</code>.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nisNaN(\"Hello\")  // Returns true\r\nisNaN(345)   // Returns false\r\nisNaN('1')  // Returns false, since '1' is converted to Number type which results in 0 ( a number) \r\nisNaN(true) // Returns false, since true converted to Number type results in 1 ( a number)\r\nisNaN(false) // Returns false\r\nisNaN(undefined) // Returns true\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về phép gán quá giá trị và phép gán qua tham chiếu?",
              "answer": "<p>Trong JavaScript, kiểu dữ liệu nguyên thuỷ được gán với giá trị, còn kiểu đối tượng được gán bằng tham chiếu.\r\n\r\nTrước tiên, ta cần hiểu về điều gì xảy ra khi ta tạo một biến và gán giá trị cho nó.\r\n\r\n``<code>js\r\nvar x = 2;\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, ta tạo một biến </code>x<code> và gán nó giá trị là \"2\". Phép \"=\" chỉ định một vài không gian trong bộ nhớ, để lưu trữ giá trị là \"2\" và trả về vị trí được chỉ định trong bộ nhớ. Do đó, biến </code>x<code> ở trên trỏ đến vị trí trong bộ nhớ thay vì trỏ trực tiếp đến giá trị 2.\r\n\r\nPhép gán thực hiện hành vi khác nhau khi làm việc với kiểu nguyên thuỷ và kiểu đối tượng.\r\n\r\n<strong>Phép gán với kiểu nguyên thuỷ</strong>\r\n\r\n<img src=\"/interview-assets/passed_by_value.png\" alt=\"\" />\r\n\r\n</code>`<code>js\r\nvar y = 234;\r\nvar z = y;\r\n</code>`<code>\r\n\r\nỞ ví dụ này, dòng đầu phép gán giá trị cho </code>y<code> là kiểu nguyên thuỷ, sau đó ở dòng thứ hai, giá trị của </code>y<code> được gán cho </code>z<code>. Phép gán chỉ định một vùng không gian mới trong bộ nhớ và trả về địa chỉ của nó. Do đó, biến </code>z<code> không chỉ đến vị trí của biến </code>y<code> thay vào đó nó chỉ đến vùng không gian mới trong bộ nhớ.\r\n\r\n</code>`<code>js\r\nvar y = #8454; // y pointing to address of the value 234\r\n\r\nvar z = y; \r\n        \r\nvar z = #5411; // z pointing to a completely new address of the value 234\r\n        \r\n// Changing the value of y\r\ny = 23;\r\nconsole.log(z);  // Returns 234, since z points to a new address in the memory so changes in y will not effect z\r\n</code>`<code>\r\n\r\nTừ ví dụ trên, ta có thể thấy rằng các kiểu dữ liệu nguyên thủy khi được truyền cho một biến khác sẽ được truyền theo giá trị. Thay vì chỉ gán cùng một địa chỉ cho một biến khác, giá trị sẽ được gán và không gian bộ nhớ mới được tạo ra.\r\n\r\n<strong>Phép gán với kiểu đối tượng</strong>\r\n\r\n<img src=\"/interview-assets/passed_by_reference.png\" alt=\"\" />\r\n\r\n</code>`<code>js\r\nvar obj = { name: \"Vivek\", surname: \"Bisht\" };\r\n\r\nvar obj2 = obj;\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, phép gán truyền trực tiếp vị trí của biến </code>obj<code> đến biến </code>obj2<code>. Nói cách khác, tham chiếu của biến </code>obj<code> được chuyển cho biến </code>obj2<code>.\r\n\r\n</code>`<code>js\r\nvar obj = #8711;  // obj pointing to address of { name: \"Vivek\", surname: \"Bisht\" }\r\n\r\nvar obj2 = obj;\r\n        \r\nvar obj2 = #8711; // obj2 pointing to the same address \r\n        \r\n        \r\n// changing the value of obj1\r\n        \r\nobj1.name = \"Akki\";\r\n        \r\nconsole.log(obj2);\r\n        \r\n// Returns {name:\"Akki\", surname:\"Bisht\"} since both the variables are pointing to the same address.\r\n</code>``\r\n\r\nTừ ví dụ trên, ta có thể thấy rằng trong khi truyền các kiểu dữ liệu đối tượng, phép gán trực tiếp truyền địa chỉ (tham chiếu).\r\n\r\nDo đó, các kiểu dữ liệu đối tượng luôn được truyền bằng tham chiếu.</p>",
              "level": "fresher"
            },
            {
              "question": "IIFE là gì trong JavaScript?",
              "answer": "<p>Immediately Invoked Function (IIFE) là một hàm được chạy ngay sau khi nó được định nghĩa.\r\n\r\nCú pháp của IIFE:\r\n\r\n``<code>js\r\n(function(){ \r\n  // Do something;\r\n})();\r\n</code>`<code>\r\n\r\nĐể hiểu về IIFE, trước hết cần hiểu về hai dấu ngoặc đơn được thêm vào để tạo IIFE.\r\n\r\nDấu ngoặc đơn đầu tiên:\r\n\r\n</code>`<code>js\r\n(function (){\r\n   //Do something;\r\n})\r\n</code>`<code>\r\n\r\nKhi thực thi code javascript, bất cứ khi nào trình biên dịch bắt gặp từ \"function\" nó cũng sẽ cho rằng ta đang khai báo một function. Do đó, nếu ta không dùng dấu ngoặc đơn, trình biên dịch sẽ báo lỗi vì nó nghĩa ta đang khái báo một function và theo cú pháp thì các function buộc phải có tên.\r\n\r\nĐể tránh lỗi ta thêm dấu ngoặc đơn vào để trình biên dịch biết đây không phải là khai báo function mà là một biểu thức function.\r\n\r\nDấu ngoặc đơn thứ hai:\r\n\r\n</code>`<code>js\r\n(function (){\r\n  //Do something;\r\n})();\r\n</code>``\r\n\r\nTừ định nghĩa IIFE, ta biết rằng code sẽ chạy ngay sai khi khai báo. Một function chỉ chạy khi nó được gọi. Nếu ta không gọi, thì chúng ta chỉ nhận về được khai báo hàm.\r\n\r\nDo đó để gọi function ta sử dụng dấu ngoặc đơn thứ hai.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về HOC(Higher Order Functions) trong JavaScript?",
              "answer": "<p>Các hàm hoạt động trên các hàm khác bằng cách sử dụng chúng làm tham số hoặc kết quả trả về thì được gọi là Higher Order Functions - HOC. Ví dụ:\r\n\r\n``<code>js\r\nfunction higherOrder(fn) {\r\n  fn();\r\n}\r\n     \r\nhigherOrder(function() { console.log(\"Hello world\") }); \r\n</code>`<code>\r\n\r\n</code>`<code>js\r\nfunction higherOrder2() {\r\n  return function() {\r\n    return \"Do something\";\r\n  }\r\n}\r\n        \r\nvar x = higherOrder2();\r\nx()   // Returns \"Do something\"\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về \"this\"?",
              "answer": "<p>Từ khoá \"this\" trong javascript tham chiếu đến một đối tượng có thuộc tính là một hàm.\r\n\r\nGiá trị của \"this\" phụ thuộc vào đối tượng đang gọi hàm.\r\n\r\nGiả sử ta có code sau:\r\n\r\n``<code>js\r\nfunction doSomething() {\r\n  console.log(this);\r\n}\r\n        \r\ndoSomething();\r\n</code>`<code>\r\n\r\nNhư vậy theo định nghĩa, this tham chiếu đến một đối tượng có hàm là thuộc tính. Vậy trong đoạn code trên hàm là thuộc tính của đối tượng nào?\r\n\r\nVì hàm được gọi từ ngữ cảnh tổng thể, nên <strong>hàm sẽ là thuộc tính của đối tượng toàn cục</strong>. Do đó, nếu ta chạy đoạn code trên trình duyệt kết quả sẽ là <strong>window object</strong>.\r\n\r\nVí dụ 2:\r\n\r\n</code>`<code>js\r\nvar obj = {\r\n    name:  \"vivek\",\r\n    getName: function(){\r\n    console.log(this.name);\r\n  }\r\n}\r\n        \r\nobj.getName();\r\n</code>`<code>\r\n\r\nTrong đoạn code này, hàm </code>getName<code> là thuộc tính của </code>obj<code>. Do đó, <strong>this</strong> sẽ tham chiếu đến đối tượng </code>obj<code>, và output sẽ là \"vivek\".\r\n\r\nVí dụ 3:\r\n\r\n</code>`<code>js\r\nvar obj = {\r\n    name:  \"vivek\",\r\n    getName: function(){\r\n    console.log(this.name);\r\n  }\r\n        \r\n}\r\n        \r\nvar getName = obj.getName;\r\n        \r\nvar obj2 = {name:\"akshay\", getName };\r\nobj2.getName();\r\n</code>`<code>\r\n\r\nOutput sẽ là \"akshay\". Mặc dù hàm </code>getName<code> được khai báo trong đối tượng </code>obj<code>, nhưng ở thời điểm gọi thì </code>getName()<code> lại là thuộc tính của </code>obj2<code>, do đó \"this\" sẽ tham chiếu đến </code>obj2<code>. \r\n\r\nCách ngớ ngẩn để hiểu \"this\" là, bất cứ khi nào hàm được gọi, hãy kiểm tra đối tượng trước dấu chấm. Giá trị của this sẽ luôn là đối tượng trước dấu chấm.\r\n\r\nNếu không có đối tượng nào như ở ví dụ 1, giá trị sẽ là đối tượng toàn cục.\r\n\r\nVí dụ 4:\r\n\r\n</code>`<code>js\r\nvar obj1 = {\r\n    address : \"Mumbai,India\",\r\n    getAddress: function(){\r\n    console.log(this.address); \r\n  }\r\n}\r\n       \r\nvar getAddress = obj1.getAddress;\r\nvar obj2 = {name:\"akshay\"};\r\nobj2.getAddress();   \r\n</code>`<code>\r\n\r\nKết quả sẽ là lỗi, vì từ khóa this tham chiếu đến đối tượng </code>obj2<code>, nhưng </code>obj2<code> không có thuộc tính “address” ‘, do đó hàm </code>getAddress` sẽ xảy ra lỗi.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về phương thức call(), aplly() và bind()?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Currying trong JavaScript là gì?",
              "answer": "<p>Currying là một kỹ thuật nâng cao để biến đổi một hàm với n tham số, thành n hàm với một tham số duy nhất.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nfunction add (a) {\r\n  return function(b){\r\n    return a + b;\r\n  }\r\n}\r\n\r\nadd(3)(4)\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, ta có hàm </code>f(a,b)<code> sau khi currying ta đã biến đổi nó thành </code>f(a)(b)<code>.\r\n\r\nBằng cách sử dụng kỹ thuật currying, chúng ta không thay đổi chức năng của một hàm, mà chỉ thay đổi cách nó được gọi.\r\n\r\n</code>`<code>js\r\nfunction multiply(a,b){\r\n  return a*b;\r\n}\r\n\r\nfunction currying(fn){\r\n  return function(a){\r\n    return function(b){\r\n      return fn(a,b);\r\n    }\r\n  }\r\n}\r\n\r\nvar curriedMultiply = currying(multiply);\r\n\r\nmultiply(4, 3); // Returns 12\r\n\r\ncurriedMultiply(4)(3); // Also returns 12\r\n</code>`<code>\r\n\r\nNhư ta có thể thấy trong đoạn code trên, chúng ta đã chuyển đổi hàm </code>multiply(a, b)<code> thành một hàm </code>curriedMultiply`, nhận một tham số tại một thời điểm.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Scope và Scope Chain?",
              "answer": "<p>Scope trong JS, xác định khả năng truy cập của các biến, hàm ở các phần khác nhau trong một đoạn code.\r\n\r\nNói chung, Scope cho biết phạm vi mà biến và hàm của ta có thể hay không thể truy cập. Có 3 loại scope trong JS:\r<ul><li>Global Scope</li></ul>\r<ul><li>Local hay Function Scope</li></ul>\r<ul><li>Block Scope</li></ul>\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Closures trong JavaScript?",
              "answer": "<p>Closures là khả năng của một hàm ghi nhớ các biến và hàm được khai báo bên ngoài phạm vi của nó.\r\n\r\n``<code>js\r\nvar Person = function(pName){\r\n  var name = pName;\r\n\r\n  this.getName = function(){\r\n    return name;\r\n  }\r\n}\r\n\r\nvar person = new Person(\"Neelesh\");\r\nconsole.log(person.getName());\r\n</code>`<code>\r\n\r\nHiểu closure qua ví dụ sau:\r\n\r\n</code>`<code>js\r\nfunction randomFunc(){\r\n  var obj1 = {name:\"Vivian\", age:45};\r\n\r\n  return function(){\r\n    console.log(obj1.name + \" is \"+ \"awesome\"); // Has access to obj1 even when the randomFunc function is executed\r\n\r\n  }\r\n}\r\n\r\nvar initialiseClosure = randomFunc(); // Returns a function\r\n\r\ninitialiseClosure(); \r\n</code>`<code>\r\n\r\nTrong đoạn code trên:\r\n\r\nHàm </code>randomFunc()<code> được thực thi và trả về một hàm khi ta thực hiện phép gán:\r\n\r\n</code>`<code>js\r\nvar initialiseClosure = randomFunc();\r\n</code>`<code>\r\n\r\nHàm được trả về được thực thi khi ta gọi </code>initialiseClosure<code>:\r\n\r\n</code>`<code>js\r\ninitialiseClosure();\r\n</code>`<code>\r\n\r\nKết quả sẽ là \"Vivian is awesome\" điều này xảy ra là do closure.\r\n\r\nKhi hàm </code>randomFunc()<code> chạy, nó sẽ thấy rằng hàm trả về đang sử dụng biến </code>obj1<code> bên trong nó: \r\n\r\n</code>`<code>js\r\nconsole.log(obj1.name + \" is \"+ \"awesome\");\r\n</code>`<code>\r\n\r\nDo đó, </code>randomFunc()<code>, thay vì hủy giá trị của </code>obj1` sau khi thực thi, sẽ lưu giá trị lại vào trong bộ nhớ để tham khảo thêm. Đây là lý do tại sao hàm trả về có thể sử dụng biến được khai báo bên ngoài phạm vi ngay cả sau khi hàm đã được thực thi.\r\n\r\n<strong>Khả năng này của một hàm nhằm lưu trữ một biến để tham khảo thêm ngay cả sau khi nó được thực thi, được gọi là Closure.</strong></p>",
              "level": "fresher"
            },
            {
              "question": "Prototype là gì?",
              "answer": "<p>Tất cả các đối tượng javascript đều kế thừa các thuộc tính từ một <strong>prototype</strong>.\r\n\r\nVí dụ:\r\n\r\nĐối tượng Date kế thừa các thuộc tính từ prototype Date.\r\n\r\nĐối tượng Math kế thừa các thuộc tính từ prototype Math.\r\n\r\nĐối tượng Array kế thừa các thuộc tính từ prototype Array.\r\n\r\nTrên đầu chuỗi là <code>Object.prototype</code>. Mọi prototype đều kế thừa các thuộc tính và phương thức từ <code>Object.prototype</code>.\r\n\r\nPrototype là một bản thiết kế của một đối tượng. Prototype cho phép chúng ta sử dụng các thuộc tính và phương thức trên một đối tượng ngay cả khi các thuộc tính và phương thức không tồn tại trên đối tượng hiện tại.\r\n\r\n<img src=\"/interview-assets/object_prototype.png\" alt=\"\" />\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nvar arr = [];\r\narr.push(2);\r\n\r\nconsole.log(arr); // Outputs [2]\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, có thể thấy ta chưa xác định bất kỳ thuộc tính hoặc phương thức nào được gọi là push trên mảng </code>arr<code> nhưng javascript engine không đưa ra lỗi.\r\n\r\nLý do là việc sử dụng các prototype. Như đã thảo luận trước đây, các đối tượng Array kế thừa các thuộc tính từ prototype Array.\r\n\r\nJavascript engine thấy rằng phương thức </code>push` không tồn tại trên đối tượng mảng hiện tại, do đó nó tìm kiếm phương thức push bên trong prototype Array và nó tìm thấy phương thức.\r\n\r\nBất cứ khi nào thuộc tính hoặc phương thức không được tìm thấy trên đối tượng hiện tại, javascript engine sẽ luôn tìm kiếm trong prototype của nó và nếu nó vẫn không tồn tại, nó sẽ tìm bên trong prototype của prototype, v.v.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "react",
          "name": "Câu hỏi phỏng vấn React",
          "description": "",
          "questions": [
            {
              "question": "React là gì?",
              "answer": "<p>React là một thư viện JavaScript mã nguồn mở và giao diện người dùng, rất hữu ích trong việc phát triển giao diện người dùng dành riêng cho các ứng dụng SPA. Nó hữu ích trong việc xây dựng các thành phần giao diện người dùng (UI) phức tạp và có thể tái sử dụng của các ứng dụng web và di động vì nó tuân theo mô hình dựa trên component.\r\n\r\nTính năng của React:\r<ul><li>Tăng hiệu suất của ứng dụng với Virtual DOM.</li></ul>\r<ul><li>JSX làm cho code dễ đọc và viết.</li></ul>\r<ul><li>Nó kết xuất cả phía máy khách và máy chủ.</li></ul>\r<ul><li>Dễ dàng tích hợp với các frameworks khác (Angular, BackboneJS) vì nó chỉ là một thư viện giao diện.</li></ul>\r<ul><li>Dễ dàng viết các trường hợp kiểm thử UI và tích hợp với các công cụ như JEST.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Lợi ích khi dùng React?",
              "answer": "<p><ul><li>ReactJS giúp cho việc viết các đoạn code Javascript sẽ trở nên dễ dàng hơn vì nó sử dụng một cú pháp đặc biệt đó chính là cú pháp JSX. Thông qua JSX cho phép nhúng code HTML và Javascript.</li></ul>\r<ul><li>ReactJS cho phép nhà phát triển phá vỡ những cấu trúc UI phức tạp thành những component độc lập. Các nhà phát triển sẽ không phải lo lắng về tổng thể ứng dụng web, giờ đây có thể dễ dàng chia nhỏ các cấu trúc UI/UX phức tạp thành từng component đơn giản hơn. </li></ul>\r<ul><li>Đi kèm với ReactJS là rất nhiều các công cụ phát triển giúp cho việc debug code một cách dễ dàng hơn.</li></ul>\r<ul><li>Một trong những ưu điểm nữa của ReactJS đó là sự thân thiện với SEO. Hầu như các JS Frameworks không thân thiện với các tìm kiếm mặc dù đã được cải thiện nhiều nhưng dưới sự hỗ trợ của các render dữ liệu trả về dưới dạng web page giúp cho SEO chuẩn hơn.</li></ul>\r<ul><li>React cùng với React Native, Redux, Electro cùng với nhiều công cụ hữu ích khác giúp nhà phát triển xây dựng được đa dạng loại ứng dụng phù hợp với nhiều yêu cầu.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hạn chế của React?",
              "answer": "<p><ul><li>React không phải một framework hoàn chỉnh mà chỉ là thư viện.</li></ul>\r<ul><li>Component trong React sẽ rất nhiều và mất nhiều thời gian để hiểu với các trang web phức tạp.</li></ul>\r<ul><li>Code sẽ trở nên phức tạp khi dùng template với JSX.</li></ul>\r<ul><li>Khá khó cho người mới bắt đầu.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "useState() trong React là gì?",
              "answer": "<p>useState() là một hooks có sẵn trong React, cho phép bạn quản lý biến state của các function component. Nó được dùng khi DOM có thứ gì đó cần được điều khiển/quản lý.\r\n\r\nTrong code bên dưới, <code>useState(0)</code> sẽ trả về một mảng trong đó tham số đầu tiên là state hiện tại của <code>counter</code> và tham số thứ hai là phương thức <code>setCounter</code> cho phép cập nhật state của counter.\r\n\r\n``<code>jsx\r\n...\r\nconst [count, setCounter] = useState(0);\r\nconst [otherStuffs, setOtherStuffs] = useState(...);\r\n...\r\nconst setCount = () => {\r\n   setCounter(count + 1);\r\n   setOtherStuffs(...);\r\n   ...\r\n};\r\n</code>`<code>\r\n\r\nTa có thể sử dụng phương thức </code>setCounter()<code> cho cập nhật state của count ở bất cứ đâu. Trong ví dụ này, ta sử dụng </code>setCounter()<code> trong hàm </code>setCount` . Đây là một ý tưởng tuyệt với để quản lý state trong các function component, tránh sử dụng class component khi không cần thiết.</p>",
              "level": "fresher"
            },
            {
              "question": "Keys trong React?",
              "answer": "<p>Key là một thuộc tính chuỗi đặc biệt dùng khi sử dụng danh sách phần tử.\r\n\r\n<img src=\"/interview-assets/What_are_keys_in_React.png\" alt=\"\" />\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nconst ids = [1,2,3,4,5];\r\nconst listElements = ids.map((id)=>{\r\n    return(\r\n        <li key={id.toString()}>\r\n            {id}\r\n        </li>\r\n    )\r\n})\r\n</code>``\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "JSX là gì?",
              "answer": "<p>JSX là viết tắt của JavaScript XML. Nó cho phép ta viết HTML trong JavaScript và đặt nó vào DOM mà không cần dùng <code>appendChild()</code> hay <code>createElement()</code>.\r\n\r\nTheo trang chủ của React, JSX cung cấp cú pháp tuyệt vời hơn cho <code>React.createElement()</code>. Ví dụ\r<ul><li>Không dùng JSX:</li></ul>\r\n\r\n``<code>js\r\nconst text = React.createElement('p', {}, 'This is a text');\r\nconst container = React.createElement('div','{}',text );\r\nReactDOM.render(container,rootElement);\r\n</code>`<code>\r<ul><li>Dùng JSX:</li></ul>\r\n\r\n</code>`<code>jsx\r\nconst container = (\r\n<div>\r\n    <p>This is a text</p>\r\n</div>\r\n);\r\nReactDOM.render(container,rootElement);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa class component và function component?",
              "answer": "<p>Trước khi giới thiệu hooks ở phiên bản 16, các function component được gọi là stateless component và ít khi được dùng trong React. Sau khi hook ra đời, các function component giờ đã ngang hàng với class component.\r\n\r\nDù function component đang là trend hiện tại, nhưng class component vẫn còn rất quan trọng. Dưới đây là một vài so sánh cơ bản:\r<ul><li><strong>Khai báo</strong></li></ul>\r\n\r\nFunction component giống như một hàm thông thường trong JS, ta có thể tạo kiểu arrow function hoặc function:\r\n\r\n``<code>jsx\r\nfunction card(props){\r\n    return(\r\n        <div className=\"main-container\">\r\n            <h2>Title of the card</h2>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst card = (props) => {\r\n    return(\r\n        <div className=\"main-container\">\r\n            <h2>Title of the card</h2>\r\n        </div>\r\n    )\r\n}\r\n</code>`<code>\r\n\r\nClass component sử dụng cú pháp tạo lớp của ES6\r\n\r\n</code>`<code>jsx\r\nclass Card extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n    }\r\n    render(){\r\n        return(\r\n            <div className=\"main-container\">\r\n                <h2>Title of the card</h2>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Xử lý props</strong></li></ul>\r\n\r\nTa thử render component dưới đây theo cả hai cách:\r\n\r\n</code>`<code>jsx\r\n<Student Info name=\"Vivek\" rollNumber=\"23\" />\r\n</code>`<code>\r\n\r\nTrong function component, xử lý props rất thẳng thắn. Bất ký props nào cũng được xem như tham số của function component có thể xử lý trực tiếp:\r\n\r\n</code>`<code>jsx\r\nfunction StudentInfo(props){\r\n    return(\r\n        <div className=\"main\">\r\n            <h2>{props.name}</h2>\r\n            <h4>{props.rollNumber}</h4>\r\n        </div>\r\n    )\r\n}\r\n</code>`<code>\r\n\r\nVới class component, props được xử lý bằng </code>this<code>:\r\n\r\n</code>`<code>jsx\r\nclass StudentInfo extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n    }\r\n    \r\n    render(){\r\n        return(\r\n            <div className=\"main\">\r\n                <h2>{this.props.name}</h2>\r\n                <h4>{this.props.rollNumber}</h4> \r\n            </div>\r\n        )\r\n    }\r\n}\r\n</code>`<code>\r<ul><li><strong>Xử lý state</strong></li></ul>\r\n\r\nFunction component sử dụng hook để quản lý state. Hook hữu ích nhất là </code>useState<code> cho thiết lập state trong component.\r\n\r\n</code>`<code>jsx\r\nfunction ClassRoom(props){\r\n    let [studentsCount,setStudentsCount] = useState(0);\r\n    \r\n    const addStudent = () => {\r\n        setStudentsCount(++studentsCount);\r\n    }\r\n        \r\n    return(\r\n        <div>\r\n            <p>Number of students in class room: {studentsCount}</p>\r\n            <button onClick={addStudent}>Add Student</button>\r\n        </div>\r\n    )\r\n}\r\n</code>`<code>\r\n\r\nTa không thể sử dụng hook bên trong class component, thế nên ta vẫn phải xử lý state bằng </code>this<code> trong class component.\r\n\r\n</code>`<code>jsx\r\nclass ClassRoom extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n\r\n        this.state = {studentsCount : 0};\r\n        this.addStudent = this.addStudent.bind(this);\r\n    }\r\n    \r\n    addStudent(){\r\n        this.setState((prevState)=>{\r\n            return {studentsCount: prevState.studentsCount++}\r\n        });\r\n    }\r\n    \r\n    render(){\r\n        return(\r\n            <div>\r\n                <p>Number of students in class room: {this.state.studentsCount}</p>\r\n                <button onClick={this.addStudent}>Add Student</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Virtual DOM là gì?",
              "answer": "<p>Virtual DOM là một khái niệm trong đó biểu diễn ảo của DOM thực được lưu giữ bên trong bộ nhớ và được đồng bộ hóa với DOM thực bởi một thư viện như ReactDOM.\r\n\r\n<img src=\"/interview-assets/virtual_DOM.png\" alt=\"\" />\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa controlled component và uncontrolled component?",
              "answer": "<p>| Tính năng | Uncontrolled | Controlled \r\n|-|-|-|\r\n| Truy xuất giá trị một lần (như khi submit) | Yes | Yes |\r\n| Xác thực submit | Yes | Yes |\r\n| Xác thực trường | No | Yes |\r\n| Điều kiện cho kích hoạt nút submit | No | Yes |\r\n| Định dạng đầu vào | No | Yes |\r\n| Cung cấp nhiều input cho một mẫu dữ liệu | No | Yes |\r\n| Input động | No | Yes |\r\n\r\n<strong>Controlled component</strong>\r\n\r\nTrong controlled component, giá trị của phần tử input được điều khiển bởi React. Ta lưu trữ trạng thái của phần tử input trong code, và sử dụng callback, với bất kỳ thay đổi nào đến input sẽ được phản ánh tương tự trong code.\r\n\r\nKhi người dùng nhập dữ liệu vào phần tử input trong controlled component, hàm <code>onChange</code> kích hoạt và trong code, ta kiểm tra giá trị nhập vào là hợp lệ hay không. Nếu hợp lệ, ta thay đổi trạng thái và re-render phần tử input với giá trị mới.\r\n\r\n``<code>jsx\r\nfunction FormValidation(props) {\r\n    let [inputValue, setInputValue] = useState(\"\");\r\n    let updateInput = e => {\r\n        setInputValue(e.target.value);\r\n    };\r\n    return (\r\n        <div>\r\n            <form>\r\n            <input type=\"text\" value={inputValue} onChange={updateInput} />\r\n            </form>\r\n        </div>\r\n    );\r\n}\r\n</code>`<code>\r\n\r\nNhư đoạn code trên, giá trị của phần tử input được xác định bởi biến </code>inputValue<code>. Bất kỳ thay đổi nào đến phần tử input sẽ được xử lý bởi hàm </code>updateInput<code>.\r\n\r\n<strong>Uncontrolled component</strong>\r\n\r\nTrong uncontrolled component, giá trị của phần tử input được xử lý bởi chính DOM. Các phần tử input này hoạt động giống như phần tử input HTML.\r\n\r\nTrạng thái của phần tử input được xử lý bởi DOM. Nên khi giá trị input thay đổi, callback sẽ không được gọi. Hoặc có thể nói là React không thực hiện bất cứ hàng động nào khi xảy ra thay đổi.\r\n\r\nKhi người dùng nhập dữ liệu vào trường input, dữ liệu cập nhật được hiển thị trực tiếp. Để truy cập giá trị phần tử input, ta có thể dùng <strong>ref</strong>.\r\n\r\n</code>`<code>jsx\r\nfunction FormValidation(props) {\r\n    let inputValue = React.createRef();\r\n    let handleSubmit = e => {\r\n        alert(</code>Input value: ${inputValue.current.value}<code>);\r\n        e.preventDefault();\r\n    };\r\n    return (\r\n        <div>\r\n            <form onSubmit={handleSubmit}>\r\n            <input type=\"text\" ref={inputValue} />\r\n            <button type=\"submit\">Submit</button>\r\n            </form>\r\n        </div>\r\n    );\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Props trong React là gì?",
              "answer": "<p>Props trong React là dữ liệu được truyền cho các component. Nó có thể là giá trị đơn hoặc đối tượng có tập giá trị được truyền cho component trong suốt quá trình bằng cách thực hiện truyền tham số (tương tự với cú pháp thuộc tính trong HTML). Ta có thể nói props là dữ liệu kế thừa được truyền từ component cha sang component con.\r\n\r\nCác chức năng của props:\r<ul><li>Truyền dữ liệu tuỳ chỉnh đến component.</li></ul>\r<ul><li>Kích hoạt thay đổi trạng thái</li></ul>\r<ul><li>Sử dụng cho render dữ liệu.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích state và props?",
              "answer": "<p>| Props | State |\r\n|-|-|\r\n| Bất biến | Có thể thay đổi |\r\n| Hiệu suất tốt hơn | Phạm vi cục bộ |\r\n| Truyền được cho component khác | Truyền được giống như props |\r\n| | Có phương thức setState để đổi giá trị |\r\n| | Đổi trạng bất đồng bộ |\r\n\r\n<strong>React State</strong>\r\n\r\nTất cả component đều có sẵn đối tượng state, bao gồm tất cả giá trị thuộc tính cùng với component đó. Nói cách khác, đối tượng state điều khiển hành vi của component. Bất kỳ thay đổi giá trị thuộc tính nào của đối tượng state sẽ dẫn đến re-render component.\r\n\r\n<em>Khai báo đối tượng state</em>\r\n\r\n``<code>jsx\r\nclass Car extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            brand: \"BMW\",\r\n            color: \"black\"\r\n        }\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<em>Dùng và cập nhật đối tượng state</em>\r\n\r\n</code>`<code>jsx\r\nclass Car extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            brand: \"BMW\",\r\n            color: \"Black\"\r\n        };\r\n    }\r\n    changeColor() {\r\n        this.setState(prevState => {\r\n            return { color: \"Red\" };\r\n        });\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <button onClick={() => this.changeColor()}>Change Color</button>\r\n                <p>{this.state.color}</p>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>React Props</strong>\r\n\r\nTất cả component đều nhận vào một đối thượng tham số gọi là props (viết tắt của properties). Props có thể được truyền đi component khác và các component này nhận props như một đối số.\r\n\r\n<em>Truyền props cho component</em>\r\n\r\n</code>`<code>jsx\r\n<Car brand=\"Mercedes\"/>\r\n</code>`<code>\r\n\r\n<em>Nhận props từ component khác</em>\r\n\r\nTrong class:\r\n\r\n</code>`<code>jsx\r\nclass Car extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            brand: this.props.brand,\r\n            color: \"Black\"\r\n        };\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong function:\r\n\r\n</code>`<code>jsx\r\nfunction Car(props) {\r\n    let [brand, setBrand] = useState(props.brand);\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu side effect trong React component?",
              "answer": "<p>Có hai kiểu side effect trong React.\r<ul><li><strong>Effect không có cleanup:</strong> Side effect này sẽ được sử dụng trong <code>useEffect</code> không hạn chế trình duyệt cập nhật màn hình. Nó cũng cải thiện khả năng phản hồi của một ứng dụng. Một vài ví dụ phổ biến là yêu cầu mạng, logging, chỉnh sửa DOM thủ công, v.v.</li></ul>\r<ul><li><strong>Effect có cleanup:</strong> Một số Hook effect sẽ yêu cầu cleanup sau khi cập nhật xong DOM. Ví dụ: nếu bạn muốn thiết lập đăng ký nguồn dữ liệu bên ngoài, nó yêu cầu dọn dẹp bộ nhớ, nếu không có thể xảy ra sự cố rò rỉ bộ nhớ. Có một thực tế là React sẽ thực hiện dọn dẹp bộ nhớ khi các component unmounting. Nhưng các effect sẽ chạy mỗi phương thức <code>render()</code> hơn là cho bất kỳ phương thức cụ thể nào. Do đó, chúng ta có thể nói rằng, trước khi thực thi các hiệu ứng thời gian, React cũng sẽ dọn dẹp các hiệu ứng từ lần hiển thị trước đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Prop drilling trong React?",
              "answer": "<p>Đôi khi trong việc phát triển các ứng dụng React, cần phải truyền dữ liệu từ một thành phần cao hơn trong hệ thống phân cấp đến một thành phần được lồng sâu vào nhau. Để truyền dữ liệu giữa các thành phần như vậy, ta chuyển các props từ một thành phần nguồn và tiếp tục truyền phần hỗ trợ cho thành phần tiếp theo trong hệ thống phân cấp cho đến khi chúng ta tiếp cận thành phần được lồng sâu.\r\n\r\nHạn chế của sử dụng prop drilling là việc truy cập dữ liệu sẽ vô cùng phức tạp trong các ứng dụng lớn.</p>",
              "level": "fresher"
            },
            {
              "question": "Error boundary là gì?",
              "answer": "<p>Được giới thiệu ở React v16, error boundary cung cấp một cách để xử lý lỗi xảy ra trong giai đoạn render.\r\n\r\nBất kỳ component nào sử dụng các phương thức lifecycle cũng được xem là một error boundary. Các vị trí mà error boundary có thể được phát hiện:\r\n\r\n1. Giai đoạn Render\r\n2. Trong một phương thức lifecycle\r\n3. Trong constructor\r\n\r\n<strong>Không dùng error boundary</strong>\r\n\r\n``<code>jsx\r\nclass CounterComponent extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            counterValue: 0\r\n        }\r\n        this.incrementCounter = this.incrementCounter.bind(this);\r\n    }\r\n\r\n    incrementCounter(){\r\n        this.setState(prevState => counterValue = prevState+1);\r\n    }\r\n    render(){\r\n        if(this.state.counter === 2){\r\n            throw new Error('Crashed');\r\n        }\r\n        return(\r\n            <div>\r\n                <button onClick={this.incrementCounter}>Increment Value</button>\r\n                <p>Value of counter: {this.state.counterValue}</p>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, khi </code>counterValue<code> bằng 2, ta có lỗi bên trong phương thức render.\r\n\r\nKhi không dùng error boundary, ta sẽ thấy một trang trống thay vì lỗi. Bất cứ lỗi nào trong phương thức render đều dẫn đến unmounting component. Để hiển thị lỗi khi đó, ta sử dụng error boundary.\r\n\r\n<strong>Sử dụng error boundary</strong>: error bounary là một component sử dụng một hoặc cả hai phương thức sau:\r<ul><li></code>getDerivedStateFromError<code></li></ul>\r<ul><li></code>componentDidCatch<code></li></ul>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>jsx\r\nclass ErrorBoundary extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { hasError: false };\r\n    }\r\n    static getDerivedStateFromError(error) {     \r\n        return { hasError: true }; \r\n    }\r\n    componentDidCatch(error, errorInfo) {       \r\n        logErrorToMyService(error, errorInfo); \r\n    }\r\n    render() {\r\n        if (this.state.hasError) {     \r\n            return <h4>Something went wrong</h4>     \r\n        }\r\n        return this.props.children;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, hàm </code>getDerivedStateFromError<code> render một fallback UI interface khi phương thực render có lỗi.\r\n\r\n</code>componentDidCatch<code> ghi lại thông tin lỗi vào một dịch vụ theo dõi lỗi.\r\n\r\nBây giờ với error boundary ta có thể render CounterComponent như sau:\r\n\r\n</code>`<code>jsx\r\n<ErrorBoundary>\r\n    <CounterComponent />\r\n</ErrorBoundary>\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "React Hooks là gì?",
              "answer": "<p>React Hooks là các hàm có sẵn cho phép các nhà phát triển sử dụng các phương thức trạng thái (state) và vòng đời (lifecycle) trong các component React. Đây là những tính năng mới được bổ sung có sẵn trong phiên bản React 16.8. Mỗi lifecycle của một component có 3 giai đoạn bao gồm mount, unmount và update. Cùng với đó, các component có state và props. Hooks sẽ cho phép các nhà phát triển sử dụng các phương pháp này để cải thiện việc tái sử dụng code với tính linh hoạt cao hơn trong việc điều hướng cây component.\r\n\r\nSử dụng Hook, tất cả các tính năng của React có thể được sử dụng mà không cần viết các class component. Ví dụ, trước phiên bản React 16.8, nó yêu cầu một class component để quản lý trạng thái của một component. Nhưng bây giờ bằng cách sử dụng hook useState, chúng ta có thể giữ trạng thái trong một function component.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "typescript",
          "name": "Câu hỏi phỏng vấn TypeScript",
          "description": "",
          "questions": [
            {
              "question": "Các kiểu nguyên thuỷ trong TypeScript?",
              "answer": "<p>Trong TypeScript có loại kiểu dữ liệu là kiểu có sẵn (built-in) và kiểu người dùng định nghĩa (user-defined).\r\n\r\n<em> Built-in:\r<ul><li>string</li></ul>\r<ul><li>number</li></ul>\r<ul><li>boolean</li></ul>\r<ul><li>void</li></ul>\r<ul><li>symbol</li></ul>\r<ul><li>null & undefined</li></ul>\r\n</em> User-defined:\r<ul><li>arrays</li></ul>\r<ul><li>enums</li></ul>\r<ul><li>classes</li></ul>\r<ul><li>interfaces</li></ul>\r\n\r\n<img src=\"/interview-assets/Typescript_Types.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cách mảng làm việc trong TypeScript?",
              "answer": "<p>Ta sử dụng mảng cho lưu trữ các giá trị cùng kiểu. Mảng là tập hợp giá trị có thứ tự và được đánh chỉ mục. Phần tử đầu tiên có chỉ mục là 0, kế tiếp là 1, ....\r\n\r\nCú pháp khai báo và khởi tạo mảng trong TypeScript:\r\n\r\n``<code>ts\r\nlet values: number[] = [];\r\nvalues[0] = 10;\r\nvalues[1] = 20;\r\nvalues[2] = 30;\r\n</code>`<code>\r\n\r\nTa có thể tạo mảng với cú pháp đơn giản hơn:\r\n\r\n</code>`<code>ts\r\nlet values: number[] = [15, 20, 25, 30];\r\n</code>`<code>\r\n\r\nHoặc là dùng từ khoá Array:\r\n\r\n</code>`<code>ts\r\nlet values: Array<number> = [15, 20, 25, 30];\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu any là gì?",
              "answer": "<p>Khi bạn muốn lưu một biến mà không biết trước kiểu của biến đó. Ví dụ, giá trị từ lệnh gọi API hoặc đầu vào người dùng. Kiểu <code>any</code> cho phép gán bất kỳ giá trị nào cho biến.\r\n\r\n``<code>ts\r\nlet person: any = \"Foo\";\r\n</code>`<code>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>ts\r\n// json may come from a third-party API\r\nconst employeeData: string = </code>{\"name\": \"John Doe\", \"salary\": 60000}<code>;\r\n\r\n// parse JSON to build employee object\r\nconst employee: any = JSON.parse(employeeData);\r\n\r\nconsole.log(employee.name);\r\nconsole.log(employee.salary);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu void là gì?",
              "answer": "<p>Void cho biết sự vắng mặt của kiểu với biến. Nó hoạt động như đối lập với bất kỳ kiểu nào. Nó hữu ích cho các hàm không trả về giá trị.\r\n\r\n``<code>ts\r\nfunction notify(): void {\r\n    alert(\"The user has been notified.\");\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu unknown là gì?",
              "answer": "<p>Kiểu unknown là kiểu đối chứng với kiểu any. Bạn có thể gán cho kiểu unknown với bất cứ thứ gì , nhưng không thể gán bất kỳ thứ gì bằng kiểu unknown (có thể khi ta thu hẹp kiểu dựa trên luồng điều khiển). Bạn không thể thực hiện bất kỳ thao tác nào trên một biến thuộc kiểu unknown mà không xác định trước loại cụ thể của biến đó.\r\n\r\nHãy xem xét ví dụ sau. Chúng ta tạo biến unknown <code>foo</code> và gán giá trị chuỗi cho nó. Nếu chúng ta cố gắng gán biến unknown vào một biến chuỗi <code>bar</code>, trình biên dịch sẽ báo lỗi.\r\n\r\n``<code>ts\r\nlet foo: unknown = \"Akshay\";\r\nlet bar: string = foo; // Type 'unknown' is not assignable to type 'string'.(2322)\r\n</code>`<code>\r\n\r\nBạn có thể thu hẹp một biến của một kiểu unknown thành một kiểu gì đó cụ thể bằng cách thực hiện kiểm tra kiểu hoặc kiểm tra so sánh hoặc sử dụng bảo vệ kiểu. Ví dụ: chúng ta có thể loại bỏ lỗi trên bằng cách\r\n\r\n</code>`<code>ts\r\nlet foo: unknown = \"Akshay\";\r\nlet bar: string = foo as string;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các cách khai báo biến trong TypeScript?",
              "answer": "<p><strong>var</strong> khai báo một biến cục bộ hoặc toàn cục. Bạn có thể thiết lập giá trị khi khai báo. Các hành vi và phạm vi của nó tương tự với ở JavaScript. Ví dụ:\r\n\r\n``<code>ts\r\nvar foo = \"bar\";\r\n</code>`<code>\r\n\r\n<strong>let</strong> khai báo biến cục bộ. Tương tự var, bạn có thể thiết lập giá trị biến khi khai báo. Ví dụ:\r\n\r\n</code>`<code>ts\r\nlet a = 5;\r\n\r\nif (true) {\r\n    let a = 10;\r\n    console.log(a);  // 10\r\n}\r\nconsole.log(a);  // 5\r\n</code>`<code>\r\n\r\n<strong>const</strong> khai báo hằng cục bộ không thể thay đổi sau khi khởi tạo.\r\n\r\n</code>`<code>ts\r\nconst a = 5;\r\n\r\nif (true) {\r\n    a = 10; // Error: Cannot assign to 'a' because it is a constant.(2588)\r\n} \r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cung cấp cú pháp cho hàm với chú thích kiểu?",
              "answer": "<p>Hàm là các khối code để thực hiện một code cụ thể. Các hàm có thể tùy ý nhận một hoặc nhiều tham số, xử lý chúng và tùy chọn trả về một giá trị. Trong TypeScript hàm cần có chú thích kiểu là kiểu giá trị trả về của hàm.\r\n\r\n``<code>ts\r\nfunction greet(name: string): string {\r\n  return </code>Hello, ${name}<code>;\r\n}\r\n\r\nlet greeting = greet(\"Anders\");\r\nconsole.log(greeting);  // \"Hello, Anders\"\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách tạo đối tượng trong TypeScript?",
              "answer": "<p>Đối tượng là một tập hợp key/value. Key là duy nhất. Nó gần tương đồng với mảng nên còn gọi là mảng liên kết. Tuy nhiên, mảng sử dụng key/chỉ mục là giá trị số, trong khi đối tượng cho phép bất kỳ kiểu dữ liệu nào là key.\r\n\r\nTrong TypeScript, kiểu đối tượng đề cập đến bất kỳ thuộc tính nào. Nó có thể định nghĩa danh sách thuộc tính và kiểu của nó. Ví dụ:\r\n\r\n``<code>ts\r\nlet pt: { x: number; y: number } = {\r\n  x: 10,\r\n  y: 20\r\n};\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tuỳ chọn thuộc tính trong TypeScript?",
              "answer": "<p>Một đối tượng có thể có thuộc tính tuỳ chọn (có hoặc không có) bằng cách thêm <code>?</code> sau tên thuộc tính.\r\n\r\n``<code>ts\r\nlet pt: { x: number; y: number; z?: number } = {\r\n  x: 10,\r\n  y: 20\r\n};\r\nconsole.log(pt);\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, thuộc tính </code>z` là tuỳ chọn, trình biên dịch không bắt buộc ta cung cấp khi khởi tạo đối tượng.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích khái niệm null trong TypeScript?",
              "answer": "<p>Trong lập trình, giá trị null cho biết không có giá trị. Một biến null không trỏ đến bất kỳ đối tượng nào. Do đó, bạn không thể truy cập bất kỳ thuộc tính nào trên biến hoặc gọi một phương thức trên đó.\r\n\r\nTrong TypeScript, giá trị null được chỉ định bằng từ khoá <code>null</code>. Ví dụ\r\n\r\n``<code>ts\r\nfunction greet(name: string | null) {\r\n    if (name === null) {\r\n        console.log(\"Name is not provided\");\r\n    } else {\r\n        console.log(\"Good morning, \" + name.toUpperCase());\r\n    }\r\n}\r\n\r\nvar foo = null;\r\ngreet(foo); // \"Name is not provided\"\r\n\r\nfoo = \"Anders\";\r\ngreet(foo);  // \"Good morning, ANDERS\"\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "undefined trong TypeScript là gì?",
              "answer": "<p>Khi một biến được khai báo mà không tạo giá trị, nó sẽ được gán giá trị undefined. \r\n\r\n``<code>ts\r\nconsole.log(null == null); // true\r\nconsole.log(undefined == undefined); // true\r\nconsole.log(null == undefined); // true, with type-conversion\r\nconsole.log(null === undefined); // false, without type-conversion\r\nconsole.log(0 == undefined); // false\r\nconsole.log('' == undefined); // false\r\nconsole.log(false == undefined); // false\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích kiểu never trong TypeScript?",
              "answer": "<p>Kiểu never trong TypeScript là một kiểu không chứa giá trị. Do đó, bạn không thể gán bất kỳ giá trị nào cho biến có kiểu never.\r\n\r\n``<code>ts\r\nfunction error(message: string): never {\r\n    throw new Error(message);\r\n}\r\n</code>`<code>\r\n\r\nCâu hỏi đặt ra là tại sao cần kiểu </code>never<code> khi ta đã có </code>void<code>. Vì cả hai khá giống nhau, nhưng thực sự chúng lại là đại diện cho hai khái niệm khác nhau.\r\n\r\nMột hàm không trả về một giá trị nào ngầm hiểu là giá trị undefined trong JavaScript. Do đó, khi ta dùng </code>void<code> với một hàm thực tế nó vẫn nhận về kiểu undefined. Để đảm bảo hàm không nhận bất cứ giá trị nào, kiểu </code>never<code> được dùng cho những trường hợp như vậy.\r\n\r\n</code>`<code>ts\r\nconst test = (arg): void => {\r\n    console.log(arg)\r\n}\r\n\r\nconsole.log(test('test'))\r\n\r\n// \"test\"\r\n// undefined\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách enum hoạt động trong TypeScript?",
              "answer": "<p>Enums cho phép chúng ta tạo các hằng số được đặt tên. Đây là một cách đơn giản để đặt tên thân thiện hơn cho các giá trị hằng số. Một enum được định nghĩa bởi từ khóa enum, theo sau là tên và các thành viên của nó.\r\n\r\nVí dụ:\r\n\r\n``<code>ts\r\nenum Team {\r\n    Alpha,\r\n    Beta,\r\n    Gamma,\r\n    Delta\r\n}\r\n\r\nlet t: Team = Team.Delta;\r\n</code>`<code>\r\n\r\nMặc định, enum bắt đầu đánh số từ 0. Bạn có thể ghi đè lên giá trị mặc định bằng cách gán giá trị cho các thành viên của nó. Ví dụ:\r\n\r\n</code>`<code>ts\r\nenum Author {\r\n  Anders = \"Anders\",\r\n  Hejlsberg = \"Hejlsberg\"\r\n};\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Toán tử typeof trong TypeScript là gì?",
              "answer": "<p>Tương tự JavaScript, đây là toán tử trả về kiểu dữ liệu của toán hạng.\r\n\r\n``<code>ts\r\nconsole.log(typeof 10);  // \"number\"\r\n\r\nconsole.log(typeof 'foo');  // \"string\"\r\n\r\nconsole.log(typeof false);  // \"boolean\"\r\n\r\nconsole.log(typeof bar);  // \"undefined\"\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tham số còn lại trong TypeScript?",
              "answer": "<p>Tham số còn lại (<code>...</code>) cho phép một hàm nhận một lượng không giới hạn tham số như là một mảng. \r\n\r\n``<code>ts\r\nfunction add(...values: number[]) {\r\n    let sum = 0;\r\n    values.forEach(val => sum += val);\r\n    \r\n    return sum;\r\n}\r\n\r\nconst sum = add(5, 10, 15, 20);\r\nconsole.log(sum);  // 50\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "web-api",
          "name": "Câu hỏi phỏng vấn Web API",
          "description": "",
          "questions": [
            {
              "question": "Tại sao Web API quan trọng?",
              "answer": "<p>Web API được xem như một dịch vụ cơ bản cung cấp thông tin hoặc dữ liệu từ server. Nó quan trọng vì những lý do sau:\r<ul><li>Nó được dùng để cung cấp interface cho web hay ứng dụng để có thể truy cập dữ liệu.</li></ul>\r<ul><li>Nó còn được dùng cho truy cập hay lưu trữ dữ liệu vào cơ sở dữ liệu.</li></ul>\r<ul><li>Nó hỗ trợ nhiều định dạng dữ liệu khác nhau như XML, JSON,...</li></ul>\r<ul><li>Nó phù hợp với nhiều kiểu trình duyệt và thiết bị</li></ul>\r<ul><li>Nó sử dụng băng thông thấp do đó phù hợp với các thiết bị giới hạn băng thông như smartphone,...</li></ul>\r<ul><li>Từ góc nhìn doanh nghiệp, Web API ứng dụng tốt hơn cho UX/UI, tăng lưu lượng truy cập và tạo sự thu hút cho sản phẩm hay dịch vụ công ty.</li></ul>\r\n\r\n<img src=\"/interview-assets/API_Application.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Chính xác thì Web API là gì?",
              "answer": "<p>Web API (Application Programming Interfce), là một API dùng cho truy cập xuyên qua web với giao thức HTTP. Nó được xem là nền tảng tốt nhất để cho phép các dịch vụ khác truy cập dữ liệu hay dịch vụ của server. Nó có thể được xây dựng bằng các công nghệ khác nhau như Nodejs, Java, ASP.NET,...\r\n\r\n<img src=\"/interview-assets/WEB_API.png\" alt=\"\" />\r\n\r\nWeb API được dùng:\r<ul><li>Nó chứa các lớp bổ sung giúp chuẩn hóa thông tin liên lạc một cách đơn giản và cung cấp các tùy chọn khác nhau về cách định dạng đầu vào và đầu ra.</li></ul>\r<ul><li>Nếu muốn tạo các dịch vụ hướng tài nguyên, thì các dịch vụ Web API được coi là tốt nhất.</li></ul>\r<ul><li>Hỗ trợ phát triển cả RESTful và SOAP.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Kiểu trả về được hỗ trợ trong Web API?",
              "answer": "<p>Nó không có bất kỳ kiểu dữ liệu cụ thể nào. Nó có thể trả về bất kỳ loại dữ liệu nào tùy thuộc vào yêu cầu nghiệp vụ. Có nhiều phương thức HTTP như GET, POST, PUT, v.v., có thể trả về dữ liệu ở các định dạng khác nhau tùy thuộc vào trường hợp sử dụng.</p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa WCF và Web API?",
              "answer": "<p><strong>WCF (Windows Communication Foundation):</strong> là một framework dùng cho phát triển SOAP (Service-oriented applications). Framework này dùng cho phát triển, cấu hình và triển khai dịch vụ mạng phân phối.\r\n\r\n<strong>Web API:</strong> là API cho cả trình duyệt web và web server. \r\n\r\n| Web API | WCF |\r\n|-|-|\r\n| Dùng cho phát triển cả SOAP và RESTful | Chỉ dùng cho phát triển SOAP |\r\n| Hỗ trợ các tính năng MVC như routing, binding,.. | Không hỗ trợ MVC |\r\n| Chỉ dùng giao thức HTTP | Dùng nhiều giao thức HTTP, UDP,.. |\r\n| Là tốt nhất cho phát triển dịch vụ RESTful | Hỗ trợ giới hạn các dịch vụ RESTful |\r\n| Hỗ trợ định dạng UTF-8 | Hỗ trợ văn bản, mã hoá nhị phân, MTOM (Message Transmission Optimization Mechanism) |\r\n| Dùng cho tiết lộ thông tin, dữ liệu với trình duyệt hay thiết bị di động | Dùng cho tạo các dịch vụ sử dụng kênh truyền tải nhanh như TCP, UDP,... |</p>",
              "level": "middle"
            },
            {
              "question": "Web API tốt hơn WCF ở điểm nào?",
              "answer": "<p><ul><li>Web API cung cấp đầy đủ các tính năng của HTTP như URI, header, caching, versioning,...</li></ul>\r<ul><li>Web API dùng các định dạng văn bản khác nhau như XML vì nó nhanh hơn các dịch vụ.</li></ul>\r<ul><li>Web API hỗ trợ tính năng MVC.</li></ul>\r<ul><li>Web API cung cấp khả năng mở rộng tốt hơn.</li></ul>\r<ul><li>Web API sử dụng chuẩn bảo mật như xác thực token để cung cấp khả năng bảo mật dịch vụ.</li></ul>\r<ul><li>Người ta không phải xác định hoặc giải thích bất kỳ cài đặt cấu hình bổ sung nào cho các thiết bị khác nhau trong API Web.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa REST API và RESTful API?",
              "answer": "<p>| REST API | RESTful API |\r\n|-|-|\r\n| Là mẫu kiến trúc sử dụng trong dịch vụ web | Được dùng cho triển khai REST |\r\n| Định dạng dữ liệu dựa vào HTTP | Định dạng dữ liệu JSON, HTTP và văn bản |\r\n| LÀm việc của URL dựa vào request/respone | Làm việc của RESTful dựa vào ứng dụng REST |\r\n| Nó thân thiện hơn với người dùng và có khả năng thích ứng cao với tất cả các doanh nghiệp kinh doanh và CNTT | Nó quá linh hoạt |\r\n| Nó yêu cầu phát triển API cho phép tương tác giữa client và server | Nó chỉ đơn giản tuân theo cơ sở hạ tầng REST cung cấp khả năng tương tác giữa các hệ thống khác nhau trên toàn mạng |</p>",
              "level": "middle"
            },
            {
              "question": "Ưu điểm của sử dụng REST trong Web API?",
              "answer": "<p><ul><li>Nó cho phép truyền ít dữ liệu hơn giữa máy khách và máy chủ.</li></ul>\r<ul><li>Nó rất dễ sử dụng và nhẹ.</li></ul>\r<ul><li>Nó cung cấp tính linh hoạt hơn.</li></ul>\r<ul><li>Nó cũng xử lý và kiểm soát nhiều loại cuộc gọi khác nhau, trả về nhiều định dạng dữ liệu khác nhau.</li></ul>\r<ul><li>Nó được coi là tốt nhất để sử dụng nó trong các ứng dụng dành cho thiết bị di động vì nó truyền ít dữ liệu giữa máy khách và máy chủ hơn.</li></ul>\r<ul><li>Nó sử dụng các lệnh gọi HTTP đơn giản để giao tiếp giữa các máy thay vì sử dụng các tùy chọn phức tạp hơn như CORBA, COM +, SOAP hoặc RPC.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa REST và SOAP?",
              "answer": "<p><strong>REST (Representational State Transfer):</strong> mô tả một phong cách cấu trúc hệ thống mạng. Nó không yêu cầu băng thông rộng khi bạn gửi yêu cầu đến server. Nó chứa các thông điệp định dạng JSON. Ví dụ\r\n\r\n``<code>js\r\n{\"city\":\"Mumbai\",\"state\":\"Maharashtra\"}\r\n</code>`<code>\r\n\r\n<strong>SOAP (Simple Object Access Protocol):</strong> Nó là một giao thức đơn giản và nhẹ thường được sử dụng để trao đổi thông tin có cấu trúc và được đánh máy trên Web. Nó hoạt động chủ yếu với HTTP và RPC. Giao thức này chủ yếu được sử dụng cho các ứng dụng B2B mà người ta có thể xác định hợp đồng dữ liệu với nó. Thông điệp SOAP có nội dung nặng hơn và do đó sử dụng băng thông lớn hơn.\r\n\r\n</code>`<code>xml\r\n<?xml version=\"1.0\"?>\r\n<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://www.w3.org/2001/12/soap-envelope\" SOAP-ENV:encodingStyle=\" http://www.w3.org/2001/12/soap-encoding\">\r\n    <soap:Body>\r\n        <Demo.guru99WebService xmlns=\"http://tempuri.org/\">   \r\n            <EmployeeID>int</EmployeeID>   \r\n        </Demo.guru99WebService> \r\n    </soap:Body>\r\n</SOAP-ENV:Envelope>\r\n</code>``\r\n\r\n| SOAP | REST |\r\n|-|-|\r\n| Một giao thức gửi nhận thông điệp có định dạng XML | Một loại kiến trúc bao gồm các quy tắc để thao tác với server |\r\n| Sử dụng WSDL để giao tiếp giữa máy chủ và máy khách | Sử dụng XML hoặc JSON để gửi nhận dữ liệu |\r\n| Gọi các dịch vụ thông qua phương thức RPC | Gọi các dịch vụ qua đường dẫn URL |\r\n| Kết quả trả về không dễ đọc | Kết quả trả về dễ đọc vì đơn giản chỉ là text XML hoặc JSON |\r\n| Có thể truyền qua nhiều giao thức khác nhau như HTTP, SMTP, FTP,…\t| Chỉ có thể truyền qua HTTP |\r\n| JS có thể dùng để gọi SOAP, nhưng rất khó để làm | Quá đơn giản nếu dùng JS |\r\n| Hiệu suất không tốt bằng REST | Hiệu suất tốt hơn SOAP, tốn ít tài nguyên CPU hơn, code ngắn gọn hơn |</p>",
              "level": "middle"
            },
            {
              "question": "Giao thức hỗ trợ Web API?",
              "answer": "<p>Web API chỉ hỗ trợ giao thức HTTP</p>",
              "level": "middle"
            },
            {
              "question": "XML và JSON là gì?",
              "answer": "<p><strong>XML (Extensible Markup Language):</strong>\r<ul><li>Được thiết kế đặc biệt để lưu trữ và truyền tải dữ liệu.</li></ul>\r<ul><li>Giống như HTML nhưng linh hoạt hơn cho phép người dùng tự tạo thẻ.</li></ul>\r<ul><li>Dùng cho biểu diễn thông tin có cấu trúc như dữ liệu, tài liệu, cấu hình,...</li></ul>\r\n\r\n<strong>JSON (JavaScript Object Notation):</strong>\r<ul><li>Là định dạng nhẹ được thiết kế để lưu trữ và truyền tải dữ liệu.</li></ul>\r<ul><li>Là chuẩn định dạng văn bản dùng cho biểu diễn cấu trúc dữ liệu dựa trên đối tượng JavaScript.</li></ul>\r<ul><li>Nó nhanh và dễ sử dụng.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Đối tượng sử dụng Web API?",
              "answer": "<p>Một loạt các ứng dụng client như trình duyệt, thiết bị di động, iPhone, ..., sử dụng web API. Nó cũng dùng cùng với các ứng dụng native yêu cầu dịch vụ web nhưng không hỗ trợ SOAP. Nó cũng có thể được sử dụng bởi bất kỳ ứng dụng client nào hỗ trợ các hành động HTTP như GET, DELETE, POST, PUT.</p>",
              "level": "middle"
            },
            {
              "question": "Web API và MVC có gì khác?",
              "answer": "<p>MVC (Model-View-Controller) là mô hình thiết kế ứng dụng bao gồm 3 phần chính là model, view và controller. Nó cho phép người viết code xác định các thành phần khác nhau của ứng dụng và cập nhật chúng dễ dàng hơn. Nó chủ yếu được sử dụng để phát triển mô hình giao diện người dùng. Mục đích chính của nó là hiển thị các mẫu trong cấu trúc để giữ cho màn hình và dữ liệu được tách biệt cho phép cả hai thay đổi mà không ảnh hưởng đến những người khác.\r\n\r\n| MVC | Web API |\r\n|-|-|\r\n| Dùng cho xây dựng ứng dụng web dựa trên dữ liệu và view | Dùng cho xây dựng dịch vụ HTTP chỉ dựa trên dịch vụ |\r\n| Trả về dữ liệu dạng JSON |Trả về các định dạng dữ liệu khác nhau XML, JSON |\r\n| Hỗ trợ tự lưu trữ | Không hỗ trợ tự lưu trữ |\r\n| Không hỗ trợ dịch vụ RESTful | Hỗ trợ dịch vụ RESTful |\r\n| Trả về view (HTML) | Trả về phản hồi HTTP |\r\n\r\n<img src=\"/interview-assets/MVC_vs_Web_API.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "CORS là gì?",
              "answer": "<p>CORS (Cross-Origin Resource Sharing) là một kĩ thuật được sinh ra để làm cho việc tương tác giữa client và server được dễ dàng hơn, nó cho phép JavaScript ở một trang web có thể tạo yêu cầu HTTP lên một REST API được host ở một domain khác.\r\n\r\nTrong trường hợp đơn giản nhất, phía client (ứng dụng web đạng chạy ở trình duyệt đó) sẽ tạo yêu cầu GET, POST, PUT, HEAD,... để yêu cầu server làm một việc gì đó. Những yêu cầu này sẽ được đính kèm một header tên là <code>Origin</code> để chỉ định origin của client code (giá trị của header này chính là domain của trang web).\r\n\r\nServer sẽ xem xét <code>Origin</code> để biết được nguồn này có phải là nguồn hợp lệ hay không. Nếu hợp lệ, server sẽ trả về response kèm với header <code>Access-Control-Allow-Origin</code>. Header này sẽ cho biết xem client có phải là nguồn hợp lệ để trình duyệt tiếp tục thực hiện quá trình yêu cầu.\r\n\r\nTrong trường hợp thông thường, <code>Access-Control-Allow-Origin</code> sẽ có giá trị giống như <code>Origin</code>, một số trường hợp giá trị của <code>Access-Control-Allow-Origin</code> sẽ nhìn giống giống như Regex hay chỉ đơn giản là <code><em></code>, tuy nhiên thì cách dùng <code></em></code> thường được coi là không an toàn, ngoại trừ trường hợp API của bạn được public hoàn toàn và ai cũng có thể truy cập được.\r\n\r\nVà như thế, nếu không có header <code>Access-Control-Allow-Origin</code> hoặc giá trị của nó không hợp lệ thì trình duyệt sẽ từ chối chúng ta.\r\n\r\n<img src=\"/interview-assets/cors.png\" alt=\"\" /></p>",
              "level": "middle"
            }
          ]
        }
      ]
    },
    {
      "id": "backend",
      "name": "Backend Development",
      "icon": "storage",
      "color": "#4fc3f7",
      "subcategories": [
        {
          "id": "csharp",
          "name": "Câu hỏi phỏng vấn C#",
          "description": "",
          "questions": [
            {
              "question": "C# khác với C/C++ như thế nào?",
              "answer": "<p>C có thể xem là ngôn ngữ lập trình bậc thấp vì nó có cấu trúc, thủ tục lập trình giản đơn. C nên là lựa chọn hàng đầu khi xây dựng các chương trình lõi, hệ điều hành, chương trình nhúng….\r\n\r\nC++ có thể được phân là ngôn ngữ lập trình bậc trung. Nó là một thế hệ con của C, được thiết kế nhằm khắc phục những hạn chế của C. Nó hỗ trợ cho việc lập trình hướng đối tượng mà vẫn giữ được những tính chất ban đầu và tốc độ thực thi của C. Hoàn toàn không có lớp ảo hóa nào ở trung gian, trình biên dịch C++ chuyển trực tiếp từ mã nguồn sang mã máy.\r\n\r\nC# kế thừa C và C++, và là ngôn ngữ lập trình hướng đối tượng bậc cao, ngang hàng với các ngôn ngữ lập trình bậc cao khác như Python, Java… Lập trình viên sử dụng C#, sẽ được hỗ trợ nhiều tính năng hơn. Cũng giống như Python hay Java, mã nguồn C# sẽ được chuyển sang dạng bytecode trên máy ảo CLR (Common Language Runtime), sau đó mới chuyển sang mã máy.\r\n\r\nVới C và C++, người dùng có thể trực tiếp quản lý vùng nhớ của họ. Tuy vậy, hai ngôn ngữ lập trình này không có cơ chế dọn rác tự động.\r\n\r\nCòn với C# bạn không cần lo lắng về vùng nhớ. Nhờ hỗ trợ chức năng dọn rác tự động, ngôn ngữ này giúp bạn quản lý vùng nhớ dễ dàng và hiệu quả hơn. Khi đầy rác, vùng nhớ bị hết; nó sẽ tự xóa rác mà không cần bạn phải vào thao tác.</p>",
              "level": "fresher"
            },
            {
              "question": "CLR là gì?",
              "answer": "<p>Common Language Runtime (CLR) xử lý chương trình thực thi chương trình cho nhiều ngôn ngữ khác nhau bao gồm cả C#. Kiến trúc của CLR xử lý quản lý bộ nhớ, thu gom rác, xử lý bảo mật và trông giống như: \r\n\r\n<img src=\"/interview-assets/Common_Language_Runtime_(CLR).png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Bộ dọn rác trong C#?",
              "answer": "<p>Bộ dọn rác (garbage collection) là quá trình giải phóng bộ nhớ bị chiếm bởi các đối tượng không mong muốn. Khi bạn tạo một đối tượng, tự động một số không gian bộ nhớ được cấp cho đối tượng trong bộ nhớ heap. Bây giờ, sau khi bạn thực hiện tất cả các hành động trên đối tượng, không gian bộ nhớ bị chiếm bởi đối tượng sẽ trở thành lãng phí. Sẽ là cần thiết để giải phóng bộ nhớ. Việc thu gom rác xảy ra trong ba trường hợp: \r<ul><li>Nếu bộ nhớ bị chiếm bởi các đối tượng vượt quá ngưỡng giá trị đặt trước.</li></ul>\r<ul><li>Nếu phương thức thu gom rác được gọi</li></ul>\r<ul><li>Nếu hệ thống của bạn có bộ nhớ vật lý thấp</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu class trong C#?",
              "answer": "<p>Class trong C# chính là cách thể hiện khái niệm về lớp trong lập trình hướng đối tượng. Trong C# có 4 kiểu class:\r<ul><li><strong>static class:</strong> khai báo bởi từ khoá <code>static</code> không cho phép kế thừa. Do đó không thể tạo đối tượng từ static class.</li></ul>\r\n\r\n``<code>csharp\r\nstatic class classname\r\n{\r\n    // static data \r\n    // static methods\r\n}\r\n</code>`<code>\r<ul><li><strong>partial class:</strong> khai báo bởi từ khoá </code>partial<code> cho phép các thành viên của nó phân chia hoặc chia sẻ với file (.cs) nguồn.</li></ul>\r<ul><li><strong>abstract class:</strong> là lớp không thể khởi tạo nên bạn không thể tạo đối tượng. abstract class hoạt động dựa trên khái niệm trừu tượng trong OOP. Tính trừu tượng giúp trích xuất các chi tiết cần thiết và ẩn những chi tiết không cần thiết. </li></ul>\r<ul><li><strong>sealed class:</strong>  Lớp được đóng dấu là lớp không thể được kế thừa. Sử dụng từ khóa </code>sealead<code> để hạn chế quyền truy cập đối với người dùng kế thừa lớp đó.</li></ul>\r\n\r\n</code>`<code>csharp\r\nsealed class classname\r\n{\r\n    // static data \r\n    // static methods\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa lớp trừu tượng và interface?",
              "answer": "<p>Hãy cùng tìm hiểu sự khác biệt giữa lớp trừu tượng và interface:\r<ul><li>Các lớp trừu tượng là các lớp không thể được khởi tạo tức là chúng không thể tạo một đối tượng. Interface giống như một lớp trừu tượng vì tất cả các phương thức bên trong interface đều là phương thức trừu tượng.</li></ul>\r<ul><li>Các lớp trừu tượng có thể có cả phương thức trừu tượng và không trừu tượng nhưng tất cả các phương thức của một interface đều là phương thức trừu tượng.</li></ul>\r<ul><li>Vì các lớp trừu tượng có thể có cả phương thức trừu tượng và không trừu tượng, chúng ta cần sử dụng từ khóa <code>abstract</code> để khai báo các phương thức trừu tượng. Nhưng trong interface, không cần như vậy.</li></ul>\r<ul><li>Một lớp trừu tượng có các hàm tạo trong khi một interface thì không.</li></ul>\r\n\r\n##</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa từ khoá ref và out?",
              "answer": "<p>Từ khoá <code>ref</code> truyền đối số bằng tham chiếu chứ không phải giá trị. \r\n\r\n``<code>csharp\r\nvoid Method(ref int refArgument)\r\n{\r\n   refArgument = refArgument + 10;\r\n}\r\nint number = 1;\r\nMethod(ref number);\r\nConsole.WriteLine(number);\r\n// Output: 11\r\n</code>`<code>\r\n\r\nTừ khoá </code>out<code> truyền đối số trong phương thức và hàm. Từ khóa </code>out<code> được sử dụng để truyền các đối số trong một phương thức làm tham chiếu để trả về nhiều giá trị. Mặc dù nó giống với từ khóa </code>ref<code>, nhưng từ khóa </code>ref<code> cần phải được khởi tạo trước khi được truyền. Ở đây, các từ khóa </code>out<code> và </code>ref<code> rất hữu ích khi chúng ta muốn trả về một giá trị trong cùng các biến được truyền dưới dạng đối số.\r\n\r\n</code>`<code>csharp\r\npublic static string GetNextFeature(ref int id)  \r\n{  \r\n   string returnText = \"Next-\" + id.ToString();  \r\n   id += 1;  \r\n   return returnText;  \r\n}  \r\npublic static string GetNextFeature(out int id)  \r\n{  \r\n   id = 1;  \r\n   string returnText = \"Next-\" + id.ToString();  \r\n   return returnText;  \r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Phương thức mở rộng trong C#?",
              "answer": "<p>Các phương pháp mở rộng giúp thêm các phương pháp mới vào các phương pháp hiện có. Các phương thức được thêm vào là tĩnh. Đôi khi, khi bạn muốn thêm các phương thức vào một lớp hiện có nhưng không nhận thấy quyền sửa đổi lớp đó hoặc không có quyền, bạn có thể tạo một lớp tĩnh mới chứa các phương thức mới. Khi các phương thức mở rộng được khai báo, hãy liên kết lớp này với lớp hiện có và xem các phương thức sẽ được thêm vào lớp hiện có.\r\n\r\n``<code>csharp\r\n// C# program to illustrate the concept\r\n// of the extension methods\r\nusing System;\r\n \r\nnamespace ExtensionMethod {\r\n    static class NewMethodClass {\r\n    \r\n        // Method 4\r\n        public static void M4(this Scaler s)\r\n        {\r\n            Console.WriteLine(\"Method Name: M4\");\r\n        }\r\n        \r\n        // Method 5\r\n        public static void M5(this Scaler s, string str)\r\n        {\r\n            Console.WriteLine(str);\r\n        }\r\n    }\r\n    \r\n    // Now we create a new class in which\r\n    // Scaler class access all the five methods\r\n    public class IB {\r\n    \r\n        // Main Method\r\n        public static void Main(string[] args)\r\n        {\r\n            Scaler s = new Scaler();\r\n            s.M1();\r\n            s.M2();\r\n            s.M3();\r\n            s.M4();\r\n            s.M5(\"Method Name: M5\");\r\n        }\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nMethod Name: M1\r\n\r\nMethod Name: M2\r\n\r\nMethod Name: M3\r\n\r\nMethod Name: M4\r\n\r\nMethod Name: M5\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Generic trong C#?",
              "answer": "<p>Trong C#, lập trình tổng quát (generics) là một dạng lập trình đặc biệt trong đó kiểu dữ liệu (của biến thành viên, biến cục bộ, tham số, kiểu trả về của phương thức,...) không được xác định ở giai đoạn xây dựng đơn vị code (như lớp, phướng thức) mà chỉ được xác định ở giai đoạn khởi tạo và sử dụng.\r\n\r\nĐể thực hiện điều này, ở giai đoạn khai báo người ta dùng một kiểu dữ liệu giả. Ở giai đoạn sử dụng, kiểu dữ liệu giả sẽ được thay thế bằng kiểu dữ liệu thực. Cú pháp dùng cho generic:\r\n\r\n``<code>csharp\r\nGenericList<float> list1 = new GenericList<float>();\r\nGenericList<Features> list2 = new GenericList<Features>();\r\nGenericList<Struct> list3 = new GenericList<Struct>();\r\n</code>`<code>\r\n\r\nỞ đây, </code>GenericList<float><code> là lớp generic. Với mỗi thực thể của </code>Generic<T>`, mỗi khi T xuất hiện trong lớp đều được thay thế bằng kiểu tham số ở thời điểm chạy. Bằng cách thay thế T, ta tạo ra ba kiểu khác nhau sử dụng cùng một lớp.</p>",
              "level": "fresher"
            },
            {
              "question": "Lớp partial trong C# là gì?",
              "answer": "<p>Các lớp partial thực hiện chức năng của một lớp đơn lẻ thành nhiều file. Nhiều file này được kết hợp thành một trong thời gian biên dịch. Lớp partial có thể được tạo bằng từ khóa <code>partial</code>.\r\n\r\n``<code>csharp\r\npublic partial Clas_name  \r\n{\r\n   // code\r\n}\r\n</code>``\r\n\r\nBạn có thể dễ dàng chia các chức năng của phương thức, interface hoặc cấu trúc thành nhiều file. Thậm chí có thể thêm các lớp partial lồng nhau.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa late binding và early binding trong C#?",
              "answer": "<p>Late binding và early binding là hai ví dụ cho khái niệm đa hình trong OOPs.\r\n\r\nVí dụ: một hàm <code>calculateBill()</code> sẽ tính toán chi phí cho khách hàng vip, khách hàng cơ bản và khách hàng tiềm năng dựa trên các chính sách khác nhau. Việc tính toán cho tất cả đối tượng khác nhau này nhưng sử dụng cùng một hàm được gọi là đa hình.\r\n\r\nKhi đối tượng được gán một biến đối tượng trong C#, framework .NET thực hiện liên kết.\r\n\r\nKhi hàm liên kết xảy ra ở thời gian biên dịch nó được gọi là early binding. Nó kiểm tra các phương thức và thuộc tính của các đối tượng tĩnh. Với early binding, số lỗi thời gian chạy giảm đáng kể và nó thực thi khá nhanh.\r\n\r\nNhưng nếu liên kết xảy ra ở thời gian chạy, nó được gọi là late binding. Late binding xảy ra khi đối tượng là động (dựa trên dữ liệu mà nó giữ). Nó chậm hơn so với early binding</p>",
              "level": "fresher"
            },
            {
              "question": "Mảng trong C# là gì?",
              "answer": "<p>Khi một nhóm các phần tử tương tự được gộp lại với nhau dưới một tên, chúng được gọi là mảng.\r\n\r\nVd. Một mảng <code>Atea[4]: [green tea, chamomile tea, black tea, lemon tea]</code>. Độ dài của mảng xác định có bao nhiêu phần tử hiện diện trong mảng.\r\n\r\nTrong C#, việc cấp phát bộ nhớ cho các phần tử của mảng diễn ra tự động. Đây là cách các giá trị được lưu trữ trong một mảng một cách tuần tự.\r\n\r\n<img src=\"/interview-assets/arrays_in_C_.png\" alt=\"\" />\r\n\r\nCú pháp <code><Data Type>[] <Name_Array></code>\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Array và ArrayList trong C#?",
              "answer": "<p>Array (mảng) là một tập hợp biến có cùng kiểu được gộp lại dưới một cái tên. Trong khi ArrayList là tập hợp các đối tượng có chỉ mục riêng biệt. Với ArrayList bạn có thể truy cập với các tính ănng như cấp phát bộ nhớ động, thêm, tìm và sắp xếp mục trên ArrayList.\r<ul><li>Khi khai bao một mảng ta phải thiết lập kích cỡ tĩnh, do đó bộ nhớ là cố định. Trong khi ArrayList, có thể tăng giảm tuỳ ý.</li></ul>\r<ul><li>Mảng đi cùng với namespace <code>system.array</code> trong khi ArrayList đi cùng với namespace <code>system.collection</code>.</li></ul>\r<ul><li>Tất cả mục trong một mảng có cùng kiểu dữ liệu trong khi ArrayList có thể giống hoặc khác kiểu dữ liệu.</li></ul>\r<ul><li>Trong khi mảng không chấp nhận null, thì ArrayList chấp nhận giá trị null</li></ul>\r\n\r\n``<code>csharp\r\n// C# program to illustrate the ArrayList\r\nusing System;\r\nusing System.Collections;\r\n \r\nclass IB {\r\n \r\n    // Main Method\r\n    public static void Main(string[] args)\r\n    {\r\n    \r\n        // Create a list of strings\r\n        ArrayList al = new ArrayList();\r\n        al.Add(\"Bruno\");\r\n        al.Add(\"Husky\");\r\n        al.Add(10);\r\n        al.Add(10.10);\r\n    \r\n        // Iterate list element using foreach loop\r\n        foreach(var names in al)\r\n        {\r\n            Console.WriteLine(names);\r\n        }\r\n    }\r\n}\r\n</code>``\r\n\r\n## Câu hỏi phỏng vấn C# cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Kế thừa và đa kế thừa trong C#?",
              "answer": "<p>Kế thừa là một hoặc nhiều thuộc tính được truyền từ lớp cha sang lớp con.\r\n\r\n<img src=\"/interview-assets/Multiple-inheritance_in_C_.png\" alt=\"\" />\r\n\r\nVí dụ, lớp <code>C</code> kế thừa thuộc tính từ lớp <code>A</code> và lớp <code>B</code>. Đây là một ví dụ về kế thừa.\r\n\r\n``<code>csharp\r\n// C# program to illustrate\r\n// multiple class inheritance\r\nusing System;\r\nusing System.Collections;\r\n\r\n// Parent class 1\r\nclass Scaler {\r\n\r\n    // Providing the implementation\r\n    // of features() method\r\n    public void features()\r\n    {\r\n\r\n        // Creating ArrayList\r\n        ArrayList My<em>features= new ArrayList();\r\n\r\n        // Adding elements in the\r\n        // My</em>features ArrayList\r\n        My<em>features.Add(\"Abstraction\");\r\n        My</em>features.Add(\"Encapsulation\");\r\n        My<em>features.Add(\"Inheritance\");\r\n\r\n        Console.WriteLine(\"Features provided by OOPS:\");\r\n        foreach(var elements in My</em>features)\r\n        {\r\n            Console.WriteLine(elements);\r\n        }\r\n    }\r\n}\r\n\r\n// Parent class 2\r\nclass Scaler2 :Scaler{\r\n\r\n    // Providing the implementation\r\n    // of courses() method\r\n    public void languages()\r\n    {\r\n\r\n        // Creating ArrayList\r\n        ArrayList My<em>features = new ArrayList();\r\n\r\n        // Adding elements in the\r\n        // My</em>features ArrayList\r\n        My<em>features.Add(\"C++\");\r\n        My</em>features.Add(\"C#\");\r\n        My<em>features.Add(\"JScript\");\r\n        \r\n\r\n        Console.WriteLine(\"\\nLanguages that use OOPS concepts:\");\r\n        foreach(var elements in My</em>features)\r\n        {\r\n            Console.WriteLine(elements);\r\n        }\r\n    }\r\n}\r\n\r\n// Child class\r\nclass ScalertoScaler : Scaler2 {\r\n}\r\n\r\npublic class Scaler1 {\r\n\r\n    // Main method\r\n    static public void Main()\r\n    {\r\n\r\n        // Creating object of ScalertoScaler class\r\n        ScalertoScaler obj = new ScalertoScaler();\r\n        obj.features();\r\n        obj.languages();\r\n    }\r\n}\r\n</code>``\r\n\r\nC# không hỗ trợ đa kế thừa, thay vào đó bạn có thể dùng interface cho kế thừa thuộc tính bằng tên lớp.</p>",
              "level": "fresher"
            },
            {
              "question": "Boxing và Unboxing trong C#?",
              "answer": "<p><strong>Boxing</strong> là quá trình chuyển dữ liệu từ kiểu tham trị sang kiểu tham chiếu.Quá trình boxing một biến kiểu tham trị sẽ khởi tạo một đối tượng trong vùng nhớ heap và sao chép giá trị của biến tham trị vào đối tượng mới này. Và quá trình boxing được thực hiện nhờ quá trình chuyển đổi ngầm định.\r\n\r\n\r\n``<code>csharp\r\nint num = 23; // 23 will assigned to num\r\nObject Obj = num; // Boxing\r\n</code>`<code>\r\n\r\n<strong>Unboxing</strong> là quá trình ngược lại với Boxing, tức là đưa từ kiểu tham chiếu ra kiểu tham trị. Quá trình này sẽ được thực hiện một cách tường minh. Gồm có 2 bước :\r\n1. Kiểm tra chắc chắn rằng đối tượng đã được boxing đúng kiểu giá trị đưa ra.\r\n2. Sao chép giá trị sang biến dữ liệu kiểu tham trị.\r\n\r\n</code>`<code>csharp\r\nint num = 23;         // value type is int and assigned value 23\r\nObject Obj = num;    // Boxing\r\nint i = (int)Obj;    // Unboxing\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính trong C# là gì?",
              "answer": "<p>Các thuộc tính trong C# là các thành viên công khai của một lớp nơi chúng cung cấp khả năng truy cập các thành viên riêng tư của một lớp. Nguyên tắc cơ bản của đóng gói cho phép bạn ẩn một số thuộc tính nhạy cảm với người dùng bằng cách đặt các biến ở chế độ riêng tư. Các thành viên riêng tư không thể truy cập nếu không trong một lớp. Do đó, bằng cách sử dụng các thuộc tính trong C#, bạn có thể dễ dàng truy cập các thành viên riêng tư và thiết lập giá trị của chúng.\r\n\r\nCác giá trị có thể được gán dễ dàng bằng cách sử dụng các phương thức get và set, còn được gọi là trình truy cập. Trong khi phương thức get trích xuất giá trị, phương thức set sẽ gán giá trị cho các biến.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "django",
          "name": "Câu hỏi phỏng vấn Django",
          "description": "",
          "questions": [
            {
              "question": "Giải thích kiến trúc Django?",
              "answer": "<p>Django tuân theo mô hình kiến trúc MVT (Model View Template) thay vì mô hình MVC (Model View Controller) truyền thống. Nó khác với MVC ở chỗ, logic vốn của controller được xử lý ở chính view của framework. Còn template nằm ở tầng biểu diễn. HTML được kết hợp với Django Template Language (DTL). Các nhà phát triển cung cấp model, view và template sau đó ánh xạ nó vào URL, để nó phục vụ người dùng.\r\n\r\n<img src=\"/interview-assets/mvt.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cấu trúc thư mục Django?",
              "answer": "<p><ul><li><code>manage.py</code>: dùng cho các dòng lệnh cần thiết tương tác với ứng dụng Django.</li></ul>\r<ul><li><code><strong>init</strong>.py</code>: file rỗng nói với Python rằng xem thư mục hiện tại như một package Python.</li></ul>\r<ul><li><code>settings.py</code>: thiết lập các biến môi trường cho ứng dụng như tên cơ sở dữ liệu, secret key,...</li></ul>\r<ul><li><code>urls.py</code>: tất cả url của ứng dụng sẽ ở file này.</li></ul>\r<ul><li><code>wsgi.py</code>: điểm vào của ứng dụng, dược dùng bởi các web server khi dự án được tạo thành ứng dụng thực.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Model trong Django là gì?",
              "answer": "<p>Một model trong Django là một lớp sẽ được ánh xạ thành một bảng hoặc collection của cơ sở dữ liệu. Mỗi thuộc tính của lớp trong model sẽ là một trường trong cơ sở dữ liệu, nó được định nghĩa trong <code>app/models.py</code>\r\n\r\nVí dụ:\r\n\r\n``<code>py\r\nfrom django.db import models\r\n\r\nclass SampleModel(models.Model):\r\n    field1 = models.CharField(max<em>length = 50)\r\n    field2 = models.IntegerField()\r\n\r\n    class Meta:\r\n        db</em>table = \"sample_model\"\r\n</code>`<code>\r\n\r\nTất cả model đều kết thừa từ </code>django.db.models.Model`.\r\n\r\nỞ ví dụ trên ta có hai thuộc tính (1 char và 1 integer). Meta giúp bạn thiết lập những thứ có sẵn như quyền truy cập, phiên bản số nhiều và số ít của tên, tên bảng được liên kết, có abstract hay không,...</p>",
              "level": "fresher"
            },
            {
              "question": "Template trong Django hay DTL là gì?",
              "answer": "<p>Template là một phần trong kiến trúc MVT của Django. Nó bao gồm HTML, CSS nơi các biến hay thông tin được nhúng vào từ view. Các biến hay tag sẽ được template engine nhận ra và thông dịch chúng. \r\n\r\nTemplate được render với một ngữ cảnh nhất định, để thay thế các biến thành giá trị của nó và biểu diễn trong ngữ cảnh đó, đồng thời xử lý các tag. Tất cả thứ khác sẽ được giữ nguyên.\r\n\r\nCú pháp của DTL bao gồm các cấu trsuc sau:\r<ul><li>Biến</li></ul>\r<ul><li>Tag</li></ul>\r<ul><li>Bộ lọc</li></ul>\r<ul><li>Comment</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "View trong Django là gì?",
              "answer": "<p>Một hàm view hay view, đơn giản là một hàm Python nhận các yêu cầu web và trả về phản hồi. Phản hồi có thể là nội dung HTML của một trang web, một redirect (điều hướng sang trang khác), lỗi 404, hình ảnh hay một XML hoặc JSON,...\r\n\r\nVí dụ:\r\n\r\n``<code>py\r\nfrom django.http import HttpResponse\r\ndef sample_function(request):\r\n    return HttpResponse(\"Welcome to Django\")\r\n</code>``\r\n\r\nCó hai loại view:\r<ul><li><strong>Function-Based Views</strong>: ta import view như một hàm.</li></ul>\r<ul><li><strong>Class-based Views</strong>: tiếp cận theo hướng đối tượng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Django ORM là gì?",
              "answer": "<p>ORM (Object Relational Mapper) giúp ta tương tác với cơ sở dữ liệu theo code python thay vì viết các truy vấn sql thuần, nó giúp ta truy xuất, lưu và xoá dễ dàng hơn. Nó hoạt động ở tầng trừu tượng giữa model và cơ sở dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Static file là gì?",
              "answer": "<p>Website cần phục vụ các files như hình ảnh, js và css. Trong Django, các file này gọi là \"static file\". Nó được cung cấp bởi <code>django.contrib.staticfiles</code> để quản lý các file đấy.</p>",
              "level": "fresher"
            },
            {
              "question": "Django Rest Framework là gì?",
              "answer": "<p>Django Rest Framework (DJF) là một framework mã nguồn mở dựa trên Django để tạo RESTful API.</p>",
              "level": "fresher"
            },
            {
              "question": "Django-admin và manage.py là gì?",
              "answer": "<p>Django-admin là câu lệnh dùng cho các công việc quản trị trong Django. Bên cạnh đó, manage.py là file tự động tạo khi ta tạo dự án django. Nó không chỉ thực hiện các công việc chung như django-admin mà còn thiết lập môi trường biến <code>DJANGO<em>SETTINGS</em>MODULE</code> trỏ đến file settings.py trong dự án.\r\nCác câu lệnh thường dùng trong django.\r<ul><li><code>django-admin startproject</code> - tạo dự án Django với cấu trúc thư mục cho tên dự án nằm trong thư mục hiện tại hoặc đường dẫn.</li></ul>\r<ul><li><code>django-admin startapp</code> - tạo ứng dụng django trong dự án django với tên dự án.</li></ul>\r<ul><li><code>django-admin makemigrations</code> - tạo migration mới sau mỗi lần thay đổi model.</li></ul>\r<ul><li><code>django-admin migrate</code> - thực thi lệnh SQL, đồng bộ cơ sở dữ liệu với model và migrations.</li></ul>\r<ul><li><code>django-admin runserver</code> - chạy web server trên máy localhost. Cổng mặc định là 8000 với địa chỉ IP là 127.0.0.1. Có thể tuỳ chỉnh địa chỉ IP và port.</li></ul>\r<ul><li><code>django-admin createsuperuser</code> - tạo tài khoản với quyền quản trị.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Jinja là gì?",
              "answer": "<p>Jinja2 là một ngôn ngữ tạo template cung cấp cho các lập trình viên Python, được tạo ra dựa trên ý tưởng của Django template.\r\n\r\nJinja2 được sử dụng để tạo HTML, XML hoặc các định dạng file khác dựa trên nguyên tắc kết hợp các dữ liệu vào các vị trí đã được đánh dấu trong văn bản.</p>",
              "level": "fresher"
            },
            {
              "question": "Django URL là gì?",
              "answer": "<p>URL là một phần quan trọng trong ứng dụng web và Django cung cấp cách thiết kế để tuỳ chỉnh URL có tên là URLconf (URL Configuration). Chức năng cơ bản của nó là giúp bạn thiết kế URL ứng với các hàm view. Các URL này có thể là tĩnh hoặc động, được khai báo trong <code>urls.py</code> \r\n\r\nCú pháp:\r\n\r\n``<code>py\r\nfrom django.urls import path\r\nfrom . import views\r\nurlpatterns = [\r\n   path('data/2020/', views.data<em>2020),\r\n   path('data/<int:year>/', views.data</em>year)\r\n]\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa ứng dụng và dự án trong Django?",
              "answer": "<p>Trong Django, dự án (project) chỉ toàn bộ ứng dụng (app) và ứng dụng là một phần trong dự án cho xử lý một trường hợp cụ thể.\r\nVí dụ, hệ thống thanh toán (app) trong ứng dụng e-commerce(project).</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu kế thừa trong Django?",
              "answer": "<p><ul><li><strong>Abstract Base Class Inheritance:</strong> dùng khi bạn cần giữ thông tin ở lớp cha để không phải ghi lại ở mỗi lớp con.</li></ul>\r<ul><li><strong>Multi-Table Model Inheritance:</strong> dùng khi phân lớp một model đã có và cần bảng riêng cho mỗi model trong cơ sở dữ liệu.</li></ul>\r<ul><li><strong>Proxy Model Inheritance:</strong>  dùng khi muốn giữ lại vài trường trong model trong khi chỉnh sửa model của hàm python.</li></ul>\r\n\r\n## Câu hỏi phỏng vấn Django cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Signals trong Django là gì?",
              "answer": "<p>Bất cứ khi nào chỉnh sửa model, ta cần kích hoạt vài hành động. Django cung cấp một cách để xử lý chúng dưới dạng tín hiệu (signal). Các tín hiệu là những tiện ích cho phép chúng ta liên kết các sự kiện với các hành động. Chúng ta có thể thực hiện những điều này bằng cách phát triển một hàm sẽ chạy khi một tín hiệu gọi nó. \r\n\r\n| Signals | Mô tả |\r\n|---------|-------|\r\n| django.db.models.pre<em>init & django.db.models.post</em>init | Gửi trước hoặc sau khi phương thức <code><em>init</em>()</code> của model được gọi |\r\n| django.db.models.signals.pre<em>save & django.db.models.signals.post</em>save | Gửi trước hoặc sau khi phương thức <code>save()</code> của model được gọi |\r\n| django.db.models.signals.pre<em>delete & django.db.models.signals.post</em>delete | Gửi trước hoặc sau phương thức <code>delete()</code> của model hoặc queryset được gọi |\r\n| django.db.models.signals.pre<em>delete & django.db.models.signals.post</em>delete | Gửi khi <code>ManyToManyField</code> được thay đổi |\r\n| django.core.signals.request<em>started & django.core.signals.request</em>finished | Gửi khi yêu cầu HTTP bắt đầu hoặc kết thúc |</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về caching trong Django?",
              "answer": "<p>Caching đề cập đến kỹ thuật lưu giữ kết quả output ở lần xử lý đầu tiên cho các lần tiếp theo nếu kết quả trùng lặp. Thay vì xử lý các yêu cầu giống nhau lại lần nữa, ta lấy kết quả cũ đã lưu, giúp truy cập nhanh hơn. Django cung cấp hệ thống cache mạnh mẽ cho lưu trữ ở các trang web động.\r\n\r\n| Cache | Mô tả |\r\n|-------|-------|\r\n| Memcached | Một memory-based cache server nhanh và hiệu quả |\r\n| FileSystem Caching | Giá trị cache được lưu từng file riêng biệt theo trật tự serialize |\r\n| Local-memory Caching | Chiến lược cache mặc định của django. Nó xử lý từng tiến trình và thread-safe. |\r\n| Database caching | Dữ liệu cache được lưu trong cơ sở dữ liệu và hoạt động hiệu quả nếu bạn đánh chỉ mục DB |</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "microservice",
          "name": "Câu hỏi phỏng vấn Microservice",
          "description": "",
          "questions": [
            {
              "question": "Các tính năng chính của Microservices?",
              "answer": "<p><img src=\"/interview-assets/features_of_Microservices.jpg\" alt=\"\" />\r<ul><li><strong>Phân Tách:</strong> Trong một hệ thống, các dịch vụ chủ yếu được phân tách. Do đó, toàn bộ ứng dụng có thể dễ dàng được xây dựng, thay đổi và có thể mở rộng.</li></ul>\r<ul><li><strong>Thành phần hóa:</strong> Microservice được xem như các thành phần độc lập có thể dễ dàng được trao đổi hoặc nâng cấp.</li></ul>\r<ul><li><strong>Kích cỡ nghiệp vụ:</strong> Microservice tương đối đơn giản và chỉ tập trung vào một dịch vụ.</li></ul>\r<ul><li><strong>Quyền tự chủ của nhóm:</strong> Các nhà phát triển làm việc độc lập với nhau, cho phép tiến trình dự án nhanh hơn.</li></ul>\r<ul><li><strong>Phân phối liên tục:</strong> Cho phép phát hành phần mềm thường xuyên thông qua hệ thống tự động hóa phát triển, kiểm tra và phê duyệt phần mềm.</li></ul>\r<ul><li><strong>Trách nhiệm:</strong> Microservices không tập trung vào các ứng dụng như các dự án. Thay vào đó, họ coi các ứng dụng là sản phẩm mà họ chịu trách nhiệm.</li></ul>\r<ul><li><strong>Quản trị phi tập trung:</strong> Lựa chọn công cụ phù hợp theo công việc là mục tiêu. Các nhà phát triển có thể chọn các công cụ tốt nhất để giải quyết vấn đề của họ</li></ul>\r<ul><li><strong>Kết hợp Agile:</strong> Microservices tạo điều kiện cho kết hợp với phương pháp Agile. Có thể tạo các tính năng mới một cách nhanh chóng và loại bỏ chúng bất cứ lúc nào</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thành phần chính trong Microservices?",
              "answer": "<p><em> Containers, Clustering, và Orchestration.\r\n</em> IaC [Infrastructure as Code Conception] \r\n<em> Cloud Infrastructure \r\n</em> API Gateway \r\n<em> Enterprise Service Bus \r\n</em> Service Delivery</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu nhược điểm của Microservices?",
              "answer": "<p><strong>Ưu điểm</strong>\r<ul><li>Module triển khai khép kín và độc lập.</li></ul>\r<ul><li>Các dịch vụ được quản lý độc lập.</li></ul>\r<ul><li>Để cải thiện hiệu suất, dịch vụ yêu cầu có thể được triển khai trên nhiều server.</li></ul>\r<ul><li>Nó dễ kiểm tra hơn và có ít phụ thuộc hơn.</li></ul>\r<ul><li>Khả năng mở rộng lớn hơn.</li></ul>\r<ul><li>Đơn giản trong việc debug và bảo trì.</li></ul>\r<ul><li>Giao tiếp tốt hơn giữa nhà phát triển và người dùng doanh nghiệp.</li></ul>\r<ul><li>Các nhóm phát triển có quy mô nhỏ hơn.</li></ul>\r\n\r\n<strong>Nhược điểm</strong>\r<ul><li>Do sự phức tạp của kiến trúc, việc kiểm tra và giám sát khó khăn hơn.</li></ul>\r<ul><li>Thiếu văn hóa doanh nghiệp phù hợp để nó hoạt động.</li></ul>\r<ul><li>Lập kế hoạch trước là điều cần thiết.</li></ul>\r<ul><li>Phát triển phức tạp.</li></ul>\r<ul><li>Yêu cầu một sự chuyển dịch văn hóa.</li></ul>\r<ul><li>Đắt so với monoliths.</li></ul>\r<ul><li>Nguy cơ về bảo mật.</li></ul>\r<ul><li>Việc duy trì mạng khó khăn hơn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các công cụ thường dùng cho Microservices?",
              "answer": "<p><ul><li>Wiremock</li></ul>\r<ul><li>Docker</li></ul>\r<ul><li>Hstrix</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích kiến trúc Microservice?",
              "answer": "<p><img src=\"/interview-assets/Microservice_Architecture.jpg\" alt=\"\" />\r<ul><li><strong>Clients</strong>: Người dùng khác nhau gửi yêu cầu đến thiết bị khác nhau.</li></ul>\r<ul><li><strong>Identity Provider</strong>: Xác thực định danh người dùng hoặc client và cấp token bảo mật.</li></ul>\r<ul><li><strong>API Gateway</strong>: xử lý yêu cầu từ client.</li></ul>\r<ul><li><strong>Static Content</strong>: Bao gồm tất cả nội dung của hệ thống.</li></ul>\r<ul><li><strong>Management</strong>: Dịch vụ được cản bằng trên các node và lỗi được xác định.</li></ul>\r<ul><li><strong>Service Discovery</strong>: Hướng dẫn khám phá các định tuyến để giao tiếp trong microservices.</li></ul>\r<ul><li><strong>CDN</strong>: bao gồm mạng phân phối của proxy server và trung tâm dữ liệu của họ.</li></ul>\r<ul><li><strong>Remote Service</strong>: Cung cấp khả năng truy cập từ xa vào dữ liệu hoặc thông tin trên các máy tính và thiết bị được nối mạng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Monolithic, SOA và Microservices?",
              "answer": "<p><img src=\"/interview-assets/difference_between_Monolithic__SOA_and_Microservices_Architecture.jpg\" alt=\"\" />\r\n\r\n<strong>Monolithic</strong>: Giống như một container lớn, trong đó là tất cả thành phần của ứng dụng được gói cùng với nhau. Nó được xây dựng như một hệ thống lớn với một code-base.\r\n\r\n<strong>SOA (Serivce-Oriented Architecture)</strong>: Nó là một nhóm các dịch vụ tương tác hoặc giao tiếp với nhau. Tùy thuộc vào bản chất của giao tiếp, nó có thể là trao đổi dữ liệu đơn giản hoặc nó có thể liên quan đến một số dịch vụ phối hợp một số hoạt động. \r\n\r\n<strong>Microservice</strong>: Nó liên quan đến việc cấu trúc một ứng dụng dưới dạng một cluster (cụm) các dịch vụ nhỏ, tự trị được mô hình hóa xung quanh một miền doanh nghiệp. Các module chức năng có thể được triển khai độc lập, có thể mở rộng, nhằm đạt được các mục tiêu kinh doanh cụ thể và giao tiếp với nhau qua các giao thức tiêu chuẩn.</p>",
              "level": "fresher"
            },
            {
              "question": "Cohesion và Coupling là gì?",
              "answer": "<p><strong>Khớp nối (Cohesion):</strong> Nó được định nghĩa là mối quan hệ giữa các module phần mềm A và B, và mức độ một module phụ thuộc hoặc tương tác với một module khác. Các cohesion nối được chia thành ba loại chính:\r<ul><li>Các module phụ thuộc nhiều vào nhau.</li></ul>\r<ul><li>Các module ít phụ thuộc (lỏng lẻo).</li></ul>\r<ul><li>Các module tách rời hoàn toàn.</li></ul>\r\n\r\nLoại cohesion tốt nhất là loại ít phụ thuộc, được thực hiện thông qua các interface.\r\n\r\n<strong>Liên kết (Coupling):</strong> Nó được định nghĩa là mối quan hệ giữa hai hoặc nhiều phần tử của một module phục vụ cùng một mục đích. Nói chung, một module có tính liên kết cao có thể thực hiện một chức năng cụ thể một cách hiệu quả mà không cần giao tiếp với bất kỳ module nào khác. Tính liên kết cao nâng cao chức năng của module.\r\n\r\n<img src=\"/interview-assets/Cohesion_and_Coupling.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Bounded Context là gì?",
              "answer": "<p>Một bounded context là một mẫu trung tâm trong DDD (Domain-Driven Design), đề cập đến sự cộng tác giữa các mô hình và nhóm lớn. DDD chia nhỏ các mô hình lớn thành nhiều ngữ cảnh để giúp chúng dễ quản lý hơn. Ngoài ra, nó giải thích mối quan hệ của chúng một cách rõ ràng. Khái niệm này thúc đẩy phương pháp tiếp cận hướng đối tượng để phát triển các dịch vụ gắn với mô hình dữ liệu và cũng chịu trách nhiệm đảm bảo tính toàn vẹn và khả năng thay đổi của mô hình dữ liệu nói trên.\r\n\r\n<img src=\"/interview-assets/Bounded_Context.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Viết các đặc điểm cơ bản của Thiết kế Microservice?",
              "answer": "<p><ul><li>Dựa trên khả năng kinh doanh: Các dịch vụ được phân chia và tổ chức xoay quanh khả năng kinh doanh.</li></ul>\r<ul><li>Sản phẩm không phải dự án: Một sản phẩm nên thuộc về team có trách nhiệm xử lý nó.</li></ul>\r<ul><li>Dựa vào các framework message: Loại bỏ các bus dịch vụ tập trung bằng cách nắm lấy khái niệm phân quyền.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thách thức khi sử dụng Microservices?",
              "answer": "<p>Những thách thức mà ta phải đối mặt khi sử dụng microservices có thể là cả chức năng và kỹ thuật như dưới đây:\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích PACT trong Microservices?",
              "answer": "<p>PACT được định nghĩa là một công cụ mã nguồn mở cho phép các nhà cung cấp dịch vụ và người tiêu dùng kiểm tra các tương tác một cách tách biệt với các hợp đồng đã được thực hiện để tăng độ tin cậy của tích hợp microservice. Nó cũng cung cấp hỗ trợ cho nhiều ngôn ngữ, chẳng hạn như Ruby, Java, Scala, .NET, JavaScript, Swift/Objective-C.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích cách microservice giao tiếp với các phần khác?",
              "answer": "<p>Giao tiếp giữa các microservice có thể thực hiện:\r<ul><li>HTTP/REST với JSON hoặc giao thức nhị phân cho request/response.</li></ul>\r<ul><li>Websocket cho streaming</li></ul>\r<ul><li>Một broker hoặc server dùng cho các thuật toán routing.</li></ul>\r\n\r\nRabbitMQ, Kafka,... có thể dùng như một message broker, mỗi cái được xây dựng để xử lý message cụ thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Client certificates là gì?",
              "answer": "<p>Client certificates là một loại chứng chỉ kỹ thuật số thường cho phép các hệ thống client xác thực các yêu cầu của họ tới các server từ xa. Trong nhiều thiết kế xác thực lẫn nhau, nó đóng một vai trò quan trọng trong việc cung cấp sự đảm bảo mạnh mẽ về danh tính của người yêu cầu.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về CDC?",
              "answer": "<p>Như tên của nó, CDC (Consumer-Driven Contract) về cơ bản đảm bảo khả năng tương thích giao tiếp dịch vụ bằng cách thiết lập một thỏa thuận giữa người tiêu dùng và nhà cung cấp dịch vụ về định dạng dữ liệu được trao đổi giữa họ. Một thỏa thuận như thế này được gọi là hợp đồng (contract). Nó là một mẫu được sử dụng để phát triển các Microservices để chúng có thể được các hệ thống bên ngoài sử dụng một cách hiệu quả.</p>",
              "level": "fresher"
            },
            {
              "question": "Các công ty nổi tiếng sử dụng kiến trúc Microservices?",
              "answer": "<p><ul><li>Twitter</li></ul>\r<ul><li>Netflix</li></ul>\r<ul><li>Amazon</li></ul>\r\n\r\n## Câu hỏi phỏng vấn cho Experienced</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "nginx",
          "name": "Câu hỏi phỏng vấn Nginx",
          "description": "",
          "questions": [
            {
              "question": "Nginx hoạt động như thế nào?](#1-nginx-ho%E1%BA%A1t-%C4%91%E1%BB%99ng-nh%C6%B0-th%E1%BA%BF-n%C3%A0o)",
              "answer": "<p>[</p>",
              "level": "middle"
            },
            {
              "question": "Các tính năng của Nginx Server?](#2-c%C3%A1c-t%C3%ADnh-n%C4%83ng-c%E1%BB%A7a-nginx-server)",
              "answer": "<p><a href=\"#3-s%E1%BB%B1-kh%C3%A1c-bi%E1%BB%87t-gi%E1%BB%AFa-nginx-v%C3%A0-apache\" target=\"<em>blank\">3. Sự khác biệt giữa Nginx và Apache?</a>\r\n\r\n<a href=\"#4-nginx-x%E1%BB%AD-l%C3%BD-y%C3%AAu-c%E1%BA%A7u-http-nh%C6%B0-th%E1%BA%BF-n%C3%A0o\" target=\"</em>blank\">4. Nginx xử lý yêu cầu HTTP như thế nào?</a>\r\n\r\n<a href=\"#5-trong-nginx-l%C3%A0m-c%C3%A1ch-n%C3%A0o-%C4%91%E1%BB%83-ng%C4%83n-ch%E1%BA%B7n-c%C3%A1c-y%C3%AAu-c%E1%BA%A7u-x%E1%BB%AD-l%C3%BD-v%E1%BB%9Bi-t%C3%AAn-server-kh%C3%B4ng-x%C3%A1c-%C4%91%E1%BB%8Bnh\" target=\"<em>blank\">5. Trong Nginx, làm cách nào để ngăn chặn các yêu cầu xử lý với tên server không xác định?</a>\r\n\r\n<a href=\"#6-%C6%B0u-%C4%91i%E1%BB%83m-c%E1%BB%A7a-%22reverse-proxy-server%22\" target=\"</em>blank\">6. Ưu điểm của \"reverse proxy server\"?</a>\r\n\r\n<a href=\"#7-c%C3%A1ch-d%C3%B9ng-nginx-t%E1%BB%91t-nh%E1%BA%A5t\" target=\"<em>blank\">7. Cách dùng Nginx tốt nhất?</a>\r\n\r\n<a href=\"#8-ti%E1%BA%BFn-tr%C3%ACnh-master-v%C3%A0-worker-trong-nginx\" target=\"</em>blank\">8. Tiến trình master và worker trong Nginx?</a>\r\n\r\n<a href=\"#9-gi%E1%BA%A3i-th%C3%ADch-c%C3%A1ch-kh%E1%BB%9Fi-%C4%91%E1%BB%99ng-nginx-%E1%BB%9F-c%E1%BB%95ng-kh%C3%A1c-80\" target=\"<em>blank\">9. Giải thích cách khởi động Nginx ở cổng khác 80?</a>\r\n\r\n<a href=\"#10-c%C3%B3-th%E1%BB%83-thay-th%E1%BA%BF-l%E1%BB%97i-502-th%C3%A0nh-503-trong-nginx-kh%C3%B4ng\" target=\"</em>blank\">10. Có thể thay thế lỗi 502 thành 503 trong Nginx không?</a>\r\n\r\n<a href=\"#11-trong-nginx-l%C3%A0m-th%E1%BA%BF-n%C3%A0o-gi%E1%BB%AF-d%E1%BA%A5u-g%E1%BA%A1ch-ch%C3%A9o-trong-urls\" target=\"<em>blank\">11. Trong Nginx, làm thế nào giữ dấu gạch chéo trong URLs?</a>\r\n\r\n<a href=\"#12-ngxhttpupstreammodule-l%C3%A0-g%C3%AC\" target=\"</em>blank\">12. ngx<em>http</em>upstream<em>module là gì?</a>\r\n\r\n<a href=\"#13-v%E1%BA%A5n-%C4%91%E1%BB%81-c10k-l%C3%A0-g%C3%AC\" target=\"</em>blank\">13. Vấn đề C10K là gì?</a>\r\n\r\n<a href=\"#14-c%C3%A1ch-d%C3%B9ng-stubstatus-v%C3%A0-subfilter-directives\" target=\"<em>blank\">14. Cách dùng stub</em>status và sub<em>filter directives?</a>\r\n\r\n<a href=\"#15-gi%E1%BA%A3i-th%C3%ADch-nginx-c%C3%B3-h%E1%BB%97-tr%E1%BB%A3-n%C3%A9n-y%C3%AAu-c%E1%BA%A7u-l%C3%AAn-upstream-kh%C3%B4ng\" target=\"</em>blank\">15. Giải thích Nginx có hỗ trợ nén yêu cầu lên upstream không?</a>\r\n\r\n<a href=\"#16-c%C3%A1ch-l%E1%BA%A5y-th%E1%BB%9Di-gian-hi%E1%BB%87n-t%E1%BA%A1i-trong-nginx\" target=\"<em>blank\">16. Cách lấy thời gian hiện tại trong Nginx?</a>\r\n\r\n<a href=\"#17-gi%E1%BA%A3i-th%C3%ADch--s-trong-nginx-server\" target=\"</em>blank\">17. Giải thích -s trong Nginx server?</a>\r\n\r\n<a href=\"#18-c%C3%A1ch-th%C3%AAm-module-v%C3%A0o-nginx-server\" target=\"_blank\">18. Cách thêm module vào Nginx server?</a>\r\n\r\n## Câu hỏi phỏng vấn Nginx</p>",
              "level": "middle"
            },
            {
              "question": "Nginx hoạt động như thế nào?",
              "answer": "<p>Nginx được phát triển cho các mục đích tối ưu việc sử dụng (RAM) bộ nhớ thấp nhưng phục vụ được nhiều kết nối đồng thời cao hơn. Nginx sử dụng kiến trúc hướng sự kiện (event-driven) bất đồng bộ (asynchronous) và có khả năng mở rộng. Ngay cả khi bạn không cần phải xử lý hàng ngàn truy vấn đồng thời, thì bạn vẫn nên sử dụng Nginx do hiệu suất cao và yêu cầu bộ nhớ thấp của Nginx so với Apache.</p>",
              "level": "middle"
            },
            {
              "question": "Các tính năng của Nginx Server?",
              "answer": "<p><ul><li>Có khả năng xử lý hơn 10.000 kết nối cùng lúc với bộ nhớ thấp.</li></ul>\r<ul><li>Phục vụ tập tin tĩnh (static files) và lập chỉ mục tập tin.</li></ul>\r<ul><li>Tăng tốc reverse proxy bằng bộ nhớ đệm (cache), cân bằng tải đơn giản và khả năng chịu lỗi.</li></ul>\r<ul><li>Hỗ trợ tăng tốc với bộ nhớ đệm của FastCGI, uwsgi, SCGI, và các máy chủ memcached.</li></ul>\r<ul><li>Kiến trúc modular, tăng tốc độ nạp trang bằng nén gzip tự động.</li></ul>\r<ul><li>Hỗ trợ mã hoá SSL và TLS.</li></ul>\r<ul><li>Cấu hình linh hoạt; lưu lại nhật ký truy vấn</li></ul>\r<ul><li>Chuyển hướng lỗi 3XX-5XX</li></ul>\r<ul><li>Rewrite URL (URL rewriting) dùng regular expressions</li></ul>\r<ul><li>Hạn chế tỷ lệ đáp ứng truy vấn</li></ul>\r<ul><li>Giới hạn số kết nối đồng thời hoặc truy vấn từ 1 địa chỉ</li></ul>\r<ul><li>Khả năng nhúng mã PERL</li></ul>\r<ul><li>Hỗ trợ và tương thích với IPv6</li></ul>\r<ul><li>Hỗ trợ WebSockets</li></ul>\r<ul><li>Hỗ trợ truyền tải file FLV và MP4</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa Nginx và Apache?",
              "answer": "<p>| Nginx | Apache |\r\n|-|-|\r\n| Là web server dựa trên sự kiện | Là web server dựa trên tiến trình |\r\n| Tất cả yêu cầu được xử lý đơn luồng | Mỗi luồng xử lý một yêu cầu đơn |\r\n| Nginx tránh ý tượng tiến trình con | Apache dựa trên tiến trình con |\r\n| Nginx thiên về tốc độ | Apache thiên về sức mạnh |\r\n| Nginx tốt hơn khi nói đến mức tiêu thụ bộ nhớ và kết nối | Apache không đạt chuẩn khi nói đến mức tiêu thụ bộ nhớ và kết nối |\r\n| Nginx tốt hơn khi muốn cân bằng tải | Apache sẽ từ chối các kết nối mới khi lưu lượng đạt đến giới hạn của các tiến trình |\r\n| Nginx không hỗ trợ hệ điều hành như IBMi và OpenVMS | Apache hỗ trợ nhiều hệ điều hành hơn |\r\n| Nginx chỉ đi kèm tính năng cốt lỗi | Apache cung cấp nhiều hàm hơn Nginx |\r\n| Hiệu suất và khả năng mở rộng không phụ thuộc phần cứng | Phụ thuộc phần cứng như CPU hay bộ nhớ |</p>",
              "level": "middle"
            },
            {
              "question": "Nginx xử lý yêu cầu HTTP như thế nào?",
              "answer": "<p>Nginx sử dụng react pattern. Event loop chính đợi hệ điều hành báo hiệu một sự kiện sẵn sàng - sao cho dữ liệu có thể truy cập để đọc từ một socket, tại thời điểm đó, nó được đọc vào bộ đệm và được xử lý. Một luồng đơn có thể phục vụ hàng chục nghìn kết nối đồng thời.</p>",
              "level": "middle"
            },
            {
              "question": "Trong Nginx, làm cách nào để ngăn chặn các yêu cầu xử lý với tên server không xác định?",
              "answer": "<p>``<code>\r\nServer {\r\n    listen 80;\r\n\r\n    server_name \"\";\r\n\r\n    return 444;\r\n}\r\n</code>``\r\n\r\nỞ đây, tên server được giữ dưới dạng một chuỗi trống sẽ khớp với yêu cầu mà không có trường tiêu đề <strong>Host</strong> và code không chuẩn 444 của Nginx đặc biệt được trả về sẽ chấm dứt kết nối.</p>",
              "level": "middle"
            },
            {
              "question": "Ưu điểm của \"reverse proxy server\"?",
              "answer": "<p>Reverse proxy server có thể ẩn sự hiện diện và đặc điểm của server gốc. Nó hoạt động như một trung gian giữa internet cloud và web server. Nó tốt cho lý do bảo mật, đặc biệt là khi bạn đang sử dụng các dịch vụ lưu trữ web.</p>",
              "level": "middle"
            },
            {
              "question": "Cách dùng Nginx tốt nhất?",
              "answer": "<p>Cách sử dụng tốt nhất Nginx server là triển khai nội dung HTTP động trên mạng bằng cách sử dụng server ứng dụng SCGI, WSGI, trình xử lý FastCGI cho script. Nó cũng có thể hoạt động như một bộ cân bằng tải.</p>",
              "level": "middle"
            },
            {
              "question": "Tiến trình master và worker trong Nginx?",
              "answer": "<p><ul><li><strong>Tiến trình master:</strong> nó đọc cũng như đánh giá cấu hình và duy trì tiến trình worker.</li></ul>\r<ul><li><strong>Tiến trình worker:</strong> nó xử lý yêu cầu thực.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Giải thích cách khởi động Nginx ở cổng khác 80?",
              "answer": "<p>Để khởi động Nginx ở các công khác, ta đi đến <code>/etc/Nginx/sites-enabled/</code> và nếu đây là file mặc định, thì bạn phải mở file có tên là \"default\". Chỉnh sửa file và sửa cổng mà bạn muốn</p>",
              "level": "middle"
            },
            {
              "question": "Có thể thay thế lỗi 502 thành 503 trong Nginx không?",
              "answer": "<p><ul><li>502= Bad gateway</li></ul>\r<ul><li>503= Server overloaded</li></ul>\r\n\r\nCó thể, nhưng phải đảm bảo rằng <code>fastcgi<em>intercept</em>errors</code> được đặt ON, và sử dụng điều hướng lỗi trang.\r\n\r\n``<code>\r\nLocation / {\r\n\r\nfastcgi<em>pass 127.0.01:9001;\r\n\r\nfastcgi</em>intercept<em>errors on;\r\n\r\nerror</em>page 502 =503/error_page.html;\r\n\r\n#...\r\n\r\n}\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Trong Nginx, làm thế nào giữ dấu gạch chéo trong URLs?",
              "answer": "<p>Để giữ dấu gạch chéo (/) trong URL, ta có thể dùng <code>merge<em>slashes</em>off;</code>\r\n\r\nCú pháp: <code>merge<em>slashes [on/off]</code>\r\n\r\nMặc định: <code>merge</em>slashes_on</code>\r\n\r\nNgữ cảnh: http, server</p>",
              "level": "middle"
            },
            {
              "question": "ngx_http_upstream_module là gì?",
              "answer": "<p>ngx<em>http</em>upstream_module được dùng để xác định nhóm server có thể tham chiếu bằng pass fastcgi, pass proxy, pass uwsgi, pass memcached và scgi pass directives.</p>",
              "level": "middle"
            },
            {
              "question": "Vấn đề C10K là gì?",
              "answer": "<p>Vấn đề C10K là do socket mạng không thể xử lý một số lượng lớn máy khách (10.000 người dùng) cùng một lúc.</p>",
              "level": "middle"
            }
          ]
        },
        {
          "id": "nodejs",
          "name": "Câu hỏi phỏng vấn Node.js",
          "description": "",
          "questions": [
            {
              "question": "First class function là gì?",
              "answer": "<p>First class function hay hàm hạng nhất là khi một hàm được sử dụng như một biến (được gán, truyền như tham số hay trả về). Có nhiều ngôn ngữ lập trình như Scala, Haskell, và JavaScript... đều có hàm hạng nhất.\r\nCác hàm này có thể truyền dưới dạng tham số hay trả về cho một hàm khác gọi là HOC(high-order function).\r\n\r\nCác hàm <code>map()</code> và <code>filter()</code> là các HOC phổ biến được dùng.</p>",
              "level": "fresher"
            },
            {
              "question": "Node.js hoạt động thế nào?",
              "answer": "<p>Node hoàn toàn theo cơ chế event-driven. Về cơ bản server bao gồm một luồng duy nhất xử lý từ sự kiện này đến sự kiện khác.\r\n\r\nMột yêu cầu mới đến là một loại sự kiện. Server bắt đầu xử lý nó và khi có hoạt động blocking IO, nó sẽ không đợi cho đến khi hoàn thành mà thay vào đó sẽ đăng ký một hàm callback. Sau đó, server ngay lập tức bắt đầu xử lý một sự kiện khác (có thể là một yêu cầu khác). Khi hoạt động IO kết thúc, đó là một loại sự kiện khác và server sẽ xử lý nó (tức là tiếp tục làm việc theo yêu cầu) bằng cách thực hiện lệnh callback ngay khi có thời gian.\r\n\r\nVì vậy, server không bao giờ cần tạo thêm các luồng hoặc chuyển đổi giữa các luồng, có nghĩa là nó có rất ít chi phí. Nếu bạn muốn sử dụng đầy đủ nhiều lõi phần cứng, bạn chỉ cần bắt đầu nhiều đối tượng node.js\r\n\r\nNền tảng Node.js không tuân theo mô hình đa luồng. Mà nó theo mô hình đơn luồng với Event Loop. Mô hình xử lý trong Node.js chủ yếu dựa trên mô hình JavaScript Event và cơ chế callback.\r\n\r\nCác bước trong mô hình xử lý đơn luồng với Event Loop:\r<ul><li>Client gửi yêu cầu đến web server.</li></ul>\r<ul><li>Web server Node.js duy trì một Thread pool để cung cấp dịch vụ cho các yêu cầu từ client.</li></ul>\r<ul><li>Node.js nhận các yêu cầu này và đặt nó vào một hàng đợi. Gọi là Event Queue.</li></ul>\r<ul><li>Trong Nodejs có một thành phần là Event Loop. Nó sử dụng một vòng lặp để nhận yêu cầu và xử lý chúng.</li></ul>\r<ul><li>Event Loop sử dụng một luồng duy nhất. Nó được gọi là trái tim của Node.js</li></ul>\r<ul><li>Event Loop kiểm tra yêu cầu có ở trong Event Queue. Nếu khong nó sẽ đợi cho đến khi yêu cầu đến.</li></ul>\r<ul><li>Nếu có, nó lấy yêu cầu từ Event Queue:</li></ul>\r<ul><li>Nó bắt đầu xử lý yêu cầu đó.</li></ul>\r<ul><li>Nếu yêu cầu đó không phải là blocking IO, thì nó xử lý và chuẩn bị phản hồi để gửi về client.</li></ul>\r<ul><li>Nếu nó cần vài thao tác blocking IO như tương tác với cơ sở dữ liệu, hệ thống file, mạng thì nó sẽ có cách tiếp cận khác:</li></ul>\r<ul><li>Kiểm tra luồng khả dụng từ Thread Pool</li></ul>\r<ul><li>Chọn luồng và gán nó cho yêu cầu client.</li></ul>\r<ul><li>Các luồng này nhận yêu cầu và xử lý chúng thực hiện hành động blocking IO, chuẩn bị phản hồi và gửi nó về Event Loop.</li></ul>\r<ul><li>Event Loop lấy nó và gửi phản hồi đó về lại client.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Quản lý package trong ứng dụng Node.js?",
              "answer": "<p>Khi thảo luận về Node js thì một điều chắc chắn không nên bỏ qua là xây dựng package quản lý sử dụng các công cụ NPM mà mặc định với mọi cài đặt Node js. Ý tưởng của mô-đun NPM là khá tương tự như Ruby-Gems: một tập hợp các hàm có sẵn có thể sử dụng được, thành phần tái sử dụng, tập hợp các cài đặt dễ dàng thông qua kho lưu trữ trực tuyến với các phiên bản quản lý khác nhau. Bên cạnh npm cũng có thể sử dụng yarn với bộ chức năng tương tự.</p>",
              "level": "fresher"
            },
            {
              "question": "Node.js có tốt hơn các framework khác?",
              "answer": "<p><ul><li><strong>Bất đồng bộ</strong>: Đặc điểm đầu tiên của Nodejs là tính bất đồng bộ. Node.js không cần đợi API trả dữ liệu về, vậy nên mọi APIs nằm trong thư viện Node.js đều không được đồng bộ, hiểu đơn giản là chúng không hề blocking (khóa). Server có cơ chế riêng để gửi thông báo và nhận phản hồi về các hoạt động của Node.js và API đã gọi.</li></ul>\r<ul><li><strong>Tốc độ nhanh</strong>: Với phần core phía dưới lập trình gần như toàn bộ bằng ngôn ngữ C++, kết hợp với V8 Javascript Engine mà Google Chrome cung cấp, tốc độ vận hành, thực hiện code của thư viện Node.js diễn ra rất nhanh.</li></ul>\r<ul><li><strong>Đơn giản/Hiệu quả</strong>: Tiến trình vận hành của Node.js đơn giản song lại mang đến hiệu năng cao nhờ ứng dụng mô hình single thread và các sự kiện lặp. Một loạt cơ chế sự kiện cho phép server trả về phản hồi bằng cách không block, đồng thời tăng hiệu quả sử dụng. Các luồng đơn cung cấp dịch vụ cho nhiều request hơn hẳn Server truyền thống.</li></ul>\r<ul><li><strong>Không đệm</strong>: Nền tảng Node.js không có vùng đệm, tức không cung cấp khả năng lưu trữ dữ liệu buffer.</li></ul>\r<ul><li><strong>Có giấy phép</strong>: Đây là nền tảng đã được cấp giấy phép, phát hành dựa trên MIT License.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các bước để luồng điều khiển kiểm soát các lệnh gọi hàm?",
              "answer": "<p><ul><li>Kiểm soát trật tự thực thi</li></ul>\r<ul><li>Thu thập dữ liệu</li></ul>\r<ul><li>Giới hạn đồng thời</li></ul>\r<ul><li>Gọi bước sau trong chương trình.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các tính năng thời gian của Node.js?",
              "answer": "<p>Các hàm Set Timer:\r<ul><li><code>setImmediate()</code> : chạy ngay lập tức (thực ra nó sẽ chạy ở lần lặp tiếp theo trong event loop)</li></ul>\r<ul><li><code>setTimeout()</code> : chạy trong một khoảng thời gian.</li></ul>\r<ul><li><code>setInterval()</code>: lặp đi lặp lại trong khoảng thời gian</li></ul>\r\n\r\nCác hàm Clear timer\r<ul><li><code>clearImmediate()</code> : dừng một đối tượng setImmediate, tạo bởi hàm setImmediate()</li></ul>\r<ul><li><code>clearTimeout()</code> : dừng một đối tượng setTimeout, tạo bởi hàm setTimeout()</li></ul>\r<ul><li><code>clearInterval()</code> : dừng một đối tượng setInterval, tạo bởi hàm setInterval()</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của promise so với callback?",
              "answer": "<p>Ưu điểm chính của việc sử dụng <strong>promise</strong> là bạn có được một đối tượng để quyết định hành động cần được thực hiện sau khi tác vụ bất đồng bộ hoàn thành. Điều này cung cấp cod dễ quản lý hơn và tránh callback hell.</p>",
              "level": "fresher"
            },
            {
              "question": "fork trong Node.js là gì?",
              "answer": "<p>Một fork dùng cho tạo các tiến trình con. Trong nodejs, nó được dùng để tạo thực thể mới của v8 để chạy nhiều worker cho thực thi code.</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao Node.js lại là đơn luồng?",
              "answer": "<p>Node.js được tạo rõ ràng như một thử nghiệm trong xử lý bất đồng bộ. Lý thuyết là thực hiện xử lý bất đồng bộ trên một luồng duy nhất có thể cung cấp hiệu suất và khả năng mở rộng cao hơn so với các triển khai đa luồng truyền thống.\r\n\r\nMột ứng dụng node.js không hoạt động chuyên sâu về CPU có thể chạy hàng nghìn kết nối đồng thời tốt hơn Apache hoặc IIS hoặc các máy chủ đa luồng khác.</p>",
              "level": "fresher"
            },
            {
              "question": "Tạo ứng dụng hello world với node.js?",
              "answer": "<p>``<code>js\r\nvar http = require(\"http\");\r\nhttp.createServer(function (request, response) {\r\n    response.writeHead(200, {'Content-Type': 'text/plain'});\r\n    response.end('Hello World\\n');\r\n}).listen(3000);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu hàm API trong node.js?",
              "answer": "<p>Có hai kiểu hàm API:\r<ul><li>Hàm bất đồng bộ, non-blocking: sử dụng chủ yếu cho các hoạt động I/O có thể tách ra khỏi vòng lặp chính.</li></ul>\r<ul><li>Hàm đồng bộ, blocking: sử dụng cho các hoạt động ảnh hưởng đến tiến trình đang chạy trong vòng lặp chính.</li></ul>\r\n\r\n<strong>Hàm blocking</strong> trong các thao tác blocking, tất cả code khác sẽ bị ngăn khi cho đến khi thực hiện xong thao tác IO. Vd:\r\n\r\n``<code>js\r\nconst fs = require('fs');\r\nconst data = fs.readFileSync('/file.md'); // blocks here until file is read\r\nconsole.log(data);\r\n// moreWork(); will run after console.log\r\n</code>`<code>\r\n\r\nDòng code thứ hai chặn việc thực thi JavaScript bổ sung cho đến khi toàn bộ file được đọc. </code>moreWork()<code> sẽ chỉ được gọi sau </code>console.log<code>.\r\n\r\n<strong>Hàm non-blocking</strong> trong các thao tác non-blocking, nhiều lệnh gọi IO có thể thực hiện mà chương trình không bị tạm dừng. Vd:\r\n\r\n</code>`<code>js\r\nconst fs = require('fs');\r\nfs.readFile('/file.md', (err, data) => {\r\n  if (err) throw err;\r\n  console.log(data);\r\n});\r\n// moreWork(); will run before console.log\r\n</code>`<code>\r\n\r\nVì </code>fs.readFile()<code> là không chặn, </code>moreWork()` không phải đợi file đọc xong trước khi được gọi.</p>",
              "level": "fresher"
            },
            {
              "question": "REPL là gì?",
              "answer": "<p>REPL là từ viết tắt của Read Eval Print Loop (hiểu nôm na là: Đọc – Đánh giá – In – Lặp) và nó biểu diễn môi trường máy tính như màn hình console trong Linux shell nơi bạn có thể gõ các dòng lệnh và hệ thống sẽ trả về các kết quả. NodeJS cũng có môi trường REPL. Nó để thực hiện các tác vụ mong muốn:\r\n\r\n<strong>Read</strong>: Đọc các thông tin input của người dùng, chuyển đổi thành các dữ liệu Javascript và lưu trữ trong bộ nhớ.\r\n\r\n<strong>Eval</strong>: Đánh giá các cấu trúc dữ liệu này.\r\n\r\n<strong>Print</strong>: In các kết quả.\r\n\r\n<strong>Loop</strong>: Lặp các dòng lệnh đến khi người dùng gõ ctrl-c hai lần.</p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa bất đồng bộ và non-blocking?",
              "answer": "<p><ul><li><strong>Bất đồng bộ:</strong> Kiến trúc của bất đồng bộ giải thích rằng thông điệp được gửi sẽ không trả lời ngay lập tức giống như chúng ta gửi mail nhưng không nhận được trả lời ngay lập tức. Nó không có bất kỳ sự phụ thuộc hay thứ tự nào. Do đó cải thiện hiệu quả và hiệu suất của hệ thống. Server lưu trữ thông tin và khi hành động được thực hiện, nó sẽ được thông báo.</li></ul>\r<ul><li><strong>Non-blocking:</strong> Non-blocking phản hồi ngay lập tức với bất kỳ dữ liệu nào có sẵn. Hơn nữa, nó không chặn bất kỳ quá trình thực thi nào và tiếp tục chạy từng yêu cầu. Nếu một câu trả lời không thể được truy xuất hơn trong những trường hợp đó, API trả về ngay lập tức với một lỗi. Tính năng non-block hầu hết được sử dụng với I/O (input/output). Bản thân Node.js dựa trên mô hình I/O non-blocking. Hàm callback sẽ được gọi khi hoạt động hoàn thành. Lệnh gọi non-blocking sử dụng sự trợ giúp của javascript cung cấp chức năng callback.</li></ul>\r\n\r\n| Bất đồng bộ | Non-blocking |\r\n|-|-|\r\n| Bất đồng bộ không phản hồi ngay lập tức | Non-blocing phản hồi ngay lập tức nếu dữ liệu khả dụng còn không nó sẽ trả về lỗi |\r\n| Bất đồng bộ cải thiện hiệu quả bằng cách thực hiện tác vụ nhanh chóng vì phản hồi có thể đến sau đó, trong lúc đó có thể hoàn thành các tác vụ khác | Non-blocking không chặn bất kỳ quá trình thực thi nào và nếu dữ liệu có sẵn, nó sẽ truy xuất thông tin một cách nhanh chóng |\r\n| Là đối nghịch của đồng bộ | Là đối nghịch của blocking IO |</p>",
              "level": "fresher"
            },
            {
              "question": "Ý nghĩa của module.exports?",
              "answer": "<p>Được sử dụng để hiển thị các chức năng của một module hoặc file cụ thể sẽ được sử dụng ở những nơi khác trong dự án. Nó có thể được sử dụng để đóng gói tất cả các chức năng tương tự trong một file giúp cải thiện cấu trúc dự án.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nconst getSolutionInJavaScript = async ({\r\n    problem<em>id\r\n}) => {\r\n...\r\n};\r\nconst getSolutionInPython = async ({\r\n    problem</em>id\r\n}) => {\r\n    ...\r\n};\r\nmodule.exports = { getSolutionInJavaScript, getSolutionInPython }\r\n</code>`<code>\r\n\r\nBây giờ ta có thể sử dụng lại các hàm trên ở file khác:\r\n\r\n</code>`<code>js\r\nconst { getSolutionInJavaScript, getSolutionInPython} = require(\"./utils\")\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Công cụ dùng để đảm bảo code style nhất quán?",
              "answer": "<p>ESLint có thể dùng với bất kỳ IDE nào để đảm bảo code style nhất quán cho duy trì codebase trong tương lai.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "php",
          "name": "Câu hỏi phỏng vấn PHP",
          "description": "",
          "questions": [
            {
              "question": "Sự khác biệt giữa biến và hằng trong PHP?",
              "answer": "<p>| Biến | Hằng |\r\n|------|------|\r\n| Có thể thay đổi giá trị khi thực thi script | Không thể thay đổi giá trị khi thực thi script |\r\n| Các biến yêu cầu bắt buộc sử dụng ký hiệu $ khi bắt đầu | Ký hiệu $ không bắt buộc khi dùng hằng |\r\n| Có thể khai báo thông qua phép gán đơn giản | Không thể khai báo qua phép gán mà phải sử dụng hàm define() |\r\n| Scope mặc định là scope đang truy cập | Có thể được truy cập bởi bất kỳ scope nào |</p>",
              "level": "fresher"
            },
            {
              "question": "Session trong PHP là gì?",
              "answer": "<p>Session là một cách để lưu trữ thông tin (trong các biến) được sử dụng trên nhiều trang.\r\n\r\nKhông giống như một cookie, thông tin session được lưu trữ trên server, chứ không được lưu trữ trên máy tính người dùng.\r\n\r\nKhi bạn làm việc với một ứng dụng, bạn mở nó, thực hiện một số thay đổi, và sau đó bạn đóng nó lại. Điều này giống như một phiên (session). Máy tính biết bạn là ai. Nó biết khi bạn bắt đầu ứng dụng và khi bạn kết thúc. Nhưng trên internet có một vấn đề: máy chủ web không biết bạn là ai hoặc bạn làm gì, vì giao thức HTTP không duy trì trạng thái.\r\n\r\nCác biến session giải quyết vấn đề này bằng cách lưu trữ thông tin người dùng được sử dụng trên nhiều trang (ví dụ: tên người dùng, sở thích, v.v.). Theo mặc định, các biến session tồn tại cho đến khi người dùng đóng trình duyệt.\r\n\r\nVì thế biến sesion giữ thông tin về một người dùng duy nhất và có sẵn cho tất cả các trang trong một ứng dụng.</p>",
              "level": "fresher"
            },
            {
              "question": "PEAR là gì?",
              "answer": "<p>PEAR là viết tắt của <strong>PHP Extension and Application Repository</strong>. Mục đích chính của nó là trở thành một kho chứa cho phần mã thư viện và mở rộng dùng cho PHP, và với tham vọng định ra các chuẩn mực có thể giúp các nhà phát triển tạo nên những dòng mã khả chuyển và có thể dùng lại.\r\n\r\nPEAR  nó cung cấp:\r<ul><li>Một thư viện có cấu trúc các mã nguồn mở cho người dùng PHP.</li></ul>\r<ul><li>Một hệ thống phân phối và đóng gói mã nguồn</li></ul>\r<ul><li>Một phong cách chuẩn viết mã trong PHP</li></ul>\r<ul><li>PHP Foundation Classes (PFC)</li></ul>\r<ul><li>PHP Extension Community Library (PECL)</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích sự khác biệt giữa `$message` và `$$message`?",
              "answer": "<p>| $message | $$message |\r\n|----------|-----------|\r\n| Là biến thông thường | Là biến tham chiếu |\r\n| Có tên và lưu trữ giá trị cố định | Lưu trữ dữ liệu về biến |\r\n| Lưu trữ dữ liệu cố định | Dữ liệu được lưu có thể thay đổi khi giá trị của biến thay đổi |</p>",
              "level": "fresher"
            },
            {
              "question": "PHP có phải là case-sensitive?",
              "answer": "<p>PHP chỉ case-sensitive một nữa. Tên các biến là phân biệt hoa thường nhưng hàm thì không. \r\n\r\nVí dụ: các hàm do người dùng định nghĩa trong PHP có thể được định nghĩa bằng chữ thường nhưng sau đó được gọi bằng chữ hoa thì nó vẫn hoạt động bình thường.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu dữ liệu trong PHP?",
              "answer": "<p><img src=\"/interview-assets/Different_Types_Of_PHP_Variables.jpg\" alt=\"\" />\r\n\r\nCó 8 kiểu dữ liệu chính trong PHP cho khai báo biến:\r<ul><li><strong>Integer:</strong> bao gồm toàn bộ số nguyên. Vd: 1235</li></ul>\r<ul><li><strong>Double:</strong> bao gồm các số dấu phẩy động như 7.786</li></ul>\r<ul><li><strong>Booleans:</strong> biểu diễn giá trị luân lý - true hoặc false.</li></ul>\r<ul><li><strong>NULL:</strong> là kiểu đặc biệt chỉ có một giá trị là NULL. Khi không có giá trị nào được gán cho một biến, nó có thể được gán với NULL. </li></ul>\r<ul><li><strong>Arrays:</strong> là tập hợp có thứ tự với kiểu dữ liệu giống nhau. </li></ul>\r<ul><li><strong>Strings:</strong> là chuỗi tuần tự các ký tự.</li></ul>\r<ul><li><strong>Resources:</strong> là biến đặc biệt bao gồm tham chiếu đến các nguồn tài nguyên bên ngoài PHP.</li></ul>\r<ul><li><strong>Objects:</strong> là thực thể của lớp bao gồm dữ liệu và hàm</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Luật đặt tên biến trong PHP?",
              "answer": "<p><ul><li>Biến phải bắt đầu với ký tự dollar \"$\", theo sau là tên biến. Ví dụ: <code>$price=100</code>, trong đó price là tên biến.</li></ul>\r<ul><li>Tên biến phải bắt đầu là một ký tự chữ cái hoặc gạch dưới.</li></ul>\r<ul><li>Tên biến có thể bao gồm chữ cái, số hay gạch dưới. Nhưng không thể sử dụng ký tự như <code>+</code>, <code>-</code>, <code>%</code>, <code>&</code>,...</li></ul>\r<ul><li>Tên biến không thể bao gồm khoảng trắng.</li></ul>\r<ul><li>Biến PHP phân biệt hoa thường. Nên $NAME và $name là hai biến khác nhau.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa echo và print trong PHP?",
              "answer": "<p>| echo | print |\r\n|------|-------|\r\n| echo có thể xuất một hay nhiều chuỗi | print chỉ xuất một chuỗi và luôn trả về 1 |\r\n| echo nhanh hơn print vì không phải trả về giá trị | print chậm hơn echo |\r\n| Nếu bạn muốn truyền nhiều hơn một tham số cho echo, thì nên sử dụng dấu ngoặc đơn | Không bắt buộc phải sử dụng dấu ngoặc với danh sách đối số |</p>",
              "level": "fresher"
            },
            {
              "question": "Hạn chế của PHP?",
              "answer": "<p><ul><li>Nhược điểm phải nói đến đầu tiên khi dùng PHP chính là cấu trúc ngôn ngữ của nó nhìn không được gọn gàng cho lắm. Mọi câu lệnh được viết trong cặp câu lệnh <code><?php … ?></code>.</li></ul>\r<ul><li>Không giống như Java và C# khi bạn học thì có thể làm website, các ứng dụng điện thoại, chương trình hay phần mềm… . tuy nhiên đối với PHP chỉ có thể sử dụng làm website và các ứng dụng website mở rộng mà thôi.</li></ul>\r<ul><li>Nhược điểm lớn nhất đáng nói đến là khả năng bị sao chép và hack mã code dễ hơn và độ an toàn không cao như các ngôn ngữ lập trình khác. Nhưng từ khi lên phiên bản PHP 7 chấm trở lên đã khác phục được rất nhiều vấn đề này.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "HTML và PHP tương tác như thế nào?",
              "answer": "<p>Script PHP có thể tạo ra HTML, và có thể chuyển thông tin từ HTML sang PHP.\r\n\r\nPHP là ngôn ngữ server-side trong khi HTML là ngôn ngữ client-side. Vì vậy PHP thực thi ở phía server và tạo ra kết quả là chuỗi, mảng, đối tượng rồi hiển thị các giá trị đó ở HTML.</p>",
              "level": "fresher"
            },
            {
              "question": "@ trong PHP là gì?",
              "answer": "<p>PHP có một toán tử kiểm soát lỗi, tức là ký hiệu (<code>@</code>). Bất cứ khi nào nó được sử dụng với một biểu thức, thì tất cả thông báo lỗi nào có thể được tạo ra bởi biểu thức đó sẽ bị bỏ qua.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về Parser trong PHP?",
              "answer": "<p>Một PHP Parser là một phần mềm chuyển mã nguồn PHP thành code mà máy tính có thể hiểu được. Tức là bất cứ tập hướng dẫn nào mà ta đưa ra dưới dạng code PHP đều được trình phân tích cú pháp chuyển đổi thành dạng máy có thể đọc được.\r\n\r\nTa có thể parse code PHP bằng cách dùng hàm <code>token<em>get</em>all()</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu array trong PHP?",
              "answer": "<p>Trong PHP có 3 kiểu array:\r\n\r\n<img src=\"/interview-assets/Types_of_Arrays_in_PHP.jpg\" alt=\"\" />\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích các kiểu lỗi?",
              "answer": "<p>Có 3 kiểu lỗi trong PHP:\r<ul><li><strong>Notices</strong>: là những lỗi không nghiêm trọng có thể xảy ra trong quá trình thực thi script. Những điều này không hiển thị cho người dùng. Ví dụ một biến undefined.</li></ul>\r<ul><li><strong>Warrnings</strong>: là những cảnh báo quan trọng hơn. Warning không làm gián đoạn quá trình thực thi script. Theo mặc định chúng hiển thị cho người dùng. Vd: <code>include</code> một file không tồn tại.</li></ul>\r<ul><li><strong>Fatal</strong>: là loại lỗi nghiêm trọng nhất khi xảy ra, nó sẽ chấm dứt thực thi script. Vd truy cập thuộc tính của một đối tượng không tồn tại hoặc <code>require()</code> một file không tồn tại.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Trait là gì?",
              "answer": "<p>Traits là một cơ chế để tái sử dụng code trong các ngôn ngữ đơn kế thừa như PHP. Một Trait nhằm giảm hạn chế của sự đơn thừa kế bằng cách cho phép nhà phát triển sử dụng lại các bộ phương thức một cách tự do trong một số lớp độc lập trong các hệ thống phân cấp lớp khác nhau.\r\n\r\nMột Trait tương tự như một lớp (Class), nhưng chỉ nhằm mục đích nhóm chức năng một cách chi tiết và nhất quán. Và nó không có khả năng khởi tạo ví dụ: <code>new class ABC()</code>. Nó là một sự bổ sung cho sự thừa kế truyền thống (đơn kế thừa) trong ngôn ngữ PHP.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "python",
          "name": "Câu hỏi phỏng vấn Python",
          "description": "",
          "questions": [
            {
              "question": "Thế nào là ngôn ngữ kiểu động?",
              "answer": "<p>Trước khi hiểu về ngôn ngữ kiểu động ta nên biết về kiểu là gì. Trong ngôn ngữ lập trình, kiểu đề cập đến việc kiểm tra kiểu dữ liệu. Nếu một ngôn ngữ kiểu mạnh, thì <code>\"1\" + 2</code> sẽ báo lỗi vì không thể tự động ép kiểu. Nhưng nếu là ngôn ngữ kiểu yếu thì sẽ cho về kết quả là <code>12</code>.\r\n\r\nKiểm tra kiểu có hai loại:\r<ul><li><strong>Static</strong>: kiểm tra kiểu dữ liệu trước khi thực thi.</li></ul>\r<ul><li><strong>Dynamic</strong>: kiểm tra kiểu dữ liệu khi đang thực thi.</li></ul>\r\n\r\nPython là ngôn ngữ thông dịch, thực thi câu lệnh theo từng dòng do đó việc kiểm tra kiểu xảy ra khi đang thực thi. Python là ngôn ngữ kiểu động.\r\n\r\n<img src=\"/interview-assets/dynamically_typed_language.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Ngôn ngữ thông dịch là gì?",
              "answer": "<p>Ngôn ngữ thông dịch là ngôn ngữ thực thi từng dòng lệnh, ví dụ như Python, JavaScript, R, PHP và Ruby. Chương trình viết bằng ngôn ngữ thông dịch có thể chạy trực tiếp từ code, không cần bước biên dịch.</p>",
              "level": "fresher"
            },
            {
              "question": "PEP 8 là gì và tại sao nó lại quan trọng?",
              "answer": "<p>PEP là viết tắt của <strong>Python Enhancement Proposal</strong>. Một PEP là một tài liệu thiết kế chính thống cung cấp thông tin từ cộng đồng Python hoặc mô tả tính năng mới của Python. PEP 8 đặc biệt quan trọng vì nó ghi lại các hướng dẫn về phong cách code Python. Rõ ràng là việc đóng góp cho cộng đồng mã nguồn mở Python đòi hỏi bạn phải tuân theo các nguyên tắc về phong cách này một cách nghiêm ngặt.</p>",
              "level": "fresher"
            },
            {
              "question": "Scope trong Python?",
              "answer": "<p>Phạm vi (scope) đề cập đến vùng code mà từ đó đối tượng trong Python có thể truy cập được. Do đó, ta không thể truy cập bất kỳ đối tượng cụ thể nào từ bất kỳ nơi nào trong code, việc truy cập phải được cho phép theo phạm vi của đối tượng.\r\n\r\nCác kiểu phạm vi trong Python:\r<ul><li>Một <strong>local scope</strong> đề cập đến đối tượng cục bộ khả dụng trong hàm hiện tại.</li></ul>\r<ul><li>Một <strong>global scope</strong> đề cập đến đối tượng khả dụng trong suốt quá trình thực thi code kể từ khi chúng ra đời.</li></ul>\r<ul><li>Một <strong>module-level scope</strong> đề cập đến đối tượng toàn cục của module hiện tại có thể truy cập trong chương trình.</li></ul>\r<ul><li>Một <strong>outermost scope</strong> đề cập đến các tên built-in có thể gọi trong chương trình.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "List và Tuple là gì? Sự khác biệt giữa chúng?",
              "answer": "<p>List và Tuple là hai kiểu dữ liệu tuần tự cho lưu trữ tập hợp đối tượng trong Python. List được biểu diễn bằng cặp ngoặc vuông <code>['sara', 6, 0.19]</code> trong khi tuple được biểu diễn bằng dấu ngoặc đơn <code>('ansh', 5, 0.97)</code>.\r\n\r\nBên cạnh sự khác biệt về cú pháp, điểm khác biệt chính của cả hai là tuple chỉ lưu đối tượng <em>bất biến</em>. Có nghĩa là list có thể chỉnh sửa, thêm hay xoá trong khi tuple chỉ lưu hằng và không chỉnh sửa gì được. \r\n\r\n``<code>python\r\nmy<em>tuple = ('sara', 6, 5, 0.97)\r\nmy</em>list = ['sara', 6, 5, 0.97]\r\nprint(my<em>tuple[0])     # output => 'sara'\r\nprint(my</em>list[0])     # output => 'sara'\r\nmy<em>tuple[0] = 'ansh'    # modifying tuple => throws an error\r\nmy</em>list[0] = 'ansh'    # modifying list => list modified\r\nprint(my<em>tuple[0])     # output => 'sara'\r\nprint(my</em>list[0])     # output => 'ansh'\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Kiểu dữ liệu trong Python?",
              "answer": "<p>Mặc dù Python không yêu cầu kiểu dữ liệu khi khai báo biến nhưng lỗi vẫn xảy là nếu ta dùng kiểu dữ liệu khác với tương thích của nó. Python cung cấp hàm <code>type()</code> và <code>isinstance()</code> để kiểm tra kiểu của các các biến. Trong Python có các kiểu dữ liệu sau:\r<ul><li><strong>None</strong>: từ khoá <code>None</code> biểu diễn giá trị null trong Python. Có thể thực hiện so sánh bằng với đối tượng kiểu None.</li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |------------|-------------|\r\n   | NoneType | Biểu diễn giá trị Null |\r<ul><li><strong>Kiểu số</strong>: có 3 kiểu số trong Python là <strong>int</strong>, <strong>float</strong> và <strong>complex</strong>. Bên cạnh đó boolean cũng là kiểu con của int.</li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |-----|-------|\r\n   | int | lưu trữ kiểu số nguyên dạng thập phân, nhị phân, bát phân |\r\n   | float | lưu trữ giá trị thập phân, phân số, số chấm động |\r\n   | complex | lưu trữ kiểu số phức (A + Bj) với A là phần thực, B là phần ảo |\r\n   | bool | lưu giá trị nhị nguyên (True hoặc False) |\r<ul><li><strong>Kiểu tuần tự</strong>: có 3 kiểu tuần tự cơ bản trong Python - <strong>list</strong>, <strong>tuple</strong> và <strong>range</strong>. Kiểu tuần tự có thể thực hiện toán tử <code>in</code> và <code>not in</code>  để duyệt qua tất cả phần tử của chúng. Các toán tử này có cùng mức độ ưu tiên với các toán tử so sánh.</li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |-----|-------|\r\n   | list | Dùng cho lưu tập hợp phần tử, có thể chỉnh sửa |\r\n   | tuple | Dùng cho lưu tập hợp phần tử, bất biến |\r\n   | range | Biểu diễn chuỗi số bất biến trong suốt quá trình thực thi |\r\n   | str | Chuỗi bất biến Unicode cho lưu trữ dữ liệu văn bản |\r\n\r\n   <em>Lưu ý</em>: thư viện chuẩn còn bổ sung hai kiểu là Binary data như <code>bytearray bytes</code>, <code>memoryview</code> và Text string như <code>str</code>.\r<ul><li><strong>Kiểu ánh xạ</strong>: Trong Python, một đối tượng ánh xạ (mapping object) là một tập hợp các cặp key-value. Nó ánh xạ giá trị (value) với key tương ứng. Kiểu dữ liệu ánh xạ duy nhất trong Python là <strong>dictionary</strong>. </li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |-----|-------|\r\n   | dict | Lưu trữ tập hợp riêng biệt dạng cặp key/value |\r<ul><li><strong>Kiểu tập hợp</strong>: hiện tại Python có hai kiểu tập hợp là <strong>set</strong> và <strong>frozenset</strong>. Kiểu set có thể thay đổi với hai phướng thức là <code>add()</code> và <code>remove()</code>, kiểu frozenset là bất biến, không thể chỉnh sửa sau khi tạo.</li></ul>\r\n\r\n   | Tên | Mô tả |\r\n   |-----|-------|\r\n   | set | Tập hợp không thứ tự có thể chỉnh sửa |\r\n   | frozenset | Tập hợp đối tượng riêng biệt bất biến |\r<ul><li><strong>Modules</strong></li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Pass trong Python?",
              "answer": "<p>Từ khoá <code>pass</code> biểu diễn toán tử null trong Python. Nó được dùng nhằm mục đích lắp đầy các khối code trống có thể thực thi trong thời gian chạy nhưng hiện tại vẫn chưa viết. Nếu không có lệnh pass, ta có thể gặp lỗi khi thực thi code.\r\n\r\n``<code>python\r\ndef myEmptyFunc():\r\n   # do nothing\r\n   pass\r\nmyEmptyFunc()    # nothing happens\r\n## Without the pass keyword\r\n# File \"<stdin>\", line 3\r\n# IndentationError: expected an indented block\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Module và package trong Python?",
              "answer": "<p>Package và module là hai cơ chế cho phép <strong>lập trình module</strong> trong Python. Việc module hoá đem lại các lợi ích như:\r<ul><li><strong>Tính đơn giản:</strong> Làm việc trên một module duy nhất giúp bạn tập trung vào một phần tương đối nhỏ của vấn đề hiện tại. Điều này giúp cho việc phát triển dễ dàng hơn và ít bị lỗi hơn.</li></ul>\r<ul><li><strong>Khả năng bảo trì:</strong> Các module được thiết kế để thực thi các logic giữa các khía cạnh vấn đề khác nhau. Nếu chúng được viết theo cách làm giảm sự phụ thuộc lẫn nhau, thì các sửa đổi trong một module ít gây ảnh hưởng đến các phần khác của chương trình.</li></ul>\r<ul><li><strong>Khả năng tái sử dụng:</strong> Các hàm được khai báo trong một module có thể được sử dụng lại dễ dàng bởi các phần khác của ứng dụng.</li></ul>\r<ul><li><strong>Phạm vi:</strong> Các module thường xác định một namespace riêng biệt, giúp tránh nhầm lẫn giữa các định danh từ các phần khác của chương trình.</li></ul>\r\n\r\n<strong>Modules</strong>, là một file Python với mở rộng <code>.py</code> và có một tập hàm, lớp hoặc biến được khai báo và triển khai trong nó. Nó có thể được import ở file khác bằng lệnh <code>import</code>. Vd:\r\n\r\n``<code>py\r\nfrom foo import bar\r\n</code>`<code>\r\n\r\n<strong>Package</strong> cho phép cấu trúc phân cấp module bằng cách dùng ký hiệu </code>.`. Nếu như module giúp tránh xung đột giữa các tên biến toàn cục thì các package giúp tránh xung đột giữa các tên module.\r\n\r\nViệc tạo một package rất dễ dàng vì nó sử dụng cấu trúc file vốn có của hệ thống. Vì vậy, chỉ cần đưa các module vào một thư mục là bạn sẽ có nó, tên thư mục là tên package. Việc import một module hoặc nội dung của nó từ package này yêu cầu tên package làm tiền tố cho tên module được nối bằng dấu chấm.</p>",
              "level": "fresher"
            },
            {
              "question": "Các quyền truy cập thuộc tính trong Python?",
              "answer": "<p><ul><li><strong>Global</strong> là các biến công khai được khai báo ở global scope. Để dùng các biến này trong hàm, ta sử dụng từ khoá <code>global</code>.</li></ul>\r<ul><li><strong>Protected</strong> là thuộc tính được khai báo với dấu gạch dưới phía trước để định danh, vd <code><em>sara</code>. Nó có thể truy cập và chỉnh sửa bên ngoài lớp. </li></ul>\r<ul><li><strong>Private</strong> là thuộc tính với hai dấu gạch dưới phía trước để định danh, vd: <code></em>_ansh</code>. Nó không thể truy cập hay chỉnh sửa bên ngoài lớp.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Self trong Python?",
              "answer": "<p>Self được sử dụng để đại diện cho thực thể của lớp. Với từ khóa <code>this</code>, bạn có thể truy cập các thuộc tính và phương thức của lớp trong python. Nó liên kết các thuộc tính với các đối số đã cho. Self được sử dụng ở những nơi khác nhau và thường được cho là một từ khóa. Nhưng không giống như trong C ++, self không phải là một từ khóa trong Python.</p>",
              "level": "fresher"
            },
            {
              "question": "__init__ là gì?",
              "answer": "<p><code><strong>init</strong></code> là một phương thức khởi tạo trong Python và tự động gọi bộ nhớ cấp phát khi một đối tượng/thực thể mới được tạo. Tất cả lớp đều có phương thức <code>_<em>init</em>-</code> liên kết với chúng. Nó giúp phân biệt phương thức và thuộc tính từ biến cục bộ.\r\n\r\n``<code>py\r\n# class definition\r\nclass Student:\r\n   def <strong>init</strong>(self, fname, lname, age, section):\r\n      self.firstname = fname\r\n      self.lastname = lname\r\n      self.age = age\r\n      self.section = section\r\n# creating a new object\r\nstu1 = Student(\"Sara\", \"Ansh\", 22, \"A2\")\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "break, continue và pass trong Python?",
              "answer": "<p>| | |\r\n|-|-|\r\n| Break | lệnh break huỷ vòng lặp ngay lập tức và chuyển luồng điều khiển đến phần thân sau vòng lặp đó |\r\n| Continue | lệnh continue huỷ lần lặp hiện tại của câu lệnh, nó bỏ quả phần code của lần lặp hiện tại và chuyển luồng điều khiển đến lần lặp kế tiếp |\r\n| Pass | Từ khoá pass trong Python dùng để lấp đầy các empty block, tương tự một câu lệnh trống (<code>;</code>) trong Java, C++ |\r\n\r\n``<code>py\r\npat = [1, 3, 2, 1, 2, 3, 1, 0, 1, 3]\r\nfor p in pat:\r\n   pass\r\n   if (p == 0):\r\n       current = p\r\n       break\r\n   elif (p % 2 == 0):\r\n       continue\r\n   print(p)    # output => 1 3 1 3 1\r\nprint(current)    # output => 0\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Unit test trong Python là gì?",
              "answer": "<p><ul><li>Unit test là một framework kiểm thử đơn vị của Python.</li></ul>\r<ul><li>Unit test có nghĩa là kiểm tra các thành phần khác nhau của phần mềm một cách riêng biệt. Bạn có thể biết lý do tại sao unit test lại quan trọng không? Hãy tưởng tượng một tình huống, bạn đang xây dựng phần mềm sử dụng ba thành phần là A, B và C. Bây giờ, giả sử phần mềm của bạn bị hỏng tại một thời điểm. Làm thế nào bạn sẽ tìm thấy thành phần nào chịu trách nhiệm cho sự cố đó? Có thể thành phần A bị lỗi, thành phần B bị lỗi, và điều này thực sự đã làm hỏng phần mềm. Có thể có nhiều cách kết hợp như vậy.</li></ul>\r<ul><li>Đây là lý do tại sao cần phải kiểm tra từng thành phần đúng cách để thành phần nào có thể chịu trách nhiệm chính cho sự cố của phần mềm.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Docstring là gì?",
              "answer": "<p>Docstring hay documentation string là một chuỗi nhiều dòng dùng để ghi lại một đoạn code cụ thể.\r\n\r\nDocstrign mô tả hàm hoặc phương thức hoạt động.</p>",
              "level": "fresher"
            },
            {
              "question": "Slicing trong Python?",
              "answer": "<p>Slicing mô tả hành vi phân tách các mục trong một đối tượng dạng mảng (array, string, list và tuple). Cú pháp <strong>[start: stop: step]</strong>\r<ul><li><code>start</code> là chỉ mục bắt đầu tách.</li></ul>\r<ul><li><code>stop</code> là chỉ mục dừng lại.</li></ul>\r<ul><li><code>step</code> là số bước nhảy.</li></ul>\r\n\r\nGiá trị mặc định của start là 0, stop là số lượng mục, step là 1.\r\n\r\n``<code>py\r\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\nprint(numbers[1 : : 2])  \r\n\r\n#output : [2, 4, 6, 8, 10]\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "web-services",
          "name": "Câu hỏi phỏng vấn dịch vụ web",
          "description": "",
          "questions": [
            {
              "question": "Giải thích các kiểu dịch vụ web khác nhau?",
              "answer": "<p>Có hai kiểu dịch vụ web cơ bản là :\r\n\r\n<img src=\"/interview-assets/Web_Service_type.png\" alt=\"\" />\r\n\r\n<strong>SOAP (Simple Object Access Protocol)</strong>: Nó còn được gọi là giao thức truyền tải thông điệp độc lập với mục đích chính là truyền thông báo, và dựa trên giao thức XML. \r\n\r\n<strong>RESTful (Representational State Transfer)</strong>: Nó được phát triển để khắc phục những thiếu sót của SOAP và làm cho các dịch vụ web hiệu quả hơn.</p>",
              "level": "fresher"
            },
            {
              "question": "Các tính năng quan trọng của dịch vụ Web?",
              "answer": "<p>Một số tính năng quan trọng của dịch vụ web bao gồm:\r<ul><li>Được sử dụng để tiêu chuẩn hóa hệ thống truyền tải thông điệp XML.</li></ul>\r<ul><li>Không ràng buộc với bất kỳ ngôn ngữ lập trình hoặc hệ điều hành nào.</li></ul>\r<ul><li>Có thể tìm thấy thông qua một cơ chế tìm kiếm đơn giản.</li></ul>\r<ul><li>Có sẵn trên internet hoặc các mạng riêng.</li></ul>\r<ul><li>Hỗ trợ kết nối mềm giữa các hệ thống.</li></ul>\r<ul><li>Có thể đồng bộ hoặc bất đồng bộ.</li></ul>\r<ul><li>Hỗ trợ trao đổi dữ liệu minh bạch để tạo điều kiện tích hợp.</li></ul>\r<ul><li>Hỗ trợ giao tiếp giữa các ứng dụng khác nhau bằng HTML, XML, WSDL, SOAP, v.v.</li></ul>\r<ul><li>Hỗ trợ RPC (Remote Procedure Calls).</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các thành phần của dịch vụ Web?",
              "answer": "<p>Các thành phần khác nhau của dịch vụ web:\r<ul><li>SOAP (Simple Object Access Protocol) </li></ul>\r<ul><li>UDDI (Universal Description, Discovery, and Integration) </li></ul>\r<ul><li>WSDL (Web Services Description Language) </li></ul>\r<ul><li>RDF (Resource Description Framework) </li></ul>\r<ul><li>XML (Extensible Markup Language)</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Khác biệt giữa API và dịch vụ Web?",
              "answer": "<p><strong>API (Application Programming Interface):</strong> hành động như một interface giữa hai thiết bị để chúng có thể giao tiếp với nhau mà không cần người dùng can thiệp. Một số tính năng của chúng như linh động, dễ tích hợp với GUI, ngôn ngữ độc lập,... Các API không nhất thiết phải là dịch vụ Web\r\n\r\n<strong>Dịch vụ Web:</strong> tạo điều kiện tương tác giữa hai thiết bị qua mạng. Chúng được sử dụng rộng rãi để trao đổi dữ liệu giữa các hệ thống hoặc ứng dụng. Một số tính năng của nó bao gồm liên kết mềm, hỗ trợ trao đổi dữ liệu, khả năng tương tác, khả năng mở rộng, v.v. Mọi dịch vụ Web đều là API.\r\n\r\n| API | Dịch vụ Web |\r\n|-----|-------------|\r\n| Có thể online hoặc offline | Buộc phải có mạng |\r\n| Kiến trúc gọn nhẹ | Yêu cầu SOAP cho gửi và nhận dữ liệu mạng, do đó kiến trúc không nhẹ |\r\n| Có thể dùng bất kỳ kiểu thiết kế hay giao thức nào | Chỉ dùng SOAP, thỉnh thoảng dùng REST, RPC, XML |\r\n| Không yêu cầu mạng cho các thao tác | Cần mạng cho mọi thao tác |\r\n| Mã nguồn mở và dùng XML | Mã nguồn đóng và dùng JSON |</p>",
              "level": "fresher"
            },
            {
              "question": "Các công cụ kiểm thử dịch vụ web?",
              "answer": "<p>Có nhiều công cụ khác nhau cho kiểm tra dịch vụ web:\r\n\r\n<em> SoapUI \r\n</em> Poster \r\n<em> Postman \r\n</em> REST client \r<ul><li>JMeter</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "WSDL là gì?",
              "answer": "<p>WSDL (Web Services Description Language) được coi là định dạng tiêu chuẩn được sử dụng để mô tả tính khả dụng của các dịch vụ web và cách truy cập chúng. Nó dựa trên giao thức XML để trao đổi dữ liệu trong các môi trường phân tán và phi tập trung. Nó cũng mô tả các chi tiết kỹ thuật hoặc định vị giao diện người dùng cho dịch vụ web. Tài liệu WSDL chứa một số thông tin quan trọng như được cung cấp bên dưới:\r<ul><li>Tên phương thức và tham số</li></ul>\r<ul><li>Kiểu cổng</li></ul>\r<ul><li>Dịch vụ endpoint</li></ul>\r<ul><li>Thông tin header</li></ul>\r\n\r\n<img src=\"/interview-assets/wsdl.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "XML-RPC là gì?",
              "answer": "<p>XML-RPC được xem là giao thức đơn giản và căn bản dựa trên XML để trao đổi dữ liệu giữa các thiết bị khác nhau trên mạng. Nó sử dụng HTTP như một giao thức truyền tải để truyền thông tin dữ liệu giữa hai thiết bị một cách nhanh chóng và dễ dàng. XML-RPC có thể sử dụng các ngôn ngữ như C, C++, Java, Python,...\r\n\r\n<img src=\"/interview-assets/xml-rpc.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Tính năng của XML-RPC?",
              "answer": "<p><ul><li>Nền tảng độc lập</li></ul>\r<ul><li>Cho phép ứng dụng giao tiếp đa dạng.</li></ul>\r<ul><li>Được coi là cách dễ nhất và đơn giản nhất để bắt đầu với các dịch vụ web.</li></ul>\r<ul><li>Sử dụng XML để mã hóa các cuộc gọi của nó và HTTP làm giao thức truyền tải.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "UDDI là gì?",
              "answer": "<p>UDDI (Universal Description, Discovery, and Integration) là một dịch vụ thư mục được sử dụng để mô tả, phát hành và tìm kiếm các dịch vụ web. Nó dựa trên một tập hợp các tiêu chuẩn web bao gồm HTTP, XML, SOAP, WSDL, XML. Mục tiêu chính của nó là hợp lý hóa các giao dịch kỹ thuật số và thương mại điện tử giữa các hệ thống công ty.\r\n\r\n<img src=\"/interview-assets/UDDI.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các tính năng nổi bật của UDDI",
              "answer": "<p><em> Nền tảng độc lập\r\n</em> Sử dụng WSDL để mô tả interface cho các dịch vụ web\r\n<em> Có thể giao tiếp thông qua SOAP, Java RMI và giao thức CORBA\r\n</em> Phân định giữa interface và triển khai\r<ul><li>Trung lập về giao thức</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tên ngôn ngữ thường được sử dụng bởi UDDI?",
              "answer": "<p>Ngôn ngữ thường được UDDI sử dụng là WSDL (Web Service Description Language).</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về kiến trúc dịch vụ web?",
              "answer": "<p>Mọi framework đều yêu cầu một số kiểu kiến trúc để đảm bảo rằng toàn bộ framework hoạt động hoàn hảo như mong muốn, đối với các dịch vụ web cũng vậy. Kiến trúc dịch vụ web được sử dụng để hỗ trợ nhà phát triển với các bước và thủ tục cần thiết để hoàn thành việc tạo. Kiến trúc dịch vụ web bao gồm ba vai trò riêng biệt, tức là nhà cung cấp dịch vụ (provider), người yêu cầu dịch vụ (requestor) và sổ đăng ký dịch vụ (registry). Nó cũng bao gồm ba hoạt động khác nhau bao gồm:\r\n\r\n<strong>Publish (Publication of Service Descriptions):</strong> Một mô tả dịch vụ cần được phát hành để người yêu cầu dịch vụ có thể xác định vị trí và có quyền truy cập vào nó. Nó có thể được phát hành ở bất cứ đâu tùy thuộc vào yêu cầu của ứng dụng.\r\n\r\n<strong>Find (Finding of Services Descriptions):</strong> một mô tả dịch vụ được truy xuất trực tiếp bởi người yêu cầu dịch vụ. Người yêu cầu tham khảo ý kiến của broker để tìm một dịch vụ web đã được phát hành. \r\n\r\n<strong>Bind (Invoking of Service based on Service Description):</strong> mọi dịch vụ cần được gọi. Để xác định vị trí, liên hệ và gọi dịch vụ, người yêu cầu dịch vụ bắt đầu tương tác với dịch vụ trong thời gian chạy bằng cách sử dụng các chi tiết ràng buộc trong mô tả dịch vụ.\r\n\r\n<img src=\"/interview-assets/Web_Service_roles__operation____artifacts.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Web Service Provider là gì?",
              "answer": "<p>Nhà cung cấp dịch vụ (Web Service Provider) tạo các dịch vụ web và cung cấp quyền truy cập vào ứng dụng client cần nó. Mục đích chính của nó là triển khai dịch vụ và cung cấp dịch vụ này trên internet để các ứng dụng client có thể sử dụng bất cứ khi nào được yêu cầu. Nói dễ hiểu, nó là một nền tảng để tạo và lưu trữ các dịch vụ web.</p>",
              "level": "fresher"
            },
            {
              "question": "Web Service Requestor là gì?",
              "answer": "<p>Người yêu cầu dịch vụ (Web Service Requestor) là ứng dụng client yêu cầu sử dụng dịch vụ web. Mục đích chính của nó là sử dụng một dịch vụ web hiện có bằng cách mở một kết nối mạng và gửi một yêu cầu XML. Nói một cách dễ hiểu, họ là những người sử dụng dịch vụ web.</p>",
              "level": "fresher"
            },
            {
              "question": "Web Service Registry là gì?",
              "answer": "<p>Sổ đăng ký dịch vụ (Web Service Registry) về cơ bản giống như một 'danh bạ điện thoại' cho các dịch vụ web. Nó cho phép các ứng dụng client có thể xuất bản các dịch vụ mới hoặc có thể xác định vị trí các dịch vụ đã tồn tại. Hai tiêu chuẩn đăng ký được sử dụng rộng rãi thường được hỗ trợ bởi các máy chủ ứng dụng, là ebXML (Electronic Business sử dụng XML) và UDDI (Universal Description, Discovery, and Integration).</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "websocket",
          "name": "Câu hỏi phỏng vấn WebSocket",
          "description": "",
          "questions": [
            {
              "question": "WebSockets là gì?",
              "answer": "<p>WebSocket là công nghệ cho phép client thiết lập kết nối hai chiều <em>full-duplex</em> để giao tiếp với server.\r\n\r\nVới WebSocket, cả client và server có thể kích hoạt giao tiếp với phía còn lại, chúng có thể gửi tin nhắn cùng lúc. Ngược lại trong giao tiếp HTTP truyền thống chỉ có thể đi một chiều là client đến server.</p>",
              "level": "middle"
            },
            {
              "question": "Giải thích Server-Sent Events/EventSource?",
              "answer": "<p>SSE (Server-Sent Events) là một kỹ thuật cho gửi thông điệp, nó cho phép server đẩy cập nhật lên client bằng cách tận dụng JavaScript <code>EventSource</code>.\r\n\r\nEventSource mở một một kết nối liên tục, một chiều với server qua HTTP sử dụng header đặc biệt <code>text/event-stream</code> và lắng nghe thông điệp, được code của bạn xử lý giống như sự kiện JavaScript.\r\n\r\nServer-Sent Events (SSE) phù hợp cho các ứng dụng mà bạn không cần gửi cho server bất kỳ dữ liệu nào. Ví dụ: trang tin tức Twitter hoặc sàn chứng khoán cổ phiếu. Một điểm ưu việc khác là SSE hoạt động qua HTTP và API tương đối dễ sử dụng.\r\n\r\nTuy nhiên:\r<ul><li>SSE không hỗ trợ các trình duyệt cũ.</li></ul>\r<ul><li>Phần lớn trình duyệt giới hạn số lượng kết nối SSE mà bạn tạo cùng lúc.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Tương tác với độ trễ thấp là gì?",
              "answer": "<p><strong>Độ trễ thấp (low latency)</strong> có nghĩa là có rất ít độ trễ giữa thời gian bạn yêu cầu điều gì đó và thời gian bạn nhận được phản hồi. Như nó áp dụng cho WebSockets, nó có nghĩa là dữ liệu có thể được gửi nhanh hơn (đặc biệt là qua các liên kết chậm) bởi vì kết nối đã được thiết lập nên không cần thêm gói tin để thiết lập kết nối TCP.</p>",
              "level": "middle"
            },
            {
              "question": "Short Polling là gì?",
              "answer": "<p>Short Polling hoặc Ajax Polling là một kỹ thuật khi bạn yêu cầu client ping liên tục đến server, chẳng hạn như sau mỗi 500ms(hoặc trên một số độ trễ nhất định). Bằng cách đó, bạn nhận được dữ liệu mới sau mỗi 500ms:\r\n1. Client yêu cầu trang web từ một server bằng HTTP thông thường.\r\n2. Client nhận được trang web và thực thi JavaScript trên trang yêu cầu file từ server theo khoảng thời gian đều đặn (vd: 0.5s)\r\n3. Server tính toán từng phản hồi và gửi lại, giống như lưu lượng HTTP thông thường.\r\n\r\n<img src=\"/interview-assets/short-polling.png\" alt=\"\" />\r\n\r\nCó một số nhược điểm rõ ràng của điều này:\r<ul><li>Có độ trễ 500ms</li></ul>\r<ul><li>Nó tiêu thụ tài nguyên server với một loạt các yêu cầu và hầu hết các yêu cầu sẽ trả về trống nếu dữ liệu không được cập nhật thường xuyên.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Tại sao dùng WebSocket thay vì HTTP?",
              "answer": "<p>WebSocket là một kết nối liên tục giữa client và server. Kết nối liên tục đó cho phép những điều sau:\r<ul><li>Dữ liệu có thể được gửi từ server đến client bất kỳ lúc nào mà không cần client yêu cầu. Điều này thường được gọi là push server và rất có giá trị đối với các ứng dụng mà khách hàng cần biết khá nhanh khi có điều gì đó xảy ra trên server (chẳng hạn như một tin nhắn trò chuyện mới đã được nhận hoặc giá mới đã được cập nhật). Một client không thể push được dữ liệu qua HTTP. Client sẽ phải thường xuyên thăm dò ý kiến bằng cách đưa ra yêu cầu HTTP vài giây một lần để có được dữ liệu mới kịp thời. Client polling không hiệu quả.</li></ul>\r<ul><li>Dữ liệu có thể được gửi theo cả hai cách rất hiệu quả. Bởi vì kết nối đã được thiết lập và khung dữ liệu webSocket được tổ chức rất hiệu quả, người ta có thể gửi dữ liệu hiệu quả hơn rất nhiều thông qua một yêu cầu HTTP nhất thiết phải chứa header, cookie, v.v.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Giải thích Long Polling là gì?",
              "answer": "<p>Phương thức <strong>Long Polling</strong> được server dùng để nhận yêu cầu, nhưng không phản hồi cho đến khi nó nhận dữ liệu mới từ yêu cầu khác.\r\n\r\nLong polling hiệu quả hơn ping server liên tục vì nó giúp tiết kiệm những rắc rối khi parse header của yêu cầu, truy vấn dữ liệu mới và gửi phần hồi (thường là trống).\r\n\r\nTuy nhiên:\r<ul><li>server phải theo dõi nhiều yêu cầu và thứ tự của chúng</li></ul>\r<ul><li>yêu cầu có thể hết thời gian chờ và yêu cầu mới cần đưa ra định kỳ</li></ul>\r\n\r\nCác bước:\r\n\r\n<img src=\"/interview-assets/long-polling.png\" alt=\"\" />\r\n\r\n1. Client yêu cầu trang web từ server sử dụng HTTP thông thường.\r\n2. Client nhận trang web được yêu cầu và thực thi JavaScript trên trang yêu cầu file từ server.\r\n3. Server không phản hồi ngay lập tức với thông tin được yêu cầu mà đợi cho đến khi có thông tin mới.\r\n4. Khi có thông tin mới, server sẽ phản hồi với thông tin mới.\r\n5. Client nhận được thông tin mới và ngay lập tức gửi một yêu cầu khác đến server, bắt đầu lại quy trình.</p>",
              "level": "middle"
            },
            {
              "question": "Lợi ích của SSE so với WebSocket?",
              "answer": "<p><ul><li>Được truyền qua HTTP đơn giản thay vì một giao thức tùy chỉnh</li></ul>\r<ul><li>Có thể được lấp đầy bằng javascript để \"backport\" SSE cho các trình duyệt chưa hỗ trợ nó.</li></ul>\r<ul><li>Tích hợp hỗ trợ cho tái kết nối và id của sự kiện</li></ul>\r<ul><li>Giao thức đơn giản hơn</li></ul>\r<ul><li>Không có vấn đề gì với tường lửa của công ty thực hiện kiểm tra packet.</li></ul>\r\n\r\n#</p>",
              "level": "middle"
            },
            {
              "question": "Giải thích các kỹ thuật giao tiếp khác nhau trên web mà bạn biết?",
              "answer": "<p><ul><li><strong>AJAX</strong> - <code>request</code> → <code>response</code>. Tạo một kết nối đến server, gửi yêu cầu gồm header và dữ liệu tuỳ chọn, nhận phản hồi từ server và đóng kết nối. Được hỗ trợ trên mọi loại trình duyệt.</li></ul>\r<ul><li><strong>Long poll</strong> - <code>request</code> → <code>wait</code> → <code>response</code>. Tạo một kết nối đến server giống như AJAX, nhưng duy trì kết nối mở keep-alive trong một khoảng thời gian. Trong suốt kết nối, client có thể truy xuất dữ liệu từ server. Client phải kết nối lại đỊnh kỳ sau khi kết nối bị đóng, do hết thời gian chờ hoặc hết dữ liệu. Ở phía server, nó vẫn được xem như một yêu cầu HTTP, giống như AJAX, ngoại trừ câu trả lời cho yêu cầu xảy ra ngay bây giờ hoặc một lúc nào đó trong tương lại, được xác định bởi logic ứng dụng.</li></ul>\r<ul><li><strong>WebSockets</strong> - <code>client</code> ↔ <code>server</code>. Tạo kết nối TCP tới server và giữ nó mở nếu cần. Server hoặc client có thể dễ dàng đóng kết nối. Client trải qua quá trình bắt tay 3 bước HTTP. Nếu nó thành công, thì server và client có thể trao đổi dữ liệu theo cả hai hướng bất kỳ lúc nào. Sẽ hiệu quả nếu ứng dụng yêu cầu trao đổi dữ liệu thường xuyên theo cả hai cách. WebSockets có khung dữ liệu bao gồm che dấu cho mỗi tin nhắn được gửi từ client đến server, vì vậy dữ liệu được mã hóa đơn giản.</li></ul>\r<ul><li><strong>WebRTC</strong> - <code>peer</code> ↔ <code>peer</code>. Transport thiết lập giao tiếp giữa client và các phương tiện truyền tải, vì vậy nó có thể sử dụng UDP, TCP hoặc các lớp trừu tượng khác. Nó thường được dùng để truyền dữ liệu khối lượng lớn chẳng hạn như video/audio, trong đó độ tin cậy là thứ yêu và một vài frame có thể hy sinh đổi lại thời gian phản hồi và truyền dữ liệu. Cả hai phía (peer) có thể đẩy dữ liệu một cách độc lập. Mặc dù nó có thể được sử dụng hoàn toàn độc lập với bất kỳ server tập trung nào, nó vẫn yêu cầu một số cách trao đổi dữ liệu endPoints, trong đó trong hầu hết các trường hợp, các nhà phát triển vẫn sử dụng server tập trung để \"liên kết\" các server. Điều này chỉ được yêu cầu để trao đổi dữ liệu cần thiết để thiết lập kết nối, sau đó không cần server tập trung.</li></ul>\r<ul><li><strong>Server-Sent Events</strong> - <code>client</code> ← <code>server</code>. Client thiết lập kết nối liên tục và lâu dài với server. Chỉ server mới có thể gửi dữ liệu đến client. Nếu client muốn gửi dữ liệu đến server, nó sẽ yêu cầu sử dụng công nghệ/giao thức khác để làm điều đó. Giao thức này tương thích với HTTP và dễ triển khai trong hầu hết các nền tảng phía server. Đây là một giao thức thích hợp được sử dụng thay vì Long Polling.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa SSE và WebSocket?",
              "answer": "<p>Websockets và SSE (Server Sent Events) đều có khả năng đẩy dữ liệu lên trình duyệt, tuy nhiên chúng không phải là công nghệ cạnh tranh.\r<ul><li>Kết nối Websockets vừa có thể gửi dữ liệu đến trình duyệt vừa nhận dữ liệu từ trình duyệt. Một ví dụ điển hình về ứng dụng có thể sử dụng websockets là ứng dụng chat.</li></ul>\r<ul><li>Kết nối SSE chỉ có thể đẩy dữ liệu đến trình duyệt. Báo giá cổ phiếu trực tuyến hoặc cập nhật newsfeed hoặc nguồn cấp dữ liệu là những ví dụ điển hình về một ứng dụng có thể sử dụng SSE.</li></ul>\r\n\r\nViệc sử dụng WebSockets có thể là quá mức cần thiết đối với một số loại ứng dụng và backend có thể dễ dàng triển khai hơn với một giao thức như SSE. Hơn nữa, SSE có thể được thêm vào các trình duyệt cũ hơn không hỗ trợ nó nguyên bản chỉ sử dụng JavaScript.</p>",
              "level": "middle"
            },
            {
              "question": "Giải thích về giao thức WebSocket?",
              "answer": "<p>WebSocket là giao thức khác cho gửi và nhận thông điệp như HTTP.\r\n\r\nCả HTTP và WebSocket gửi thông điệp qua một kết nối TCP (Transmission Control Protocol), nó là một chuẩn transport-layer để đảm bảo tằng streams của byte, được gửi qua packet và phân phối đến những máy khác. Thế nên, HTTP và WebSocket sử dụng cùng cơ chế phân phối ở level packet/byte, nhưng giao thức cho cấu trúc thông điệp lại khác nhau.\r\n\r\nKhi WebSocket thiết lập kết nối đến server, client sẽ gửi một yêu cầu \"bắt tay\" HTTP với header nâng cấp, chỉ ra rằng client muốn thiết lập một kết nối webSocket. Yêu cầu được gửi có URI là <code>ws:</code> hoặc <code>wss:</code> (như http và https). Nếu server có khả năng thiết lập một kết nối WebSocket và kết nối được chấp nhận (vd, nếu yêu cầu đến cùng với xác thực) server sẽ phản hồi \"bắt tay\" thành công, được biểu thị bằng code <strong>101 Switching Protocols</strong>.\r\n\r\nSau khi kết nối được nâng cấp, giao thức chuyển từ HTTP sang WebSocket, và các packet vẫn được gửi qua TCP, nhưng bây giờ giao tiếp sẽ chuyển qua định dạng thông điệp của WebSocket. Vì TCP là giao thức bên dưới việc truyền tải packet dữ liệu, là một giao thức full-duplex, cả client và server có thể gửi dữ liệu cùng lúc. Thông điệp có thể bị phân mảnh, vì vậy có thể gửi một thông điệp lớn mà không cần khai báo trước kích thước. Trong trường hợp đó, WebSockets sẽ chia nó thành các frame. Mỗi frame chứa một header nhỏ cho biết độ dài và loại payload và liệu đây có phải là frame cuối cùng hay không.</p>",
              "level": "middle"
            },
            {
              "question": "WebSocket Frame là gì?",
              "answer": "<p>WebSocket không phải giao thức dựa trên stream như TCP, mà nó dựa trên thông điệp. Giao thức websocket giao tiếp với các <strong>frame</strong>. Frame bao gồm header và dữ liệu ứng dụng. Dữ liệu ứng dụng là bất cứ thứ gì nằm trong \"body\".\r\n\r\nPhần lớn giao thức websocket có 3 frame điều kiến và 3 frame không điều kiến:\r<ul><li>Điều khiển (control):</li></ul>\r<ul><li>'close' - nói rằng chúng tôi muốn đóng hoặc đang phản hồi về việc đóng</li></ul>\r<ul><li>'ping' - pings!</li></ul>\r<ul><li>'pong' - pongs!</li></ul>\r<ul><li>Không điều kiển (no-control):</li></ul>\r<ul><li>'text' - biểu thị chúng tôi đang gửi các byte được mã hóa \"UTF-8\"</li></ul>\r<ul><li>'binary' - biểu thị chúng tôi đang gửi các byte raw</li></ul>\r<ul><li>'continue' - biểu thị thông báo này là một đoạn tiếp nối của thông báo trước đó.</li></ul>\r\n\r\n``<code>shell\r\n0                   1                   2                   3\r\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\r\n+-+-+-+-+-------+-+-------------+-------------------------------+\r\n|F|R|R|R| opcode|M| Payload len |    Extended payload length    |\r\n|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\r\n|N|V|V|V|       |S|             |   (if payload len==126/127)   |\r\n| |1|2|3|       |K|             |                               |\r\n+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\r\n|     Extended payload length continued, if payload len == 127  |\r<ul><li>- - - - - - - - - - - - - - - +-------------------------------+</li></ul>\r\n|                               |Masking-key, if MASK set to 1  |\r\n+-------------------------------+-------------------------------+\r\n| Masking-key (continued)       |          Payload Data         |\r\n+-------------------------------- - - - - - - - - - - - - - - - +\r\n:                     Payload Data continued ...                :\r<ul><li>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</li></ul>\r\n|                     Payload Data continued ...                |\r\n+---------------------------------------------------------------+\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Khi nào WebRTC tốt hơn WebSocket?",
              "answer": "<p>Khi bạn xây dựng một ứng dụng chat cho phép video, audio và văn bản. Bạn sẽ chọn WebRTC hay WebSocket.\r<ul><li><strong>WebRTC</strong> được thiết kế để giao tiếp video/audio hiệu suất cao, chất lượng cao  và dữ liệu tùy ý. Nói cách khác, đối với các ứng dụng chính xác như những gì bạn mô tả.</li></ul>\r<ul><li>WebRTC chủ yếu là UDP. Vì vậy, lý do chính của việc sử dụng WebRTC thay vì Websocket là độ trễ. Với WebRTC, bạn có thể đạt được độ trễ thấp và phát lại mượt mà là yếu tố quan trọng đối với truyền thông VoIP.</li></ul>\r<ul><li>Với WebRTC, dữ liệu được mã hóa end-to-end và không chuyển qua server (ngoại trừ đôi khi server TURN là cần thiết, nhưng chúng không có quyền truy cập vào phần nội dung của thông điệp mà chúng chuyển tiếp).</li></ul>\r<ul><li>Các ứng dụng WebRTC cần một dịch vụ mà qua đó chúng có thể trao đổi metadata mạng và phương tiện, một quá trình được gọi là báo hiệu.</li></ul>\r<ul><li>Mặt khác, <strong>WebSocket</strong> được thiết kế để giao tiếp hai chiều giữa client và server. Có thể phát trực tuyến âm thanh và video qua WebSocket, nhưng công nghệ và API vốn dĩ không được thiết kế để phát trực tuyến hiệu quả, mạnh mẽ theo cách của WebRTC.</li></ul>\r<ul><li>Websockets sử dụng giao thức TCP. Với phát trực tuyến websocket, bạn sẽ có độ trễ cao hoặc phát lại bị giật với độ trễ thấp.</li></ul>\r<ul><li>Với Websockets, dữ liệu phải đi qua một server web trung tâm, server này thường thấy tất cả lưu lượng truy cập và có thể truy cập nó.</li></ul></p>",
              "level": "middle"
            }
          ]
        }
      ]
    },
    {
      "id": "database",
      "name": "Database",
      "icon": "database",
      "color": "#ff9800",
      "subcategories": [
        {
          "id": "mongodb",
          "name": "Câu hỏi phỏng vấn MongoDB",
          "description": "",
          "questions": [
            {
              "question": "Lợi ích của MongoDB?",
              "answer": "<p><em> Hiệu suất cao\r\n</em> Tính sẵn sàng cao – Nhân rộng\r\n<em> Khả năng mở rộng cao – Sharding\r\n</em> Năng động – Không có lược đồ cứng nhắc.\r\n<em> Linh hoạt – thêm / xóa trường có ít hoặc không ảnh hưởng đến ứng dụng\r\n</em> Dữ liệu không đồng nhất\r\n<em> Không joins\r\n</em> Phân phối được\r\n<em> Biểu diễn dữ liệu trong JSON hoặc BSON\r\n</em> Hỗ trợ không gian địa lý (Geospatial)\r<ul><li>Tích hợp dễ dàng với BigData Hadoop</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Document trong MongoDB là gì?",
              "answer": "<p>Một document trong MongoDB là một tập hợp key/value. Nó được biểu diễn bằng map, hash, hoặc dictionary. Trong JavaScript, document được biểu diễn dưới dạng các đối tượng:\r\n\r\n``<code>js\r\n{\"greeting\": \"Hello world!\"}\r\n</code>`<code>\r\n\r\nCác document phức tạp sẽ chứa nhiều cặp key/value:\r\n\r\n</code>`<code>js\r\n{\r\n    \"welcome\": \"Hello world!\", \r\n    \"views\": 3\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Collection trong MongoDB là gì?",
              "answer": "<p>Collection là một nhóm document. Nếu một document trong MongoDB tương tự như một hàng trong SQL, thì một collection sẽ tương tự như một bảng.\r\n\r\nCác document trong cùng một collection có thể khác nhau,... do tính chất <strong>lược đồ dữ liệu động</strong>.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\n{\"greeting\" : \"Hello world!\", \"views\": 3}\r\n{\"signoff\": \"Good bye\"}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cơ sở dữ liệu trong MongoDB",
              "answer": "<p>Tập hợp các collection nằm trong cơ sở dữ liệu. MongoDB có thể có nhiều cơ sở dữ liệu, mỗi cơ sở dữ liệu chứa nhiều collection.\r\n\r\nMột số tên cơ sở dữ liệu dành riêng như sau:\r<ul><li><em>admin</em></li></ul>\r<ul><li><em>local</em></li></ul>\r<ul><li><em>config</em></li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "MongoDB Shell là gì?",
              "answer": "<p>Nó là một JavaScript shell cho phép tương tác với một phiên bản MongoDB từ dòng lệnh. Nhờ đó, người ta có thể thực hiện các chức năng quản trị, kiểm tra một phiên bản hoặc sử dụng MongoDB.\r\n\r\nĐể bắt đầu shell, ta chạy lệnh mongo:\r\n\r\n``<code>shell\r\n$ mongod\r\n$ mongo\r\nMongoDB shell version: 4.2.0\r\nconnecting to: test\r\n>\r\n</code>`<code>\r\n\r\nShell là một trình thông dịch JavaScript đầy đủ tính năng, có khả năng chạy các chương trình JavaScript tùy ý. Hãy xem cách phép toán cơ bản hoạt động:\r\n\r\n</code>`<code>shell\r\n> x = 100;\r\n200\r\n> x / 5;\r\n20\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Scale-Out xảy ra như thế nào trong MongoDB?",
              "answer": "<p>Để scale out trong MongoDB, ta thực hiện Sharding.\r\n\r\nSharding là một phương pháp để lưu trữ dữ liệu (storage) của cơ sở dữ liệu trên nhiều máy chủ. MongoDB sử dụng sharding để hỗ trợ việc phân tán một lượng dữ liệu trên nhiều máy chủ, ở đây có thể là các tập collection trong DB điều này giúp cho việc truy cập nhanh hơn, giảm tải việc quá tải ổ cứng cho một vài máy chủ và giúp hệ thống dễ dàng mở rộng khi có nhu cầu hơn.\r\n\r\nMongodb Sharded Cluster bao gồm các thành phần chính như sau:\r<ul><li><strong>Shards</strong>: Là nơi chứa dữ liệu, được phân tán bởi nhiều máy chủ theo cơ chế \"replica set\".</li></ul>\r<ul><li><strong>Query routers - Mongos</strong>: Là nơi điều hướng việc client truy cập chính xác dữ liệu vào shard nào, mỗi hệ thống Sharding có thể có nhiều query router.</li></ul>\r<ul><li><strong>Config servers</strong>: Là nơi chưa các metadata (nôm na là các thông số kỹ thuật) của hệ thống Sharding, nó chứa một bản đồ dữ liệu của việc thiết lập các Shards. Query routers dùng các metadata này xác định được chính xác việc truy vấn vào Shards nào trên hệ thống. Mỗi hệ thống Sharding có chính xác là 3 file Config servers.</li></ul>\r\n\r\n<img src=\"/interview-assets/Mongos.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các tính năng của MongoDB?",
              "answer": "<p><ul><li><strong>Indexing</strong> hỗ trợ chỉ mục thứ cấp và cung cấp tính năng đánh chỉ mục duy nhất, đa hợp, không gian địa lý và toàn văn bản.</li></ul>\r<ul><li><strong>Aggregation</strong> cung cấp framework aggregation dựa trên khái niệm xử lý dữ liệu trong pipelines.</li></ul>\r<ul><li><strong>Special collection và index types</strong>: nó hỗ trợ time-to-live collection cho dữ liệu sẽ hết hạn vào một thời điểm nhất định.</li></ul>\r<ul><li><strong>File storage</strong> cung cấp giao thức đơn giản cho lưu trữ file và thông tin file.</li></ul>\r<ul><li><strong>Sharing</strong> là quá trình chia sẽ dữ liệu trên nhiều máy.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Làm sao để thêm dữ liệu trong MongoDB?",
              "answer": "<p>Phương thức thêm dữ liệu cơ bản trong MongoDB là \"insert\". Để thêm một document ta dùng <code>insertOne</code>:\r\n\r\n``<code>\r\n> db.books.insertOne({\"title\": \"Start With Why\"})\r\n</code>`<code>\r\n\r\nĐể thêm nhiều document vào một collection, ta có thể dùng </code>insertMany`, phương thức này cho phép chuyển một mảng document vào cơ sở dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để cập nhật một document?",
              "answer": "<p>Sau khi document được lưu trữ trong cơ sở dữ liệu, nó có thể được cập nhật bằng một trong các phương pháp sau: <code>updateOne</code>, <code>updateMany</code> và <code>replaceOne</code>. \r\n\r\n<code>updateOne</code> và <code>updateMany</code> mỗi cái lấy một document lọc làm tham số đầu tiên và một document chỉnh sửa làm tham số thứ hai. <code>replaceOne</code> cũng lấy một bộ lọc làm tham số đầu nhưng với tham số thức hai, <code>replaceOne</code> sẽ mong đợi tài liệu thay thế phù hợp với filter.\r\n\r\n``<code>js\r\n{\r\n   \"_id\" : ObjectId(\"4b2b9f67a1f631733d917a7a\"),\r\n   \"name\" : \"alice\",\r\n   \"friends\" : 24,\r\n   \"enemies\" : 2\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách xoá một document?",
              "answer": "<p>Xoá trong MongoDB được hỗ trợ bằng <code>deleteOne</code> và <code>deleteMany</code>. Cả hai phương thức này đều nhận vào một bộ lọc document làm tham số đầu tiên. Bộ lọc chỉ định một tập hợp các tiêu chí phù hợp với việc xoá document.\r\n\r\n``<code>\r\n> db.books.deleteOne({\"_id\" : 3})\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm sao để truy vấn trong MongoDB?",
              "answer": "<p>Phương thức <code>find</code> được dùng để thực hiện truy vấn trong MongoDB. Truy vấn trả về một tập con document trong một collection, có thể là không có document nào cũng có thể là toàn bộ. Document được trả về được xác định bởi tham số đầu tiên cần tìm là tiêu chí truy vấn document.\r\n\r\n``<code>\r\n> db.users.find({\"age\" : 24})\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu dữ liệu trong MongoDB?",
              "answer": "<p>MongoDB hỗ trợ nhiều kiểu dữ liệu dưới dạng giá trị trong document. Các document trong MongoDB tương tự như các đối tượng trong JavaScript. Cùng với bản chất key/value thiết yếu của JSON, MongoDB bổ sung hỗ trợ cho một số kiểu dữ liệu bổ sung. Các kiểu dữ liệu phổ biến trong MongoDB là:\r<ul><li>Null</li></ul>\r\n\r\n``<code>js\r\n{\"x\" : null}\r\n</code>`<code>\r<ul><li>Boolean</li></ul>\r\n\r\n</code>`<code>js\r\n{\"x\" : true}\r\n</code>`<code>\r<ul><li>Number</li></ul>\r\n\r\n</code>`<code>js\r\n{\"x\" : 4}\r\n</code>`<code>\r<ul><li>String</li></ul>\r\n\r\n</code>`<code>js\r\n{\"x\" : \"foobar\"}\r\n</code>`<code>\r<ul><li>Date</li></ul>\r\n\r\n</code>`<code>js\r\n{\"x\" : new Date()}\r\n</code>`<code>\r<ul><li>Regular expression</li></ul>\r\n\r\n</code>`<code>js\r\n{\"x\" : /foobar/i}\r\n</code>`<code>\r<ul><li>Array</li></ul>\r\n\r\n</code>`<code>js\r\n{\"x\" : [\"a\", \"b\", \"c\"]}\r\n</code>`<code>\r<ul><li>Embedded document</li></ul>\r\n\r\n</code>`<code>js\r\n{\"x\" : {\"foo\" : \"bar\"}}\r\n</code>`<code>\r<ul><li>Object ID</li></ul>\r\n\r\n</code>`<code>js\r\n{\"x\" : ObjectId()}\r\n</code>``\r<ul><li>Binary Data là một chuỗi các byte tùy ý.</li></ul>\r<ul><li>Code</li></ul>\r\n{\"x\" : function() { /<em> ... </em>/ }}</p>",
              "level": "fresher"
            },
            {
              "question": "Khi nào sử dụng MongoDB?",
              "answer": "<p>Bạn nên sử dụng MongoDB khi bạn đang xây dựng các ứng dụng internet và doanh nghiệp cần phát triển nhanh chóng và mở rộng quy mô một cách gọn gàng. MongoDB phổ biến với các nhà dev đang xây dựng các ứng dụng có khả năng mở rộng bằng cách sử dụng các phương pháp agile.\r\n\r\nMongoDB là một lựa chọn tuyệt vời nếu bạn cần:\r<ul><li>Hỗ trợ phát triển lặp đi lặp lại nhanh chóng.</li></ul>\r<ul><li>Mở rộng quy mô đến mức cao của lưu lượng đọc và ghi - MongoDB hỗ trợ mở rộng quy mô theo chiều ngang thông qua Sharding, phân phối dữ liệu trên một số máy và tạo điều kiện cho các hoạt động thông lượng cao với bộ dữ liệu lớn.</li></ul>\r<ul><li>Quy mô kho dữ liệu của bạn có một kích thước lớn.</li></ul>\r<ul><li>Phát triển loại hình triển khai khi doanh nghiệp thay đổi.</li></ul>\r<ul><li>Lưu trữ, quản lý và tìm kiếm dữ liệu với các văn bản, không gian địa lý hoặc chuỗi thời gian.</li></ul>\r\n\r\n## Câu hỏi phỏng vấn MongoDB cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về indexing trong Mongodb?",
              "answer": "<p>Chỉ mục (Index) hỗ trợ việc phân giải các truy vấn hiệu quả hơn. Nếu không có chỉ mục, MongoDB phải quét qua mọi Document của một Collection để chọn các Document mà kết nối với lệnh truy vấn. Việc quét này có thể không hiệu quả và yêu cầu MongoDB xử lý một số lượng lớn dữ liệu.\r\n\r\nChỉ mục (Index) là các cấu trúc dữ liệu đặc biệt, lưu giữ một phần nhỏ của tập hợp dữ liệu, giúp việc độc collection một cách dễ dàng hơn. Chỉ mục lưu giữ giá trị của một trường cụ thể hoặc tập hợp các trường, được sắp xếp bởi giá trị của trường như đã được xác định trong chỉ mục.\r\n\r\nĐể tạo chỉ mục, có thể dùng phương thức <code>createIndex</code>. Ví dụ:\r\n\r\n``<code>\r\n> db.users.find({\"username\": \"user101\"}).explain(\"executionStats\")\r\n</code>`<code>\r\n\r\nỞ đây, chế độ </code>executionStats` giúp ta hiểu tác dụng của việc sử dụng một chỉ mục để đáp ứng các truy vấn.</p>",
              "level": "fresher"
            },
            {
              "question": "Chỉ mục địa lý (Geospatial Indexes) trong MongoDB?",
              "answer": "<p>MongoDB có hai loại chỉ mục đia lý là: <strong>2d</strong> và <strong>2dsphere</strong>.\r\n\r\nChỉ mục 2dsphere làm việc với các hình cầu mô phỏng bề mặt trái đất dựa trên hệ toạ độ WGS-84. Hệ toạ độ này mô hình hoá bề mặt trái đất như một hình cầu phẳng. Do đó, ác phép tính khoảng cách sử dụng chỉ mục 2dsphere, sẽ tính đến hình dạng của trái đất và cung cấp cách xử lý chính xác hơn về khoảng cách giữa hai thành phố.\r\n\r\nVí dụ: Tính toán khoảng cách giữa hai thành phố\r<ul><li>Sử dụng chỉ mục 2d cho các điểm lưu trữ trên mặt phẳng hai chiều:</li></ul>\r\n``<code>js\r\n{\r\n    \"name\" : \"New York City\",\r\n    \"loc\" : {\r\n        \"type\" : \"Point\",\r\n        \"coordinates\" : [50, 2]\r\n    }\r\n}\r\n</code>`<code>\r<ul><li>2dsphere cho phép bạn chỉ định các điểm, đường thẳng, đa giác ở dạng GeoJSON. Một điểm được biểu diễn bởi một mảng hai phần tử[kinh độ, vĩ độ]:</li></ul>\r\n\r\n</code>`<code>js\r\n{\r\n    \"name\" : \"Hudson River\",\r\n    \"loc\" : {\r\n        \"type\" : \"LineString\",\r\n        \"coordinates\" : [[0,1], [0,2], [1,2]]\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "mysql",
          "name": "Câu hỏi phỏng vấn MySQL",
          "description": "",
          "questions": [
            {
              "question": "MySQL là gì?",
              "answer": "<p>MySQL là hệ quản trị cơ sở dữ liệu mã nguồn mở lớn nhất thế giới, đặc biết được dùng rất nhiều cho các dự án, ứng dụng, website trên internet.</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của MySQL?",
              "answer": "<p><ul><li><strong>Dễ sử dụng:</strong> MySQL là cơ sở dữ liệu tốc độ cao, ổn định, dễ sử dụng và hoạt động trên nhiều hệ điều hành cung cấp một hệ thống lớn các hàm tiện ích rất mạnh.</li></ul>\r<ul><li><strong>Độ bảo mật cao:</strong>  MySQL rất thích hợp cho các ứng dụng có truy cập CSDL trên Internet khi sở hữu nhiều nhiều tính năng bảo mật thậm chí là ở cấp cao.</li></ul>\r<ul><li><strong>Đa tính năng:</strong> MySQL hỗ trợ rất nhiều chức năng SQL được mong chờ từ một hệ quản trị cơ sở dữ liệu quan hệ cả trực tiếp lẫn gián tiếp.</li></ul>\r<ul><li><strong>Khả năng mở rộng và mạnh mẽ:</strong> MySQL có thể xử lý rất nhiều dữ liệu và hơn thế nữa nó có thể được mở rộng nếu cần thiết.</li></ul>\r<ul><li><strong>Nhanh chóng:</strong> Việc đưa ra một số tiêu chuẩn cho phép MySQL để làm việc rất hiệu quả và tiết kiệm chi phí, do đó nó làm tăng tốc độ thực thi.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu \"cơ sở dữ liệu\" là gì?",
              "answer": "<p>Cơ sở dữ liệu là hệ thống bao gồm rất nhiều thông tin, dữ liệu được xây dựng theo một cấu trúc nhất định nhằm đáp ứng nhu cầu khai thác, sử dụng của nhiều người hay chạy nhiều chương trình ứng dụng cùng một lúc.\r\n\r\nKhi áp dụng hình thức lưu trữ này, nó sẽ giúp khắc phục được những điểm yếu của việc lưu file thông thường trên máy tính. Các thông tin lưu trữ sẽ đảm bảo được nhất quán, hạn chế tình trạng trùng lặp thông tin.</p>",
              "level": "fresher"
            },
            {
              "question": "Chuẩn SQL là gì?",
              "answer": "<p>Chuẩn SQL (Structured Query Language) là ngôn ngữ sử dụng cho các RDBMS bên cạnh MySQL như Oracle, Microsoft SQL Server. Có thể coi SQL là ngôn ngữ chung mà bất cứ hệ thống cơ sở dữ liệu quan hệ (RDBMS) nào cũng phải đáp ứng.</p>",
              "level": "fresher"
            },
            {
              "question": "Một cơ sở dữ liệu MySQL bao gồm những gì?",
              "answer": "<p>Một cơ sở dữ liệu MySQL bao gồm một hay nhiều bảng, mỗi bảng gồm cột và dòng. Trong đó cột là các thuộc tính dữ liệu còn hàng là các bản ghi dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để tương tác với MySQL?",
              "answer": "<p>Có 3 cách để tương tác với MySQL:\r<ul><li>dùng lệnh trực tiếp</li></ul>\r<ul><li>qua web interface</li></ul>\r<ul><li>qua ngôn ngữ lập trình</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Truy vấn MySQL là gì?",
              "answer": "<p>Một truy vấn là một yêu cầu hay câu hỏi cụ thể. Nó đòi hỏi cơ sở dữ liệu phải trả về một hay nhiều bảng ghi cụ thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Các lệnh phổ biến trong MySQL?",
              "answer": "<p>| Command | Action |\r\n|---------|--------|\r\n| ALTER | Chỉnh sửa bảng hay cơ sở dữ liệu |\r\n| BACKUP | Phục hồi bảng |\r\n| CREATE | Tạo cơ sở dữ liệu |\r\n| DELETE | Xoá hàm của bảng |\r\n| DESCRIBE | Mô tả cột của bảng |\r\n| DROP | Xoá bảng hay cơ sở dữ liệu |\r\n| EXIT | Thoát |\r\n| GRANT | Đổi quyền người dùng |\r\n| HELP | Hiển thị bảng trợ giúp |\r\n| INSERT | Thêm dữ liệu |\r\n| LOCK | Khoá bảng |\r\n| QUIT | Giống EXIT |\r\n| RENAME | Đổi tên bảng |\r\n| SHOW | Liệt kê chi tiết đối tượng |\r\n| SOURCE | Thực thi một file |\r\n| STATUS | Hiển thị trạng thái hiện tại |\r\n| TRUNCATE | Làm trống bảng |\r\n| UNLOCK | Mở khoá bảng |\r\n| UPDATE | Cập nhật bảng ghi đã tồn tại |\r\n| USE | Sử dụng cơ sở dữ liệu |</p>",
              "level": "fresher"
            },
            {
              "question": "Cách tạo cơ sở dữ liệu trong MySQL?",
              "answer": "<p>``<code>sql\r\nCREATE DATABASE books;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách tạo bảng trong MySQL?",
              "answer": "<p>``<code>sql\r\nCREATE TABLE history (\r\n    author VARCHAR(128),\r\n    title VARCHAR(128),\r\n    type VARCHAR(16),\r\n    year CHAR(4)\r\n) ENGINE InnoDB;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách chèn dữ liệu vào MySQL?",
              "answer": "<p>Lệnh INSERT INTO dùng cho chèn bảng ghi mới vào bảng MySQL:\r\n\r\n``<code>sql\r\nINSERT INTO table<em>name (column1, column2, column3,...)\r\nVALUES (value1, value2, value3,...)\r\n</code>`<code>\r\n\r\nNếu bạn muốn thêm dữ liệu cho tất cả cột trong bảng, bạn không cần chỉ định tên cột trong truy vấn SQL. Tuy nhiên, trật tự của giá trị sẽ tương ứng với thứ tự cột của bảng.\r\n\r\n</code>`<code>sql\r\nINSERT INTO table</em>name \r\nVALUES (value1, value2, value3,...)\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Xoá cột trong MySQL?",
              "answer": "<p>``<code>sql\r\nALTER TABLE classics DROP pages;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Đánh chỉ mục trong MySQL?",
              "answer": "<p>Trong MySQL, có nhiều kiểu chỉ mục khác nhau như regular index, fulltext index hay primary key. Các chỉ mục giúp ta tìm kiếm nhanh hơn. Chỉ mục gia tăng hiệu suất bằng cách đánh thứ tự dữ liệu trên đĩa, nhờ đó mà nó tìm kiếm kết quả nhanh hơn, hoặc nói cho SQL engine biết vị trí cần tìm dữ liệu.\r\n\r\nVí dụ: \r\n\r\n``<code>sql\r\nALTER TABLE history ADD INDEX(author(10));\r\nALTER TABLE history ADD INDEX(title(10));\r\nALTER TABLE history ADD INDEX(category(5));\r\nALTER TABLE history ADD INDEX(year);\r\nDESCRIBE history;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Xoá dữ liệu trong bảng MySQL?",
              "answer": "<p>``<code>sql\r\nDELETE FROM table<em>name\r\nWHERE column</em>name = value_name\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách để xem cơ sở dữ liệu trong MySQL?",
              "answer": "<p>``<code>sql\r\nmysql> SHOW DATABASES;  \r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "postgresql",
          "name": "Câu hỏi phỏng vấn PostgreSQL",
          "description": "",
          "questions": [
            {
              "question": "Các tính năng trong PostgreSQL?",
              "answer": "<p><ul><li>Toàn vẹn dữ liệu: Là ràng buộc loại từ, khóa khuyến nghị, Primary Keys, Foreign Keys,…</li></ul>\r<ul><li>Kiểu dữ liệu: cấu trúc, nguyên hàm, hình học và tùy chỉnh</li></ul>\r<ul><li>Hiệu suất, đồng quy: Những tính năng lập danh mục, lập danh mục nâng cao và trình lập kế hoạch,…chúng đều được thực hiện một cách tự động.</li></ul>\r<ul><li>Các chức năng bảo mật: Bảo mật, xác thực, hệ thống kiểm soát truy cập mạnh mẽ, bảo mật cấp độ cột và hàng.</li></ul>\r<ul><li>Khả năng tìm kiếm văn bản: Tìm kiếm đầy đủ những văn bản, hệ thống bao gồm các kỳ tự quốc tế thông qua ICU collations.</li></ul>\r<ul><li>Khả năng mở rộng: PostgreSQL có phương pháp lưu trữ, ngôn ngữ thủ tục, tính năng kết nối cơ sở dữ liệu hoặc luồng khác với giao diện SQL chuẩn cùng với nhiều tính năng mở rộng vượt trội khác.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Multi-version Concurrency Control trong Postgres là gì?",
              "answer": "<p>Một trong những tính năng nổi bật của Postgres đó là cách mà nó thực hiện điều khiển tương tranh giữa các transaction, nghĩa là read sẽ không bao giờ chặn write và ngược lại. Nói một cách dễ hình dung hơn, nếu hai transaction thực thi cùng một lúc thì nguyên tắc thực thi là thực thi độc lập, Postgres thực hiện được điều này là nhờ một cơ chế gọi là Multi Version Concurrency Control (MVCC)</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để đánh chỉ mục trong Postgres?",
              "answer": "<p>Chỉ mục (Indexex) là các hàm có sẵn trong Postgres được sử dụng cho các truy vấn tìm kiếm để đạt hiệu quả cao hơn đối với một bảng trong cơ sở dữ liệu. Giả sữ rằng bạn có một bảng với hàng ngìn bản ghi và câu truy vấn của bạn thì chỉ có vài bản ghi là phù hợp với điều kiện, như vậy sẽ mất rất nhiều thời gian để tìm và trả về nững hàng thoả mã điều kiện này vì nó phải thực hiện hoạt động tìm kiếm trên từng hàng đơn lẻ. Điều này chắc chẵn không hiệu quả đối với một hệ thống xử lý dữ liệu khổng lồ. Bây giờ nếu hệ thống này có một chỉ mục trên cột mà chúng tôi đang áp dụng tìm kiếm, nó có thể sử dụng một phương pháp hiệu quả để xác định các hàng phù hợp bằng cách chỉ đi qua một vài cấp độ. Đây được gọi là lập chỉ mục (indexing).\r\n\r\n``<code>sql\r\nSELECT * FROM some<em>table WHERE table</em>col=120\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để thay đổi kiểu dữ liệu của cột?",
              "answer": "<p>Có thể sử dụng lệnh ALTER TABLE như bên dưới\r\n\r\n``<code>sql\r\nALTER TABLE tname\r\nALTER COLUMN col<em>name [SET DATA] TYPE new</em>data_type;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh dùng cho tạo cơ sở dữ liệu trong Postgres?",
              "answer": "<p>Cú pháp tạo cơ sở dữ liệu trong Postgres trong psql là:\r\n\r\n``<code>sql\r\nCREATE DATABASE db_name;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách để khởi động, dừng và khởi động lại trong PostgreSQL Server?",
              "answer": "<p><ul><li>Để khởi động Postgres server:</li></ul>\r\n\r\n``<code>text\r\nservice postgresql start\r\n</code>`<code>\r<ul><li>Sau khi server khởi động thành công, sẽ có thông báo như sau:</li></ul>\r\n\r\n</code>`<code>text\r\nStarting PostgreSQL: ok\r\n</code>`<code>\r<ul><li>Để khởi động lại Postgres server:</li></ul>\r\n\r\n</code>`<code>text\r\nservice postgresql restart\r\n</code>`<code>\r<ul><li>Nếu khởi động lại thành công:</li></ul>\r\n\r\n</code>`<code>text\r\nRestarting PostgreSQL: server stopped\r\nok\r\n</code>`<code>\r<ul><li>Để dừng server, ta chạy lệnh:</li></ul>\r\n\r\n</code>`<code>text\r\nservice postgresql stop\r\n</code>`<code>\r<ul><li>Nếu dừng thành công:</li></ul>\r\n\r\n</code>`<code>text\r\nStopping PostgreSQL: server stopped\r\nok\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu partioned table?",
              "answer": "<p>Partitioned table là một cấu trúc logic được dùng cho chia một bảng lớn thành các cấu trúc nhỏ hơn gọi là partition. Cách tiếp cận này được dùng để tăng hiệu suất truy vấn khi làm việc với bảng cơ sở dữ liệu lớn. Để tạo một partition, một khoá gọi là khoá phân vùng được dùng cho các cột hoặc biểu thức, và một phương thức phân vùng cần định nghĩa. Có 3 kiểu phương thức phân vùng có sẵn được cung cấp bởi Postgres:\r<ul><li><strong>Range Partitioning</strong>: Phương pháp này được thực hiện bằng cách phân vùng dựa trên một loạt các giá trị. Phương pháp này được sử dụng phổ biến nhất dựa trên các trường ngày tháng để lấy dữ liệu hàng tháng, hàng tuần hoặc hàng năm. Trong trường hợp như giá trị thuộc phần cuối của phạm vi, ví dụ: nếu phạm vi của phân vùng 1 là 10-20 và phạm vi của phân vùng 2 là 20-30 và giá trị đã cho là 10, thì 10 thuộc về đến phân vùng thứ hai chứ không phải phân vùng đầu tiên.</li></ul>\r<ul><li><strong>List Partitioning</strong>: Phương pháp này được sử dụng để phân vùng dựa trên danh sách các giá trị đã biết. Thường được sử dụng nhất khi chúng ta có key có giá trị phân loại. Ví dụ: nhận dữ liệu bán hàng dựa trên các khu vực được chia thành quốc gia, thành phố hoặc tiểu bang.</li></ul>\r<ul><li><strong>Hash Partitioning</strong>: Phương pháp này sử dụng một hàm băm trên khoá phân vùng. Điều này được thực hiện khi không có yêu cầu cụ thể nào đối với việc phân chia dữ liệu và được sử dụng để truy cập dữ liệu riêng lẻ. Ví dụ: bạn muốn truy cập dữ liệu dựa trên một sản phẩm cụ thể, thì việc sử dụng phân vùng băm sẽ dẫn đến tập dữ liệu đã yêu cầu.</li></ul>\r\n\r\nLoại khoá phân vùng và loại phương pháp được sử dụng để phân vùng xác định mức độ tích cực của hiệu suất và mức độ quản lý của bảng được phân vùng.</p>",
              "level": "fresher"
            },
            {
              "question": "Token trong Postgres?",
              "answer": "<p>Token trong Postgres là một từ khoá, tên định danh, hằng, hay bất kỳ ký hiệu nào cho tính riêng biệt. Nó có thể được phân chia (hoặc không) bằng khoảng trắng, tab hay xuống dòng. Nếu token là từ khoá, nó thường là một lệnh hữu ích. Token có thể được tạo bằng bất kỳ code PostgreSQL nào.</p>",
              "level": "fresher"
            },
            {
              "question": "Câu lệnh TRUNCATE là gì?",
              "answer": "<p>Lệnh TRUNCATE TABLE name<em>of</em>table xoá dữ liệu một cách hiệu quả và nhanh chóng khỏi bảng.\r\n\r\n``<code>sql\r\nTRUNCATE TABLE name<em>of</em>table \r\nRESTART IDENTITY;\r\n</code>`<code>\r\n\r\nTa còn có thể dùng lệnh cho xoá nhiều bảng cùng lúc như sau:\r\n\r\n</code>`<code>sql\r\nTRUNCATE TABLE \r\n   table<em>1, \r\n   table</em>2,\r\n   table_3;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Dung lượng của một bảng trong Postgres?",
              "answer": "<p>Kích cỡ lớn nhất cho một bản là 32TB.</p>",
              "level": "fresher"
            },
            {
              "question": "Sequence trong Postgres?",
              "answer": "<p>Sequence là một đối tượng dữ liệu trong PostgreSQL, được sử dụng để tạo ra chuỗi các số tự nhiên (integer) theo 1 quy tắc nhất định. Để tạo 1 Sequece chúng ta sử dụng câu lệnh SQL là: <code>CREATE SEQUENCE</code>\r\n\r\n``<code>sql\r\nCREATE SEQUENCE serial<em>num START 100;\r\n</code>`<code>\r\n\r\nĐể lấy số 101 trong sequence, ta sử dụng phương thức </code>nextval()<code>:\r\n\r\n</code>`<code>sql\r\nSELECT nextval('serial</em>num');\r\n</code>`<code>\r\n\r\nTa cũng có thể dùng sequence trong khi chèn bản ghi:\r\n\r\n</code>`<code>sql\r\nINSERT INTO ib<em>table</em>name VALUES (nextval('serial_num'), 'interview');\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Chuỗi trong Postgres?",
              "answer": "<p>Nó là một chuỗi ký tự nằm trong dấu nháy đơn. Nó được dùng trong suốt quá trình thêm hay cập nhật ký tự trong cơ sở dữ liệu.\r\n\r\nChuỗi hằng nằm trong dấu dollar. Cú pháp <code>$tag$<string_constant>$tag$</code>. Thẻ trong hằng là tuỳ chọn và có thể không cần chỉ định, hằng còn được gọi là một vòng lặp chuỗi dollar kép.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm cách nào để hiện thị tất cả cơ sở dữ liệu trong Postgres?",
              "answer": "<p>Trong psql dùng lệnh <code>\\l</code> để xem tất cả cơ sở dữ liệu.</p>",
              "level": "fresher"
            },
            {
              "question": "Xoá cơ sở dữ liệu trong Postgres?",
              "answer": "<p>Cú pháp xoá cơ sở dữ liệu như sau:\r\n\r\n``<code>sql\r\nDROP DATABASE database_name;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính ACID là gì?",
              "answer": "<p>ACID (viết tắt của Atomicity, Consistency, Isolation, Durability) là tính chất trong đó bao gồm tập hợp của 4 đặc tính khác nhau áp dụng cho một database transaction.\r<ul><li><strong>Atomicity</strong> quy định rằng tất các hành động của một transaction cần được thực hiện thành công hoặc ngược lại nếu có một hành động không được thực hiện thì sẽ không có bất cứ hành động nào khác được thực hiện thành công.</li></ul>\r<ul><li><strong>Consistency</strong> quy định tại bất kỳ thời điểm nào, trước hoặc sau một transaction được thực hiện dù lỗi hay không lỗi, thì cơ sở dữ liệu vẫn phải được giữ ở trạng thái hợp lệ (ví dụ dữ liệu phải phù hợp với các quy định được định nghĩa cho cơ sở dữ liệu).</li></ul>\r<ul><li><strong>Isolation</strong> quy định từng transaction khác nhau cần phải được thực hiện trong một môi trường độc lập, nếu có 2 transaction diễn ra tại cùng một thời điểm thì cần một cơ chế đảm bảo transaction này không ảnh hưởng tới transaction khác.</li></ul>\r<ul><li><strong>Durability</strong> quy định rằng khi transaction được diễn ra (thành công hoặc rollback lại khi có lỗi) thì sau đó dù có bất cứ sự cố nào diễn ra với cơ sở dữ liệu (mất điện, server tràn bộ nhớ...) thì khi được khôi phục lại thì dữ liệu được khôi phục sẽ giữ nguyên trạng thái trước khi có sự cố (đảm bảo không có bất cứ transaction trước đó không bị mất).</li></ul>\r\n\r\nPostgreSQL tuân theo các thuộc tính ACID.\r\n\r\n<img src=\"/interview-assets/acid.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "sql",
          "name": "Câu hỏi phỏng vấn SQL",
          "description": "",
          "questions": [
            {
              "question": "Cơ sở dữ liệu là gì?",
              "answer": "<p>Cơ sở dữ liệu là một tập hợp dữ liệu có tổ chức, được lưu trữ và truy xuất từ một hệ thống máy tính cục bộ hoặc từ xa. Cơ sở dữ liệu có thể rất lớn và phức tạp, những cơ sở dữ liệu như vậy được phát triển bằng cách sử dụng các phương pháp thiết kế và mô hình hóa cố định.</p>",
              "level": "middle"
            },
            {
              "question": "DBMS là gì?",
              "answer": "<p>DBMS là viết tắt của Database Management System. DBMS là một phần mềm hệ thống chịu tránh nhiệm tạo, truy xuất, chỉnh sửa và quản lý cơ sở dữ liệu. Nó đảm bảo rằng dữ liệu của ta sẽ được tổ chức nhất quán, và dễ dàng truy cập bằng cách dùng interface giữa cơ sở dữ liệu và người dùng hay phần mềm ứng dụng.</p>",
              "level": "middle"
            },
            {
              "question": "RDBMS là gì? Nó khác với DBMS như thế nào",
              "answer": "<p>RDBMS là viết tắt của Relational Database Management System. Điểm khác biệt của nó với DBMS là RDBMS lưu trữ dữ liệu ở dạng bảng, và các mối quan hệ được xác định là các trường chung giữa các bảng này. Các RDBMS phổ biến nhất hiện này có thể kể đến: MySQL, Oracle, PostgreSQL, Microsoft SQL Server,...\r\n\r\n<img src=\"/interview-assets/dbms_vs_rdbms.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "SQL là gì?",
              "answer": "<p>SQL là viết tắt của Structured Query Language. Nó là ngôn ngữ chuẩn cho các RDBMS. Nó đặc biệt hữu ích trong việc tổ chức dữ liệu bao gồm các thực thế và các mối quan hệ giữa các thực thế khác nhau của dữ liệu.</p>",
              "level": "middle"
            },
            {
              "question": "Sự khác biệt giữa SQL và MySQL?",
              "answer": "<p>SQL như đã nói ở trên là ngôn ngữ chuẩn cho truy vấn và quản lý cơ sở dữ liệu. Còn MySQL là một RDBMS giống như Postgres hay Oracle, được dùng để quản lý cơ sở dữ liệu SQL.\r\n\r\n<img src=\"/interview-assets/sql_vs_mysql.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Bảng và trường là gì?",
              "answer": "<p>Bảng là một tập hợp dữ liệu có tổ chức được lưu trữ dưới dạng hàng và cột. Các cột có thể được phân loại thành hàng dọc và hàng ngang. Các cột trong bảng được gọi là trường trong khi các hàng có thể được gọi là bản ghi.</p>",
              "level": "middle"
            },
            {
              "question": "Ràng buộc trong SQL?",
              "answer": "<p>Các ràng buộc được sử dụng để chỉ định các quy tắc liên quan đến dữ liệu trong bảng. Nó có thể được áp dụng cho một hoặc nhiều trường trong bảng SQL, khi bắt đầu tạo bảng hoặc sau khi tạo bằng lệnh <code>ALTER TABLE</code>. Các ràng buộc là:\r<ul><li><strong>NOT NULL</strong> - Không được thêm giá trị <code>NULL</code> vào một cột.</li></ul>\r<ul><li><strong>CHECK</strong> - Xác minh rằng tất cả các giá trị trong một trường thỏa mãn một điều kiện.</li></ul>\r<ul><li><strong>DEFAULT</strong> - Tự động gán giá trị mặc định nếu không có giá trị nào được chỉ định cho trường.</li></ul>\r<ul><li><strong>UNIQUE</strong> - Đảm bảo các giá trị được chèn vào trường là duy nhất trong bảng.</li></ul>\r<ul><li><strong>INDEX</strong> - Đánh chỉ mục một trường, giúp truy xuất nhanh hơn.</li></ul>\r<ul><li><strong>PRIMARY KEY</strong> - Định danh duy nhất cho từng bản ghi trong bảng.</li></ul>\r<ul><li><strong>FOREIGN KEY</strong> - Đảm bảo tính toàn vẹn tham chiếu cho một bản ghi trong bảng khác.</li></ul>\r\n\r\n## 8. Khoá chính là gì?\r\n\r\nRàng buộc <code>PRIMARY KEY</code> là định danh duy nhất cho mỗi hàng trong bảng. Nó phải chứa các giá trị <code>UNIQUE</code> và có ràng buộc <code>NOT NULL</code> ngầm.\r\n\r\nMột bảng trong SQL bị hạn chế nghiêm ngặt chỉ có một khóa chính, bao gồm một hoặc nhiều trường (cột).\r\n\r\n``<code>sql\r\nCREATE TABLE Students (   /<em> Create table with a single field as primary key </em>/\r\n   ID INT NOT NULL\r\n   Name VARCHAR(255)\r\n   PRIMARY KEY (ID)\r\n);\r\n\r\nCREATE TABLE Students (   /<em> Create table with multiple fields as primary key </em>/\r\n   ID INT NOT NULL\r\n   LastName VARCHAR(255)\r\n   FirstName VARCHAR(255) NOT NULL,\r\n   CONSTRAINT PK<em>Student\r\n   PRIMARY KEY (ID, FirstName)\r\n);\r\n\r\nALTER TABLE Students   /<em> Set a column as primary key </em>/\r\nADD PRIMARY KEY (ID);\r\nALTER TABLE Students   /<em> Set multiple columns as primary key </em>/\r\nADD CONSTRAINT PK</em>Student   /<em>Naming a Primary Key</em>/\r\nPRIMARY KEY (ID, FirstName);\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Ràng buộc UNIQUE là gì?",
              "answer": "<p>Ràng buộc <code>UNIQUE</code> đảm bảo rằng tất cả các giá trị trong một cột là khác nhau. Điều này cung cấp tính duy nhất cho (các) cột và giúp xác định từng hàng duy nhất. Không giống như khóa chính, có thể có nhiều ràng buộc <code>UNIQUE</code> được xác định trên mỗi bảng. Cú pháp code cho <code>UNIQUE</code> khá giống với cú pháp của <code>PRIMARY KEY</code> và có thể được sử dụng thay thế cho nhau.\r\n\r\n``<code>sql\r\nCREATE TABLE Students (   /<em> Create table with a single field as unique </em>/\r\n   ID INT NOT NULL UNIQUE\r\n   Name VARCHAR(255)\r\n);\r\n\r\nCREATE TABLE Students (   /<em> Create table with multiple fields as unique </em>/\r\n   ID INT NOT NULL\r\n   LastName VARCHAR(255)\r\n   FirstName VARCHAR(255) NOT NULL\r\n   CONSTRAINT PK<em>Student\r\n   UNIQUE (ID, FirstName)\r\n);\r\n\r\nALTER TABLE Students   /<em> Set a column as unique </em>/\r\nADD UNIQUE (ID);\r\nALTER TABLE Students   /<em> Set multiple columns as unique </em>/\r\nADD CONSTRAINT PK</em>Student   /<em> Naming a unique constraint </em>/\r\nUNIQUE (ID, FirstName);\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Khoá ngoại là gì?",
              "answer": "<p><code>FOREIGN KEY</code> bao gồm một hoặc một tập hợp các trường trong bảng tham chiếu đến <code>PRIMARY KEY</code> trong một bảng khác. Ràng buộc khóa ngoại đảm bảo tính toàn vẹn tham chiếu trong mối quan hệ giữa hai bảng.\r\n\r\nBảng có ràng buộc khóa ngoại được gắn nhãn là bảng con và bảng chứa khóa chính được gắn nhãn là bảng tham chiếu hoặc bảng cha.\r\n\r\n``<code>sql\r\nCREATE TABLE Students (   /<em> Create table with foreign key - Way 1 </em>/\r\n   ID INT NOT NULL\r\n   Name VARCHAR(255)\r\n   LibraryID INT\r\n   PRIMARY KEY (ID)\r\n   FOREIGN KEY (Library<em>ID) REFERENCES Library(LibraryID)\r\n);\r\n\r\nCREATE TABLE Students (   /<em> Create table with foreign key - Way 2 </em>/\r\n   ID INT NOT NULL PRIMARY KEY\r\n   Name VARCHAR(255)\r\n   LibraryID INT FOREIGN KEY (Library</em>ID) REFERENCES Library(LibraryID)\r\n);\r\n\r\nALTER TABLE Students   /<em> Add a new foreign key </em>/\r\nADD FOREIGN KEY (LibraryID)\r\nREFERENCES Library (LibraryID);\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "JOIN là gì? Liệt kê các kiểu JOIN?",
              "answer": "<p>Mệnh đề SQL Join được sử dụng để kết hợp các bản ghi (hàng) từ hai hoặc nhiều bảng trong cơ sở dữ liệu SQL dựa trên một cột có liên quan giữa hai bảng.\r\n\r\n<img src=\"/interview-assets/sql_join.jpg\" alt=\"\" />\r\n\r\nCó 4 kiểu JOIN trong SQL:\r<ul><li><strong>INNER JOIN</strong>: truy xuất các bảng ghi có giá trị phù hợp giữa hai bảng liên quan đến join. Đấy là kiểu join được sử dụng rộng rãi cho truy vấn.</li></ul>\r\n\r\n``<code>sql\r\nSELECT <em>\r\nFROM Table<em>A\r\nJOIN Table</em>B;\r\nSELECT </em>\r\nFROM Table<em>A\r\nINNER JOIN Table</em>B;\r\n</code>`<code>\r<ul><li><strong>LEFT (OUTER) JOIN</strong>: Truy xuất tất cả các bản ghi/hàng từ bên trái và các bản ghi/hàng phù hợp từ bảng bên phải.</li></ul>\r\n\r\n</code>`<code>sql\r\nSELECT <em>\r\nFROM Table<em>A A\r\nLEFT JOIN Table</em>B B\r\nON A.col = B.col;\r\n</code>`<code>\r<ul><li><strong>RIGHT (OUTER) JOIN</strong>: Truy xuất tất cả các bản ghi/hàng từ bên phải và các bản ghi/hàng phù hợp từ bảng bên trái.</li></ul>\r\n\r\n</code>`<code>sql\r\nSELECT </em>\r\nFROM Table<em>A A\r\nRIGHT JOIN Table</em>B B\r\nON A.col = B.col;\r\n</code>`<code>\r<ul><li><strong>FULL (OUTER) JOIN</strong>: Truy xuất tất cả các bản ghi có sự phù hợp trong bảng bên trái hoặc bên phải.</li></ul>\r\n\r\n</code>`<code>sql\r\nSELECT *\r\nFROM Table<em>A A\r\nFULL JOIN Table</em>B B\r\nON A.col = B.col;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Self-Join là gì?",
              "answer": "<p>Self JOIN à một trường hợp join thông thường trong đó một bảng được liên kết với chính nó dựa trên một số mối quan hệ giữa (các) cột của chính nó. Self-Join  sử dụng mệnh đề INNER JOIN hoặc LEFT JOIN và tên bí danh bảng để gán các tên khác nhau cho bảng trong truy vấn. \r\n\r\n``<code>sql\r\nSELECT A.emp<em>id AS \"Emp</em>ID\",A.emp<em>name AS \"Employee\",\r\nB.emp</em>id AS \"Sup<em>ID\",B.emp</em>name AS \"Supervisor\"\r\nFROM employee A, employee B\r\nWHERE A.emp<em>sup = B.emp</em>id;\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "Cross-Join là gì?",
              "answer": "<p>Cross-Join có thể được định nghĩa là một tích descartes của hai bảng trong phép join. Bảng sau khi join có số hàng là tích descartes số hàng của hai bảng. Nếu mệnh đề WHERE được sử dụng trong cross-join thì truy vấn sẽ hoạt động giống như một INNER JOIN. \r\n\r\n``<code>sql\r\nSELECT stu.name, sub.subject \r\nFROM students AS stu\r\nCROSS JOIN subjects AS sub;\r\n</code>``\r\n\r\n<img src=\"/interview-assets/cross_join.jpg\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Đánh chỉ mục là gì? Giải thích các kiểu chỉ mục khác nhau?",
              "answer": "<p>Chỉ mục trong cơ sở dữ liệu là một dạng cấu trúc dữ liệu cung cấp chức năng tìm kiếm dữ liệu nhanh trong cột hay bảng. Nó tăng tốc độ chi truy cập dữ liệu từ cơ sở dữ liệu với chi phí bổ sung ghi và bộ nhớ để duy trì cấu trúc dữ liệu chỉ mục. \r\n\r\n``<code>sql\r\nCREATE INDEX index<em>name   /<em> Create Index </em>/\r\nON table</em>name (column<em>1, column</em>2);\r\nDROP INDEX index<em>name;   /<em> Drop Index </em>/\r\n</code>`<code>\r\n\r\nCác kiểu chỉ mục có thể được tạo cho các mục đích khác nhau:\r<ul><li><strong>Unique/Non-Unique Index</strong>: chỉ mục duy nhất là chỉ mục giúp duy trì tính toàn vẹn của dữ liệu bằng cách đảm bảo rằng không có hai hàng dữ liệu nào trong bảng có giá trị khoá giống nhau. Khi một chỉ mục duy nhất đã được xác định cho một bảng, tính duy nhất được thực thi bất cứ khi nào khoá được thêm vào hay thay đổi chỉ mục.</li></ul>\r\n\r\n</code>`<code>sql\r\nCREATE UNIQUE INDEX myIndex\r\nON students (enroll</em>no);\r\n</code>``\r\n\r\nNgược lại các chỉ mục không phải là duy nhất không được dùng để ràng bụooc các bảng mà chúng được liên kết với nhau. Các chỉ mục này được dùng để cải thiện hiệu suất truy vấn bằng cách duy trì thứ tự được sắp xếp của các giá trị dữ liệu được sắp xếp thường xuyên.\r<ul><li><strong>Clustered/Non-Clustered Index</strong>: </li></ul>\r\n\r\nClustered Index lưu trữ và sắp xếp dữ liệu vật lý trong bảng dựa trên các giá trị khóa của chúng. Các cột khóa này được chỉ định trong định nghĩa index. Mỗi bảng chỉ có duy nhất một Clusterd Index vì bản thân các dòng dữ liệu được lưu trữ và sắp xếp theo thứ tự vật lý dựa trên các cột trong loại Index này.\r\n\r\nNon-Clustered có một cấu trúc tách biệt với dữ liệu hàng trong bảng. Mỗi một index loại này chứa các giá trị của các cột khóa trong khai báo của index, và mỗi một bản ghi giá trị của key trong index này chứa một con trỏ tới dòng dữ liệu tương ứng của nó trong bảng.</p>",
              "level": "middle"
            },
            {
              "question": "Toàn vẹn dữ liệu là gì?",
              "answer": "<p>Toàn vẹn dữ liệu (data integrity) là sự dảm bảo tính nhất quán và chính xác của dữ liệu trong toàn bộ vòng đời của chúng. Nó là một khía cạnh quan trọng trong thiết kế, triển khai và sử dụng bất kỳ hệ thống nào lưu trữ, xử lý hoặc truy xuất dữ liệu. Nó cũng xác định các ràng buộc toàn vẹn để thực thi các quy tắc nghiệp vụ trên dữ liệu khi nó được nhập vào ứng dụng hoặc cơ sở dữ liệu.</p>",
              "level": "middle"
            },
            {
              "question": "Truy vấn là gì?",
              "answer": "<p>Truy vấn là một yêu cầu về dữ liệu hay thông tin từ một bảng hay là kết hợp nhiều bảng trong cơ sở dữ liệu. Một truy vấn có thể là truy vấn chọn lựa hoặc truy vấn hành động.\r\n\r\n``<code>sql\r\nSELECT fname, lname    /<em> select query </em>/\r\nFROM myDb.students\r\nWHERE student<em>id = 1;\r\n</code>`<code>\r\n</code>`<code>sql\r\nUPDATE myDB.students    /<em> action query </em>/\r\nSET fname = 'Captain', lname = 'America'\r\nWHERE student</em>id = 1;\r\n</code>``</p>",
              "level": "middle"
            }
          ]
        }
      ]
    },
    {
      "id": "devops",
      "name": "DevOps",
      "icon": "settings",
      "color": "#9c27b0",
      "subcategories": [
        {
          "id": "docker",
          "name": "Câu hỏi phỏng vấn Docker",
          "description": "",
          "questions": [
            {
              "question": "Giải thích về container trong Docker?",
              "answer": "<p><ul><li>Nói một cách đơn giản nhất, container bao gồm các ứng dụng và tất cả các phụ thuộc của chúng.</li></ul>\r<ul><li>Chúng chia sẻ nhân và tài nguyên hệ thống với các container khác và chạy như các hệ thống biệt lập trong hệ điều hành chủ.</li></ul>\r<ul><li>Mục đích chính của container là loại bỏ sự phụ thuộc vào cơ sở hạ tầng trong khi triển khai và chạy các ứng dụng. Điều này có nghĩa là bất kỳ ứng dụng được chứa trong container nào cũng có thể chạy trên bất kỳ nền tảng nào bất kể cơ sở hạ tầng đang được sử dụng bên dưới.</li></ul>\r<ul><li>Về mặt kỹ thuật, chúng chỉ là các phiên bản runtime của docker image.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Docker image là gì?",
              "answer": "<p>Chúng là các gói thực thi (được đóng gói với code ứng dụng và phần phụ thuộc, gói phần mềm, v.v.) nhằm mục đích tạo container. Docker image có thể được triển khai cho bất kỳ môi trường docker nào và các container có thể được xoay ở đó để chạy ứng dụng.</p>",
              "level": "fresher"
            },
            {
              "question": "DockerFile là gì?",
              "answer": "<p>Nó là một file văn bản có tất cả các lệnh cần được chạy để xây dựng một image nhất định.\r\n\r\n<img src=\"/interview-assets/Docker_File.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Chức năng của hypervisor là gì?",
              "answer": "<p>Hypervisor là một phần mềm giúp cho quá trình ảo hóa diễn ra vì nó đôi khi được gọi là Virtual Machine Monitor. Điều này phân chia tài nguyên của hệ thống máy chủ và phân bổ chúng cho từng môi trường khách được cài đặt.\r\n\r\n<img src=\"/interview-assets/Hypervisor.png\" alt=\"\" />\r\n\r\nĐiều này có nghĩa là nhiều hệ điều hành có thể được cài đặt trên một hệ thống máy chủ duy nhất. Hypervisor có 2 loại:\r\n\r\n1. Native Hypervisor: Loại này còn được gọi là Bare-metal Hypervisor và chạy trực tiếp trên hệ thống máy chủ bên dưới, điều này cũng đảm bảo quyền truy cập trực tiếp vào phần cứng máy chủ, đó là lý do tại sao nó không yêu cầu hệ điều hành cơ bản.\r\n2. Hosted Hypervisor: Loại này sử dụng hệ điều hành máy chủ cơ bản đã được cài đặt hệ điều hành hiện có.</p>",
              "level": "fresher"
            },
            {
              "question": "Docker compose là gì?",
              "answer": "<p>Nó là một file YAML bao gồm tất cả các chi tiết liên quan đến các dịch vụ, mạng và khối lượng khác nhau cần thiết để thiết lập ứng dụng dựa trên Docker. Vì vậy, docker-compose được sử dụng để tạo nhiều container, lưu trữ chúng và thiết lập giao tiếp giữa chúng. Với mục đích giao tiếp giữa các container, các cổng được tiếp xúc bởi từng container.</p>",
              "level": "fresher"
            },
            {
              "question": "Docker namespace là gì?",
              "answer": "<p>Namespace về cơ bản là một tính năng của Linux đảm bảo phân vùng tài nguyên hệ điều hành theo cách loại trừ lẫn nhau. Điều này hình thành khái niệm cốt lõi đằng sau quá trình container hóa khi namespace giới thiệu một lớp cách ly giữa các container. Trong docker, namespace đảm bảo rằng các container có thể di động và chúng không ảnh hưởng đến máy chủ bên dưới. Ví dụ về các loại namespace hiện đang được Docker hỗ trợ - PID, Mount, User, Network, IPC.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách hiển thị trạng thái của tất cả docker container bằng dòng lệnh?",
              "answer": "<p>``<code>\r\ndocker ps -a\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Dữ liệu được lưu trữ trong container sẽ bị mất trong những trường hợp nào?",
              "answer": "<p>Dữ liệu của container vẫn ở trong đó cho đế khi bạn xóa container.</p>",
              "level": "fresher"
            },
            {
              "question": "Docker image registry?",
              "answer": "<p>Theo thuật ngữ đơn giản, Docker image registry là một khu vực lưu trữ các docker image. Thay vì chuyển đổi các ứng dụng thành container mỗi lần, một nhà phát triển có thể sử dụng trực tiếp các iamge được lưu trữ trong registry.\r\nDocker image registry có thể là công khai hoặc riêng tư và DockerHub là tổ chức đăng ký công khai phổ biến và nổi tiếng nhất hiện có.</p>",
              "level": "fresher"
            },
            {
              "question": "Các thành phần trong Docker?",
              "answer": "<p>Có 3 thành phần Docker là:\r\n\r\n<em> <strong>Docker Client:</strong> Thành phần này sẽ thực hiện hành động \"build\" và \"run\" nhằm mục đích mở ra giao tiếp với docket host.\r\n</em> <strong>Docker Host:</strong> Thành phần này gồm daemon chính của docker, các host container và image của chúng. Daemon thiết lập một kết nối đến docker registry.\r<ul><li><strong>Docker Registry:</strong> Thành phần này lưu trữ docker image. Nó có thể là công khai hoặc riêng tư. Các registry công khai nổi tiếng là Docker Hub và Docker Cloud.</li></ul>\r\n\r\n<img src=\"/interview-assets/docker_components.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Docker Hub là gì?",
              "answer": "<p><ul><li>Là một nền tảng đám mây được cung cấp bởi Docker cho phép lưu trữ công khai image của Docker đồng thời cho phép tìm kiếm và chia sẻ với người khác.</li></ul>\r<ul><li>Image có thể được đẩy lên Docker Hub bằng câu lệnh <code>docker push</code>.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh để export một docket image như một archive?",
              "answer": "<p>Cú pháp đó là:\r\n\r\n``<code>\r\ndocker save -o <exported_name>.tar <container-name>\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh để import một Docker image đến một Docker host khác?",
              "answer": "<p>``<code>\r\ndocker load -i <export<em>image</em>name>.tar\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể xoá container bị tạm dừng khỏi Docker không?",
              "answer": "<p>Không thể! Container phải bị dừng trạng thái trước khi ta có thể xoá chúng.</p>",
              "level": "fresher"
            },
            {
              "question": "Lệnh kiểm tra phiên bản Docker client và server?",
              "answer": "<p>Để kiểm tra tất cả không tin phiên bản client và server là:\r\n\r\n``<code>\r\ndocker version\r\n</code>`<code>\r\n\r\nĐể lấy chỉ phiên bản server, ta có thể chạy:\r\n\r\n</code>`<code>\r\ndocker version --format '{{.Server.Version}}'\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "golang",
          "name": "Câu hỏi phỏng vấn Golang",
          "description": "",
          "questions": [
            {
              "question": "Golang là gì?",
              "answer": "<p><ul><li>Go là một ngôn ngữ lập trình đa năng, cấp cao, static typing và mạnh mẽ bằng cách cung cấp hỗ trợ cho việc thu gom rác và lập trình đồng thời.</li></ul>\r<ul><li>Trong Go, các chương trình được xây dựng bằng cách sử dụng các package (gói) giúp quản lý các phần dependencies (phụ thuộc) một cách hiệu quả. Nó cũng sử dụng mô hình compile-link để tạo các file nhị phân thực thi từ mã nguồn. </li></ul>\r<ul><li>Go là một ngôn ngữ đơn giản với cấu trúc cú pháp thanh lịch và dễ hiểu. Nó có một tập hợp có sẵn các thư viện tiêu chuẩn mạnh mẽ giúp các nhà phát triển giải quyết vấn đề mà không cần đến các package của bên thứ ba. </li></ul>\r<ul><li>Go có hỗ trợ first-class cho concurrency có khả năng sử dụng kiến trúc bộ xử lý đa lõi theo lợi thế của nhà phát triển và sử dụng bộ nhớ hiệu quả. Điều này giúp các ứng dụng mở rộng quy mô theo cách đơn giản hơn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao nên học Golang?",
              "answer": "<p>Go tuân theo nguyên tắc phát huy tác dụng tối đa với nỗ lực tối thiểu. Mọi tính năng và cú pháp của Go đều được phát triển để giúp các lập trình viên dễ dàng sử dụng. Sau đây là những ưu điểm của Go:\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Golang package là gì?",
              "answer": "<p>Go Package (gọi tắt là <code>pkg</code>) là một đường dẫn đến workspace của Go bao gồm file nguồn hoặc các package khác của nó. Tất cả các phần code từ biến đến hàm được viết trong file nguồn sẽ được lưu trong package được liên kết. Tất cả file nguồn nên nằm trong một package.\r\n\r\nNhư ảnh bên dưới, ta có thể thấy Go Package được biểu diễn như một các hộp nơi chứa tất cả file nguồn Go hoặc mở rộng <code>.go</code>. Ta cũng có thể lưu package Go trong một package khác.\r\n\r\n<img src=\"/interview-assets/Golang_packages.png\" alt=\"\" />\r\n\r\nPackage được khai báo ở đầu file với cú pháp\r\n\r\n``<code>go\r\npackage <package<em>name>\r\n</code>`<code>\r\n\r\nVà được import theo cú pháp\r\n\r\n</code>`<code>go\r\nimport <package</em>name>\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Golang là case sensitive hay insensitive?",
              "answer": "<p>Go là ngôn ngữ case-sensitive.</p>",
              "level": "fresher"
            },
            {
              "question": "Go Pointer là gì?",
              "answer": "<p>Con trỏ (pointer) trong Go là các biến giữ địa chỉ của biến khác. Con trỏ hỗ trợ hai toán tử là:\r<ul><li>Toán tử <code><em></code>: còn được gọi là toán tử tham chiếu được dùng để truy cập giá trị trong địa chỉ được lưu trữ bởi con trỏ.</li></ul>\r<ul><li>Toán tử <code>&</code>: còn được gọi là toán tử địa chỉ được dùng để trả về địa chỉ của biến được lưu trữ bởi con trỏ.</li></ul>\r\n\r\nĐiều này được minh họa trong sơ đồ dưới đây. Ở đây, chúng ta có một biến <code>x</code> được gán cho <code>100</code>. Chúng ta lưu trữ <code>x</code> trong địa chỉ bộ nhớ <code>0x0201</code>. Bây giờ, khi chúng ta tạo một con trỏ tên <code>Y</code> cho biến <code>x</code>, chúng ta gán giá trị là <code>&x</code> để lưu trữ địa chỉ của biến <code>x</code>. Biến con trỏ được lưu trong địa chỉ <code>0x0208</code>. Bây giờ để lấy giá trị được lưu trong địa chỉ được lưu trong con trỏ, chúng ta chỉ cần viết <code>int z: = </em> Y</code>.\r\n\r\n<img src=\"/interview-assets/Golang_pointers.png\" alt=\"\" />\r\n\r\nCon trỏ được dùng cho các mục đích sau:\r<ul><li>Cho phép hàm thay đổi trực tiếp giá trị tham số được truyền cho nó. </li></ul>\r<ul><li>Để tăng hiệu suất trong các trường hợp cạnh khi có cấu trúc dữ liệu lớn. Sử dụng con trỏ giúp sao chép dữ liệu lớn một cách hiệu quả.</li></ul>\r<ul><li>Giúp biểu thị sự thiếu giá trị. Ví dụ: trong khi giải nén dữ liệu JSON vào một struct, sẽ rất hữu ích khi biết nếu khóa có hay không có thì khóa hiện diện với giá trị 0.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Chuỗi ký tự trong Golang?",
              "answer": "<p>Chuỗi ký tự là những biến lưu trữ các hằng chuỗi có thể là một ký tự đơn lẻ hoặc có thể là kết quả của việc nối một chuỗi ký tự. Go cung cấp hai loại chuỗi ký tự:\r<ul><li>Chuỗi ký tự thuần: Ở đây giá trị của chuỗi không bị gián đoạn giữa các dấu backqoute(<code>).</li></ul>\r\n\r\n</code>`<code>go\r\n</code>interview<code>\r\n</code>`<code>\r<ul><li>Chuỗi ký tự thông dịch: ở đây các chuỗi ký tự được đặt trong dấu hoặc kép, giá trị có thể xuống dòng.</li></ul>\r\n\r\n</code>`<code>go\r\n\"Interviewbit\r\nWebsite\"\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cú pháp vòng lặp for trong Golang?",
              "answer": "<p>Cú pháp vòng lặp for như sau:\r\n\r\n``<code>go\r\nfor [condition |  ( init; condition; increment ) | Range]  \r\n{  \r\n   statement(s);  \r\n   //more statements\r\n}\r\n</code>`<code>\r\n\r\nTrong đó:\r<ul><li>Bước </code>init<code> thực thi đầu tiên. Điều này chỉ được thực hiện một lần khi bắt đầu vòng lặp. Nhằm mục đích khai báo và khởi tạo các biến điều khiển vòng lặp. Trường này là tùy chọn nếu chúng ta đã khởi tạo các biến điều khiển vòng lặp trước đó. Ngay cả khi chúng ta không làm gì ở đây, dấu chấm phẩy vẫn cần phải hiện diện.</li></ul>\r<ul><li>Bước </code>condition<code> là để đánh giá. Nếu </code>condition<code> thoả mãn, thân vòng lặp sẽ được thực thi. Nếu </code>condition<code> không thoả mãn, vòng lặp sẽ dùng lại. Sau khi thân vòng lặp thực thi nếu điều kiện vẫn thoả mãn nó sẽ thực thi lệnh </code>increment<code> để cập nhật biến điều kiển vòng lặp. Quá trình này được tiếp tục đến khi nào </code>condition<code> trở thành false.</li></ul>\r<ul><li>Nếu </code>Range<code> được đề cập, vòng lặp sẽ thực thi với từng mục trong Range.</li></ul>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>go\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n   // For loop to print numbers from 1 to 5\r\n   for j := 1; j <= 5; j++ {\r\n      fmt.Println(j)\r\n   }\r\n\r\n}\r\n</code>`<code>\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\n1\r\n2\r\n3\r\n4\r\n5\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Phạm vi biến trong Go?",
              "answer": "<p>Phạm vi biến được định nghĩa là một phần của chương trình mà biến có thể được truy cập. Mọi biến đều được xác định phạm vi tĩnh (có nghĩa là phạm vi biến có thể được xác định tại thời điểm biên dịch) trong Go có nghĩa là phạm vi được khai báo tại thời điểm biên dịch chính nó. Có hai phạm vi trong cờ vây, đó là:\r<ul><li>Biến cục bộ: Được khai bao trong một hàm hay khối chỉ được truy cập trong các hàm/khối đó.</li></ul>\r<ul><li>Biến toàn cục: Được khai báo bên ngoài hàm hay khối được truy cập trên toàn bộ file.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Goroutine là gì?",
              "answer": "<p>Goroutines là các hàm hoặc phương thức chạy đồng thời với các hàm/ phương thức khác. Goroutines có thể được coi là những luồng gọn nhẹ. Chi phí tạo một Goroutine tương đối thấp so với một luồng. Do vậy, những ứng dụng Go có hàng ngàn Goroutines chạy đồng thời là điều hết sức bình thường. Goroutines được quản lý bởi Go Runtime. \r\n\r\nTa có thể bắt đầu một goroutines bắt cách chỉ định từ khoá <code>go</code> trước khi gọi hàm. Hàm sau đó sẽ được gọi và chạy như một goroutine.\r\n\r\n``<code>go\r\npackage main\r\nimport (\r\n   \"fmt\"\r\n   \"time\"\r\n)\r\nfunc main() {\r\n   go sampleRoutine()\r\n   fmt.Println(\"Started Main\")\r\n   time.Sleep(1 * time.Second)\r\n   fmt.Println(\"Finished Main\")\r\n}\r\n\r\nfunc sampleRoutine() {\r\n   fmt.Println(\"Inside Sample Goroutine\")\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta thấy hàm </code>sampleRoutine()<code> được gọi bởi từ khoá </code>go<code> ở phía trước. Khi một hàm được gọi là một goroutine, nó sẽ trả về ngay lập tức dòng kế tiếp trong chương trình đó là lý do tại sao \"Started Main\" sẽ in đầu tiên, và goroutine sẽ được lên lịch và chạy đồng thời trong nền. Câu lệnh </code>sleep<code> đảm bảo rằng goroutine sẽ hoàn thành trước hàm main.\r\n\r\nKết quả chương trình:\r\n\r\n</code>`<code>\r\nStarted Main\r\nInside Sample Goroutine\r\nFinished Main\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể trả về nhiều giá trị từ một hàm trong Go?",
              "answer": "<p>Có, bằng cách phân tách các giá trị bằng dấu phẩy trong câu lênh return và gán nó cho nhiều biến như ví dụ bên dưới:\r\n\r\n``<code>go\r\npackage main\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc reverseValues(a,b string)(string, string){\r\n   return b,a    //notice how multiple values are returned\r\n}\r\n\r\nfunc main(){\r\n   val1,val2:= reverseValues(\"interview\",\"question\")    // notice how multiple values are assigned\r\n   fmt.Println(val1, val2)\r\n}\r\n</code>`<code>\r\n\r\nỞ ví dụ trên, ta có hàm </code>reverseValues<code> đơn giản là đảo ngược trật tự input. Trong \r\nmain, ta gọi hàm </code>reverseValues<code> và giá trị trả về đượC gán cho </code>val1<code> và </code>val2<code>.\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nquestion interview\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể khai báo nhiều biến khác kiểu trong cùng một dòng không?",
              "answer": "<p>``<code>go\r\nvar a,b,c= 9, 7.1, \"interviewbit\"\r\n</code>``\r\n\r\nCó, ở trên ta gán kiểu integer, float và chuỗi cho ba biến trong cùng một dòng.</p>",
              "level": "fresher"
            },
            {
              "question": "Slice trong Go là gì?",
              "answer": "<p>Slice là kiểu dữ liệu mô tả dãy các đối tượng cùng kiểu dữ liệu như mảng nhưng không cố định chiều dài như mảng. Slice được khai báo là <code>[]<kiểu dữ liệu></code> nên nó như là mảng không xác định chiều dài. Thực ra mỗi khi khai báo 1 biến kiểu slice, Go sẽ tạo 1 mảng để chứa dữ liệu cho nó.\r\n\r\nMột biến kiểu slice gồm 3 thành phần: \r<ul><li>Con trỏ tham chiếu đến mảng chứa các phần tử của slice.</li></ul>\r<ul><li>Chiều dài (số phần tử).</li></ul>\r<ul><li>Sức chứa (số phần tử tối đa, là chiều dài mảng chứa các phần tử). </li></ul>\r\n\r\nVí dụ\r\n\r\n``<code>go\r\npackage main\r\n \r\nimport \"fmt\"\r\n \r\nfunc main() {\r\n \r\n   // Creating an array\r\n   arr := [6]string{\"This\",\"is\", \"a\",\"Go\",\"interview\",\"question\"}\r\n\r\n   // Print array\r\n   fmt.Println(\"Original Array:\", arr)\r\n\r\n   // Create a slice\r\n   slicedArr := arr[1:4]\r\n\r\n   // Display slice\r\n   fmt.Println(\"Sliced Array:\", slicedArr)\r\n\r\n   // Length of slice calculated using len()\r\n   fmt.Println(\"Length of the slice: %d\", len(slicedArr))\r\n\r\n   // Capacity of slice calculated using cap()\r\n   fmt.Println(\"Capacity of the slice: %d\", cap(slicedArr))\r\n}\r\n</code>`<code>\r\n\r\nỞ đây ta sử dụng slice để tìm 3 phần tử tính từ phần tử thứ 2 trong mảng gốc. Sau đó ta tìm độ dài và sức chứa của slice.\r\n\r\nKết quả:\r\n\r\n</code>`<code>\r\nOriginal Array: [This is a Go interview question ]\r\nSliced Array: [is a Go]\r\nLength of the slice: 3\r\nThe capacity of the slice: 5\r\n</code>``\r\n\r\n<img src=\"/interview-assets/slice.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Go Interface là gì?",
              "answer": "<p>Go interface là một tập hợp các phương thức đặc trưng xác định. Nó là kiểu tuỳ chọn cho phép nhận các giá trị có triển khai các phương thức này. Các interface là trừu tượng, đó là lý do ta không thể tạo đối tượng của nó. Nhưng ta có thể tạo biến interface sau đó gán cho một giá trị cụ thể mà các phương thức interface yêu cầu. Interface có thể hoạt động như:\r\n1. Tập hợp phương thức đặc trưng\r\n2. Kiểu tuỳ chọn\r\n\r\nChúng được tạo bằng từ khoá <code>type</code> theo sau tên của interface và cuối cùng là từ khoá <code>interface</code>. Cú pháp:\r\n\r\n``<code>go\r\ntype name<em>of</em>interface interface {\r\n   // Method signatures\r\n}\r\n</code>`<code>\r\n\r\nInterface cũng thúc đẩy tính trừu tượng. Trong Go, ta có thể dùng interface để tạo các trừu tượng chung có thể được sử dụng bằng nhiều kiểu bằng cách xác định các khai báo phương thức tương thích với interface.\r\n\r\n</code>`<code>go\r\npackage main\r\n \r\nimport \"fmt\"\r\n \r\n// \"Triangle\" data type\r\ntype Triangle struct {\r\n\tbase, height float32\r\n}\r\n \r\n// \"Square\" data type\r\ntype Square struct {\r\n\tlength float32\r\n}\r\n \r\n// \"Rectangle\" data type\r\ntype Rectangle struct {\r\n\tlength, breadth float32\r\n}\r\n \r\n// To calculate area of triangle\r\nfunc (triangle Triangle) Area() float32 {\r\n\treturn 0.5 <em> triangle.base </em> triangle.height\r\n}\r\n \r\n// To calculate area of square\r\nfunc (square Square) Area() float32 {\r\n\treturn square.length <em> square.length\r\n}\r\n \r\n// To calculate area of rectangle\r\nfunc (rect Rectangle) Area() float32 {\r\n\treturn rect.length </em> rect.breadth\r\n}\r\n \r\n// Area interface for achieving abstraction\r\ntype Area interface {\r\n\tArea() float32\r\n}\r\n \r\nfunc main() {\r\n\t// Declare and assign values to varaibles\r\n\ttriangleObject := Triangle{base: 20, height: 10}\r\n\tsquareobject := Square{length: 25}\r\n\trectObject := Rectangle{length: 15, breadth: 20}\r\n \r\n\t// Define a variable of type interface\r\n\tvar shapeObject Area\r\n \r\n\t// Assign to \"Triangle\" type variable to the Area interface\r\n\tshapeObject = triangleObject\r\n\tfmt.Println(\"Triangle Area = \", shapeObject.Area())\r\n \r\n\t// Assign to \"Square\" type variable to the Area interface\r\n\tshapeObject = squareobject\r\n\tfmt.Println(\"Square Area = \", shapeObject.Area())\r\n \r\n\t// Assign to \"Rectangle\" type variable to the Area interface\r\n\tshapeObject = rectObject\r\n\tfmt.Println(\"Rectangle Area = \", shapeObject.Area())\r\n}\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, ta có 3 kiểu hình dạng là triangle, square và rectangle. Ta cũng khai báo hàm </code>Area()<code> để tính toán diện tích của các hình dựa trên input được truyền. Ta cũng khai báo interface tên </code>Area<code> để xác định phương thức đặt trưng </code>Area()<code>. Trong hàm main, ta tạo đối tương gán đối tượng với interface và tính diện tích theo phương thức được khai báo trong interface. Do đó, ta không cần biết cụ thể về hàm được gọi. Phương thức interface sẽ giải quyết vấn đề này khi xem xét kiểu đối tượng. Điều này gọi là trừu tượng.\r\n\r\n</code>`<code>\r\nTriangle Area =  100\r\nSquare Area =  625\r\nRectangle Area =  300\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Golang có nhanh hơn các ngôn ngữ lập trình khác?",
              "answer": "<p>Golang nhanh hơn các ngôn ngữ lập trình khác vì mô hình đồng thời và quản lý bộ nhớ đơn giản và hiệu quả. Quá trình biên dịch mã máy diễn ra rất nhanh và hiệu quả. Ngoài ra, các phần phụ thuộc được liên kết với một tệp nhị phân duy nhất, do đó loại bỏ các phần phụ thuộc vào máy chủ.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách kiểm tra key trong Go map?",
              "answer": "<p>Map nói chung là một tập hợp các phần tử theo cặp key-value. Một key đề cập đến một value. Map cung cấp truy cập nhanh hơn với độ phức tạp O(1) đối với các giá trị nếu biết key. Một map được biểu diễn như hình bên dưới.\r\n\r\n<img src=\"/interview-assets/How_can_we_check_if_the_Go_map_contains_a_key.png\" alt=\"\" />\r\n\r\nMỗi lần giá trị được lưu trữ trong cặp key-value trong map, ta có thể truy xuất đến đối tượng bằng cách dùng <code>map<em>name[key</em>name]</code> và ta có thể kiểm tra key có tồn tại không bằng cách thực hiện như sau:\r\n\r\n``<code>go\r\nif val, isExists := map_obj[\"foo\"]; isExists {\r\n   //do steps needed here\r\n}\r\n</code>`<code>\r\n\r\nTừ đoạn code trên, chúng ta có thể thấy rằng hai biến đang được khởi tạo. Biến </code>val<code> sẽ nhận giá trị tương ứng với khóa \"foo\" từ map. Nếu không có giá trị nào, ta sẽ nhận được \"giá trị không\" và biến khác </code>isExists<code> sẽ nhận giá trị bool là true nếu khóa \"foo\" có trong map, ngược lại thì là false. Sau đó, điều kiện </code>isExists` được kiểm tra, nếu giá trị là true, thì phần thân của if sẽ được thực thi.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "kubernetes",
          "name": "Câu hỏi phỏng vấn Kubernetes",
          "description": "",
          "questions": [
            {
              "question": "Làm thế nào để thực hiện bảo trì trên nút K8?",
              "answer": "<p>Bất cứ khi nào có sẵn các bản vá bảo mật, quản trị viên Kubernetes phải thực hiện nhiệm vụ bảo trì để áp dụng bản vá bảo mật cho container đang chạy nhằm ngăn nó khỏi lỗ hổng bảo mật, đây thường là một phần không thể tránh khỏi trong quản trị. Hai lệnh sau rất hữu ích để thoát nút K8s một cách an toàn.\r\n\r\n``<code>\r\nkubectl cordon\r\nkubectl drain –ignore-daemon set\r\n</code>`<code>\r\n\r\nLệnh đầu tiên chuyển node sang chế độ bảo trì hoặc làm cho node không khả dụng, tiếp theo là lệnh </code>kubectl drain<code> sẽ loại bỏ pod khỏi node. Sau khi lệnh thoát thành công, bạn có thể thực hiện bảo trì.\r\n\r\nLưu ý nếu bạn muốn thực hiện bảo trì trên một pod đơn, có thể dùng hai lệnh sau:\r<ul><li></code>kubectl get nodes<code>: hiển thị tất cả node</li></ul>\r<ul><li></code>kubectl drain <node name>`: thoát một node cụ thể</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Làm cách nào để kiểm soát việc sử dụng tài nguyên của POD?",
              "answer": "<p>Ta có thể dùng limit và request:\r<ul><li><strong>Request:</strong> Số lượng tài nguyên đang được yêu cầu cho một container. Nếu một container vượt quá yêu cầu tài nguyên của nó, nó sẽ được điều chỉnh trở lại.</li></ul>\r<ul><li><strong>Limit:</strong> Giới hạn trên đối với các tài nguyên mà một container duy nhất có thể sử dụng. Nếu nó cố gắng vượt quá giới hạn được xác định trước này, nó có thể bị chấm dứt nếu K8 quyết định rằng một container khác cần những tài nguyên này. Nếu bạn nhạy cảm với việc khởi động lại pod, bạn nên đặt tổng tất cả các giới hạn tài nguyên container nhỏ hơn hoặc bằng tổng dung lượng tài nguyên cho cụm của bạn.</li></ul>\r\n\r\nVí dụ:\r\n\r\n``<code>\r\napiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n name: demo\r\nspec:\r\n containers:\r<ul><li>name: example1</li></ul>\r\n image:example/example1\r\n resources:\r\n   requests:\r\n     memory: \"<em>Mi\"\r\n     cpu: \"</em>m\"\r\n   limits:\r\n     memory: \"<em>Mi\"\r\n     cpu: \"</em>m\"\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các dịch vụ K8 khác nhau chạy trên một nút?",
              "answer": "<p>Cụm K8 bao gồm hai kiểu nút là executor node và dịch vụ master.\r\n\r\n<strong>Executor node:</strong>\r<ul><li>Kube-proxy: dịch vụ này có trách nhiệm giao tiếp của pods trong cụm và đến bên ngoài mạng, nó chạy trên mọi nút. Dịch vụ này chịu trách nhiệm duy trì giao thức mạng khi pod của bạn thiết lập một giao tiếp mạng.</li></ul>\r<ul><li>kubelet: Mỗi nút chạy một dịch vụ kubelet để cập nhật nút đang chạy tương ứng với file cấu hình (YAML hay JSON).</li></ul>\r\n\r\n<em>Lưu ý</em>: dịch vụ kubelet chỉ dành cho các container được tạo bởi Kubernetes.\r\n\r\n<strong>Dịch vụ master</strong>\r<ul><li>Kube-apiserver: Dịch vụ master API hành động như một entry point đến cụm K8.</li></ul>\r<ul><li>Kube-scheduler: Lập lịch POD theo các tài nguyên có sẵn trên các executor node.</li></ul>\r<ul><li>Kube-controller-manager: là một vòng điều khiển theo dõi trạng thái được chia sẻ của cụm thông qua apiserver và thực hiện các thay đổi cố gắng di chuyển trạng thái hiện tại sang trạng thái ổn định mong muốn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "PBD là gì?",
              "answer": "<p>Quản trị viên Kubernetes có thể tạo một loại triển khai: PodDisruptBudget (PBD) để ứng dụng có tính khả dụng cao, nó đảm bảo rằng số lượng tối thiểu các pods đang chạy được thừa nhận như đã đề cập trong thuộc tính <code>minAvailable</code>. Điều này rất hữu ích khi thực hiện thoát, nơi thoát sẽ tạm dừng cho đến khi PDB được thừa nhận để đảm bảo tính sẵn sàng cao (High Availability) của ứng dụng. Spec sau đây cũng hiển thị minAvailable là 2 ngụ ý số lượng tối thiểu của một pods có sẵn (ngay cả sau cuộc bầu cử).\r\n\r\n``<code>\r\napiVersion: policy/v1beta1\r\nkind: PodDisruptionBudget\r\nmetadata:\r\n name: zk-pdb\r\nspec:\r\n minAvailable: 2\r\n selector:\r\n   matchLabels:\r\n     app: zookeeper\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Init container là gì?",
              "answer": "<p>Init Containers là các container chạy trước khi container chính chạy với ứng dụng được container hóa của bạn. Chúng thường chứa các script thiết lập chuẩn bị môi trường cho ứng dụng được chứa trong container của bạn. Init Containers cũng đảm bảo môi trường máy chủ rộng hơn đã sẵn sàng để ứng dụng của bạn bắt đầu chạy.</p>",
              "level": "fresher"
            },
            {
              "question": "Vai trò của cân bằng tải trong Kubernetes?",
              "answer": "<p>Load balancer (cân bằng tải) là một cách để phân phối lưu lượng trên nhiều server, nó hữu ích cho việc đảm bảo ứng dụng luôn khả dụng với người dùng.\r\n\r\n<img src=\"/interview-assets/Load_Balancer.jpg\" alt=\"\" />\r\n\r\nTrong Kubernetes, như hình trên tất cả lưu lượng truy cập đến một địa chỉ IP đơn trên bộ cân bằng tải, để lộ dịch vụ của bạn với internet bên ngoài, nó định tuyến các lưu lượng truy cập đến một pod (thông qua dịch vụ) cụ thể bằng thuật toán Round-Robin. Ngay cả khi bất kỳ pod nào gặp sự cố, cân bằng tải cũng được thông báo để không chuyển lưu lượng truy cập đến nút không khả dụng đó. Do đó, bộ cân bằng tải trong Kubernetes chịu trách nhiệm phân phối một tập hợp các tác vụ (lưu lượng) đến các nhóm.</p>",
              "level": "fresher"
            },
            {
              "question": "Các điều cần biết để bảo mật Kubernetes?",
              "answer": "<p>Mặc định, POD có thể giao tiếp với bất kỳ POD nào khác, ta có thể thiết lập chính sách mạng để giới hạn các giao tiếp đó.\r<ul><li>RBAC (Role-based access control) để thu hẹp các quyền.</li></ul>\r<ul><li>Dùng namespace để thiết lập ranh giới bảo mật.</li></ul>\r<ul><li>Thiết lập chính sách điều khiển quản trị để tránh chạy các container đặc quyền.</li></ul>\r<ul><li>Bật logging kiểm tra.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách giám sát cụm Kubernetes?",
              "answer": "<p>Prometheus dùng cho giám sát Kubernetes. Hệ sinh thái Prometheus bao gồm các thành phần sau:\r<ul><li>Server chính Prometheus nơi scrape và lưu trữ dữ liệu thời gian</li></ul>\r<ul><li>Thư viện client cho các lệnh code ứng dụng.</li></ul>\r<ul><li>Cổng push cho hỗ trợ công việc ngắn hạn.</li></ul>\r<ul><li>Exporter đặc biệt cho dịch vụ như StatsD, HAProxy, Graphite,...</li></ul>\r<ul><li>Quản lý cảnh báo để xử lý cảnh báo trên các công cụ hỗ trợ khác nhau.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Lấy logs trung tâm của POD?",
              "answer": "<p>Kiến trúc này phụ thuộc vào ứng dụng và nhiều yếu tố khác. Sau đây là các mẫu logging phổ biến\r<ul><li>Node level logging agent.</li></ul>\r<ul><li>Streaming sidecar container.</li></ul>\r<ul><li>Sidecar container với logging agent.</li></ul>\r<ul><li>Xuất trực tiếp logs từ ứng dụng.</li></ul>\r\n\r\nTrong quá trình thiết lập, journalbeat và filebeat đang chạy dưới dạng daemonset. Các logs được thu thập bởi những thứ này được chuyển sang kafka, cuối cùng được chuyển vào ngăn xếp ELK.\r\n\r\nĐiều tương tự cũng có thể thực hiện được bằng cách sử dụng ngăn xếp EFK và fluentd-bit.</p>",
              "level": "fresher"
            },
            {
              "question": "Làm thế nào để biến dịch vụ trong spec bên dưới thành dịch vụ bên ngoài?",
              "answer": "<p>``<code>\r\nspec:\r\n  selector:\r\n    app: some-app\r\n  ports:\r<ul><li>protocol: UDP</li></ul>\r\n      port: 8080\r\n      targetPort: 8080\r\n</code>`<code>\r\n\r\nThêm LoadBalancer và nodePort như bên dưới:\r\n\r\n</code>`<code>\r\nspec:\r\n selector:\r\n   app: some-app\r\n type: LoadBalancer\r\n ports:\r<ul><li>protocol: UDP</li></ul>\r\n     port: 8080\r\n     targetPort: 8080\r\n     nodePort: 32412\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hoàn thành file thông số cấu hình sau để làm cho nó Ingress?",
              "answer": "<p>``<code>\r\nmetadata:\r\n  name: someapp-ingress\r\nspec:\r\n</code>`<code>\r\n\r\nThực hiện:\r\n\r\n</code>`<code>\r\napiVersion: networking.k8s.io/v1\r\nkind: Ingress\r\nmetadata:\r\n name: someapp-ingress\r\nspec:\r\n rules:\r<ul><li>host: my.host</li></ul>\r\n   http:\r\n     paths:\r<ul><li>backend:</li></ul>\r\n         serviceName: someapp-internal-service\r\n         servicePort: 8080\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cấu hình TLS với Ingress?",
              "answer": "<p>Thêm tls và secretName:\r\n\r\n``<code>\r\nspec:\r\n tls:\r<ul><li>hosts:</li></ul>\r<ul><li>some_app.com</li></ul>\r\n   secretName: someapp-secret-tls\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Có vấn đề gì khi dùng namespace mặc định?",
              "answer": "<p>Chỉ sử dụng namespace mặc định, sẽ trở nên khó khăn theo thời gian để có được cái nhìn tổng quan về tất cả các ứng dụng bạn có thể quản lý trong cụm của mình. Namespace giúp dễ dàng tổ chức các ứng dụng thành các nhóm có ý nghĩa, chẳng hạn như namespace của tất cả các ứng dụng giám sát và namespace cho tất cả các ứng dụng bảo mật, v.v.\r\n\r\nNamespace cũng có thể hữu ích để quản lý môi trường Blue/Green trong đó mỗi namespace có thể bao gồm một phiên bản ứng dụng khác nhau và cũng chia sẻ tài nguyên trong namespace khác (namespace như logging, giám sát, v.v.).\r\n\r\nMột trường hợp sử dụng khác cho namespace là một cụm có nhiều nhóm. Khi nhiều đội sử dụng cùng một cụm, họ có thể dẫm chân lên nhau. Ví dụ: nếu họ kết thúc việc tạo một ứng dụng có cùng tên, điều đó có nghĩa là một trong các nhóm sẽ ghi đè ứng dụng của nhóm kia vì không thể có hai ứng dụng trong Kubernetes có cùng tên (trong cùng một namespace).</p>",
              "level": "fresher"
            },
            {
              "question": "Cho biết dịch vụ và namespace trong file sau?",
              "answer": "<p>``<code>\r\napiVersion: v1\r\nkind: ConfigMap\r\nmetadata:\r\n  name: some-configmap\r\ndata:\r\n  some_url: silicon.chip\r\n</code>``\r\n\r\nTrả lời - Dịch vụ là \"silicon\", namespace là \"chip\".</p>",
              "level": "fresher"
            },
            {
              "question": "Operator là gì?",
              "answer": "<p>\"Các operator là mở rộng phần mềm cho K8s sử dụng các tài nguyên tùy chỉnh để quản lý các ứng dụng và các thành phần của chúng. Các operator tuân theo các nguyên tắc Kubernetes, đặc biệt là vòng điều khiển.\"</p>",
              "level": "fresher"
            }
          ]
        }
      ]
    },
    {
      "id": "basics",
      "name": "Computer Science Basics",
      "icon": "school",
      "color": "#f44336",
      "subcategories": [
        {
          "id": "algorithms",
          "name": "Thuật toán",
          "description": "",
          "questions": [
            {
              "question": "Làm thế nào để so sánh hai thuật toán trên cùng một vấn đề?",
              "answer": "<p>Độ phức tạp của một thuật toán là một kỹ thuật được sử dụng để phân loại mức độ hiệu quả của một thuật toán so với các thuật toán khác. Nó tập trung vào kích thước của tập dữ liệu được xử lý ảnh hưởng đến thời gian thực thi như thế nào. Trong lập trình, tính toán độ phức tạp của thuật toán là rất quan trọng. Bạn nên phân loại các thuật toán theo lượng thời gian hoặc không gian mà chúng chiếm dụng và mô tả thời gian hoặc không gian mà chúng chiếm dưới dạng một hàm của kích thước đầu vào.\r\n\r\n<em> <strong>Độ phức tạp thời gian (Complex of Time)</strong>: thời gian chạy của một chương trình được xem như một hàm phụ thuộc vào kích thước đầu vào được gọi là độ phức tạp thời gian.\r\n</em> <strong>Độ phức tạp không gian (Complex of Space)</strong>: dựa trên không gian mà chương trình yêu cầu để xử lý hoàn tất một tác vụ.\r\n\r\n> Trước đây, bộ nhớ phần cứng bị hạn chế nên độ phức tạp không gian là rất quan trọng, nhưng ngày nay bộ nhớ máy tính rất lớn, nên khi đề cập đến độ phức tạp người ta chủ yếu tập trung vào độ phức tạp thời gian.</p>",
              "level": "fresher"
            },
            {
              "question": "Trường hợp tốt nhất, xấu nhất và trung bình?",
              "answer": "<p>Nền tảng toán học cho hiệu suất thực thi thuật toán được xác định bằng tiệm cận. Ta có thể quyết định trường hợp tốt nhất, xấu nhất và trung bình của một thuật toán bằng cách dùng tiệm cận.\r\n\r\n<em> <strong>Trường hợp tốt nhất:</strong> là tập dữ liệu được sắp xếp sao cho thuật toán hoạt động nhanh nhất hay tốn ít không gian nhất. Ví dụ như trong tìm kiếm nhị phân, trường hợp tốt nhất là khi giá trị cần tìm ở giữa mảng dữ liệu, lúc đó thuật toán có độ phức tạp thời gian là <code>O(1)</code>.\r\n</em> <strong>Trường hợp xấu nhất:</strong> ngược lại với trường hợp tốt nhất, là khi tập dữ liệu khiến thuật toán mất nhiều thời gian và không gian thực thi nhất. Ví dụ, trong quicksort trường hợp xấu nhất là khi giá trị <code>pivot</code> là phần tử lớn nhất hoặc nhỏ nhất của <code>sublist</code>, lúc này sẽ có độ phức tạp thời gian là <code>O(n^2)</code> với n là kích thước của tập dữ liệu cần sắp xếp.\r\n<em> <strong>Trường hợp trung bình:</strong> theo lý thuyết về độ phức tạp, thì trường hợp trung bình là lượng tài nguyên mà chương trình cần dùng, được tính trung bình trên tất cả đầu vào có thể. Vd, độ phức tạp trung bình của quicksort là <code>O(n</em>log(n))</code>, với n là kích thước của tập dữ liệu cần sắp xếp.</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về ký hiệu tiệm cận?",
              "answer": "<p>Phân tích tiệm cận là một kỹ thuật được dùng để xác định hiệu quả của một thuật toán mà không dựa vào các thông số kỹ thuật phần cứng và tránh để thuật toán so sánh chính nó với cách tiếp cận lãng phí thời gian. Với phân tích tiệm cận, ký hiệu tiệm cận là một kỹ thuật toán học được dùng để chỉ ra độ phức tạp thời gian của thuật toán.\r\n\r\nTa có 3 ký hiệu tiệm cận phổ biến như sau:\r<ul><li><strong>Ký hiệu theta (θ)</strong>: dùng để xác định chính xác <em>dáng điệu tiệm cận</em>. Nó liên kết các hàm từ bên trên và bên dưới để xác định dáng điệu tiệm cận. Bỏ qua các số hạng bậc thấp và các hằng số đứng đầu là một cách đơn giản để lấy ký hiệu theta cho một biểu thức.</li></ul>\r\n\r\n<img src=\"/interview-assets/The_Theta_Notation.png\" alt=\"\" />\r<ul><li><strong>Ký hiệu O lớn</strong>: dùng để xác định cận trên của một thuật toán. Xem xét thuật toán Insert Sort: trong trường hợp tốt nhất nó cần thời gian tuyến tính và trường hợp xấu nhất cần thời gian bậc hai. Insert Sort có độ phức tạp thời gian là (O(n^2)). Nó hữu ích khi ta chỉ có cận trên về độ phức tạp thời gian của thuật toán.</li></ul>\r\n\r\n<img src=\"/interview-assets/Big_O.png\" alt=\"\" />\r<ul><li><strong>Ký hiệu omega (Ω)</strong>: dùng để cung cấp cận dưới cho một hàm, ngược với ký hiệu O lớn. Nó hữu ích khi ta chỉ có cận dưới của độ phức tạp thời gian của thuật toán.</li></ul>\r\n\r\n<img src=\"/interview-assets/Omega.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Viết chương trình đổi giá trị hai số mà không dùng biến tạm?",
              "answer": "<p>Đây là một câu hỏi thường gặp trong các cuộc phỏng vấn ở nhiều công ty khác nhau. Có nhiều cách để đổi giá trị cho hai số, tuy nhiên ở đây điều kiệu là không được dùng biến tạm. Đối với bài toán này, nếu bạn có thể giải quyết tình huống overflow bạn sẽ để lại ấn tượng tốt với người phỏng vấn.\r\n\r\nGiả sử ta có hai số nguyên a và b, với <code>a=5</code> và <code>b=6</code> ta cần hoán đổi hai số này mà không cần dùng biến tạm, ta có thể làm như sau:\r\n\r\n``<code>java\r\na = a + b;\r\nb = a - b; // this will act like (a+b) - b, and now b equals a.\r\na = a - b; // this will act like (a+b) - a, and now an equals b.\r\n</code>`<code>\r\n\r\nĐã xong, nhưng nó có một vấn đề là nếu phép cộng vượt quá giá trị lớn nhất của kiểu int (như </code>Integer.MAX<em>VALUE<code> trong Java) hoặc nếu phép trừ nhỏ hơn giá trị nhỏ nhất (</code>Integer.MIN</em>VALUE`) thì nó sẽ gây ra hiện tượng overflow.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về mô hình Chia Để Trị. Liệt kê các thuật toán sử dụng mô hình này?",
              "answer": "<p>Chia để trị là một mô hình thuật toán, không phải thuật toán. Nó được xây dựng để xử lý một lượng lớn dữ liệu, bằng cách chia nhỏ nó thành từng phần nhỏ hơn và xác định giải pháp cho các phần nhỏ. Nó kết hợp giải pháp của tất cả phần nhỏ thành một giải pháp toàn cục duy nhất. Dưới đây là mô hình của chia để trị:\r\n\r\n<em> <strong>Devider</strong>: Tách bài toán ban đầu thành một tập các bài toán con.\r\n</em> <strong>Conquer</strong>: Giải quyết từng bài toán con đơn lẻ.\r\n<em> <strong>Combiner</strong>: Kết hợp giải pháp của các bài toán con thành một giải pháp tổng thể.\r\n\r\n<img src=\"/interview-assets/Divide_and_Conquer.png\" alt=\"\" />\r\n\r\nCác thuật toán dùng mô hình chia để trị:\r\n\r\n</em> Binary Search\r\n<em> Merge Sort\r\n</em> Strassen's Matrix Multiplication\r\n<em> Quick Sort\r\n</em> Closest pair of points</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về thuật toán tham lam và liệt kê các ví dụ sử dụng nó?",
              "answer": "<p>Thuật toán tham lam là một phương pháp nhằm mục địch chọn ra quyết định tối ưu nhất ở mỗi bước con, cuối cùng dẫn đến giải pháp tối ưu tổng thể. Tức là, tại mỗi thời điểm thuật toán luôn chọn câu trả lời tốt nhất ngay lập tức mà không cần cân nhắc tương lai. Cũng có thể nói thuật toán sẽ chọn ra câu trả lời tốt nhất hiện có, bất kể hậu quả là gì. Các thuật toán tham lam có thể tìm ra câu trả lời không phải là tối ưu nhất trong một số trường hợp.\r\n\r\nCác ví dụ sử dụng thuật toán tham lam:\r\n\r\n<em> Prim's Minimal Spanning Tree Algorithm\r\n</em> Kruskal's Minimal Spanning Tree Algorithm\r\n<em> Travelling Salesman Problem\r\n</em> Fractional Knapsack Problem\r\n<em> Dijkstra's Algorithm\r\n</em> Job Scheduling Problem\r\n<em> Graph Map Coloring\r\n</em> Graph Vertex Cover</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về thuật toán tìm kiếm? Liệt kê vài thuật toán tìm kiếm?",
              "answer": "<p>Thuật toán tìm kiếm được sử dụng để tìm kiếm một phần tử hoặc lấy nó ra từ một cấu trúc dữ liệu (thường là một danh sách các phần tử). Các thuật toán này được chia thành hai loại dựa trên loại hoạt động tìm kiếm:\r\n\r\n<em> <strong>Tìm kiếm tuần tự</strong>: Phương pháp này duyệt qua danh sách các phần tử liên tục, kiểm tra từng phần tử và báo cáo nếu phần tử cần tìm có được tìm thấy hay không. Tìm kiếm tuyến tính là một ví dụ về Thuật toán tìm kiếm tuần tự.\r\n</em> <strong>Tìm kiếm theo khoảng</strong>: các thuật toán này được tạo đặc biệt cho tìm kiếm trên các cấu trúc dữ liệu đã sắp xếp. Vì nó hướng đến tìm kiếm ở trung tâm cấu trúc và chia ra thành các khoảng nhỏ, để tìm kiếm mục tiêu. Các loại thuật toán này hiệu quả hơn nhiều so với tìm kiếm tuần tự. Tìm kiếm Nhị phân là một ví dụ về tìm kiếm theo khoảng</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả thuật toán tìm kiếm tuyến tính?",
              "answer": "<p>Để tìm kiếm một phần tử trong một tập hợp phần tử, có thể sử dụng tìm kiếm tuyến tính. Nó hoạt động bằng cách duyệt qua tập phần tử từ đầu đến cuối và quan sát thuộc tính của tất cả phần tử đã đi qua. Giả sử ta có trường hợp với mảng chỉ toàn số nguyên, ta muốn tìm và in tất cả vị trí của phần tử trùng với một giá trị cụ thể (còn gọi là <code>key</code> trong tìm kiếm tuyến tính). Tìm kiếm tuyến tính hoạt động như sau:\r\n\r\n1. Dùng vòng lặp duyệt qua danh sách phần tử đã cho.\r\n2. Với mỗi lần lặp, so sánh giá trị hiện tại với key.\r\n3. Nếu trùng in ra vị trí của phần tử hiện tại.\r\n4. Chuyển đến phần tử kế tiếp nếu giá trị không trùng.\r\n5. Lặp lại từ 1 đến 4 cho đến khi hết danh sách.\r\n\r\n<img src=\"/interview-assets/Linear_Search_Algorithm.png\" alt=\"\" />\r\n\r\nĐộ phức tạp thời gian của thuật toán tìm kiếm tuyến tính là <code>O(n)</code> trong đó n là kích thước của danh sách các phần tử và độ phức tạp không gian của nó là không đổi, nghĩa là <code>O(1)</code>.</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả thuật toán tìm kiếm nhị phân?",
              "answer": "<p>Để áp dụng tìm kiếm nhị phân trên danh sách các phần tử, điều kiện tiên quyết là danh sách các phần tử phải được sắp xếp. Nó dựa trên mô hình thuật toán Chia để Trị. Trong tìm kiếm nhị phân, ta chia khoảng tìm kiếm thành hai phần để tìm trong danh sách đã sắp xếp. Ta bắt đầu bằng cách tạo khoảng trên toàn bộ danh sách. Nếu giá trị của khoá tìm kiếm nhỏ hơn phần tử ở giữa khoảng, thì khoảng đó được thu hẹp về trước, còn không nó sẽ được thu hẹp về sau. Ta tiếp tục thực hiện chia trên các khoảng nhỏ cho đến khi tìm được kết quả. Dưới đây là mô tả thuật toán tìm kiếm nhỉ phân.\r\n\r\n1. <code>x</code> sẽ được so sánh với phần tử ở giữa\r\n2. Trả về nếu <code>x</code> trùng với phần tử ở giữa\r\n3. Ngược lại nếu <code>x</code> lớn hơn, <code>x</code> chỉ có thể ở nữa phía sau của mảng vì mảng được sắp xếp theo thứ tự tăng dần. Ta lặp lại với nữa mảng con phía sau.\r\n4. Nếu như <code>x</code> bé hơn, <code>x</code> chỉ có thể ở nữa phía trước của mảng, ta lặp lại với nữa mảng con phía trước.\r\n5. Nếu các khoảng được chia chỉ còn một phần tử(không thể chia nữa), ta dừng tìm kiếm nhị phân.\r\n\r\nĐộ phức tạp thời gian của tìm kiếm nhị phân là <code>O(log(n))</code> với n là kích thước của danh sách phần tử và độ phức tạp không gian là <code>O(1)</code></p>",
              "level": "fresher"
            },
            {
              "question": "Viết ra một thuật toán để thêm một nút vào danh sách liên kết được sắp xếp theo thứ tự tăng dần (duy trì thuộc tính sắp xếp)?",
              "answer": "<p>Dưới đây là một thuật toán để thêm một nút vào danh sách liên kết được sắp xếp:\r\n\r\n1. Kiểm tra danh sách liên kết có rỗng hay không. Nếu có tạo nút <code>head</code> và trả về.\r\n2. Kiểm tra giá trị của nút thêm vào có nhỏ hơn nút <code>head</code> hay không. Nếu có, đặt nó ở đầu và biến nó thành <code>head</code>.\r\n3. Nếu không thì thì sử dụng vòng lặp để thêm nút đó vào vào vị trí thích hợp. Bằng cách bắt đầu duyệt từ nút <code>head</code> trỏ đến phần tử kế tiếp cho đến khi tìm được nút có giá trị lớn hơn nút đầu vào.\r\n4. Sau khi tìm được vị trí cần chèn thì thực hiện chèn nút.</p>",
              "level": "fresher"
            },
            {
              "question": "Viết thuật toán đếm số nút lá trong cây nhị phân?",
              "answer": "<p>Dưới đây là một thuật toán để đếm số lượng nút lá trong cây nhị phân:\r\n\r\n1. Nếu nút hiện tại là null, trả về giá trị 0.\r\n2. Nếu gặp phải nút lá, nghĩa là nếu nút trái và nút phải của nút hiện tại đều rỗng, thì trả về 1.\r\n3. Tính đệ quy số nút lá bằng cách cộng số nút lá trong cây con bên trái với số nút lá trong cây con bên phải.</p>",
              "level": "fresher"
            },
            {
              "question": "Quy hoạch động là gì? Liệt kê các vấn đề sử dụng quy hoạch động?",
              "answer": "<p><img src=\"/interview-assets/Dynamic_Programming.png\" alt=\"\" />\r\n\r\nQuy hoạch động chủ yếu là tối ưu hoá đệ quy. Ta có thể sử dụng Quy hoạch động để tối ưu hoá bất kỳ giải pháp đệ quy nào có các lời gọi lặp lại cho cùng một đầu vào. Mục đích đơn giản là để lưu trữ kết quả các vấn đề con cho lần tính toán tiếp theo. Độ phức tạp thời gian của sự tối ưu hoá này được giảm theo cấp số nhân. Ví dụ: nếu  ta tạo một giải pháp đệ quy đơn giản cho số Fibonacci, thì độ phức tạp về thời gian là cấp số nhân, nhưng nếu ta tối ưu hóa nó bằng cách lưu trữ các câu trả lời cho các bài toán con bằng Quy hoạch động, thì độ phức tạp về thời gian là tuyến tính. \r\n\r\nCode minh hoạ như sau:\r\n\r\n<strong>Với đệ quy (không QHĐ)</strong>: Độ phức tạp về thời gian của code đã cho sẽ theo cấp số nhân.\r\n\r\n``<code>cpp\r\nint nFibonacci(int n){\r\n   if(n == 0 || n == 1) return n;\r\n   else return nFibonacci(n - 1) + nFibonacci(n - 2);\r\n}\r\n</code>`<code>\r\n\r\n<strong>Với đệ quy (dùng QHĐ)</strong>: Độ phức tạp về thời gian của code đã cho sẽ là tuyến tính.\r\n\r\n</code>`<code>cpp\r\nint nFibonacci(int n){\r\n   vector<int> fib(n + 1);\r\n   fib[0] = 0;\r\n   fib[1] = 1;\r\n   for(int i = 2;i <= n;i ++){\r\n      fib[i] = fib[i - 1] + fib[i - 2];\r\n   }\r\n   return fib[n]; \r\n}\r\n</code>``\r\n\r\nMột vài vấn đề cần dùng Quy Hoạch động:\r<ul><li>Tìm số Fibonacci thứ n</li></ul>\r<ul><li>Tìm chuỗi con chung dài nhất giữa hai chuỗi.</li></ul>\r<ul><li>Tìm chuỗi con Palindromic dài nhất trong một chuỗi.</li></ul>\r<ul><li>Vấn đề Knapsack (hoặc 0-1) rời rạc.</li></ul>\r<ul><li>Đường đi ngắn nhất giữa hai nút bất kỳ trong đồ thị (Thuật toán Floyd Warshall).</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Viết thuật toán đảo chuỗi. Ví dụ như nhập vào Hello đảo thành Olleh?",
              "answer": "<p>Thuật toán cho đảo chuỗi như sau:\r\n\r\n1. Ta có hai biến là <code>l</code> và <code>r</code>.\r\n2. Gán giá trị cho <code>l</code> là 0 và <code>r</code> là chiều dài chuỗi - 1.\r\n3. Hoán đổi giá trị của các ký tự ở vị trí <code>l</code> và <code>r</code> trong chuỗi.\r\n4. Tăng <code>l</code> lên một đơn vị.\r\n5. Giảm <code>r</code> xuống một đơn vị.\r\n6. Nếu giá trị <code>r</code> lớn hơn <code>l</code>, trở về bước 3.\r\n7. Dừng.</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về thuật toán BFS (Breadth First Search)?",
              "answer": "<p>Thuật toán duyệt đồ thị ưu tiên chiều rộng (Breadth-first search - BFS) là một trong những thuật toán tìm kiếm cơ bản và thiết yếu trên đồ thị. Mà trong đó, những đỉnh nào gần đỉnh xuất phát hơn sẽ được duyệt trước. Nó bắt đầu bằng cách duyệt qua đồ thị từ nút gốc và đi đến tất cả các nút lân cận. Nó chọn nút gần nhất và từ đó truy cập tất cả các nút chưa được truy cập. Cho đến khi nó đến nút mục tiêu, thuật toán lặp lại cùng một phương pháp cho mỗi nút gần nhất.\r\n\r\nThuật toán BFS được đưa ra dưới đây:\r\n\r\n1. Đặt <code>status = 1</code> làm bước đầu tiên cho tất cả các nút (trạng thái sẵn sàng).\r\n2. Đặt <code>status</code> của nút ban đầu A là <code>2</code>, tức là trạng thái chờ.\r\n3. Lặp lại các bước 4 và 5 cho đến khi đầy hàng đợi.\r\n4. Dequeue và xử lý nút N từ hàng đợi, thiết lập <code>status</code> của nó thành 3, nghĩa là trạng thái đã xử lý.\r\n5. Đặt tất cả nút lân cận của N đang ở trạng thái sẵn sàng (<code>status = 1</code>) vào hàng đợi và chuyển <code>status</code> của chúng thành 2 (trạng thái chờ)\r\n6. Thoát.</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu gì về thuật toán DFS (Depth First Search)?",
              "answer": "<p>Tìm kiếm ưu tiên chiều sâu hay tìm kiếm theo chiều sâu là một kỹ thuật để duyệt hoặc tìm kiếm trên các cấu trúc dữ liệu như cây và đồ thị. Thuật toán bắt đầu ở nút gốc (trong trường hợp đồ thị, bất kỳ nút ngẫu nhiên nào cũng có thể được sử dụng làm nút gốc) và kiểm tra từng nhánh càng xa càng tốt trước khi kiểm tra lại. Vì vậy, ý tưởng cơ bản là bắt đầu tại gốc hoặc bất kỳ nút nào tùy ý và đánh dấu nó, sau đó tiến tới nút không được đánh dấu tiếp theo và lặp lại cho đến khi không còn nút nào chưa được đánh dấu. Sau đó, quay lại và kiểm tra xem có bất kỳ nút nào chưa được đánh dấu để vượt qua không. Cuối cùng, in các nút của đường đi. Thuật toán DFS được đưa ra dưới đây:\r\n\r\n1. Tạo một hàm đệ quy lấy chỉ mục của nút và một mảng đã đi qua làm đầu vào.\r\n2. Đặt nút hiện tại thành nút đã truy cập và hiển thị nó.\r\n3. Gọi hàm đệ quy với chỉ mục của nút liền kề sau khi đi ngang qua tất cả các nút lân cận và không được đánh dấu.\r\n\r\n## Câu hỏi phỏng vấn cho Experienced</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "cpp",
          "name": "Câu hỏi phỏng vấn C++",
          "description": "",
          "questions": [
            {
              "question": "Các kiểu dữ liệu trong C++?",
              "answer": "<p>Có 4 kiểu dữ liệu trong C++:\r<ul><li>Kiểu nguyên thuỷ, như char, short, int, float, long, double, bool,...</li></ul>\r<ul><li>Kiểu dẫn xuất, như array, pointer,..</li></ul>\r<ul><li>Enum</li></ul>\r<ul><li>Kiểu người dùng định nghĩa: structure, class,...</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa C và C++?",
              "answer": "<p>| C | C++ |\r\n|---|-----|\r\n| C là ngôn ngữ hướng thủ tục | C++ là ngôn ngữ hướng đối tượng |\r\n| C không hỗ trợ ẩn dữ liệu | Dữ liệu được ẩn bởi tính đóng gói đảm bảo cấu trúc dữ liệu và phép toán được sử dụng nội bộ |\r\n| C là tập con của C++ | C++ là mở rộng của C |\r\n| Không hộ trợ nạp chồng | Hỗ trợ nạp chồng hàm và toán tử |\r\n| Không có tính năng namespace | Có tính năng namespace để tránh xung đột |\r\n| Hàm không thể định nghĩa bên trong cấu trúc | Hàm có thể định nghĩa bên trong cấu trúc |\r\n| hàm calloc() và malloc() dùng cho cấp phát bộ nhớ và free() để giải phóng | toán tử new dùng cho cấp phát bộ nhớ và toán tử delete dùng cho giải phóng bộ nhớ |</p>",
              "level": "fresher"
            },
            {
              "question": "Lớp và đối tượng trong C++ là gì?",
              "answer": "<p>Một lớp là kiểu người dùng tự định nghĩa có dữ liệu và hàm thành viên. Dữ liệu là các biến và hàm là các hàm thực hiện hành động trên các biến.\r\n\r\nĐối tượng là một thực thể của lớp. \r\n\r\nVí dụ:\r\n\r\n``<code>cpp\r\nclass A {\r\n    private:\r\n        int data;\r\n    public:\r\n        void func() {\r\n\r\n        }\r\n}\r\n</code>``\r\n\r\n<img src=\"/interview-assets/Class_in_C__.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa struct và class?",
              "answer": "<p>| Struct | Class |\r\n|--------|-------|\r\n| Các thành viên của struct mặc định là public | Thành viên của class mặc định là private |\r\n| Khi dẫn xuất một struct từ một struct khác, truy cập mặc định cho struct cơ sở là public | Khi dẫn xuất một class, truy cập mặc định là private |</p>",
              "level": "fresher"
            },
            {
              "question": "Nạp chồng toán tử là gì?",
              "answer": "<p>Nạp chồng toán tử là một yếu tố rất cần thiết để thực hiện các hoạt động trên các kiểu dữ liệu do người dùng xác định. Bằng cách nạp chồng toán tử, chúng ta có thể sửa đổi ý nghĩa mặc định thành các toán tử như +, -, *, /, <=, v.v.\r\n\r\nVí dụ: Đoạn code bên dưới thực hiện công hai số phức bằng nạp chồng toán tử\r\n\r\n``<code>cpp\r\nclass complex{\r\n    private:\r\n        float r, i;\r\n    public:\r\n        complex(float r, float i){\r\n            this->r=r;\r\n            this->i=i;\r\n        }\r\n        complex(){}\r\n        void displaydata(){\r\n            cout<<\"real part = \"<<r<<endl;\r\n            cout<<\"imaginary part = \"<<i<<endl;\r\n        }\r\n        complex operator+(complex c) {\r\n            return complex(r+c.r, i+c.i);\r\n        }\r\n};\r\n\r\nint main(){\r\n    complex a(2,3);\r\n    complex b(3,4);\r\n    complex c=a+b;\r\n    c.displaydata();\r\n    return 0;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Đa hình trong C++?",
              "answer": "<p>Đa hình nói một cách đơn giản có nghĩa là có nhiều dạng. Hành vi của nó là khác nhau trong các tình huống khác nhau. Và điều này xảy ra khi chúng ta có nhiều lớp có liên quan với nhau theo kế thừa.\r\n\r\nVí dụ: Ta có một lớp cơ sở được gọi là <code>Car</code> có một phương thức được gọi là <code>car_brand()</code>. Các loại xe có nguồn gốc có thể là Mercedes, BMW, Audi - Và chúng cũng có cách triển khai xe của riêng mình\r\n\r\nHai loại đa hình trong c ++ là:\r<ul><li>Đa hình thời gian biên dịch</li></ul>\r<ul><li>Đa hình thời gian chạy</li></ul>\r\n\r\n<img src=\"/interview-assets/Polymorphism_in_C__.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về constructor trong C++?",
              "answer": "<p>Contrustor là một hàm thành viên được thực thi tự động bất cứ khi nào đối tượng được tạo. Constructor có cùng tên với lớp để trình biên dịch biết hàm thành viên nào là constructor. Constructor không có kiểu trả về.\r\n\r\n``<code>cpp\r\nclass A{\r\n    private:\r\n        int val;\r\n    public:\r\n        A(int x){             //one argument constructor\r\n            val=x;\r\n        }\r\n        A(){                    //zero argument constructor\r\n        }\r\n}\r\nint main(){\r\n    A a(3);     \r\n\r\n    return 0;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm ảo là gì?",
              "answer": "<p>Hàm ảo là một hàm thành viên trong lớp cơ sở mà bạn xác định lại trong một lớp dẫn xuất. Một hàm ảo được khai báo bằng từ khóa <code>virtual</code>. Khi hàm được tạo ảo, C++ xác định hàm nào sẽ được gọi trong thời gian chạy dựa trên kiểu đối tượng được trỏ bởi con trỏ lớp cơ sở.</p>",
              "level": "fresher"
            },
            {
              "question": "So sánh đa hình thời gian chạy và đa hình thời gian biên dịch?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Hàm bạn và lớp bạn là gì?",
              "answer": "<p>Một lớp bạn có thể truy cập thành viên pulic, protected hay private của lớp khác mà lớp đó được khai báo là bạn.\r\n\r\nGiống như lớp bạn, hàm bạn cũng có thể truy cập các thành viên private, protected và public. Nhưng, hàm bạn không phải là hàm thành viên.\r\n\r\n``<code>cpp\r\nclass A{\r\n    private:\r\n        int data<em>a;\r\n    public:\r\n        A(int x){\r\n            data</em>a=x;\r\n        }\r\n    friend int fun(A, B);\r\n}\r\nclass B{\r\n    private:\r\n        int data<em>b;\r\n    public:\r\n        A(int x){\r\n            data</em>b=x;\r\n        }\r\n        friend int fun(A, B);\r\n}\r\nint fun(A a, B b){\r\n    return a.data<em>a+b.data</em>b;\r\n}\r\nint main(){\r\n    A a(10);\r\n    B b(20);\r\n    cout<<fun(a,b)<<endl;\r\n    return 0;\r\n}\r\n</code>``\r\n\r\nDo đó, ta có thể truy cập dữ liệu private của lớp A và B.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu truy cập trong C++?",
              "answer": "<p><ul><li>Public: tất cả dữ liệu và hàm thành viên đều có thể truy cập từ bên ngoài lớp.</li></ul>\r<ul><li>Protected: tất cả dữ liệu và hàm thành viên đều có thể truy cập từ bên trong lớp và lớp dẫn xuất.</li></ul>\r<ul><li>Private: tất cả dữ liệu và hàm thành viên đều chỉ có thể truy cập từ bên trong lớp.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Function inline là gì?",
              "answer": "<p>Inline functions (hàm nội tuyến) là một loại hàm trong ngôn ngữ lập trình C++. Từ khoá inline được sử dụng để đề nghị (không phải là bắt buộc) trình biên dịch thực hiện inline expansion (khai triển nội tuyến) với hàm đó hay nói cách khác là chèn code của hàm đó tại địa chỉ mà nó được gọi.\r\n\r\nVí dụ:\r\n\r\n``<code>cpp\r\ninline int max(int a, int b)\r\n{\r\n\treturn a > b ? a : b;\r\n}\r\n\r\nint main()\r\n{\r\n\tcout << max(3, 6) << '\\n';\r\n\tcout << max(6, 3) << '\\n';\r\n\r\n\treturn 0;\r\n}\r\n</code>`<code>\r\n\r\nKhi được biên dịch, code được tạo như sau:\r\n\r\n</code>`<code>cpp\r\nint main()\r\n{\r\n\tcout << (3 > 6 ? 3 : 6) << '\\n';\r\n\tcout << (6 > 3 ? 6 : 3) << '\\n';\r\n\r\n\treturn 0;\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Tham chiếu trong C++ là gì?",
              "answer": "<p>Tham chiếu giống như con trỏ, sau khi một tham chiếu được khởi tạo với một biến, biến đó có thể truy cập đến cả tên biến và tên tham chiếu.\r\n\r\n``<code>cpp\r\nint x=10;\r\nint &ref=x;           //reference variable\r\n</code>`<code>\r\n\r\nNếu chúng ta thay đổi giá trị của </code>ref<code>, nó sẽ được phản ánh trong </code>x`. Khi một biến tham chiếu được khởi tạo, nó không thể tham chiếu đến bất kỳ biến nào khác. Chúng ta có thể khai báo một mảng con trỏ nhưng một mảng tham chiếu thì không thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Trừu tượng trong C++ là gì?",
              "answer": "<p>Trừu tượng là quá trình hiển thị các chi tiết cần thiết cho người dùng và ẩn các chi tiết mà ta không muốn hiển thị cho người dùng hoặc ẩn các chi tiết không liên quan đến một người dùng cụ thể.</p>",
              "level": "fresher"
            },
            {
              "question": "Có thể nạp chồng destructor không? Tại sao?",
              "answer": "<p>Không thể nạp chồng destructor, vì destructor không nhận về bất kỳ tham số nào, thế nên nó chỉ làm một việc là huỷ đối tượng.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "cyber",
          "name": "Câu hỏi phỏng vấn an ninh mạng",
          "description": "",
          "questions": [
            {
              "question": "Đối tượng chính trong an ninh mạng là gì?",
              "answer": "<p>Mục tiêu chính của an ninh mạng là bảo vệ dữ liệu. Để bảo vệ dữ liệu khỏi các cuộc tấn công mạng, lĩnh vực bảo mật đưa ra mô hình tam giác gồm ba nguyên tắc. Bộ ba CIA là tên cho nguyên tắc này. Mô hình CIA nhằm giúp các tổ chức phát triển các chính sách cho kiến trúc bảo mật thông tin của họ. Một hoặc nhiều nguyên tắc này sẽ bị phá vỡ khi phát hiện ra vi phạm bảo mật. Tính bảo mật, tính toàn vẹn và tính khả dụng là ba thành phần của mô hình CIA. Đó là một mô hình bảo mật hướng dẫn các cá nhân trên nhiều khía cạnh của bảo mật CNTT. Chúng ta hãy xem xét kỹ hơn từng phần.\r\n\r\n<img src=\"/interview-assets/Cyber_Security_objectives.jpg\" alt=\"\" />\r<ul><li><strong>Tính bảo mật</strong> của thông tin là mức độ bảo mật cần thiết nhằm đảm bảo những dữ liệu quan trọng không bị rò rỉ hay tiết lộ. Kẻ tấn công có thể thực hiện nhiều phương thức nhằm đạt được mục đích là lấy những thông tin mong muốn. Những phương thức đó có thể là giám sát hệ thống mạng, lấy các file chứa mật khẩu, hay social engineering. Thông tin có thể bị lộ do không sử dụng các phương thức mã hóa đủ mạnh khi truyền hay lưu trữ thông tin.</li></ul>\r<ul><li><strong>Tính toàn vẹn</strong> của thông tin là mức độ bảo mật cần thiết nhằm đảm bảo độ tin tưởng của thông tin không bị thay đổi hay chỉ được chỉnh sửa bởi người có thẩm quyền. Kẻ tấn công có thể thực hiện nhiều phương thức nhằm thay đổi những thông tin mong muốn. Những phương thức đó có thể là đột nhập vượt qua các quá trình xác thực, hoặc tấn công khai thác lỗ hổng bảo mật của hệ thống. Đây là mức độ bảo mật thông tin quan trọng, hàng năm có rất nhiều tổ chức doanh nghiệp bị tấn công khai thác lỗ hổng bảo mật và bị thay đổi dữ liệu.</li></ul>\r<ul><li><strong>Tính khả dụng</strong>, khả năng đáp ứng của thông tin là điều rất quan trọng, điều này thể hiện tính sẵn sàng phục vụ của các dịch vụ. Khả năng đáp ứng của hệ thống chịu ảnh hưởng bởi khá nhiều thành phần: có thể là phần cứng, phần mềm hay hệ thống backup. Khả năng đáp ứng của hệ thống cần được tính đến dựa trên số người truy cập và mức độ quan trọng của dữ liệu.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa mối đe dọa, lỗ hổng bảo mật và rủi ro?",
              "answer": "<p><strong>Threat:</strong> Mối đe dọa là bất kỳ dạng nguy cơ nào có khả năng phá hủy hoặc đánh cắp dữ liệu, làm gián đoạn hoạt động hoặc gây hại nói chung. Phần mềm độc hại, lừa đảo, vi phạm dữ liệu và thậm chí cả những nhân viên không có đạo đức đều là những ví dụ về các mối đe dọa.\r\nCác tác nhân đe dọa, có thể là các cá nhân hoặc nhóm với nhiều nguồn gốc và động cơ khác nhau. Hiểu các mối đe dọa là điều cần thiết để phát triển các biện pháp giảm thiểu rủi ro và đưa ra các quyết định về an ninh mạng sáng suốt. Thông tin tình báo về mối đe dọa là thông tin liên quan đến các mối đe dọa và tác nhân đe dọa.\r\n\r\n<strong>Vulnerability:</strong> Lỗ hổng bảo mật là một lỗ hổng trong phần cứng, phần mềm, nhân sự hoặc quy trình mà các tác nhân đe dọa có thể sử dụng để đạt được mục tiêu của họ.\r\n\r\nCác lỗ hổng vật lý, chẳng hạn như thiết bị mạng bị lộ công khai, lỗ hổng phần mềm, chẳng hạn như lỗ hổng tràn bộ đệm trong trình duyệt và thậm chí lỗ hổng con người, chẳng hạn như một nhân viên dễ bị tấn công lừa đảo, đều là những ví dụ về lỗ hổng.\r\n\r\nQuản lý lỗ hổng bảo mật là quá trình xác định, báo cáo và sửa chữa các lỗ hổng. Lỗ hổng zero-day là lỗ hổng chưa có biện pháp khắc phục.\r\n\r\n<strong>Risk:</strong> Xác suất của một mối đe dọa và hậu quả của một lỗ hổng được kết hợp để tạo thành rủi ro. Nói một cách khác, rủi ro là khả năng tác nhân đe dọa khai thác thành công một lỗ hổng, có thể được tính bằng công thức:\r\n\r\n<img src=\"/interview-assets/Risk___Likelihood_of_a_threat__Vulnerability_Impact.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "XSS là gì? Và cách ngăn chặn nó?",
              "answer": "<p>Cross-site scripting (XSS) là một kiểu tấn công bảo mật trong đó kẻ tấn công đưa các tập lệnh độc hại vào phần nội dung của các trang web đáng tin cậy khác. Tấn công Cross-site scripting xảy ra khi một nguồn không đáng tin cậy được phép đưa code của chính nó vào một ứng dụng web và mã độc đó được bao gồm trong nội dung gửi đến trình duyệt của nạn nhân.\r\n\r\nXSS là một trong những lỗ hổng ứng dụng web phổ biến nhất và xảy ra khi một ứng dụng web sử dụng đầu vào từ người dùng không được xác thực hoặc không được mã hóa trong đầu ra mà nó tạo ra. Tấn công XXS cho phép kẻ tấn công đóng giả người dùng, nạn nhân, và thực hiện bất kỳ hành động nào mà người dùng có thể thực hiện, cũng như truy cập bất kỳ dữ liệu nào của người dùng. Nếu người dùng có quyền truy cập đặc quyền vào ứng dụng, kẻ tấn công có thể kiểm soát hoàn toàn chức năng và dữ liệu của ứng dụng.\r\n\r\n<img src=\"/interview-assets/XSS.jpg\" alt=\"\" />\r\n\r\nCách ngăn chặn XSS có thể đơn giản trong một số trường hợp, nhưng có thể khó hơn nhiều trong những trường hợp khác, tùy thuộc vào độ tinh vi của ứng dụng và cách nó xử lý dữ liệu do người dùng kiểm soát. Nói chung, việc ngăn chặn các lỗ hổng XSS gần như chắc chắn sẽ cần sự kết hợp của các biện pháp sau: \r<ul><li>Escape đầu vào của người dùng là một cách để ngăn các lỗ hổng XSS xuất hiện trong các ứng dụng. Điều này có nghĩa là lấy dữ liệu mà ứng dụng đã nhận được và đảm bảo an toàn trước khi hiển thị nó cho người dùng. Escape input từ người dùng sẽ khiến các ký tự quan trọng trong dữ liệu mà trang web nhận được không bị hiểu là mã thực thi. Nhờ đó ngăn trình duyệt diễn giải các ký tự được sử dụng để báo hiệu bắt đầu hoặc kết thúc mã thực thi và dịch chúng thành \"escaped\". Ví dụ, các ký tự như dấu ngoặc kép, dấu ngoặc đơn, dấu ngoặc vuông và một số dấu chấm câu khác đôi khi được sử dụng để làm nổi bật mã thực thi. Escape các ký tự này có nghĩa là chuyển đổi chúng từ các ký tự đơn thành các chuỗi khi trình duyệt biên dịch.</li></ul>\r<ul><li>Sàng lọc đầu vào của người dùng là một cách khác để ngăn chặn các cuộc tấn công Cross-site scripting, đặc biệt hữu ích trên các trang web cho phép HTML markup. Phương pháp ngăn chặn này sẽ xóa sạch dữ liệu chứa các ký tự có khả năng thực thi, thay đổi đầu vào người dùng thành định dạng có thể chấp nhận và đảm bảo dữ liệu nhận được không thể được hiểu là mã thực thi.</li></ul>\r<ul><li>Xác thực đầu vào đảm bảo việc ứng dụng hiển thị dữ liệu chính xác và ngăn dữ liệu độc hại gây hại cho trang web, cơ sở dữ liệu và người dùng. Xác thực đầu vào giúp ngăn XSS trong các biểu mẫu vì nó ngăn người dùng thêm các ký tự đặc biệt vào các trường nhập dữ liệu trang web bằng cách từ chối yêu cầu. Xác thực đầu vào giúp giảm khả năng gây ảnh hưởng tiêu cực, nếu kẻ tấn công phát hiện ra một lỗ hổng XSS ở đâu đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tường lửa là gì?",
              "answer": "<p>Tường lửa (Firewall) là một hệ thống an ninh mạng, có thể dựa trên phần cứng hoặc phần mềm, sử dụng các quy tắc để kiểm soát lưu lượng truy cập vào, ra khỏi hệ thống. Tường lửa hoạt động như một rào chắn giữa mạng an toàn (LAN) và mạng không an toàn (Internet). Nó kiểm soát các truy cập đến nguồn lực của mạng thông qua một mô hình kiểm soát chủ động. Nghĩa là, chỉ những truy cập phù hợp với chính sách được định nghĩa trong tường lửa mới được truy cập vào mạng, mọi truy cập khác đều bị từ chối.\r\n\r\nNhư trong hình bên dưới là tường lửa giữa LAN và Internet.\r\n\r\n<img src=\"/interview-assets/Firewall.jpg\" alt=\"\" />\r\n\r\nCó hai loại tường lửa trong hệ thống là: một cái dùng bộ lọc tầng network còn cái kia dùng server proxy ở tầng network hay application.</p>",
              "level": "fresher"
            },
            {
              "question": "VPN là gì?",
              "answer": "<p>Thuật ngữ VPN dùng để chỉ Virtual Private Network, một mạng riêng ảo. Nó cho phép bạn kết nối máy tính của mình với mạng riêng, kết nối được mã hóa để ẩn địa chỉ IP của bạn, cho phép bạn chia sẻ dữ liệu và truy cập web một cách an toàn đồng thời bảo vệ danh tính trực tuyến của bạn. Nó chống lại việc nghe trộm lưu lượng truy cập bất hợp pháp và cho phép người dùng làm việc từ xa. Trong các công ty, công nghệ VPN thường được sử dụng.\r\n\r\n<img src=\"/interview-assets/VPN.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Hacker black hat, white hat và grey hat là gì?",
              "answer": "<p>Một cách tổng quát, hacker được chia ra làm ba loại là: black hat, grey hat và white hat.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Các loại an ninh mạng?",
              "answer": "<p>An ninh mạnh có thể được phân loại thành 7 loại riêng biệt:\r\n\r\n<em> <strong>Bảo mật mạng:</strong> Là quá trình bảo vệ mạng máy tính chống lại sự truy cập trái phép, những kẻ xâm nhập, tấn công, làm gián đoạn và lạm dụng phần cứng và phần mềm. Bảo mật này hỗ trợ trong việc bảo vệ tài sản của tổ chức khỏi các mối đe dọa từ bên ngoài lẫn bên trong. Ví dụ: Sử dụng Tường lửa.\r\n</em> <strong>Bảo mật ứng dụng:</strong> Nó đòi hỏi phải bảo vệ phần mềm và thiết bị an toàn trước các cuộc tấn công nguy hiểm. Điều này có thể được thực hiện bằng cách thường xuyên cập nhật các ứng dụng để đảm bảo rằng chúng an toàn trước các mối đe dọa.\r\n<em> <strong>Bảo mật dữ liệu:</strong> Nó đòi hỏi phải có một hệ thống lưu trữ dữ liệu mạnh mẽ để đảm bảo tính toàn vẹn và quyền riêng tư của dữ liệu trong quá trình lưu trữ và vận chuyển.\r\n</em> <strong>Quản lý danh tính:</strong> Nó đề cập đến quá trình xác định quyền truy cập của mỗi cá nhân bên trong một tổ chức. Ví dụ: Hạn chế quyền truy cập vào dữ liệu theo vai trò công việc của một cá nhân trong công ty.\r\n<em> <strong>Bảo mật hoạt động:</strong> Nó đòi hỏi phải phân tích và đưa ra quyết định về cách xử lý và bảo mật dữ liệu. Ví dụ: Lưu trữ dữ liệu ở dạng mã hóa trong cơ sở dữ liệu.\r\n</em> <strong>Bảo mật di động:</strong> Nó đề cập đến việc bảo vệ dữ liệu tổ chức và cá nhân được lưu giữ trên các thiết bị di động như điện thoại di động, máy tính bảng và các thiết bị tương tự khác chống lại nhiều cuộc tấn công thù địch. Truy cập trái phép, mất hoặc trộm thiết bị, phần mềm độc hại và các mối đe dọa khác là những ví dụ về những mối nguy hiểm này.\r<ul><li><strong>Bảo mật đám mây:</strong> Nó đề cập đến việc bảo vệ dữ liệu được lưu giữ trong môi trường kỹ thuật số hoặc trong cơ sở hạ tầng đám mây cho một tổ chức. Nó sử dụng nhiều nhà cung cấp dịch vụ đám mây khác nhau, bao gồm AWS, Azure, Google và các nhà cung cấp khác, để đảm bảo bảo vệ khỏi nhiều mối đe dọa.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của an ninh mạng?",
              "answer": "<p>Sau đây là một số ưu điểm của việc áp dụng an ninh mạng:\r<ul><li>Doanh nghiệp được bảo vệ khỏi các cuộc tấn công mạng và vi phạm dữ liệu.</li></ul>\r<ul><li>Cả dữ liệu và mạng máy tính đều được bảo vệ.</li></ul>\r<ul><li>Quyền truy cập trái phép của người dùng được hạn chế ở mức tối thiểu.</li></ul>\r<ul><li>Có thời gian phục hồi nhanh hơn sau khi bị tấn công.</li></ul>\r<ul><li>Bảo vệ cho người dùng và thiết bị endpoint.</li></ul>\r<ul><li>Hoạt động nhất quán.</li></ul>\r<ul><li>Các nhà phát triển, đối tác, người tiêu dùng, các bên liên quan và nhân viên có mức độ tin tưởng cao hơn vào danh tiếng của công ty.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Botnet là gì?",
              "answer": "<p>Botnet thuật ngữ đầy đủ là \"Bots network\" dùng để chỉ một mạng lưới các máy tính bị chi phối bởi ai đó và bị điều khiển bởi một con máy tính khác từ xa. Botnet là một phần mềm độc hại, đa phần các máy tính đều bị nhiễm bởi một Bot nào đó mà chúng ta không thể nào phát hiện được.\r\n\r\n<img src=\"/interview-assets/Botnet.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Honeypot là gì?",
              "answer": "<p>Honeypot là một hệ thống tài nguyên thông tin được xây dựng với mục đích giả dạng đánh lừa những kẻ sử dụng và xâm nhập không hợp pháp, thu hút sự chú ý của chúng, ngăn không cho chúng tiếp xúc với hệ thống thật.\r\n\r\nHoneypot có thể giả dạng bất cứ loại máy chủ tài nguyên nào như là Mail Server, Domain Name Server, Web Server… Honeypot sẽ trực tiếp tương tác với tin tặc và tìm cách khai thác thông tin về tin tặc như hình thức tấn công, công cụ tấn công hay cách thức tiến hành thay vì bị tấn công.\r\n\r\n<img src=\"/interview-assets/Honeypot.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Đánh giá lỗ hổng và Kiểm tra thâm nhập?",
              "answer": "<p>Đánh giá lỗ hổng và kiểm tra thâm nhập là hai cụm từ khác nhau, song cả hai đều phục vụ cùng một mục đích: bảo mật môi trường mạng.\r\n\r\n<img src=\"/interview-assets/Vulnerability_Assessment_and_Penetration_Testing.jpg\" alt=\"\" />\r\n\r\n<strong>Đánh giá lỗ hổng bảo mật (Vulnerability Asessment)</strong> là quá trình kiểm tra, tìm tòi, nhận diện các biện pháp an toàn cũng như lỗ hổng của hệ thống và ứng dụng. Các hệ thống và ứng dụng được kiểm tra để nhận định tính hiệu quả của các tầng bảo mật hiện thời trong việc chống lại các tấn công và lạm dụng.\r\n\r\n<strong>Kiểm tra thâm nhập (Penetration Testing)</strong> là một cuộc tấn công mạng mô phỏng được ủy quyền trên máy tính, nhằm đánh giá tính bảo mật của hệ thống. Quá trình thử nghiệm được thực hiện để xác định tất cả điểm yếu (còn được gọi là lỗ hổng), bao gồm khả năng các bên không được phép truy cập vào những tính năng và dữ liệu hệ thống, cũng như điểm mạnh là cho phép đánh giá rủi ro trên toàn hệ thống.\r\n\r\nĐánh giá lỗ hổng tương tự như việc bước đến một cánh cửa và kiểm tra xem nó có được mở khóa hay không trước khi dừng lại. Kiểm tra thâm nhập tiến xa hơn một bước, không chỉ kiểm tra xem cửa có mở khóa hay không mà còn mở cửa và bước vào ngay.</p>",
              "level": "fresher"
            },
            {
              "question": "Null Session nghĩa là gì?",
              "answer": "<p>Một phiên truy cập từ xa được tạo lập khi người dùng đăng nhập từ xa vào một máy tính sử dụng một tên người dùng và mật khẩu có quyền truy cập vào tài nguyên hệ thống. Tiến trình đăng nhập này được thực hiện qua giao thức SMB (Server Message Block) và dịch vụ Windows Server. Những kết nối này hoàn toàn hợp pháp khi những thông tin đăng nhập chính xác được sử dụng.\r\n\r\nMột Null Session xảy ra khi người dùng thực hiện kết nối tới một hệ thống Windows mà không sử dụng tên người dùng hay mật khẩu. Hình thức kết nối này không thể thực hiện trên bất kỳ hình thức chia sẻ Windows thông thường nào, tuy nhiên lại có thể thực hiện trên chia sẻ quản trị IPC (Interprocess Communication).</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu tấn công mạng phổ biến",
              "answer": "<p><ul><li>Malware </li></ul>\r<ul><li>Cross-Site Scripting (XSS) </li></ul>\r<ul><li>Denial-of-Service (DoS)</li></ul>\r<ul><li>Domain Name System Attack</li></ul>\r<ul><li>Man-in-the-Middle Attacks </li></ul>\r<ul><li>SQL Injection Attack </li></ul>\r<ul><li>Phishing</li></ul>\r<ul><li>Session Hijacking</li></ul>\r<ul><li>Brute Force</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Tấn công brute force là gì?",
              "answer": "<p>Tấn công Brute Force là một loại tấn công mạng, trong đó bạn có một phần mềm, xoay vòng các ký tự khác nhau, kết hợp để tạo ra một mật khẩu đúng. Phần mềm Brute Force Attack password cracker đơn giản sẽ sử dụng tất cả các kết hợp có thể để tìm ra mật khẩu cho máy tính hoặc máy chủ mạng. Nó rất đơn giản và không sử dụng bất kỳ kỹ thuật thông minh nào. Vì phương pháp này chủ yếu dựa trên toán học, phải mất ít thời gian hơn để crack mật khẩu, bằng cách sử dụng các ứng dụng brute force thay vì tìm ra chúng theo cách thủ công. Nói phương pháp này dựa trên toán học vì máy tính làm rất tốt các phép toán và thực hiện chúng trong vài giây, nhanh hơn rất nhiều lần so với bộ não con người (mất nhiều thời gian hơn để tạo ra các sự kết hợp).\r\n\r\n<img src=\"/interview-assets/brute-force-in-cyber-security.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Shouder surfing là gì?",
              "answer": "<p>Là một kỹ thuật thu thập password bằng cách xem qua vai người khác khi họ đăng nhập vào hệ thống. Hacker có thể xem người sử dụng thông tin đăng nhập và sau đó sử dụng password đó để giành được quyền truy xuất đến hệ thống.\r\n\r\n<img src=\"/interview-assets/Shoulder_Surfing.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "data-structures",
          "name": "Câu hỏi phỏng vấn Cấu Trúc Dữ Liệu",
          "description": "",
          "questions": [
            {
              "question": "Bạn có thể giải thích sự khác nhau giữa cấu trúc tập tin và cấu trúc lưu trữ?",
              "answer": "<p>Sự khác biệt chính giữa cấu trúc tập và cấu trúc lưu trữ là dựa trên không gian bộ nhớ đang được truy cập.\r\n\r\n<strong>Cấu trúc lưu trữ:</strong> Là sự biểu diễn cấu trúc dữ liệu trong bộ nhớ máy tính.\r\n\r\n<strong>Cấu trúc tập tin:</strong> Là biểu diễn cấu trúc lưu trữ trong bộ nhớ phụ/thứ cấp.</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn có thể nói sự khác biệt giữa cấu trúc dữ liệu tuyến tính và phi tuyến tính?",
              "answer": "<p>Nếu các phần tử của cấu trúc dữ liệu là một chuỗi hay danh sách tuyến tính thì nó gọi là cấu trúc dữ liệu tuyến tính. Trong khi đó, cấu trúc dữ liệu cho duyệt các phần tử không theo thứ tự nào gọi cấu trúc dữ liệu phi tuyến tính.\r\n\r\nDanh sách, ngăn xếp và hàng đợi là ví dụ của cấu trúc dữ liệu tuyến tính trong khi cây và đồ thị là cấu trúc dữ liệu phi tuyến tính.\r\n\r\n<img src=\"/interview-assets/linear-vs-non-linear.png\" alt=\"linear-vs-non-linear\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Mảng là gì?",
              "answer": "<p>Mảng là tập hợp các loại dữ liệu cùng <strong>kiểu</strong> được lưu trữ tại các vị trí bộ nhớ liền kề.\r\nĐây là cấu trúc dữ liệu đơn giản nhất mà phần tử dữ liệu có thể được truy cập ngẫu nhiên bằng cách sử dụng chỉ mục của nó.</p>",
              "level": "fresher"
            },
            {
              "question": "Mảng đa chiều là gì?",
              "answer": "<p>Mảng đa chiều là những cấu trúc dữ liệu mảng trên nhiều chiều khác nhau.\r\n\r\nĐiều này chỉ ra rằng sẽ có nhiều hơn một chỉ mục cho mỗi điểm lưu trữ. Loại cấu trúc dữ liệu này chủ yếu được sử dụng trong trường hợp dữ liệu không thể được biểu diễn hoặc lưu trữ trên mảng một chiều. Mảng đa chiều được sử dụng phổ biến nhất là mảng hai chiều.\r\n\r\nMảng hai chiều mô phỏng cấu trúc dạng bảng giúp dễ dàng lưu trữ lượng lớn dữ liệu được truy cập bằng cách sử dụng con trỏ hàng và cột.\r\n\r\n<img src=\"/interview-assets/multidimensional-array.png\" alt=\"multi-array\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Danh sách liên kết là gì?",
              "answer": "<p>Danh sách liên kết là một <strong>chuỗi tuần tự các nút</strong>, trong đó các nút được liên kết với nhau thông qua con trỏ tham chiếu. Các phần tử <strong>không được lưu trữ</strong> tại các vị trí liền kề trong bộ nhớ. Chúng được liên kết bằng cách sử dụng con trỏ để tạo thành một chuỗi. Điều này tạo thành một liên kết dạng chuỗi để lưu trữ dữ liệu. \r\n\r\nMỗi nút thường có hai phần:\r<ul><li>Trường dữ liệu</li></ul>\r<ul><li>Tham chiếu(con trỏ) đến nút kế tiếp</li></ul>\r\n\r\nNút đầu tiên trong danh sách liên kết gọi là head, nút cuối cùng gọi là tail và trỏ đến null. Null trong trường tham chiếu chỉ ra nút đó là tail. Nếu danh sách trống, head sẽ là tham chiếu null.\r\n\r\n<img src=\"/interview-assets/linked-list.png\" alt=\"linked-list\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Danh sách liên kết là tuyến tính hay phi tuyến tính?",
              "answer": "<p>Danh sách liên kết có thể được coi là cấu trúc dữ liệu tuyến tính và cả phi tuyến tính. Điều này phụ thuộc vào ứng dụng mà chúng được sử dụng.\r\n\r\nKhi danh sách liên kết được sử dụng cho truy cập, nó được coi là một cấu trúc dữ liệu tuyến tính. Khi chúng được sử dụng để lưu trữ dữ liệu, nó có thể được coi là một cấu trúc dữ liệu phi tuyến tính.</p>",
              "level": "fresher"
            },
            {
              "question": "Danh sách liên kết có hiệu quả hơn mảng?",
              "answer": "<p>1. <strong>Chèn và xoá</strong>\r<ul><li>Quá trình chèn và xoá là rất tốn kém trong mảng vì phải tạo các phần tử mới và dịch chuyển các phần tử đã có.</li></ul>\r<ul><li>Nhưng trong danh sách liên kết, các thao tác này dễ dàng hơn vì chỉ cập nhật địa chỉ hiện tại trong con trỏ tiếp theo của một nút.</li></ul>\r\n\r\n2. <strong>Cấu trúc dữ liệu động</strong>\r<ul><li>Danh sách liên kết là cấu trúc dữ liệu động có nghĩa là không cần cho kích thước ban đầu khi tạo, nó có thể mở rộng hay co lại theo thời gian bởi quá trình cấp phát hay thu hồi của bộ nhớ.</li></ul>\r<ul><li>Trong khi đó, kích thước của mảng là giới hạn về số lượng phần tử được lưu trong bộ nhớ chính.</li></ul>\r\n\r\n3. <strong>Không lãng phí bộ nhớ</strong>\r<ul><li>Vì kích thước của danh sách liên kết có thể tăng lên hoặc co lại dựa trên nhu cầu của chương trình, nên không có bộ nhớ nào bị lãng phí vì nó được cấp phát trong thời gian chạy.</li></ul>\r<ul><li>Với mảng, nếu chúng ta khai báo một mảng có kích thước 10 và chỉ lưu trữ 3 phần tử trong đó, thì không gian cho 7 phần tử sẽ bị lãng phí. Do đó, khả năng lãng phí bộ nhớ trong các mảng nhiều hơn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích trường hợp nào sử dụng danh sách liên kết và trường hợp nào sử dụng mảng?",
              "answer": "<p>Các trường hợp sử dụng danh sách liên kết tốt hơn mảng:\r<ul><li>Khi ta không biết trước chính xác số lượng phần tử.</li></ul>\r<ul><li>Khi ta biết sẽ có một lượng lớn thao tác thêm hoặc xoá.</li></ul>\r<ul><li>Số lượng thao tác truy cập ngẫu nhiên là rất ít.</li></ul>\r<ul><li>Khi muốn chèn các mục vào bất kỳ vị trí nào giữa danh sách, chẳng hạn như khi triển khai hàng đợi ưu tiên, danh sách liên kết sẽ phù hợp hơn.</li></ul>\r\n\r\nCác trường hợp dùng mảng tốt hơn danh sách liên kết:\r<ul><li>Khi cần đánh chỉ mục cho các truy cập phần tử ngẫu nhiên thường xuyên.</li></ul>\r<ul><li>Khi ta biết trước số lượng phần tử mảng để cấp phát bộ nhớ.</li></ul>\r<ul><li>Khi chúng ta cần tốc độ khi lặp lại các phần tử trong chuỗi.</li></ul>\r<ul><li>Khi cần quan tâm bộ nhớ:</li></ul>\r\n    1. Một mảng đầy sẽ tốn ít bộ nhớ hơn danh sách liên kết\r\n    2. Mỗi phần tử trong mảng chỉ biễu diễn dữ liệu trong khi mỗi nút trong danh sách liên kết phải biễu diễn thêm một hoặc nhiều con trỏ cho liên kết đến các nút khác.\r\n\r\nTóm lại, các yêu cầu về không gian, thời gian và mức độ dễ thực hiện được xem xét để quyết định cấu trúc dữ liệu nào sẽ được sử dụng cho mục đích gì.</p>",
              "level": "fresher"
            },
            {
              "question": "Danh sách liên kết đôi (DDL) là gì?",
              "answer": "<p>Đây là một loại danh sách liên kết phức tạp, trong đó một nút có hai tham chiếu:\r<ul><li>Một tham chiếu liên kết với nút tiếp theo trong chuỗi</li></ul>\r<ul><li>Một tham chiếu khác liên kết với nút trước đó.</li></ul>\r\n\r\nCấu trúc này cho phép duyệt các phần tử dữ liệu theo cả hai hướng (trái sang phải và ngược lại).\r\n\r\nCác ứng dụng của DLL là:\r<ul><li>Danh sách phát nhạc với bài hát tiếp theo và các tùy chọn điều hướng bài hát trước đó.</li></ul>\r<ul><li>Bộ nhớ cache của trình duyệt với các trang đã truy cập BACK-FORWARD</li></ul>\r<ul><li>Chức năng hoàn tác và phục hồi trên các nền tảng như word, paint, v.v., nơi bạn có thể nút undo để truy cập trang trước.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Ngăn xếp là gì",
              "answer": "<p>Ngăn xếp là một cấu trúc dữ liệu tuyến tính tuân theo cách tiếp cận LIFO (Last In First Out) để truy cập các phần tử. \r\n\r\nCác thao tác cơ bản trong ngăn xếp:\r<ul><li><em>Push</em>: thêm phần tử vào đỉnh ngăn xếp</li></ul>\r<ul><li><em>Pop</em>: lấy phần tử từ đỉnh ngăn xếp</li></ul>\r<ul><li><em>Peek</em>: lấy giá trị phần tử từ đỉnh ngăn xếp, mà không xóa nó khỏi ngăn xếp</li></ul>\r\n\r\n<img src=\"/interview-assets/stack.png\" alt=\"stack\" />\r\n\r\nCác ứng dụng của ngăn xếp:\r<ul><li>Tính các biểu thức đại số</li></ul>\r<ul><li>Quản lý bộ nhớ khi thực thi chương trình</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Hàng đợi là gì",
              "answer": "<p>Hàng đợi là một cấu trúc dữ liệu tuyến tính tuân theo phương pháp FIFO (First In First Out) để truy cập các phần tử.\r\n\r\nCác thao tác cơ bản trong hàng đợi:\r<ul><li><em>enqueue</em>: thêm đối tượng vào cuối hàng đợi.</li></ul>\r<ul><li><em>dequeue</em>: lấy đối tượng ở đầu ra khỏi hàng đợi và trả về giá trị của nó.</li></ul>\r<ul><li><em>front</em>: trả về giá trị của phần tử nằm ở đầu hàng đợi mà không hủy nó.</li></ul>\r<ul><li><em>rear</em>: trả về giá trị của phần tử nằm ở cuối hàng đợi mà không hủy nó.</li></ul>\r\n\r\n<img src=\"/interview-assets/queue.png\" alt=\"queue\" />\r\n\r\nỨng dụng của hàng đợi:\r<ul><li>Dùng trong các hệ điều hành song song</li></ul>\r<ul><li>Xử lý yêu cầu trang web</li></ul>\r<ul><li>Dùng làm bộ đệm cho ứng dụng nghe nhạc</li></ul>\r<ul><li>Tác vụ CPU</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Ngăn xếp và hàng đợi khác nhau thế nào?",
              "answer": "<p>Trong ngăn xếp phần tử được thêm vào gần nhất sẽ được lấy ra đầu tiên, còn trong hàng đợi nó sẽ được lấy ra cuối cùng.\r\n\r\n<img src=\"/interview-assets/stack-vs-queue.png\" alt=\"stack-queue\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích quy trình đằng sau việc lưu trữ một biến trong bộ nhớ.",
              "answer": "<p>Một biến được lưu trữ trong bộ nhớ dựa trên dung lượng bộ nhớ cần thiết. Sau đây là các bước được thực hiện để lưu trữ một biến:\r\n\r\n1. Đầu tiên, nó chỉ định số lượng bộ nhớ cần thiết.\r\n2. Sau đó, nó được lưu trữ dựa trên cấu trúc dữ liệu đang được sử dụng.\r<ul><li>Sử dụng các khái niệm như cấp phát động đảm bảo hiệu quả cao và các đơn vị lưu trữ có thể được truy cập dựa trên các yêu cầu trong thời gian thực.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Triển khai hàng đợi bằng ngăn xếp",
              "answer": "<p>Một hàng đợi có thể triển khai bằng cách dùng <strong>hai ngăn xếp</strong>. \r\n\r\nCho hàng đợi <code>q</code> và hai ngăn xếp <code>stack1</code> và <code>stack2</code> để triển khai <code>q</code>. Ta biết ngăn xếp hỗ trợ các thao tác push, pop và peek, ta sẽ dùng các thao tác đó để mô phỏng các hoạt động của hàng đợi, enqueue và dequeue. Do đó, hàng đợi <code>q</code> có thể triển khai theo hai cách (cả hai cách đều có độ phức tạp không gian là O(n)):\r\n\r\n1. Cần nhiều chi phí chi enqueue\r\n\r\nỞ đây, phần tử cũ nhất luôn ở trên cùng của <code>stack1</code> đảm bảo hoạt động dequeue xảy ra với độ phức tạp thời gian O (1).\r\n\r\nĐể đặt phần tử vào đầu <code>stack1</code>, <code>stack2</code> được sử dụng.\r\n\r\nMã giả:\r<ul><li>Enqueue: Độ phức tạp thời gian là O(n):</li></ul>\r\n\r\n``<code>text\r\nenqueue(q, data):\r\n    While stack1 is not empty:\r\n        Push everything from stack1 to stack2.\r\n        Push data to stack1\r\n        Push everything back to stack1.\r\n</code>`<code>\r<ul><li>Dequeue: Độ phức tạp thời gian là O(1):</li></ul>\r\n\r\n</code>`<code>text\r\ndequeue(q):\r\n    If stack1 is empty then error\r\n    else\r\n        Pop an item from stack1 and return it\r\n</code>`<code>\r\n\r\n2. Cần nhiều chi phí cho dequeue\r\n\r\nỞ đây, đối với thao tác enqueue, phần tử mới được đẩy lên trên cùng của </code>stack1<code>.Thế nên, độ phức tạp thời gian hoạt động của enqueue là O(1).\r\n\r\nVới dequeue, nếu </code>stack2<code> trống, tất cả các phần tử từ </code>stack1<code> sẽ được chuyển đến </code>stack2<code> và pop phần tử trên cùng của </code>stack2<code> để lấy kết quả. Về cơ bản, đảo ngược danh sách bằng cách đẩy vào một ngăn xếp và trả về phần tử được enqueue đầu tiên. Thao tác đẩy tất cả các phần tử vào ngăn xếp mới có độ phức tạp O(n).\r\n\r\nMã giả:\r<ul><li>Enqueue: Độ phức tạp thời gian là O(1):</li></ul>\r\n\r\n</code>`<code>text\r\nenqueue(q, data):\r\n    Push data to stack1\r\n</code>`<code>\r<ul><li>Dequeue: Độ phức tạp thời gian là O(n):</li></ul>\r\n\r\n</code>`<code>text\r\ndequeue(q):\r\n    If both stacks are empty then raise error.\r\n    If stack2 is empty:\r\n        While stack1 is not empty:\r\n            push everything from stack1 to stack2.\r\n    Pop the element from stack2 and return it.\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Triển khai ngăn xếp bằng hàng đợi?",
              "answer": "<p>Một ngăn xếp có thể được triển khai bằng 2 hai hàng đợi. Một hàng đợi hỗ trợ các thao tác là enqueue và dequeue. Ta sẽ dùng chúng để tạo các thao tác push, pop.\r\n\r\nĐầu tiên ta có hai hàng đợi là <code>q1</code> và <code>q2</code>. Ngăn xếp được triển khai bởi hàng đợi theo hai cách.\r\n\r\n1. Tốn chi phí cho push:\r\n\r\nPhương thức này đảm bảo các phần tử mới được thêm vào sẽ luôn ở đằng trước của <code>q1</code>, thế nên thao tác pop sẽ là deque từ <code>q1</code>.\r\n\r\n<code>q2</code> được dùng như một hàng đợi phụ trợ để phần tử mới vào trước <code>q1</code> trong khi đảm bảo pop xảy ra ở độ phức tạp O(1).\r\n\r\nMã giả:\r<ul><li>Push phần tử vào ngăn xếp: Độ phức tạp thời gian là O(n).</li></ul>\r\n``<code>\r\npush(s, data):\r\n    Enqueue data to q2\r\n    Dequeue elements one by one from q1 and enqueue to q2.\r\n    Swap the names of q1 and q2\r\n</code>`<code>\r<ul><li>Pop phần tử khỏi ngăn xếp: Độ phức tạp thời gian là O(1).</li></ul>\r\n</code>`<code>\r\npop(s):\r\n    dequeue from q1 and return it.\r\n</code>`<code>\r\n\r\n2. Tốn chi phí cho pop:\r\n\r\nTrong hoạt động push, phần tử được enqueue vào hàng đợi </code>q1<code>.\r\n\r\nTrong hoạt động pop, tất cả các phần tử từ </code>q1<code> ngoại trừ phần tử còn lại cuối cùng, được đẩy sang </code>q2<code> nếu nó trống. Phần tử cuối cùng còn lại đó của </code>q1<code> được dequeue và trả về.\r\n\r\nMã giả:\r<ul><li>Push phần tử vào ngăn xếp: Độ phức tạp thời gian là O(1).</li></ul>\r\n</code>`<code>\r\npush(s,data):\r\n    Enqueue data to q1\r\n</code>`<code>\r<ul><li>Pop phần tử khỏi ngăn xếp: Độ phức tạp thời gian là O(n).</li></ul>\r\n</code>`<code>\r\npop(s):\r\n    Step1: Dequeue every elements except the last element from q1 and enqueue to q2.\r\n    Step2: Dequeue the last item of q1, the dequeued item is stored in result variable.\r\n    Step3: Swap the names of q1 and q2 (for getting updated data after dequeue)\r\n    Step4: Return the result.\r\n</code>``\r\n\r\n## Câu hỏi phỏng vấn cho Experienced</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "design-patterns",
          "name": "Câu hỏi phỏng vấn về Design Pattern",
          "description": "",
          "questions": [
            {
              "question": "Design pattern là gì?",
              "answer": "<p>Design pattern là các giải pháp có thể tái sử dụng để giải quyết các vấn đề chung của phát triển phần mềm. Những vấn đề này bao gồm code lặp lại, các chức năng và logic dư thừa, v.v. Những vấn đề này giúp tiết kiệm đáng kể công sức và thời gian cần thiết cho các dev trong khi phát triển phần mềm. Các design pattern thường được sử dụng trong các sản phẩm phần mềm hướng đối tượng bằng cách kết hợp các phương pháp hay nhất và thúc đẩy khả năng tái sử dụng để phát triển mã mạnh mẽ. \r\n\r\n<img src=\"/interview-assets/What_are_design_patterns.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern trong Java?",
              "answer": "<p>Trong java, các pattern rất linh hoạt và dễ dàng xác định code lặp lại không mong muốn. Kiến trúc phần mềm có thể tuỳ chỉnh theo từng yêu cầu. Một vài lợi ích của sử dụng design pattern trong Java:\r<ul><li>Có thể tái sử dụng cho nhiều dự án.</li></ul>\r<ul><li>Cung cấp giải pháp mẫu cho thiết kế kiến trúc hệ thống.</li></ul>\r<ul><li>Chúng cung cấp sự minh bạch cho thiết kế phần mềm.</li></ul>\r<ul><li>Chúng là những giải pháp đã được thử nghiệm và chứng minh để phát triển phần mềm mạnh mẽ một cách dễ dàng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả một design pattern như thế nào?",
              "answer": "<p><ul><li>Xác định tên và nhóm của design pattern sẽ thuộc về.</li></ul>\r<ul><li>Mô tả vấn đề và giải pháp phù hợp.</li></ul>\r<ul><li>Tìm các biến thể và lựa chọn ngôn ngữ cho vấn đề cần giải quyết.</li></ul>\r<ul><li>Các trường hợp thời gian thực và hiệu quả của pattern này.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu design pattern?",
              "answer": "<p><ul><li><strong>Creational Pattern</strong> cung cấp các cơ chế tạo đối tượng để tăng tính linh hoạt và tái sử dụng code hiện có.</li></ul>\r<ul><li>Factory Method</li></ul>\r<ul><li>Abstract Factory</li></ul>\r<ul><li>Builder</li></ul>\r<ul><li>Prototype</li></ul>\r<ul><li>Singleton</li></ul>\r<ul><li><strong>Structural Pattern</strong> giải thích cách tập hợp các đối tượng và lớp thành các cấu trúc lớn hơn, trong khi vẫn giữ cho cấu trúc linh hoạt và hiệu quả.</li></ul>\r<ul><li>Adapter</li></ul>\r<ul><li>Bridge</li></ul>\r<ul><li>Composite</li></ul>\r<ul><li>Decorator</li></ul>\r<ul><li>Facade</li></ul>\r<ul><li>Flyweight</li></ul>\r<ul><li>Proxy</li></ul>\r<ul><li><strong>Behavioral Pattern</strong> quan tâm đến việc giao tiếp hiệu quả và phân công nhiệm vụ giữa các đối tượng.</li></ul>\r<ul><li>Chain Of Responsibility</li></ul>\r<ul><li>Command</li></ul>\r<ul><li>Iterator</li></ul>\r<ul><li>Mediator</li></ul>\r<ul><li>Memento</li></ul>\r<ul><li>Observer</li></ul>\r<ul><li>State</li></ul>\r<ul><li>Strategy</li></ul>\r<ul><li>Template Method</li></ul>\r<ul><li>Visitor</li></ul>\r\n\r\n<img src=\"/interview-assets/types_of_design_patterns_in_java.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Inversion of Control là gì?",
              "answer": "<p><strong>Inversion of Control (IoC)</strong> là một nguyên lý thiết kế trong công nghệ phần mềm trong đó các thành phần nó dựa vào để làm việc bị đảo ngược quyền điều khiển khi so sánh với lập trình hướng thủ thục truyền thống.\r\n\r\nDependency injection (DI) là một mô hình triển khai từ nguyên lý IoC, là một kỹ thuật trong lập trình trong đó một đối tượng cung cấp những phụ thuộc (dependency - là đối tượng, dịch vụ, chức năng) của đối tượng khác.\r\n\r\nVí dụ: ta có lớp <code>A</code> sử dụng lớp <code>B</code> như bên dưới:\r\n\r\n``<code>java\r\npublic class A{\r\n    private B b;\r\n    \r\n    public A(){\r\n        this.b = new B();\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nỞ đây, ta có phụ thuộc giữa lớp A và B. Nếu bạn triển khai IoC, bạn sẽ không phải dùng toán tử </code>new<code> để gán giá trị. \r\n\r\n</code>`<code>java\r\npublic class A {\r\n    private IocB b;\r\n    public A(IocB b) {\r\n        this.b = b;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nChúng ta đã dùng IoC cho việc khởi tạo đối tượng của lớp </code>B<code> cho lớp </code>IocB`.</p>",
              "level": "fresher"
            },
            {
              "question": "GoF là gì?",
              "answer": "<p><strong>Gang of Four</strong> (GOF) là 4 người đã phát minh ra khái niệm design pattern. Họ là Erich Gamma, Ralph Johnson, Richard Hel and John Vlissides. Những người này đã viết về các design pattern trong quyển sách \"Design Patterns: Elements of Reusable Object-Oriented Software\" năm 1995. Nếu không có họ, các nhà phát triển phần mềm sẽ lãng phí thời gian giải quyết các vấn đề có tính chất lặp lại thay vì tập trung vào các yêu cầu nghiệp vụ.</p>",
              "level": "fresher"
            },
            {
              "question": "Các nguyên tắc SOLID là gì?",
              "answer": "<p>Nguyên tắc SOLID là các nguyên tắc hướng đối tượng được Robert C. Martin giới thiệu trong bài báo cáo \"Design Principles and Design patterns\" năm 2000. \r\n\r\n<img src=\"/interview-assets/SOLID_principles.png\" alt=\"\" />\r<ul><li><strong>S - Single Responsibility Principle (SRP):</strong> nguyên tắc trách nhiệm đơn nhất đảm bảo tất cả lớp hay module chỉ chịu trách nhiệm cho một chức năng duy nhất. </li></ul>\r<ul><li><strong>O - Open Closed Principle (OCP):</strong> nguyên tắc đóng mở cho phép tất cả lớp đều mở cho bổ sung nhưng đóng cho chỉnh sửa. Ở đây ta cho phép mở rộng hành vi các thực thể nhưng không được chỉnh sửa code đã tồn tại.</li></ul>\r<ul><li><strong>L - Liskov Substitution Principle(LSP):</strong> nguyên tắc Liskoy nói rằng trạng thái của đối tượng có thể thay thế bằng các thể hiện con mà không ảnh hưởng đến tính đúng đắn của chương trình.</li></ul>\r<ul><li><strong>I - Interface Segregation Principle (ISP):</strong> nguyên tắc phân tách interface nêu rõ rằng có thể sử dụng nhiều interface cụ thể cho các yêu cầu của client thay vì interface chung. Client không bị buộc phải thực hiện các chức năng mà họ không yêu cầu</li></ul>\r<ul><li><strong>D - Dependency Inversion Principle:</strong> ở đây các module ở level cao nên độc lập với các module level thấp. Các module cao được xem là trừu tượng và module thấp là những triển khai cụ thể.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Bạn hiểu nguyên tắc đóng mở như thế nào?",
              "answer": "<p>Nguyên tắc Đóng mở quy định rằng bất kỳ lớp, thành phần hoặc thực thể nào phải mở để mở rộng nhưng đóng để sửa đổi. Một lớp có thể được mở rộng thông qua kế thừa, interface, hay composition bất cứ khi nào nhận được yêu cầu mới thay vì sửa đổi code của lớp. Hãy xem xét một trường hợp trong đó chúng ta có một lớp tính diện tích của một hình vuông. Sau đó, ta nhận được yêu cầu tính diện tích hình chữ nhật. Ở đây, thay vì sửa đổi lớp ban đầu, chúng ta có thể tạo một lớp cơ sở và lớp cơ sở này có thể được mở rộng bằng lớp hình chữ nhật mới.</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern trong thư viện JDK của Java?",
              "answer": "<p><em> <strong>Decorator pattern</strong> được dùng cho các lớp <code>Wrapper</code>.\r\n</em> <strong>Singleton pattern</strong> được dùng cho các lớp <code>Calendar</code> và <code>Runtime</code>.\r\n<em> <strong>Factory pattern</strong> được dùng cho các phương thức như <code>Integer.valueOf</code> trong các lớp <code>wrapper</code>.\r\n</em> <strong>Observer pattern</strong> được dùng cho xử lý sự kiện framework như <code>awt</code>, <code>swing</code>,...</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern và design principles khác nhau như thế nào?",
              "answer": "<p><strong>Design principles (Nguyên tắc thiết kế):</strong> là những nguyên tắc được tuân theo trong khi thiết kế hệ thống phần mềm cho bất kỳ nền tảng nào hay phải sử dụng bất kỳ ngôn ngữ lập trình nào. Các nguyên tắc SOLID là các nguyên tắc thiết kế mà chúng ta tuân theo để phát triển các hệ thống phần mềm mạnh mẽ, có thể dễ dàng mở rộng. Những điều này áp dụng cho tất cả các khía cạnh của lập trình.\r\n\r\n<strong>Design pattern (Mẫu thiết kế):</strong> là các giải pháp mẫu có thể tái sử dụng cho các vấn đề thường xảy ra có thể được tùy chỉnh theo yêu cầu của vấn đề. Đây là những giải pháp đã được thực hiện tốt, được thử nghiệm đúng cách và an toàn khi sử dụng. Mô hình thiết kế Factory, mô hình Singleton, mô hình Strategy là một vài trong số các ví dụ về các mẫu thiết kế.</p>",
              "level": "fresher"
            },
            {
              "question": "Các design pattern khác các thuật toán như thế nào?",
              "answer": "<p>Cả design pattern và thuật toán đều mô tả các giải pháp điển hình cho bất kỳ vấn đề nào đã cho. Nhưng sự khác biệt chính là thuật toán xác định một tập hợp các hành động rõ ràng để đạt được mục tiêu còn design pattern cung cấp mô tả cấp cao về bất kỳ giải pháp nào. Các design pattern áp dụng cho hai vấn đề khác nhau có thể giống nhau nhưng logic thực hiện sẽ khác nhau dựa trên các yêu cầu.\r\n\r\n## Câu hỏi phỏng vấn design pattern cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Factory là gì?",
              "answer": "<p>Factory thuộc nhóm design pattern creational. Ở đây các đối tượng được tạo mà không để lộ logic của việc tạo ra cho client. Bởi vì các đối tượng tham chiếu đến interface chung.\r\n\r\nVí dụ: Ta có 3 lớp <code>Square</code>, <code>Triangle</code> và <code>Rectangle</code>. Ta sẽ sử dụng design pattern factory cho tạo đối tượng từ 3 lớp mà không để lộ logic tạo bằng cách dùng lớp <code>ShapeFactory</code>. Lớp <code>Driver</code> sẽ truyền thông tin như RECTANGLE/SQUARE/TRIANGLE đến đối tượng cần thiết. Sơ đồ UML cho trường hợp này:\r\n\r\n<img src=\"/interview-assets/Factory_Design_Pattern.png\" alt=\"\" />\r\n\r\nBây giờ ta triển khai code cho ví dụ trên:\r\n\r\n<strong>Bước 1:</strong> Tạo interface Shape\r\n\r\n``<code>java\r\n//Shape.java\r\npublic interface Shape {\r\n    void draw();\r\n}\r\n</code>`<code>\r\n\r\n<strong>Bước 2:</strong> Tạo lớp cụ thể Rectangle, Square, Triangle sử dụng triển khai interface Shape.\r\n\r\n</code>`<code>java\r\n//Rectangle.java\r\npublic class Rectangle implements Shape {\r\n    @Override\r\n    public void draw() {\r\n        System.out.println(\"Rectangle Drawn\");\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//Square.java\r\npublic class Square implements Shape {\r\n    @Override\r\n    public void draw() {\r\n        System.out.println(\"Square Drawn\");\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//Triangle.java\r\npublic class Triangle implements Shape {\r\n    @Override\r\n    public void draw() {\r\n        System.out.println(\"Triangle Drawn\");\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>Bước 3:</strong> Tạo lớp ShapeFactory và tạo một phương thức gọi là </code>getShapeInstance()<code> cho tạo đối tượng ở lớp cụ thể:\r\n\r\n</code>`<code>java\r\n//ShapeFactory.java\r\npublic class ShapeFactory {\r\n    //the method will be used to get object of required shape\r\n    public Shape getShapeInstance(String type){\r\n        if(type == null){\r\n            return null;\r\n        } \r\n        if(type.equalsIgnoreCase(\"TRIANGLE\")){\r\n            return new Triangle();\r\n        } else if(type.equalsIgnoreCase(\"SQUARE\")){\r\n            return new Square();\r\n        } else if(type.equalsIgnoreCase(\"RECTANGLE\")){\r\n            return new Rectangle();\r\n        }\r\n        return null;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>Bước 4:</strong> Triển khai lớp Driver và sử dụng lớp factory để lấy đối tượng của kiểu được yêu cầu.\r\n\r\n</code>`<code>java\r\n//Driver.java\r\npublic class Driver {\r\n    public static void main(String[] args) {\r\n        ShapeFactory shapeFactory = new ShapeFactory();\r\n        //get Triangle object and call draw()\r\n        Shape triangle = shapeFactory.getShape(\"Triangle\");\r\n        triangle.draw();\r\n        //get Rectangle object and call draw()\r\n        Shape rectangle = shapeFactory.getShape(\"RECTANGLE\");\r\n        rectangle.draw();\r\n        //get Square object and call draw()\r\n        Shape square = shapeFactory.getShape(\"SQUARE\");\r\n        square.draw();\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<strong>Bước 5:</strong> Xem kết quả\r\n\r\n</code>`<code>text\r\nTriangle Drawn\r\nRectangle Drawn\r\nSquare Drawn\r\n</code>``\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Adapter là gì?",
              "answer": "<p>Thuộc nhóm design pattern structural để các đối tượng không tương thích cộng tác với nhau. Nó hành động như một wrapper giữa hai đối tượng khác nhau. Adapter nhận cuộc gọi từ một đối tượng và biến đổi chúng để đối tượng thứ hai có thể nhận.\r\n\r\nĐể dễ hiểu ta lấy ví dụ về bộ chuyển đổi từ USB sang Ethernet. Khi ta có một đầu là ethernet và đầu kia là USB, hai đầu này không tương thích nhau nên ta cần có một bộ chuyển đổi. Lớp <code>Client</code> sẽ mong đợi một số kiểu đối tượng và nó có lớp <code>Adaptee</code> có thể cung cấp tính năng tương tư nhưng bằng một interface khác. Bây giờ để cả hai giao tiếp, chúng ta có một lớp <code>Adapter</code>, <code>Client</code> yêu cầu <code>Adapter</code> sử dụng interface <code>Target</code>. Lớp <code>Adapter</code> dịch yêu cầu bằng interface <code>Adaptee</code>. <code>Client</code> nhận được kết quả mà không biết về vai trò của bộ chuyển đổi. Ta có sơ đồ lớp như bên dưới.\r\n\r\n<img src=\"/interview-assets/Class_Diagram.png\" alt=\"\" />\r\n\r\nBây giờ ta xem xét một interface <code>MediaPlayer</code> được triển khai bởi lớp <code>AudioPlayer</code>. <code>AudioPlayer</code> có thể chạy bài hát định dạng mp3. Mặt khác interface <code>AdvancedPlayer</code> được triển khai bởi lớp <code>MP4Player</code> có thể chạy định dạng mp4 và <code>WAVPlayer</code> chạy định dạng wav. Nếu ta muốn <code>AudioPlayer</code> chạy tất cả định dạng, ta phải sử dụng <code>MediaAdapter</code> để triển khai <code>MediaPlayer</code> và sử dụng đối tượng <code>AdavancedPlayer</code> cho các định dạng cần thiết. Code cho trường hợp này như sau:\r\n\r\n``<code>java\r\n//MediaPlayer.java\r\npublic interface MediaPlayer {\r\n    public void play(String format, String file);\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//AdvancedPlayer.java\r\npublic interface AdvancedPlayer { \r\n    public void playMp4(String file);\r\n    public void playWav(String file);\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//Mp4Player.java\r\npublic class Mp4Player implements AdvancedPlayer{\r\n    @Override\r\n    public void playMp4(String file) {\r\n        System.out.println(\"MP4 File \"+ file + \" Playing....\");  \r\n    }\r\n    \r\n    @Override\r\n    public void playWav(String file) {\r\n        //do nothing\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//WAVPlayer.java\r\npublic class WAVPlayer implements AdvancedPlayer{\r\n    @Override\r\n    public void playMp4(String file) {\r\n        //do nothing\r\n    }\r\n    \r\n    @Override\r\n    public void playWav(String file) {\r\n        System.out.println(\"WAV File \"+ file + \" Playing....\");  \r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//MediaAdapter.java\r\npublic class MediaAdapter implements MediaPlayer {\r\n    AdvancedPlayer advancedPlayer;\r\n    public MediaAdapter(String format){\r\n        if(format.equalsIgnoreCase(\"mp4\") ){\r\n            advancedPlayer = new Mp4Player();   \r\n        }else if(format.equalsIgnoreCase(\"wav\") ){\r\n            advancedPlayer = new WAVPlayer();   \r\n        }\r\n    }\r\n    @Override\r\n    public void play(String format, String file) {\r\n    \r\n        if(format.equalsIgnoreCase(\"mp4\")){\r\n            advancedPlayer.playMp4(file);\r\n        }\r\n        else if(format.equalsIgnoreCase(\"wav\")){\r\n            advancedPlayer.playWav(file);\r\n        }\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//AudioPlayer.java\r\npublic class AudioPlayer implements MediaPlayer {\r\n    MediaAdapter mediaAdapter;\r\n    @Override\r\n    public void play(String format, String file) {  \r\n        //inbuilt support to play mp3 music files\r\n        if(format.equalsIgnoreCase(\"mp3\")){\r\n            System.out.println(\"MP3 file \" + file +\" Playing...\");   \r\n        } \r\n        //Make use of Adapter to support different formats\r\n        else if(format.equalsIgnoreCase(\"wav\") || format.equalsIgnoreCase(\"mp4\")){\r\n            mediaAdapter = new MediaAdapter(format);\r\n            mediaAdapter.play(format, file);\r\n        }\r\n        else{\r\n            System.out.println(\"Format not supported\");\r\n        }\r\n    }   \r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>java\r\n//Driver.java\r\npublic class Driver {\r\n    public static void main(String[] args) {\r\n        AudioPlayer audioPlayer = new AudioPlayer();\r\n        audioPlayer.play(\"mp3\", \"music1.mp3\");\r\n        audioPlayer.play(\"wav\", \"music2.wav\");\r\n        audioPlayer.play(\"mp4\", \"music3.mp4\");\r\n        audioPlayer.play(\"avi\", \"music4.avi\");\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nVà đây là kết quả:\r\n\r\n</code>`<code>text\r\nMP3 file music1.mp3 Playing...\r\nWAV File music2.wav Playing...\r\nMP4 File music3.mp4 Playing...\r\nFormat not supported\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Proxy là gì?",
              "answer": "<p>Proxy thuộc nhóm structural, dùng ddeer biểu diễn một chức năng cho các lớp khác. Pattern này cho phép chúng ta tạo một vật thay thế cho một đối tượng khác, vật này được gọi là đối tượng proxy. Giúp kiểm soát quyền truy cập vào đối tượng ban đầu và cho phép thực hiện nhiều tác vụ trước hoặc sau khi yêu cầu đến đối tượng ban đầu.\r\n\r\n<img src=\"/interview-assets/Proxy_Design_Pattern.png\" alt=\"\" />\r\n\r\nNhư hình ở trên, ta có interface <code>ServiceInterface</code> cho các thao tác. Interface này được triển khai bởi lớp <code>Service</code> và <code>Proxy</code>. Lớp <code>Service</code> chứa logic nghiệp vụ hữu ích và lớp <code>Proxy</code> chứa tham chiếu trỏ đến đối tượng <code>service</code>. Sau khi proxy hoàn thành quá trình lazy initialization, logging, caching,.. yêu cầu sẽ được truyền đến đối tượng service. Và cuối cùng, ta có client làm việc với service và proxy bằng cách dùng interface.</p>",
              "level": "fresher"
            },
            {
              "question": "Design pattern Bridge là gì?",
              "answer": "<p>Cũng thuộc nhóm structural design pattern giúp chia một lớp lớn thành một 2 hệ thống phân cấp lớp - trừu tượng và triển khai. Các hệ thống phân cấp này là độc lập và được dùng bất cứ khi nào cần tách sự trừu tượng khỏi triển khai. Điều này gọi là Bridge pattern bởi vì nó hành động như một cây cầu giữa lớp trừu tường và lớp triển khai. Trong pattern này, lớp trừu tượng và lớp triển khai có thể được chỉnh sửa độc lập mà không ảnh hưởng lẫn nhau.\r\n\r\n<img src=\"/interview-assets/Bridge_design_pattern.png\" alt=\"\" />\r\n\r\nTrong hình trên ta có 4 thành phần chính trong pattern này là:\r<ul><li><strong>Abstraction</strong> – Đây là cốt lỗi của pattern, nó bao gồm một tham chiếu đến cho Implementer.</li></ul>\r<ul><li><strong>Refined Abstraction</strong> – là mở rộng của abstraction nó lấy chi tiết yêu cầu và ẩn chúng với implementers.</li></ul>\r<ul><li><strong>Implementer</strong> – là interface cho các lớp implementation.</li></ul>\r<ul><li><strong>Concrete Implementation</strong> – Đây là các lớp triển khai cụ thể triển khai interface Implementer.</li></ul></p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "network",
          "name": "Mạng máy tính",
          "description": "",
          "questions": [
            {
              "question": "Mạng máy tính được phân loại như thế nào?",
              "answer": "<p>Các loại mạng có thể được phân loại và phân chia dựa trên khu vực phân bố của chúng. Sơ đồ dưới đây sẽ giúp hiểu nhanh hơn:\r\n\r\n<img src=\"/interview-assets/Network_Types.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về các loại mạng?",
              "answer": "<p>| Loại | Mô tả |\r\n|------|-------|\r\n| PAN (Personal Area Network) | Các thiết bị kết nối và giao tiếp trong phạm vi người dùng (như kết nối bluetooth) |\r\n| LAN (Local Area Network) | Mạng thuộc sở hữu tư nhân như trong một văn phòng, nhà máy,...\r\n| MAN (Metropolotan Area Network) | Được kết nối trên khu vực toàn thành phố vd như hệ thống TV cable |\r\n| WAN (Wide Area Network) | Nó trải dài trên một khu vực địa lý rộng lớn, thường là một quốc gia hoặc lục địa. Internet là mạng WAN lớn nhất |\r\n| GAN (Global Area Network) | Còn được gọi là internet, kết nối toàn cầu thông qua vệ tinh. |</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích về LAN?",
              "answer": "<p>Mạng LAN được sử dụng rộng rãi để kết nối máy tính/laptop và thiết bị điện tử tiêu dùng cho phép chúng chia sẻ tài nguyên (ví dụ: máy in, máy fax) và trao đổi thông tin. Khi mạng LAN được sử dụng bởi các công ty hoặc tổ chức, chúng được gọi là mạng doanh nghiệp. Có hai loại mạng LAN khác nhau, tức là mạng LAN không dây (không có dây, khi sử dụng Wi-Fi) và mạng LAN có dây (sử dụng bằng cáp LAN). Ngày nay, mạng LAN không dây rất phổ biến ở những nơi khó lắp đặt dây. Các sơ đồ dưới đây giải thích cả mạng LAN không dây và có dây.\r\n\r\n<img src=\"/interview-assets/LAN_(Local_Area_Network).png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "VPN là gì?",
              "answer": "<p>VPN hay Virtual Private Network là một mạng WAN riêng tư được xây dựng trên internet. Nó cho phép tạo một đường hầm bảo mật (secured tunnel) giữa hai mạng khác nhau sử dụng internet. Bằng cách dùng VPN, một client có thể kết nối từ xa tới mạng của tổ chức. So đồ dưới đây cho thấy một mạng WAN của tổ chức ở Úc sử dụng VPN:\r\n\r\n<img src=\"/interview-assets/VPN_(Virtual_Private_Network).png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Lợi ích của VPN?",
              "answer": "<p><ul><li>VPN được sử dụng để kết nối từ xa các văn phòng ở các vị trí địa lý khác nhau, nó rẻ hơn khi so sánh với kết nối WAN.</li></ul>\r<ul><li>VPN được sử dụng cho các giao dịch an toàn và truyền dữ liệu bí mật giữa nhiều văn phòng đặt tại các vị trí địa lý khác nhau.</li></ul>\r<ul><li>VPN giữ cho thông tin của tổ chức được bảo mật trước mọi mối đe dọa hoặc sự xâm nhập tiềm ẩn bằng cách sử dụng ảo hóa.</li></ul>\r<ul><li>VPN mã hóa lưu lượng truy cập internet và che giấu danh tính trực tuyến.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các loại VPN khác nhau?",
              "answer": "<p><ul><li><strong>Access VPN</strong> được dùng để cung cấp kết nối cho người dùng di động từ xa và thiết bị viễn thông. Nó phục vụ như một sự thay thế cho kết nối dial-up hay ISDN (Integrated Services Digital Network). Nó là một giải pháp chi phí thấp và cung cấp một loạt kết nối.</li></ul>\r<ul><li><strong>Site-to-Site VPN</strong> hay Router-to-Router VPN thường được dùng bởi các công ty lớn có các chi nhánh ở các địa điểm khác nhau để kết nối mạng cho các văn phòng ở các địa điểm khác nhau. Nó có hai kiểu phụ là:</li></ul>\r<ul><li><strong>Intranet VPN</strong>: hữu ích khi kết nối các văn phòng từ xa trên các khu vực địa lý khác nhau bằng cơ sở hạ tầng chung (kết nối internet và server) với các chnh sách hỗ trợ như mạng WAN riêng tư.</li></ul>\r<ul><li><strong>Extranet VPN</strong> sử dụng cơ sở hạ tầng chung qua mạng intranet, nhà cung cấp, khách hàng, đối tác, các thực thể khác và các kết nối đến chúng bằng kết nối chuyên dụng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Nodes và links là gì?",
              "answer": "<p><strong>Node</strong> tạm dịch là nút, bất kỳ thiết bị giao tiếp nào trong mạng đều được gọi là nút. Một nút là một điểm giao nhau trong mạng. Nó có thể gửi/nhận dữ liệu và thông tin trong mạng. Ví dụ một nút có thể là máy tính, laptop, máy in, máy fax,...\r\n\r\n<strong>Link</strong> tạm dịch là liên kết, đề cập đến khả năng kết nối giữa hai nút trong mạng. Nó bao gồm kiểu kết nối không dây và có dây giữa các nút và giao thức được sử dụng để chúng có thể giao tiếp lẫn nhau.\r\n\r\n<img src=\"/interview-assets/Nodes_and_Links.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Cấu trúc liên kết mạng là gì?",
              "answer": "<p>Cấu trúc liên kết mạng là một bố trí vật lý của mạng, kết nối các nút khác nhau bằng các liên kết. Nó mô tả kết nối giữa các máy tính, thiết bị, cáp, v.v.</p>",
              "level": "fresher"
            },
            {
              "question": "Các kiểu cấu trúc liên kết mạng khác nhau?",
              "answer": "<p>#</p>",
              "level": "fresher"
            },
            {
              "question": "Địa chỉ IPv4 là gì? Các lớp của IPv4?",
              "answer": "<p>Một địa chỉ IP là địa chỉ 32-bit của một nút trong mạng. Một địa chỉ IPv4 có 4 octet, mỗi octet là 8-bit với mỗi số có giá trị lên đến 255.\r\n\r\nCác lớp IPv4 được phân biệt dựa trên số lượng máy chủ mà nó hỗ trợ trên mạng. Có năm loại lớp IPv4 và dựa trên octet đầu tiên của địa chỉ IP được phân loại là Lớp A, B, C, D hoặc E.\r\n\r\n| Lớp IPv4 | Địa chỉ bắt đầu | Địa chỉ kết thúc | Sử dụng |\r\n|----------|-----------------|------------------|---------|\r\n| A | 0.0.0.0 | 127.255.255.255 | Dùng cho mạng lớn |\r\n| B | 128.0.0.0 | 191.255.255.255 | Dùng cho mạng cỡ vừa |\r\n| C | 192.0.0.0 | 223.255.255.255 | Dùng cho mạng LAN |\r\n| D | 224.0.0.0 | 239.255.255.255 | Dành riêng cho nhiều người |\r\n| E | 240.0.0.0 | 255.255.255.254 | Nghiên cứu và R&D |</p>",
              "level": "fresher"
            },
            {
              "question": "Địa chỉ IP riêng tư và đặc biệt?",
              "answer": "<p><strong>Địa chỉ riêng tư:</strong> Đối với mỗi lớp, có các IP cụ thể được dành riêng cho mục đích sử dụng riêng. Không thể sử dụng địa chỉ IP này cho các thiết bị trên Internet vì chúng không thể định tuyến được.\r\n\r\n| Lớp IPv4 | Địa chỉ bắt đầu | Địa chỉ kết thúc |\r\n|----------|-----------------|------------------|\r\n| A | 10.0.0.0 | 10.255.255.255 |\r\n| B | 172.16.0.0 | 172.31.255.255 |\r\n| B | 192.168.0.0 | 192.168.255.255 |\r\n\r\n<strong>Địa chỉ đặc biệt:</strong> Dải IP từ 127.0.0.1 đến 127.255.255.255 là địa chỉ kiểm tra mạng còn được gọi là địa chỉ loopback hay địa chỉ IP đặc biệt.\r\n\r\n## Câu hỏi phỏng vấn mạng máy tính cho Experienced</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả mô hình OSI?",
              "answer": "<p><strong>Open System Interconnections (OSI)</strong> là kiến trúc mạng dựa trên chuẩn ISO. Được gọi là mô hình OSI, nó giải quyết việc kết nối các hệ thống mở để giao tiếp với các hệ thống khác.\r\n\r\nMô hình OSI có 7 tầng. Các nguyên tắc dùng cho mỗi tầng có thể tổng hợp như sau:\r<ul><li>Tạo một tầng mới nếu cần một sự trừu tượng khác.</li></ul>\r<ul><li>Mỗi tầng phải có chức năng được xác định rõ ràng.</li></ul>\r<ul><li>Chức năng của mỗi tầng được chọn dựa trên các giao thức chuẩn hoá quốc tế.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các tầng trong mô hình OSI là gì?",
              "answer": "<p><img src=\"/interview-assets/Layers_of_OSI_Model.png\" alt=\"\" />\r\n\r\n| Tầng | Đơn vị | Mô tả |\r\n|------|--------|-------|\r\n| 1.Physical | Bit | Tầng vật lý định nghĩa các đặc tính vật lý của mạng chẳng hạn như kết nối, cấp điện áp và thời gian. |\r\n| 2.Data Link | Frame | Các tầng liên kết dữ liệu định dạng các thông điệp vào một khung dữ liệu(Frame), và thêm vào đó một tiêu đề (header) chứa các địa chỉ phần cứng nơi nhận và địa chỉ nguồn của nó. Tiêu đề này chịu trách nhiệm cho việc tìm kiếm các thiết bị đích tiếp theo trên một mạng cục bộ. |\r\n| 3.Network | Package | Tầng này cung cấp địa chỉ logic mà router sẽ sử dụng để xác định đường đi đến đích.Trong hầu hết các trường hợp, địa chỉ logic ở đây có nghĩa là các địa chỉ IP (bao gồm nguồn & địa chỉ IP đích). |\r\n| 4.Transport | TPDU  | Tầng này duy trì kiểm soát luồng của dữ liệu, thực hiện kiểm tra lỗi và khôi phục dữ liệu giữa các thiết bị. Ví dụ phổ biến nhất của tầng này là Transmission Control Protocol (TCP) và User Datagram Protocol (UDP). |\r\n| 5.Session | SPDU | Nhiệm vụ của tầng này là thiết lập, duy trì và kết thúc giao tiếp với các thiết bị nhận. |\r\n| 6.Presentation | PPDU | Tầng này đảm bảo việc trình bày dữ liệu, mà các thông tin liên lạc qua tầng này nằm trong các hình thức thích hợp đối với người nhận. Nói chung, nó hoạt động như một dịch giả của mạng. Ví dụ, bạn muốn gửi một email và tầng trình bày sẽ định dạng dữ liệu của bạn sang định dạng email. Hoặc bạn muốn gửi ảnh cho bạn bè của bạn, nó sẽ định dạng dữ liệu của bạn vào các định dạng GIF, JPG hoặc PNG. |\r\n| 7.Application | APDU | Đây là tầng gần gũi nhất với người dùng cuối. Nó cung cấp giao diện giữa các ứng dụng với các tầng phía dưới. Nhưng chú ý rằng các chương trình bạn đang sử dụng (như trình duyệt web - IE, Firefox hay Opera ...) không thuộc về tầng Application.Telnet, FTP, client email (SMTP), HyperText Transfer Protocol (HTTP) là những ví dụ của tầng Application. |</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả mô hình TCP/IP?",
              "answer": "<p>Nó là một phiên bản nén của mô hình OSI chỉ có 4 tầng. Được phát triển bởi Bộ Quốc phòng Hoa Kỳ (DoD) vào những năm 1980. Tên của mô hình này dựa trên 2 giao thức tiêu chuẩn được sử dụng, đó là TCP (Transmission Control Protocol) và IP (Internet Protocol).</p>",
              "level": "fresher"
            },
            {
              "question": "Các tầng trong mô hình TCP/IP là gì?",
              "answer": "<p><img src=\"/interview-assets/Layers_of_TCP_IP.png\" alt=\"\" />\r\n\r\n| Tầng | Mô tả |\r\n|------|-------|\r\n| 1.Link | Là sự kết hợp giữa tầng Vật lý và tầng liên kết dữ liệu của mô hình OSI. Chịu trách nhiệm truyền dữ liệu giữa hai thiết bị trong cùng một mạng. Tại đây, các gói dữ liệu được đóng vào khung (gọi là Frame) và được định tuyến đi đến đích đã được chỉ định ban đầu. |\r\n| 2.Internet | Gần giống như tầng mạng của mô hình OSI. Tại đây, nó cũng được định nghĩa là một giao thức chịu trách nhiệm truyền tải dữ liệu một cách logic trong mạng. Các phân đoạn dữ liệu (segment) sẽ được đóng gói (Packets) với kích thước mỗi gói phù hợp với mạng chuyển mạch mà nó dùng để truyền dữ liệu. Lúc này, các gói tin được chèn thêm phần Header chứa thông tin của tầng mạng và tiếp tục được chuyển đến tầng tiếp theo. Các giao thức chính trong tầng là IP, ICMP và ARP. |\r\n| 3.Transport | Chức năng chính của tầng 3 là xử lý vấn đề giao tiếp giữa các máy chủ trong cùng một mạng hoặc khác mạng được kết nối với nhau thông qua bộ định tuyến. Tại đây dữ liệu sẽ được phân đoạn, mỗi đoạn sẽ không bằng nhau nhưng kích thước phải nhỏ hơn 64KB. Cấu trúc đầy đủ của một phân đoạn lúc này là Header chứa thông tin điều khiển và sau đó là dữ liệu. |\r\n| 4.Application | Đây là tầng giao tiếp trên cùng của mô hình. Đúng với tên gọi, tầng này đảm nhận vai trò giao tiếp dữ liệu giữa 2 máy khác nhau thông qua các dịch vụ mạng khác nhau (trình duyệt web, chat, gửi email, một số giao thức trao đổi dữ liệu: SMTP, SSH, FTP,...). Dữ liệu khi đến đây sẽ được định dạng theo kiểu Byte nối Byte, cùng với đó là các thông tin định tuyến giúp xác định đường đi đúng của một gói tin. |</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "oops",
          "name": "Lập trình hướng đối tượng",
          "description": "",
          "questions": [
            {
              "question": "Thuật ngữ OOP có nghĩa là gì?",
              "answer": "<p>OOP đề cập đến Lập trình hướng đối tượng. Đó là mô hình lập trình được xác định bằng cách sử dụng các đối tượng. Các đối tượng có thể được coi là các thể hiện trong thế giới thực của các thực thể như lớp, có một số đặc điểm và hành vi</p>",
              "level": "middle"
            },
            {
              "question": "Tại sao cần OOP?",
              "answer": "<p>Có nhiều lý do khiến OOP hầu hết được ưa thích, nhưng quan trọng nhất trong số đó là:\r<ul><li>OOP giúp người dùng hiểu phần mềm một cách dễ dàng, mặc dù họ không biết cách triển khai thực tế.</li></ul>\r<ul><li>Với OOP, khả năng đọc, hiểu và khả năng bảo trì của code tăng lên gấp nhiều lần.</li></ul>\r<ul><li>Ngay cả những phần mềm rất lớn cũng có thể được viết và quản lý dễ dàng bằng OOP.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Một số ngôn ngữ lập trình hướng đối tượng",
              "answer": "<p>Các ngôn ngữ lập trình sử dụng và tuân theo mô hình lập trình hướng đối tượng hoặc OOP, được gọi là ngôn ngữ lập trình hướng đối tượng. Một số ngôn ngữ lập trình hướng đối tượng chính bao gồm:\r<ul><li>Java</li></ul>\r<ul><li>C++</li></ul>\r<ul><li>Javascript</li></ul>\r<ul><li>Python</li></ul>\r<ul><li>PHP</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Một số mô hình lập trình khác ngoài OOP là gì?",
              "answer": "<p>Mô hình lập trình đề cập đến phương pháp phân loại ngôn ngữ lập trình dựa trên các tính năng của chúng. Chủ yếu có hai loại Mô hình lập trình:\r<ul><li>Mô hình lập trình mệnh lệnh</li></ul>\r<ul><li>Mô hình lập trình khai báo</li></ul>\r\n\r\nBây giờ, các mô hình này có thể được phân loại thêm dựa trên:\r\n\r\n1. <strong>Mô hình lập trình mệnh lệnh</strong>: Lập trình mệnh lệnh tập trung vào CÁCH thực thi logic chương trình và định nghĩa luồng điều khiển là các câu lệnh thay đổi trạng thái chương trình. Điều này có thể được phân loại thêm là:\r\n\r\n    a) <em>Mô hình lập trình hướng thủ tục</em>: Lập trình theo thủ tục xác định các bước mà một chương trình phải thực hiện để đạt được trạng thái mong muốn, thường được đọc theo thứ tự từ trên xuống dưới.\r\n    \r\n    b) <em>Lập trình hướng đối tượng hoặc OOP</em>: Lập trình hướng đối tượng (OOP) tổ chức các chương trình dưới dạng các đối tượng, chứa một số thuộc tính và có một số hành vi.\r\n    \r\n    c) <em>Lập trình song song</em>: Mô hình lập trình song song chia một nhiệm vụ thành các nhiệm vụ con và tập trung vào việc thực hiện chúng đồng thời cùng một lúc.\r\n\r\n2. <strong>Mô hình lập trình khai báo</strong>: Lập trình khai báo tập trung vào CÁI GÌ để thực thi và định nghĩa logic chương trình, nhưng không phải là một luồng điều khiển chi tiết. Mô hình khai báo có thể được phân loại thêm thành:\r\n\r\n    a) <em>Mô hình lập trình logic</em>: Mô hình lập trình logic dựa trên logic hình thức, đề cập đến một tập hợp các câu diễn đạt các dữ kiện và quy tắc về cách giải quyết một vấn đề\r\n\r\n    b) <em>Mô hình lập trình chức năng</em>: Mô hình lập trình chức năng là mô hình lập trình trong đó các chương trình được xây dựng bằng cách áp dụng và soạn thảo các hàm.\r\n    \r\n    c) <em>Mô hình lập trình cơ sở dữ liệu</em>: Mô hình lập trình cơ sở dữ liệu được sử dụng để quản lý dữ liệu và thông tin có cấu trúc như trường, bản ghi và file.\r\n\r\n<img src=\"/interview-assets/programming-paradigms.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Lập trình có cấu trúc nghĩa là gì?",
              "answer": "<p>Lập trình có cấu trúc đề cập đến phương pháp lập trình bao gồm một luồng điều khiển hoàn toàn có cấu trúc. Ở đây cấu trúc đề cập đến một khối, chứa một tập hợp các quy tắc và có một luồng điều khiển cuối cùng, chẳng hạn như (if/then/else), (while và for), cấu trúc khối và chương trình con.\r\n\r\nGần như tất cả các mô hình lập trình đều bao gồm Lập trình có cấu trúc, bao gồm cả mô hình OOP.</p>",
              "level": "middle"
            },
            {
              "question": "Các tính năng chính của OOP?",
              "answer": "<p>OOP hoặc Lập trình hướng đối tượng chủ yếu bao gồm bốn tính năng dưới đây và đảm bảo rằng bạn không bỏ lỡ bất kỳ tính năng nào sau đây:\r<ul><li>Tính kế thừa</li></ul>\r<ul><li>Tính đóng gói</li></ul>\r<ul><li>Tính đa hình</li></ul>\r<ul><li>Tính trừu tượng</li></ul>\r\n\r\n<img src=\"/interview-assets/oops-features.png\" alt=\"\" /></p>",
              "level": "middle"
            },
            {
              "question": "Lợi ích của sử dụng OOP?",
              "answer": "<p><ul><li>OOP rất hữu ích trong việc giải quyết các vấn đề ở mức độ rất phức tạp.</li></ul>\r<ul><li>Các chương trình có độ phức tạp cao có thể được tạo, xử lý và bảo trì dễ dàng bằng cách sử dụng lập trình hướng đối tượng.</li></ul>\r<ul><li>OOP, thúc đẩy việc tái sử dụng code, do đó giảm bớt sự dư thừa.</li></ul>\r<ul><li>OOP cũng giúp ẩn những chi tiết không cần thiết với sự trợ giúp của tính trừu tượng .</li></ul>\r<ul><li>OOP, dựa trên cách tiếp cận từ dưới lên, không giống như mô hình lập trình cấu trúc, sử dụng cách tiếp cận từ trên xuống.</li></ul>\r<ul><li>Tính đa hình cung cấp rất nhiều tính linh hoạt trong các OOP.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Tại sao OOP lại phổ biến như vậy?",
              "answer": "<p>Mô hình lập trình OOP được coi là một phong cách lập trình tốt hơn. Nó không chỉ giúp dễ dàng viết một đoạn code phức tạp mà còn cho phép người dùng xử lý và duy trì chúng một cách dễ dàng. Không chỉ vậy, các tính năng chính của OOP - Trừu tượng hóa, Đóng gói, Kế thừa và Đa hình, giúp lập trình viên dễ dàng giải quyết các tình huống phức tạp. Do đó, OOP rất phổ biến.</p>",
              "level": "middle"
            },
            {
              "question": "Lớp là gì?",
              "answer": "<p>Một lớp có thể được hiểu là một khuôn mẫu hoặc một bản thiết kế, chứa một số giá trị, được gọi là thuộc tính và một số bộ quy tắc, được gọi là hành vi hoặc chức năng. Vì vậy, khi một đối tượng được tạo, nó sẽ tự động lấy thuộc tính và phương thức đã được định nghĩa trong lớp.\r\n\r\nDo đó, về cơ bản lớp là một khuôn mẫu hoặc bản thiết kế cho các đối tượng. Ngoài ra, người ta có thể tạo bao nhiêu đối tượng tùy thích dựa trên một lớp.\r\n\r\nVí dụ: đầu tiên, mẫu của một chiếc ô tô được tạo. Sau đó, nhiều chiếc xe được tạo ra dựa trên mẫu đó.</p>",
              "level": "middle"
            },
            {
              "question": "Đối tượng là gì?",
              "answer": "<p>Một đối tượng đề cập đến thực thể của lớp, bao gồm toàn bộ các thuộc tính và phương thức được xác định trong lớp mẫu. Trong thực tế, một đối tượng là một thực thể thực tương tác với người dùng trong khi lớp là bản thiết kế cho đối tượng đó. Vì vậy, các đối tượng tiêu thụ không gian và có một số hành vi đặc trưng.</p>",
              "level": "middle"
            },
            {
              "question": "Tính đóng gói là gì?",
              "answer": "<p><img src=\"/interview-assets/encapsulation.png\" alt=\"\" />\r\n\r\nNgười ta có thể hình dung đóng gói là phương pháp đưa mọi thứ cần thiết để thực hiện công việc vào bên trong một viên thuốc và trình bày viên thuốc đó cho người dùng. Điều đó có nghĩa là bằng đóng gói, tất cả các dữ liệu và phương thức cần thiết được liên kết với nhau và tất cả các chi tiết không cần thiết được ẩn đối với người dùng bình thường. Vì vậy, đóng gói là quá trình liên kết các thuộc tính và các phương thức của một chương trình với nhau để thực hiện một công việc cụ thể, mà không để lộ các chi tiết không cần thiết.\r\n\r\nĐóng gói có thể được xác định theo hai cách:\r\n\r\n1. <strong>Data hiding</strong>: đóng gói là quá trình ẩn thông tin không mong muốn, hạn chế các truy cập đến thuộc tính của đối tượng.\r\n2. <strong>Data binding</strong>: là quá trình liên kết các thuộc tính và các phương thức với nhau như một tổng thể.</p>",
              "level": "middle"
            },
            {
              "question": "Tính đa hình là gì?",
              "answer": "<p>Đa hình đề cập đến một thứ có thể có nhiều hình dạng.\r\n\r\n<img src=\"/interview-assets/polymorphism.png\" alt=\"\" />\r\n\r\nTrong OOP, Đa hình đề cập đến quá trình mà một số code, dữ liệu, phương thức hoặc đối tượng hoạt động khác nhau trong các trường hợp hoặc ngữ cảnh khác nhau. Đa hình thời gian biên dịch và đa hình thời gian chạy là hai loại đa hình trong các ngôn ngữ OOP.</p>",
              "level": "middle"
            },
            {
              "question": "Sự khác nhau giữa đa hình thời gian biên dịch và đa hình thời gian chạy?",
              "answer": "<p><img src=\"/interview-assets/types_of_polymorphism.png\" alt=\"\" />\r\n\r\n<strong>Compile Time Polymorphism</strong>: còn gọi là đa hình tĩnh, đề cập đến kiểu đa hình xảy khi khi biên dịch. Có nghĩa là trình biên dịch quyết định hình dạng hoặc giá trị nào được thực thể sử dụng.\r\n\r\n``<code>java\r\n// In this program, we will see how multiple functions are created with the same name, \r\n// but the compiler decides which function to call easily at the compile time itself.\r\nclass CompileTimePolymorphism{\r\n    // 1st method with name add\r\n    public int add(int x, int y){ \r\n        return x+y;\r\n    }\r\n    // 2nd method with name add\r\n    public int add(int x, int y, int z){\r\n        return x+y+z;\r\n    }\r\n    // 3rd method with name add\r\n    public int add(double x, int y){ \r\n        return (int)x+y;\r\n    }\r\n    // 4th method with name add\r\n    public int add(int x, double y){ \r\n        return x+(int)y;\r\n    }\r\n}\r\nclass Test{\r\n    public static void main(String[] args){\r\n        CompileTimePolymorphism demo=new CompileTimePolymorphism();\r\n        // In the below statement, the Compiler looks at the argument types and decides to call method 1\r\n        System.out.println(demo.add(2,3));\r\n        // Similarly, in the below statement, the compiler calls method 2\r\n        System.out.println(demo.add(2,3,4));\r\n        // Similarly, in the below statement, the compiler calls method 4\r\n        System.out.println(demo.add(2,3.4));\r\n        // Similarly, in the below statement, the compiler calls method 3\r\n        System.out.println(demo.add(2.5,3)); \r\n    }\r\n}\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, có bốn phiên bản của các phương thức </code>add()<code>. Phương thức đầu tiên nhận hai tham số trong khi phương thức thứ hai nhận ba tham số. Đối với phương pháp thứ ba và thứ tư, có sự thay đổi thứ tự của các tham số. Trình biên dịch xem xét dấu hiệu của phương thức và quyết định phương thức nào sẽ gọi cho một lệnh gọi cụ thể tại thời điểm biên dịch.\r\n\r\n<strong>Runtime Polymorphism</strong>: còn gọi là đa hình động, đề cập đến kiểu đa hình xảy khi khi đang chạy. Điều đó có nghĩa là nó không thể được quyết định bởi trình biên dịch. Do đó, hình dạng hoặc giá trị nào phải được thực hiện tùy thuộc vào quá trình thực thi.\r\n\r\n</code>`<code>java\r\nclass AnyVehicle{\r\n    public void move(){\r\n        System.out.println(“Any vehicle should move!!”);\r\n    }\r\n}\r\nclass Bike extends AnyVehicle{\r\n    public void move(){\r\n        System.out.println(“Bike can move too!!”);\r\n    }\r\n}\r\nclass Test{\r\n    public static void main(String[] args){\r\n        AnyVehicle vehicle = new Bike();\r\n        // In the above statement, as you can see, the object vehicle is of type AnyVehicle\r\n        // But the output of the below statement will be “Bike can move too!!”, \r\n        // because the actual implementation of object ‘vehicle’ is decided during runtime vehicle.move();\r\n        vehicle = new AnyVehicle();\r\n        // Now, the output of the below statement will be “Any vehicle should move!!”, \r\n        vehicle.move();\r\n    }\r\n}\r\n</code>``</p>",
              "level": "middle"
            },
            {
              "question": "C++ hỗ trợ đa hình thế nào?",
              "answer": "<p>C++ là ngôn ngữ lập trình hướng đối tượng và hỗ trợ đa hình rất tốt:\r<ul><li>Compile Time Polymorphism: C ++ hỗ trợ tính đa hình thời gian biên dịch với sự trợ giúp của các tính năng như mẫu, nạp chồng hàm và các tham số mặc định.</li></ul>\r<ul><li>Runtime Polymorphism: C ++ hỗ trợ tính đa hình Runtime với sự trợ giúp của các tính năng như hàm ảo. Các hàm ảo có hình dạng của các hàm dựa trên loại đối tượng trong tham chiếu và được giải quyết trong thời gian chạy.</li></ul></p>",
              "level": "middle"
            },
            {
              "question": "Kế thừa là gì?",
              "answer": "<p>Thuật ngữ \"kế thừa\" có nghĩa là \"nhận được một số phẩm chất hoặc hành vi từ cha mẹ cho con cái.\" Trong lập trình hướng đối tượng, kế thừa là cơ chế mà một đối tượng hoặc lớp (được gọi là con) được tạo ra bằng cách sử dụng định nghĩa của một đối tượng hoặc lớp khác (được gọi là cha). Kế thừa không chỉ giúp giữ cho việc triển khai đơn giản hơn mà còn giúp tạo điều kiện sử dụng lại code.</p>",
              "level": "middle"
            }
          ]
        },
        {
          "id": "os",
          "name": "Câu hỏi phỏng vấn hệ điều hành",
          "description": "",
          "questions": [
            {
              "question": "Tại sao hệ điều hành quan trọng?",
              "answer": "<p>Hệ điều hành là phần thiết yếu và quan trọng nhất của máy tính mà không có nó thì máy tính gần như là vô dụng. Nó kích hoạt một giao diện hoặc hoạt động giống như một liên kết để tương tác giữa phần mềm máy tính được cài đặt trên hệ điều hành và người dùng. Đồng thời giúp giao tiếp với phần cứng và duy trì sự cân bằng giữa phần cứng và CPU. Nó cũng cung cấp các dịch vụ cho người dùng và một nền tảng cho các chương trình chạy trên đó. Nó thực hiện tất cả các tác vụ chung mà ứng dụng yêu cầu.</p>",
              "level": "fresher"
            },
            {
              "question": "Mục đích chính của hệ điều hành là gì? Các loại hệ điều hành khác nhau là gì?",
              "answer": "<p>Mục đích chính của HĐH là thực thi các chương trình của người dùng và giúp người dùng hiểu và tương tác với máy tính cũng như chạy các ứng dụng dễ dàng hơn. Nó được thiết kế đặc biệt để đảm bảo rằng hệ thống máy tính hoạt động tốt hơn bằng cách quản lý tất cả các hoạt động tính toán. Nó cũng quản lý bộ nhớ máy tính, các tiến trình và hoạt động của tất cả phần cứng và phần mềm.\r\n\r\nCác loại hệ điều hành:\r<ul><li>Batched OS (Payroll System, Transactions Process, ...)</li></ul>\r<ul><li>Multi-Programmed OS (Windows OS, UNIX OS, ...)</li></ul>\r<ul><li>Timesharing OS (Multics, ...)</li></ul>\r<ul><li>Distributed OS (LOCUS, ...)</li></ul>\r<ul><li>Real-Time OS (PSOS, VRTX, ...)</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Lợi ích của hệ thống đa xử lý?",
              "answer": "<p>Hệ thống đa xử lý là một loại hệ thống bao gồm hai hoặc nhiều CPU. Nó liên quan đến việc xử lý các chương trình máy tính khác nhau cùng một lúc, bởi hệ thống máy tính này có hai hoặc nhiều CPU đang chia sẻ một bộ nhớ duy nhất.\r\n\r\nLợi ích:\r<ul><li>Các hệ thống như vậy ngày nay được sử dụng rộng rãi để cải thiện hiệu suất trong các hệ thống đang chạy nhiều chương trình đồng thời.</li></ul>\r<ul><li>Bằng cách tăng số lượng bộ xử lý, số lượng tác vụ lớn hơn có thể được hoàn thành trong thời gian ngắn.</li></ul>\r<ul><li>Nó còn gia tăng đáng kể về thông lượng cũng như hiệu quả về chi phí vì tất cả các bộ xử lý đều chia sẻ cùng một nguồn tài nguyên.</li></ul>\r<ul><li>Cuối cùng là cải thiện độ tin cậy của hệ thống máy tính.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cấu trúc RAID trong hệ điều hành là gì?",
              "answer": "<p>RAID (Redundant Arrays of Independent Disks) là một phương pháp được dùng để lưu trữ dữ liệu trên nhiều đĩa cứng do đó có thể xem nó là một công nghệ lưu trữ dữ liệu ảo hoá để kết hợp nhiều đĩa cứng. Nhằm mụuc đích là cân bằng, bảo vệ dữ liệu, cải thiện hiệu suất hệ thống, không gian lưu trữ, v.v. \r\n\r\nNó được dùng để cải thiện toàn bộ hiệu suất và độ tin cậy của bộ lưu trữ dữ liệu. Nó còn tăng không gian lưu trữ của hệ thống nhằm mục đích chính là dự phòng dữ liệu để tránh thất thoát.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "GUI là gì?",
              "answer": "<p>GUI (Graphical User Interface) về cơ bản là một loại giao diện người dùng cho phép người dùng sử dụng đồ họa để tương tác với hệ điều hành. GUI được tạo ra vì nó thân thiện với người dùng hơn, ít phức tạp hơn và dễ hiểu hơn là một giao diện dòng lệnh. Mục tiêu chính của nó là tăng hiệu quả và dễ sử dụng. Thay vì phải ghi nhớ các lệnh, người dùng có thể chỉ cần click vào một nút để thực hiện công việc một cách đơn giản. Ví dụ về GUI bao gồm Microsoft Windows, macOS, v.v.</p>",
              "level": "fresher"
            },
            {
              "question": "Pipe là gì và khi nào sử dụng?",
              "answer": "<p>Pipe - đường ống - nói chung là một kết nối giữa hai hoặc nhiều tiến trình có liên quan đến nhau. Nó là một cơ chế được sử dụng để giao tiếp giữa các tiến trình bằng cách truyền tin nhắn. Người ta có thể dễ dàng gửi thông tin chẳng hạn như đầu ra của một tiến trình chương trình đến một tiến trình chương trình khác bằng cách sử dụng một đường ống. Nó có thể được sử dụng khi hai tiến trình muốn giao tiếp một chiều, tức là giao tiếp giữa các tiến trình (IPC).</p>",
              "level": "fresher"
            },
            {
              "question": "Các loại hoạt động khác nhau có thể có trên semaphore là gì?",
              "answer": "<p>Có hai hoạt động có thể là :\r<ul><li>Wait()</li></ul>\r<ul><li>Signal()</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Chương trình bootstrap trong hệ điều hành là gì?",
              "answer": "<p>Nó là một chương trình khởi tạo hệ điều hành trong quá trình khởi động, tức là dòng code đầu tiên được thực thi bất cứ khi nào hệ thống máy tính khởi động. Hệ điều hành được tải thông qua một tiến trình khởi động hoặc chương trình thường được gọi là booting. Nhìn chung hệ điều hành chỉ phụ thuộc vào chương trình bootstrap để thực hiện và hoạt động chính xác. Nó được lưu trữ đầy đủ trong các khối khởi động tại một vị trí cố định trên đĩa. Nó cũng định vị nhân (kernel) và tải nó vào bộ nhớ chính, sau đó chương trình bắt đầu thực thi.\r\n\r\n<img src=\"/interview-assets/boostrap_program_in_os.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Demand Paging là gì?",
              "answer": "<p>Demand paging (tạm dịch: phân trang theo yêu cầu) là một phương pháp tải các trang vào bộ nhớ theo yêu cầu. Phương pháp này chủ yếu được sử dụng trong bộ nhớ ảo. Trong đó, một trang chỉ được đưa vào bộ nhớ khi một vị trí trên trang cụ thể đó được tham chiếu trong quá trình thực thi. Các bước sau thường được tuân theo: \r<ul><li>Truy cập trang.</li></ul>\r<ul><li>Nếu trang đó hợp lệ (có trong bộ nhớ) các tiến trình của lệnh sẽ diễn ra bình thường</li></ul>\r<ul><li>Nếy là không hợp lệ, thì xảy ra <strong>page-fault trap</strong>.</li></ul>\r<ul><li>Kiểm tra nếu tham chiếu bộ là hợp lệ tham chiếu đến một vùng ở bộ nhớ phụ. Nếu không, tiến trình sẽ bị chấm dứt (<strong>truy cập bộ nhớ bất hợp pháp</strong>). Ngược lại, ta có trang trong trang được yêu cầu.</li></ul>\r<ul><li>Lên lịch hoạt động của đĩa để đọc trang mong muốn vào bộ nhớ chính.</li></ul>\r<ul><li>Khởi động lại lệnh đã bị gián đoạn bởi trap của hệ điều hành.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "RTOS là gì?",
              "answer": "<p>Real Time Operating System (RTOS) là một hệ điều hành được sử dụng cho các ứng thời gian thực. Nó hoạt động tốt hơn nhiều đối với các tác vụ cần được thực thi trong thời gian ngắn. Nó cũng xử lý các quá trình thực thi, giám sát và kiểm soát tất cả. Nó cũng chiếm ít bộ nhớ hơn và tiêu thụ ít tài nguyên hơn. \r\n\r\nCác loại RTOS:\r<ul><li>Hard Real-Time</li></ul>\r<ul><li>Firm Real-Time</li></ul>\r<ul><li>Soft Real-Time</li></ul>\r\n\r\n<img src=\"/interview-assets/RTOS.png\" alt=\"\" />\r\n\r\nRTOS được sử dụng trong Hệ thống kiểm soát không lưu, Hệ thống chống bó phanh và Máy tạo nhịp tim.</p>",
              "level": "fresher"
            },
            {
              "question": "Đồng bộ hoá tiến trình là gì?",
              "answer": "<p>Đồng bộ hóa tiến trình về cơ bản là một cách để điều phối các tiến trình sử dụng tài nguyên hoặc dữ liệu được chia sẻ. Điều cần thiết là đảm bảo thực hiện đồng bộ các tiến trình hợp tác để duy trì tính nhất quán của dữ liệu. Mục đích chính của nó là chia sẻ tài nguyên mà không có bất kỳ sự can thiệp nào bằng cách sử dụng loại trừ lẫn nhau. Có hai loại đồng bộ hóa tiến trình:\r<ul><li>Tiến trình độc lập</li></ul>\r<ul><li>Tiến trình hợp tác</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "IPC là gì? Các cơ chế IPC khác nhau?",
              "answer": "<p>IPC (Interprocess Communication) là một cơ chế yêu cầu sử dụng các tài nguyên như bộ nhớ được chia sẻ giữa các tiến trình hoặc luồng. Với IPC, hệ điều hành cho phép các tiến trình khác nhau giao tiếp với nhau. Nó được sử dụng để trao đổi dữ liệu giữa nhiều luồng trong một hoặc nhiều chương trình hoặc tiến trình. Trong cơ chế này, các tiến trình khác nhau có thể giao tiếp với nhau dưới sự chấp thuận của HĐH.\r\n\r\nCác cơ chế IPC khác nhau:\r<ul><li>Pipes</li></ul>\r<ul><li>Message Queuing</li></ul>\r<ul><li>Semaphores</li></ul>\r<ul><li>Socket</li></ul>\r<ul><li>Shared Memory</li></ul>\r<ul><li>Signals</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa bộ nhớ chính và bộ nhớ phụ?",
              "answer": "<p><strong>Bộ nhớ chính:</strong> bộ nhớ chính trong máy tính là RAM (Random Access Memory). Nó còn được gọi là bộ nhớ chính hoặc bộ nhớ đọc-ghi hoặc bộ nhớ trong. Các chương trình và dữ liệu mà CPU yêu cầu trong quá trình thực thi được lưu trữ trong bộ nhớ này.\r\n<strong>Bộ nhớ phụ:</strong> bộ nhớ phụ trong máy tính là thiết bị lưu trữ có thể lưu trữ dữ liệu và chương trình. Nó còn được gọi là bộ nhớ ngoài hoặc bộ nhớ bổ sung hoặc bộ nhớ dự phòng hoặc bộ nhớ phụ. Các thiết bị lưu trữ như vậy có khả năng lưu trữ dữ liệu kích cỡ lớn. Thiết bị lưu trữ có thể là ổ cứng, ổ USB flash, CD, v.v.\r\n\r\n| Bộ nhớ chính | Bộ nhớ phụ |\r\n|--------------|------------|\r\n|Dữ liệu được truy cập trực tiếp bởi đơn vị xử lý | Đầu tiên, dữ liệu được chuyển đến bộ nhớ chính và sau đó được chuyển đến đơn vị xử lý |\r\n| Có thể ổn định hoặc không ổn định | Luôn là ổn định |\r\n| Tốn nhiều chi phí hơn bộ nhớ phụ | Tốn ít chi phí hơn |\r\n| Dữ liệu chỉ được lưu trữ tạm thời | Dữ liệu được lưu trữ dài lâu |\r\n| Có thể mất dữ liệu khi sập nguồn | Dữ liệu không thể mất nếu sập nguồn |\r\n| Nhanh hơn bộ nhớ phụ và lưu dữ liệu đang được máy tính sử dụng | Chậm hơn nếu so với bộ nhớ chính và lưu nhiều kiểu định dạng dữ liệu |\r\n| Truy cập bằng dữ liệu | Truy cập bằng kênh I/O |</p>",
              "level": "fresher"
            },
            {
              "question": "Overlay trong hệ điều hành là gì?",
              "answer": "<p>Overlay về cơ bản là một phương pháp lập trình chia các tiến trình thành các phần để các lệnh quan trọng và cần thiết có thể được lưu vào bộ nhớ. Nó không cần bất kỳ loại hỗ trợ nào từ hệ điều hành. Nó có thể chạy các chương trình có kích thước lớn hơn bộ nhớ vật lý bằng cách chỉ giữ lại các dữ liệu và câu lệnh quan trọng có thể cần thiết tại bất kỳ thời điểm nào.</p>",
              "level": "fresher"
            },
            {
              "question": "Các hệ điều hành nổi tiếng?",
              "answer": "<p><em> MS-Windows\r\n</em> Ubuntu\r\n<em> Mac OS\r\n</em> Fedora\r\n<em> Solaris\r\n</em> Free BSD\r\n<em> Chrome OS\r\n</em> CentOS\r\n<em> Debian\r\n</em> Android\r\n\r\n## Câu hỏi phỏng vấn hệ điều hành cho Experienced</p>",
              "level": "fresher"
            }
          ]
        }
      ]
    },
    {
      "id": "mobile",
      "name": "Mobile Development",
      "icon": "phone_iphone",
      "color": "#00bcd4",
      "subcategories": [
        {
          "id": "android",
          "name": "Câu hỏi phỏng vấn Android",
          "description": "",
          "questions": [
            {
              "question": "Android là gì?",
              "answer": "<p>Android là một hệ điều hành nguồn mở được sử dụng trên các thiết bị di động, như điện thoại di động và máy tính bảng. Ứng dụng Android thực thi trong tiến trình  của nó và của Dalvik Virtual Machine (DVM) hoặc Android RunTime (ART).</p>",
              "level": "fresher"
            },
            {
              "question": "Kiến trúc của Android?",
              "answer": "<p>Kiến trúc của Android gồm các tầng khác nhau trong Android Stack. Nó bao gồm hệ điều hành, middleware và ứng dụng. Mỗi tầng trong kiến trúc Android cung cấp các dịch vụ khác nhau cho tầng ngay trên nó. \r\n\r\n5 tầng trong Android:\r\n\r\n<em> <strong>Linux Kernel</strong> - Nó chịu trách nhiệm về trình điều khiển thiết bị, quản lý thiết bị, quản lý bộ nhớ, quản lý nguồn và truy cập tài nguyên.\r\n</em> <strong>Libraries</strong> - là tập hợp các bộ thư viện mã nguồn mở như WebKit, thư viện libc, thư viện cho mở phát nhạc hay video, cơ sở dữ liệu SQLite cho chia sẻ dữ liệu và bộ nhớ ứng dụng, thư viện SSL cho bảo mật internet.\r\n<em> <strong>Android Runtime</strong> - đây là thư viện lõi cùng với DVM (Dalvik Virtual Machine) hoặc ART(Android RunTime) giúp chạy ứng dụng Android. DVM được tối ưu hoá cho các thiết bị di đông, nó cung cấp hiệu suất nhanh và tiêu tốn ít bộ nhớ hơn. Thay thế DVM, ARM được giới thiệu để thực thi các ứng dụng Android từ phiên bản Android lollipop 5.0 (API 21). \r\n</em> <strong>Android Framework</strong> - nó bao gồm Android APIs như  UI (User Interface), nguồn tài nguyên, tài nguyên, nhà cung cấp nội dung (dữ liệu), vị trí, điện thoại và trình quản lý package. Nó cung cấp các giao diện và lớp để phát triển các ứng dụng Android. \r<ul><li><strong>Android Applications</strong> - Các ứng dụng như trang chủ, trò chơi, danh bạ, cài đặt, trình duyệt, v.v. sử dụng Android Framework, để sử dụng Android runtime và libraries.</li></ul>\r\n\r\n<img src=\"/interview-assets/Android_Architecture.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Các ngôn ngữ sử dụng cho Android?",
              "answer": "<p>Các ngôn ngữ lập trình phổ biến dùng cho phát triển ứng dụng Android là:\r\n1. <strong>Java</strong>: Được phát hành năm 1995 bởi Sun Microsystems, Java là ngôn ngữ then chốt của Android. Bộ công cụ phát triển phần mềm Android SDK (Software Development Kit) sử dụng Java như ngôn ngữ nền tảng cho các ứng dụng Android. Khá là dễ dàng để sử dụng Java, đặc biệt là trong Android Studio IDE dùng phát triển các ứng dụng dành cho Android.\r\n2. <strong>Koltin</strong>: Kotlin được phát triển để giải quyết một vài vấn đề tồn tại trong Java. Theo đa số những người ủng hộ việc sử dụng Kotlin, thì syntax của nó đơn giản và gọn hơn, vì thế rất ít xảy ra việc dòng code rườm rà, dài dòng. Điều này có tác dụng giúp cho người viết tập trung trong việc giải quyết các vấn đề hơn là cố để xoay sở với những câu lệnh dài dòng phức tạp. Bên cạnh đó, bạn còn có thể kết hợp Kotlin và Java cùng nhau ở trong cùng một dự án, khai thác hết thế mạnh của cả 2 ngôn ngữ.\r\n3. <strong>C#:</strong> C# là ngôn ngữ lập trình rất nổi tiếng của Microsoft. Với sự hỗ trợ của framework Xamarin, bạn có thể xây dựng ứng dụng Android bằng C#. Xamarin là một framework đa nền tảng, cho phép bạn phát phiển ứng dụng iOS, Android, Windows.\r\n4. <strong>C++:</strong> C++ là ngôn ngữ lập trình mạnh trong việc xây dựng các ứng dụng di động dành riêng cho android và cho windows. đây là ngôn ngữ dành cho lập trình cấp thấp và cũng là ngôn ngữ được các nhà phát triển ứng dụng trên thiết bị di động.\r\n5. <strong>Python</strong>: Python dù không được hệ điều hành Android hỗ trợ những vẫn được sử dụng trong việc tạo ra các apps trên python rồi chuyển thành apk để chạy trên thiết bị android.\r\n\r\nBên cạnh đó bạn cũng có thể dùng các framework như Flutter (ngôn ngữ Dart) hay React Native (ngôn ngữ JavaScript) để lập trình với Android.</p>",
              "level": "fresher"
            },
            {
              "question": "Một activity là gì?",
              "answer": "<p>Activity trong Android là một màn hình đơn để biểu diễn GUI (Graphical User Interface) cho người dùng có thể tương tác và thực hiện một số hành động.\r\n\r\nVí dụ: trang bắt đầu của Facebook là nơi để nhập email/số điện thoại và mật khẩu để đăng nhập, nó là một activity.</p>",
              "level": "fresher"
            },
            {
              "question": "Service trong Android là gì?",
              "answer": "<p>Service là một thành phần ứng dụng chạy ở chế độ nền có thể thực hiện các hoạt động lâu dài, nó không cung cấp một giao diện người dùng. Một service có thể chạy liên tục trong nền ngay cả khi ứng dụng bị đóng hay người dùng chuyển sang ứng dụng khác.</p>",
              "level": "fresher"
            },
            {
              "question": "Phân biệt Activity và Service?",
              "answer": "<p>Activity có thể bị dừng hoặc kết thúc bất cứ khi nào bởi người dùng. Ngược lại, service được thiết kế để chạy ngầm, nên chúng có thể hoạt động độc lập.\r\n\r\nPhần lớn các service chạy liên tục không quan tâm có hay không có activity nào đang thực hiện không.\r\n\r\n| Activity | Service |\r\n|-|-|\r\n| Được thiết kế để chạy ở trền nền | Được thiết kế để chạy nền, nhưng cũng có thể chạy ở trên nền | \r\n| Cần sử dụng giao diện người dùng | Không nhất thiết phải dùng giao diện người dùng |\r\n| Phụ thuộc | Độc lập |</p>",
              "level": "fresher"
            },
            {
              "question": "Google Android SDK là gì?",
              "answer": "<p>Google Android SDK là một bộ công cụ được các nhà phát triển sử dụng để viết ứng dụng trên các thiết bị hỗ trợ Android. Các công cụ trong Android SDK bao gồm:\r<ul><li>Android Emulator - Trình giả lập Android là ứng dụng phần mềm mô phỏng thiết bị Android trên máy tính để bạn có thể kiểm tra ứng dụng trên nhiều loại thiết bị và các cấp Android API mà không cần từng thiết bị vật lý.</li></ul>\r<ul><li>DDMS (Dalvik Debug Monitoring Services) - Đây là một công cụ debug từ bộ phát triển phần mềm Android (SDK), cung cấp các dịch vụ như tạo thông báo, giả mạo cuộc gọi, chụp ảnh màn hình, v.v.</li></ul>\r<ul><li>ADB (Android Debug Bridge) - Đây là một công cụ dòng lệnh được sử dụng để cho phép và kiểm soát giao tiếp với phiên bản giả lập.</li></ul>\r<ul><li>AAPT (Android Asset Packaging Tool) - Đây là một công cụ xây dựng cung cấp cho các nhà phát triển khả năng xem, tạo và cập nhật các kho lưu trữ tương thích với ZIP (zip, jar và apk).</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Cách dùng bundle trong Android?",
              "answer": "<p>Các bundle được sử dụng để chuyển dữ liệu cần thiết giữa các activity khác nhau của Android. Chúng giống như HashMap có thể nhận các kiểu dữ liệu thông thường. Đoạn code dưới đây hiển thị cách chuyển một phần dữ liệu bằng cách sử dụng bundle:\r\n\r\n``<code>java\r\nBundle b=new Bundle();\r\nb.putString(\"Email\",\"abc@xyz.com\");\r\ni.putExtras(b); // where i is intent\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Adapter trong Android là gì?",
              "answer": "<p>Một adapter trong Android giống như một cây cầu giữa AdapterView và dữ liệu cơ bản cho view. Adapter giữ dữ liệu và gửi nó cho AdapterView, view có thể lấy dữ liệu từ AdapterView và hiển thị dữ liệu cho các view khác như SpinnerView, ListView, GridView,...\r\n\r\n<img src=\"/interview-assets/adapter.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "AAPT là gì?",
              "answer": "<p>AAPT là viết tắt của Android Asset Packaging Tool. Đây là một công cụ xây dựng cung cấp cho các nhà phát triển khả năng xem, tạo và cập nhật các kho lưu trữ tương thích với ZIP (zip, jar và apk). Nó phân tích cú pháp, lập chỉ mục và biên dịch các tài nguyên thành định dạng nhị phân được tối ưu hóa cho nền tảng Android.</p>",
              "level": "fresher"
            },
            {
              "question": "Điểm phát sóng Wi-Fi di động là gì?",
              "answer": "<p>Điểm truy cập Wi-Fi di động cho phép bạn chia sẻ kết nối Internet di động của mình với các thiết bị không dây khác. Ví dụ: sử dụng điện thoại Android làm điểm phát sóng Wi-Fi, bạn có thể sử dụng máy tính xách tay của mình để kết nối internet bằng điểm truy cập đó.</p>",
              "level": "fresher"
            },
            {
              "question": "ADB là gì?",
              "answer": "<p>ADB (Android Debug Bridge) là một công cụ dòng lệnh được sử dụng để cho phép và kiểm soát giao tiếp với một phiên bản giả lập. Nó cung cấp tính năng cho các nhà phát triển thực thi các lệnh shell từ xa để chạy các ứng dụng trên trình giả lập.</p>",
              "level": "fresher"
            },
            {
              "question": "DDMS là gì?",
              "answer": "<p>DDMS (Dalvik Debug Monitor Server) là công cụ gỡ lỗi trên nền tảng Android. Nó cung cấp các tính năng như:\r<ul><li>Chụp ảnh màn hình</li></ul>\r<ul><li>Theo dõi lưu lượng mạng</li></ul>\r<ul><li>Cuộc gọi giả mạo SMS</li></ul>\r<ul><li>Giả mạo dữ liệu vị trí</li></ul>\r<ul><li>Logcat</li></ul>\r<ul><li>Thông tin thread và heap</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "AIDL là gì?",
              "answer": "<p>AIDL - Android Interface Definition Language là một cách cho phép bạn có thể định nghĩa một cách mà cả client và server (1 ứng dụng đóng vai trò là server cho các ứng dụng khác đóng vai trò là client có thể truy cập tới) có thể giao tiếng với nhau thông qua Interprocess communication (IPC). Thông thường, trong Android một process (tiến trình) không thể trực tiếp truy cập vào bộ nhớ của một tiến trình khác. Vì vậy để có thể các tiến trình có thể giao tiếp với nhau, chúng cần phân tách các đối tượng thành dạng nguyên thủy (primitive) mà hệ thống có thể hiểu được.\r\n\r\nCác kiểu dữ liệu được hỗ trợ trong AIDL là:\r<ul><li>String</li></ul>\r<ul><li>List</li></ul>\r<ul><li>Map</li></ul>\r<ul><li>CharSequence</li></ul>\r<ul><li>Kiểu dữ liệu Java (int, long, char, and boolean)</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Vòng đời của Android Activity?",
              "answer": "<p><ul><li><code>onCreate()</code>: được gọi khi activity được tạo. Nó được dùng để tạo view và dữ liệu từ bundles.</li></ul>\r<ul><li><code>onStart()</code>: được gọi khi activity được hiển thị với người dùng. Nó có thể thành công bằng <code>onResume()</code> nếu activity xuất hiện trên nền hoặc <code>onStop()</code> bị ẩn.</li></ul>\r<ul><li><code>onResume()</code>: nó được gọi khi activity được chạy để tương tác với người dùng.</li></ul>\r<ul><li><code>onPause()</code>: nó được gọi khi activity được chạy trong nền nhưng chưa dừng hoàn toàn.</li></ul>\r<ul><li><code>onStop()</code>: được gọi khi activity không còn hiển thị với người dùng.</li></ul>\r<ul><li><code>onDestroy()</code>: được gọi khi một activity bị huỷ hay kết thúc.</li></ul>\r<ul><li><code>onRestart()</code>: được gọi khi một activity đã dừng, nhằm mục đích khởi động lại nó.</li></ul>\r\n\r\n<img src=\"/interview-assets/Life_Cycle_of_Android.png\" alt=\"\" /></p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "ios",
          "name": "Câu hỏi phỏng vấn iOS",
          "description": "",
          "questions": [
            {
              "question": "Giải thích kiến trúc iOS?",
              "answer": "<p>iOS hoạt động theo cấu trúc lớp. Kiến trúc iOS bao gồm bốn lớp, mỗi lớp cung cấp một framework lập trình để tạo các ứng dụng hoạt động trên phần cứng. Giao tiếp sẽ được tăng cường bởi các lớp giữa lớp ứng dụng và lớp phần cứng. Lớp cấp thấp hơn cung cấp các dịch vụ mà tất cả các ứng dụng yêu cầu, trong khi lớp cấp cao cung cấp các dịch vụ liên quan đến đồ họa và giao diện.\r\n\r\n<img src=\"/interview-assets/Architecture_of_iOS.png\" alt=\"\" />\r<ul><li><strong>Lớp core OS:</strong> nằm ngay trên đầu phần cứng thiết bị và là lớp dưới cùng của kiến trúc hệ điều hành iPhone. Ngoài các dịch vụ hệ điều hành cơ bản, chẳng hạn như quản lý bộ nhớ, xử lý hệ thống file và luồng, lớp này còn cung cấp mạng cấp thấp, quyền truy cập vào các phụ kiện bên ngoài,...</li></ul>\r<ul><li><strong>Lớp dịch vụ:</strong> Mục đích của nó là thiết kế các dịch vụ mà lớp trên hoặc người dùng yêu cầu. Các tính năng thiết yếu của nó là các đối tượng khối, Grand Central Dispatch, mua hàng trong ứng dụng và lưu trữ iCloud. Lớp dịch vụ đã được củng cố bằng cách bổ sung tính năng ARC Automatic Reference Counting.</li></ul>\r<ul><li><strong>Lớp Media:</strong> xử lý media như video, âm thanh, hình ảnh,... Lớp media cho phép ta sử dụng tất cả công nghệ đồ hoạ, âm thanh, hình ảnh của hệ thống.</li></ul>\r<ul><li><strong>Lớp Cocoa Touch:</strong> còn biết đến là lớp ứng dụng. Đây là nơi mà các framework được tạo ra khi các ứng dụng được xây dựng. Ngoài ra, nó có chức năng như giao diện để người dùng iOS làm việc với hệ điều hành. Điều này bao gồm khả năng cảm ứng và chuyển động.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Thuộc tính trong iOS?",
              "answer": "<p>Thuộc tính cơ bản là các giá trị được liên kết với một class, struct hay enum. Nó có thể là một biến con, một phần của đối tượng khác.\r\n\r\nVí dụ:\r\n\r\n``<code>swift\r\nstruct Icecream  \r\n{ \r\n    var flavor: String = \"\"\r\n} \r\nvar choco = Icecream() \r\nchoco.flavor = \"Chocolate Icecream\"\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta tạo một cấu trúc gọi là </code>Icecream<code>. Một trong những thuộc tính của nó được gọi là </code>flavor`, có giá trị ban đầu là một chuỗi trống.\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Bạn có thể giải thích sự khác biệt giữa các thuộc tính atomic và nonatomic không?",
              "answer": "<p><strong>Thuộc tính atomic:</strong> Nó là thuộc tính mặc định và đảm bảo một giá trị hợp lệ sẽ được trả về từ getter hoặc được thiết lập bởi setter. Điều này đảm bảo rằng chỉ một luồng có thể truy cập getter/setter của một thuộc tính nhất định tại một thời điểm và tất cả các luồng khác phải đợi cho đến khi luồng đầu tiên giải phóng getter/setter. Mặc dù luồng an toàn, nhưng nó không nhanh, vì nó đảm bảo rằng quá trình được hoàn thành hoàn toàn.\r\n\r\n<strong>Thuộc tính nonatomic:</strong> Với thuộc tính này, nhiều luồng có thể truy cập vào phương thức getter/setter của một thuộc tính nhất định cùng một lúc, do đó có khả năng tồn tại sự không nhất quán giữa các giá trị. Chúng đi kèm với quyền truy cập nâng cao, nhưng không đảm bảo về giá trị trả về.</p>",
              "level": "fresher"
            },
            {
              "question": "Các trạng thái khác nhau của ứng dụng iOS?",
              "answer": "<p>Trong quá trình thực thi, ứng dụng iOS trải qua một loạt trạng thái. Mỗi trạng thái này được coi là trạng thái vòng đời của ứng dụng. Dưới đây là năm trạng thái có thể xảy ra đối với ứng dụng iOS:\r\n\r\n<img src=\"/interview-assets/ios_application_states.png\" alt=\"\" />\r<ul><li><strong>Not running:</strong> ở trạng thái này, ứng dụng đã không được khởi chạy hoặc đã bị đóng bởi hệ thống.</li></ul>\r<ul><li><strong>Inactive:</strong> một trạng thái không hoạt động ngắn xảy ra khi ứng dụng đang rời khỏi hoặc đang ở trạng thái hoạt động. Mặc dù chạy ở chế độ đã hiển thị, nó vẫn chưa sẵn sàng để chấp nhận đầu vào hoặc sự kiện từ người dùng. Điều này có nghĩa là ứng dụng vẫn không hoạt động tại thời điểm này.</li></ul>\r<ul><li><strong>Active:</strong> trạng thái này cho biết rằng ứng dụng đang được hiển thị và nhận các sự kiện. Đây là chế độ bình thường cho các ứng dụng và Giao diện người dùng có thể truy cập được.</li></ul>\r<ul><li><strong>Background:</strong> trong trạng thái này, giao diện người dùng của ứng dụng bị ẩn, nhưng nó vẫn tiếp tục chạy trong nền của hệ thống iOS. Các ứng dụng thường vượt qua trạng thái này trước khi bị đình chỉ.</li></ul>\r<ul><li><strong>Suspended:</strong> Trong trường hợp này, ứng dụng đang ở chế độ nền nhưng không chạy code. Trong điều kiện bộ nhớ thấp, hệ thống có thể xóa các ứng dụng ở trạng thái bị treo mà không cần cảnh báo.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Trách nhiệm của nhà phát triển iOS?",
              "answer": "<p>Nhà phát triển iOS là một lập trình viên hoặc kỹ sư phần mềm, người thiết kế và phát triển các ứng dụng chạy iOS của Apple trên thiết bị iOS. Tốt nhất, nhà phát triển iOS phải có kỹ năng trong hai ngôn ngữ lập trình, là Objective-C và Swift.\r\n\r\nTrách nhiệm của nhà phát triển iOS:\r<ul><li>Code sạch sẽ, hiệu quả cho các ứng dụng iOS.</li></ul>\r<ul><li>Đảm bảo code an toàn bằng cách thực hiện khắc phục sự cố và sửa lỗi cho các ứng dụng.</li></ul>\r<ul><li>Việc phát triển và triển khai các tính năng ứng dụng nâng cao cũng như duy trì và cải tiến các tính năng hiện có.</li></ul>\r<ul><li>Phát triển các giải pháp sáng tạo để đáp ứng nhu cầu kinh doanh của khách hàng.</li></ul>\r<ul><li>Hỗ trợ tất cả các khía cạnh của phát triển ứng dụng, bao gồm thiết kế, thử nghiệm, phát hành và hỗ trợ.</li></ul>\r<ul><li>Khám phá, đánh giá và triển khai các công nghệ mới liên tục để tối đa hóa hiệu quả phát triển.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Android và iOS?",
              "answer": "<p><strong>Android</strong>: Đây là hệ điều hành di động dành cho các thiết bị Android do Google LLC cung cấp và tập trung vào các thiết bị di động có màn hình cảm ứng như điện thoại thông minh và máy tính bảng. Một số ngôn ngữ lập trình đã được sử dụng trong quá trình phát triển của nó, bao gồm C, Java, C++ và các ngôn ngữ khác.\r\n\r\n<strong>iOS</strong>: Đây là hệ điều hành dành cho các thiết bị của Apple do Apple cung cấp và nó được coi là hệ điều hành di động phổ biến thứ hai trên toàn cầu sau Android. Nó chủ yếu được thiết kế cho các thiết bị di động của Apple như iPhone, iPod Touch, v.v. Một số ngôn ngữ lập trình đã được sử dụng trong quá trình phát triển của nó, bao gồm Objective-C, Swift, C++ và các ngôn ngữ khác.\r\n\r\n| Android | iOS |\r\n|-|-|\r\n| Hệ điều hành di động cho thiết bị Android được cung cấp bởi Google LLC | Hệ điều hành cho thiết bị Apple được cung cấp bởi tập đoàn Apple |\r\n| Dành cho smartphone và máy tính bảng | Dành cho iPhone, iPod và iPad |\r\n| Chủ yếu dùng Java, C, C++ | Chủ yếu dùng Swift, Objective-C, C/C++ |\r\n| Google Chrome là trình duyệt mặc định | Safari là trình duyệt mặc định |\r\n| Hiệu suất giảm theo thời gian | Hiệu suất bảo toàn theo thời gian |\r\n| Mã nguồn mở, có thể chỉnh sửa tuỳ ý thay đổi hệ điều hành. Dẫn đến bảo mật kém | Mã nguồn đóng, các nhà phát triển không thể chỉnh sửa code trên thiết bị, giúp iOS bảo mật và khó hack hơn |</p>",
              "level": "fresher"
            },
            {
              "question": "Deep linking trong iOS là gì?",
              "answer": "<p>Deep linking là các liên kết đưa người dùng trực tiếp đến một ứng dụng thay vì trang web hoặc cửa hàng bằng cách sử dụng URI (Uniform Resource Identifier) hoặc các universal links. URI là một phương pháp phổ biến để có deep linking, nhưng từ iOS 9, Apple đã thêm Universal Link thay cho URI. \r\n\r\nDeep linking không chỉ liên quan đến việc tạo liên kết có thể click để mở ứng dụng của bạn mà còn là liên kết thông minh điều hướng đến tài nguyên mà bạn mong muốn. Người dùng được dẫn thẳng đến các vị trí trong ứng dụng bằng cách sử dụng các liên kết này, điều này giúp họ tiết kiệm thời gian và nỗ lực tự tìm kiếm các trang đó, do đó cải thiện trải nghiệm người dùng của họ rất nhiều.\r\n\r\nVí dụ: Nếu bạn dùng URL: <code>fb://</code>, bạn sẽ mở ứng dụng Facebook. Nhưng nếu dùng <code>fb://profile/33138223345</code> bạn sẽ mở thông tin người dùng trên ứng dụng Facebook.\r\n\r\n<img src=\"/interview-assets/deep_linking_in_iOS.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích GCD trong iOS?",
              "answer": "<p>Grand Central Dispatch (GCD) là một API cấp thấp cho phép người dùng chạy đồng thời nhiều tác vụ được luồng quản lý trong nền. GCD là một giải pháp của Apple để thực hiện tính đồng thời (concurrency) và song song (parallelism) trong ứng dụng iOS, thế nên nhiều tác vụ có thể chạy trong nền mà không ảnh hưởng gì đến luồng chính. Nó được giới thiệu trong iOS4 để tránh tiến trình dài dòng của việc thực hiện nối tiếp các tác vụ.</p>",
              "level": "fresher"
            },
            {
              "question": "ARC là gì?",
              "answer": "<p>Trong ngôn ngữ Swift, ARC (Automatic Reference Counting) được dùng cho quản lý bộ nhớ ứng dụng. Nó khởi tạo và xác định tài nguyên hệ thống, do đó giải phóng bộ nhớ dành cho một thực thể lớp khi nó không còn cần đến nữa. ARC theo dõi có bao nhiêu thuộc tính, hằng số và biến hiện đang tham chiếu đến mỗi thực thể lớp. Khi có ít nhất một tham chiếu hoạt động tới một thực thể, ARC sẽ giải phóng thực thể đó. Việc sử dụng các khái niệm ARC là một phần thiết yếu của quá trình phát triển iOS.\r\n\r\nChức năng ARC:\r<ul><li>ARC tạo một thực thể lớp mới bằng <code>init()</code> và cấp phát một phần của bộ nhớ cho lưu trữ thông tin.</li></ul>\r<ul><li>Bộ nhớ lưu trữ thông tin về kiểu và giá trị của nó.</li></ul>\r<ul><li>Khi thực thể lớp không còn cần nữa, ARC sẽ tự động giải phóng bộ nhớ bằng lệnh gọi <code>deinit()</code>.</li></ul>\r<ul><li>Bằng cách theo dõi tham chiếu đến thuộc tính, hằng, biến của lớp, ARC đảm bảo <code>deinit()</code> chỉ thực hiện trên các thực thể khôgn còn dùng nữa.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa Cocoa và Cocoa Touch?",
              "answer": "<p>Cocoa và Cocoa Touch là hai trong số các framework được sử dụng rộng rãi của Apple được sử dụng để xây dựng các ứng dụng. Tuy nhiên, chúng khác nhau theo những cách sau:\r\n\r\n| Cocoa | Cocoa Touch |\r\n|-|-|\r\n| Framework cho xây dựng ứng dụng chạy trên Mac OS | Framework cho xây dựng ựng dụng chạy trên iPhone hay iPad |\r\n| Framework như Foundation và AppKit được kết hợp vào Cocoa | Cocoa Touch là sự kết hợp của các framework như Foundation và UIKit được tích hợp vào Cocoa Touch |\r\n| Các lớp Cocoa sử dụng tiền tố NS (được sử dụng cho tất cả các lớp và hằng số trong framework Cocoa), như NSTextField, NSWindow | Mặt khác, các lớp Cocoa Touch sử dụng tiền tố UI (được sử dụng cho tất cả các lớp và hằng số trong framework Cacoa Touch) (như UITextField và UIWindow) |</p>",
              "level": "fresher"
            },
            {
              "question": "Các ngôn ngữ lập trình dùng cho phát triển iOS?",
              "answer": "<p><ul><li>HTML5</li></ul>\r<ul><li>.NET</li></ul>\r<ul><li>C</li></ul>\r<ul><li>C++</li></ul>\r<ul><li>Swift</li></ul>\r<ul><li>Javascript</li></ul>\r<ul><li>Objective-C</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Framework được sử dụng để xây dựng giao diện ứng dụng cho iOS là gì?",
              "answer": "<p>Trái ngược với framework Foundation định nghĩa các lớp, giao thức và hàm để phát triển cả iOS và OS X. UIKit được thiết kế đặc biệt để phát triển giao diện iOS. Trong iOS, giao diện người dùng và cơ sở hạ tầng đồ họa của ứng dụng được phát triển bằng UIKit. Nó bao gồm:\r<ul><li>Xử lý sự kiện (xử lý các cử chỉ khác nhau như cử chỉ nhập liệu, cử chỉ nhấn nút, cử chỉ đa chạm, ...)</li></ul>\r<ul><li>Cấu trúc ứng dụng (Quản lý sự tương tác giữa hệ thống và người dùng)</li></ul>\r<ul><li>Giao diện người dùng (Cung cấp các tương tác của người dùng, khả năng chia sẻ văn bản và nội dung, chọn hình ảnh, chỉnh sửa video, in tệp,...)</li></ul>\r<ul><li>Đồ họa, vẽ và in ấn.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các cách để thực hiện đồng thời trong iOS?",
              "answer": "<p>Concurrency có nghĩa là \"chạy nhiều tác vụ đồng thời\". Concurrency cho phép thiết bị iOS xử lý các tác vụ nền (chẳng hạn như tải xuống hoặc xử lý dữ liệu) trong khi vẫn duy trì giao diện người dùng. Trong iOS, bạn có thể quản lý các tác vụ đồng thời bằng cách sử dụng Grand Central Dispatch (GCD) và Operations (chính thức được gọi là NSOperation). Để thực hiện được sự đồng thời, iOS cung cấp ba cách như sau:\r\n<em> <strong>Dispatch queues:</strong> Chúng được sử dụng để quản lý các tác vụ theo thứ tự vào trước ra trước (FIFO) và thực thi các tác vụ một cách tuần tự hoặc đồng thời. Đây là một cách dễ dàng để xử lý các tác vụ bất đồng bộ (không xảy ra cùng lúc) và đồng thời trong ứng dụng của bạn.\r\n</em> <strong>Thread:</strong> Một chuỗi instructions độc lập có thể được thực thi riêng biệt với code khác trong một chương trình. Thông qua các luồng, người ta có thể thực thi nhiều đường dẫn code đồng thời trong một ứng dụng duy nhất. Có một luồng đặc biệt hữu ích khi bạn cần thực hiện một tác vụ dài mà không ảnh hưởng đến việc thực hiện phần còn lại của chương trình.\r<ul><li><strong>Operation Queues</strong>: Các đối tượng operation queue được gọi theo mức độ ưu tiên và mức độ sẵn sàng của chúng. Về cơ bản, Operation queue là sự trừu tượng hóa cấp cao của mô hình hàng đợi, được xây dựng trên GCD (Grand Central Dispatch). Do đó, có thể thực thi các tác vụ đồng thời, giống như GCD, nhưng theo cách hướng đối tượng.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biệt giữa App ID và Bundle ID?",
              "answer": "<p><ul><li><strong>Bundle ID</strong>: Chúng là định danh duy nhất của các ứng dụng trong hệ sinh thái của Apple. Nói cách khác, không có hai ứng dụng nào có thể có cùng định danh. Bundle ID được sử dụng cho cả ứng dụng OS X và iOS, và có thể được sử dụng để nhận dạng các bản cập nhật ứng dụng.</li></ul>\r\n    Ví dụ:\r\n    Nếu tên miền của tổ chức của ta là scaler.com và ta tạo một ứng dụng có tên là Edge, bạn có thể chỉ định chuỗi <code>com.scaler.edge</code> làm Bundle ID của ứng dụng.\r<ul><li><strong>App ID</strong>: Chuỗi này xác định duy nhất một hoặc nhiều ứng dụng từ cùng một nhóm phát triển. Có hai thành phần trong chuỗi, Team ID và Bundle ID, được phân tách bằng dấu chấm (.). Apple cung cấp Team ID để xác định một nhóm phát triển cụ thể, trong khi các nhà phát triển cung cấp Bundle ID để xác định một ứng dụng hoặc một bộ sưu tập ứng dụng.</li></ul>\r\n    Ví dụ:\r\n    <strong>ABCDE12345.com.scaler.edge</strong>\r\n    Trong ví dụ trên, <code>ABCDE12345</code> là Team ID và <code>com.scaler.edge</code> là Bundle ID .</p>",
              "level": "fresher"
            },
            {
              "question": "Framework SpriteKit và SceneKit trong phát triển game?",
              "answer": "<p><strong>SpriteKit</strong>: Framework này được thiết kế để giúp các nhà phát triển trò chơi dễ dàng và nhanh chóng hơn trong việc tạo các nội dung/đối tượng hoạt hình 2D trong các trò chơi thông thường. Với nó, bạn có thể vẽ các hình dạng, hạt, văn bản, hình ảnh và video theo hai chiều.\r\n\r\n<strong>SceneKit</strong>: Đây là một framework iOS kế thừa từ OS X, giúp tạo đồ họa 3D. Với SceneKit, bạn có thể tạo các cảnh và hiệu ứng hoạt hình 3D cho các trò chơi và ứng dụng iOS của mình.</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "java",
          "name": "Câu hỏi phỏng vấn Java",
          "description": "",
          "questions": [
            {
              "question": "Java có phải nền tảng độc lập không?",
              "answer": "<p>Java là một ngôn ngữ độc lập với nền tảng vì mã nguồn của Java có thể chạy trên nhiều hệ điều hành. Các chương trình Java có thể chạy trên bất kỳ máy nào hoặc hệ điều hành không cần cài đặt bất kỳ phần mềm đặc biệt nào. Mặc dù JVM cần phải có mặt trong máy. Mã Java biên dịch thành bytecode (file .class), độc lập với nền tảng. Chúng tôi có thể chạy mã bytecode này trên Windows, Linux, Mac OS,....</p>",
              "level": "fresher"
            },
            {
              "question": "Tại sao nói Java không phải ngôn ngữ thuần đối tượng?",
              "answer": "<p>Java hỗ trợ kiểu dữ liệu nguyên thuỷ byte, boolean, char, short, int, float, long, và double, do đó nó không phải là ngôn ngữ thuần đối tượng.</p>",
              "level": "fresher"
            },
            {
              "question": "Con trỏ trong Java?",
              "answer": "<p>Con trỏ là một khái niệm khá phức tạp đối với những người mới bắt đầu. Java tập trung vào sự đơn giản cho code nên việc sử dụng con trỏ có thể khiến nó trở nên phức tạp hơn. Đồng thời, tính bảo mật cũng bị ảnh hưởng nếu con trỏ được sử dụng vì người dùng có thể truy cập trực tiếp vào bộ nhớ với sự trợ giúp của con trỏ.\r\n\r\nDo đó, một mức trừu tượng nhất định được cung cấp bằng cách không bao gồm các con trỏ trong Java. Hơn nữa, việc sử dụng con trỏ có thể làm cho tiến trình thu gom rác khá chậm và sai sót. Java sử dụng các tham chiếu vì chúng không thể thao tác được, không giống như con trỏ.</p>",
              "level": "fresher"
            },
            {
              "question": "Biến toàn cục và biến cục bộ trong Java?",
              "answer": "<p><strong>Biến toàn cục (instance variables)</strong> là các biến có thể được truy cập bởi tất cả phương thức trong lớp. Chúng được khai báo bên ngoài phương thức và bên trong lớp. Các biến này mô tả thuộc tính của một đối tượng, chúng được tạo khi một đối tượng được tạo bằng việc sử dụng từ khóa “new” và sẽ bị phá hủy khi đối tượng bị phá hủy.\r\n\r\nTất cả các đối tượng của lớp sẽ có bản sao các biến để sử dụng. Nếu bất kỳ thay đổi nào được thực hiện trên các biến này, chỉ có đối tượng đó bị tác động, các đối tượng cùng lớp khác sẽ không ảnh hưởng.\r\n\r\n``<code>java\r\nclass Athlete {\r\n    public String athleteName;\r\n    public double athleteSpeed;\r\n    public int athleteAge;\r\n}\r\n</code>`<code>\r\n\r\n<strong>Biến cục bộ (local variables)</strong> là các biến được khai báo trong các phương thức, hàm contructor hoặc trong các khối (</code>{}<code>). Việc sử dụng biến bị hạn chế trong phạm vi khối. Bất cứ khi nào một biến cục bộ được khai báo bên trong một phương thức, các phương thức lớp khác không biết gì về sự tồn tại của nó.\r\n\r\n</code>`<code>java\r\npublic void athlete() {\r\n    String athleteName;\r\n    double athleteSpeed;\r\n    int athleteAge;\r\n}\r\n</code>``\r\n\r\n<img src=\"/interview-assets/instance_vs_local_variable.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Đóng gói dữ liệu là gì?",
              "answer": "<p><ul><li>Đóng gói dữ liệu là một khái niệm trong lập trình hướng đối tượng để ẩn các thuộc tính dữ liệu và hành vi của chúng trong một đơn vị duy nhất.</li></ul>\r<ul><li>Nó giúp các nhà phát triển tuân theo module trong khi phát triển phần mềm bằng cách đảm bảo rằng mỗi đối tượng độc lập với các đối tượng khác bằng cách có các phương thức, thuộc tính và chức năng riêng của nó.</li></ul>\r<ul><li>Nó được sử dụng để bảo mật các thuộc tính riêng tư của một đối tượng và do đó phục vụ mục đích ẩn dữ liệu.</li></ul>\r\n\r\n<img src=\"/interview-assets/data_encapsulation.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "JIT compiler là gì?",
              "answer": "<p>JIT là viết tắt của Just-In-Time, được dùng để cải thiện hiệu suất khi biên dịch. Nó thực hiện nhiệm vụ biên dịch các phần của bytecode có chức năng giống nhau cùng lúc, do đó giảm lượng thời gian biên dịch để chạy code.\r\n\r\nTrình biên dịch (compiler) là nơi dịch mã nguồn thành mã máy tính có thể hiểu. Nhưng JIT đặc biệt vì:\r<ul><li>Mã nguồn (.java) được chuyển thành bytecode (.class) xảy ra ở trình biên dịch javac.</li></ul>\r<ul><li>Sau đó file <code>.class</code> được tải bởi JVM và sự trợ giúp của trình thông dịch(interpreter), nó được chuyển thành mã máy tính có thể hiểu.</li></ul>\r<ul><li>Trình biên dịch JIT là một phần của JVM. Khi JIT khởi động, JVM phân tích phương thức gọi trong file <code>.class</code> và biên dịch chúng để có được code thuần và hiệu quả hơn. Nó cũng đảm bảo phương thức gọi ưu tiên được tối ưu hoá.</li></ul>\r<ul><li>Sau khi bước trên hoàn thành, JVM thực thi code tối ưu trực tiếp thay vì thông dịch lần nữa. Điều này tăng hiệu suất và tốc độ thực thi.</li></ul>\r\n\r\n<img src=\"/interview-assets/JIT_Compiler.jpg\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Sự khác biết giữa phương thức equals() và toán tử == trong Java?",
              "answer": "<p>| equals() | == |\r\n|-|-|\r\n| Phương thức khai báo trong lớp, đối tượng | Toán tử nhị phân trong Java |\r\n| Dùng cho kiếm tra so sánh bằng nội dung giữa hai đối tượng theo logic nghiệp vụ cụ thể | Dùng để so sánh địa chỉ (hoặc tham chiếu), tức là kiểm tra xem cả hai đối tượng có trỏ đến cùng một vị trí bộ nhớ hay không |\r\n\r\n<em>Lưu ý</em>\r<ul><li>Trong trường hợp phương thức <code>equals</code> không được ghi đè trong một lớp, thì lớp đó sử dụng cách triển khai mặc định của phương thức <code>equals</code> gần với lớp cha nhất.</li></ul>\r<ul><li>Lớp <code>object</code> được coi là lớp cha của tất cả các lớp java. Việc triển khai phương thức <code>equals</code> trong lớp object sử dụng toán tử <code>==</code> để so sánh hai đối tượng. Việc triển khai mặc định này có thể được ghi đè theo logic nghiệp vụ.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Dùng vòng lặp trong Java thế nào?",
              "answer": "<p><ul><li>Vòng lặp For:</li></ul>\r\n\r\n``<code>java\r\nfor(;;)\r\n{\r\n    // Business logic\r\n    // Any break logic\r\n}\r\n</code>`<code>\r<ul><li>Vòng lặp While:</li></ul>\r\n\r\n</code>`<code>java\r\nwhile(true) {\r\n    // Business logic\r\n    // Any break logic\r\n}\r\n</code>`<code>\r<ul><li>Vòng lặp do-while:</li></ul>\r\n\r\n</code>`<code>java\r\ndo {\r\n    // Business logic\r\n    // Any break logic\r\n} while(true);\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích khái niệm constructor overloading?",
              "answer": "<p>Nạp chồng hàm khởi tạo (constructor overloading) là quá trình tạo nhiều hàm khởi tạo có cùng tên nhưng khác các tham số trong lớp. Tùy thuộc vào số lượng tham số và kiểu tương ứng của chúng, việc phân biệt các loại constructor khác nhau được thực hiện bởi trình biên dịch.\r\n\r\n``<code>java\r\nclass Hospital {\r\n    int variable1, variable2;\r\n    double variable3;\r\n    public Hospital(int doctors, int nurses) {\r\n        variable1 = doctors;\r\n        variable2 = nurses;\r\n    }\r\n    public Hospital(int doctors) {\r\n        variable1 = doctors;\r\n    }\r\n    public Hospital(double salaries) {\r\n        variable3 = salaries\r\n    }\r\n}\r\n</code>``\r\n\r\n<img src=\"/interview-assets/constructor_overloading_java.png\" alt=\"\" /></p>",
              "level": "fresher"
            },
            {
              "question": "Nạp chồng phương thức và ghi đè phương thức trong Java?",
              "answer": "<p>Trong Java, việc <strong>nạp chồng phương thức (overloading)</strong> được thực hiện bằng cách đưa các phương thức khác nhau vào cùng một lớp có cùng tên. Tuy nhiên, tất cả các hàm khác nhau về số lượng hoặc kiểu tham số. Nó diễn ra bên trong một lớp và nâng cao khả năng đọc của chương trình.\r\n\r\nSự khác biệt duy nhất trong kiểu trả về của phương thức không thúc đẩy quá trình nạp chồng phương thức. Ví dụ sau đây sẽ cung cấp cho bạn một bức tranh rõ ràng về nó.\r\n\r\n``<code>java\r\nclass OverloadingHelp {\r\n    public int findarea (int l, int b) {\r\n        int var1;\r\n        var1 = l <em> b;\r\n        return var1;\r\n    }\r\n    public int findarea (int l, int b, int h) {\r\n        int var2;\r\n        var2 = l </em> b <em> h;\r\n        return var2;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<img src=\"/interview-assets/method_overloading.png\" alt=\"\" />\r\n\r\nCả hai hàm có cùng tên nhưng khác nhau về số lượng tham số. Phương pháp đầu tiên tính diện tích hình chữ nhật, trong khi phương pháp thứ hai tính diện tích hình hộp chữ nhật.\r\n\r\n<strong>Ghi đè phương thức (override)</strong> là khái niệm trong đó hai phương thức giống nhau hiện diện trong hai lớp khác nhau, trong đó có mối quan hệ kế thừa. Có thể thực hiện một phương thức cụ thể (đã có trong lớp cơ sở) cho lớp dẫn xuất bằng cách sử dụng ghi đè phương thức.\r\n\r\nHãy xem ví dụ này:\r\n\r\n</code>`<code>java\r\nclass HumanBeing {\r\n    public int walk (int distance, int time) {\r\n        int speed = distance / time;\r\n        return speed;\r\n    }\r\n}\r\nclass Athlete extends HumanBeing {\r\n    public int walk(int distance, int time) {\r\n        int speed = distance / time;\r\n        speed = speed </em> 2;\r\n        return speed;\r\n    }\r\n}\r\n</code>`<code>\r\n\r\n<img src=\"/interview-assets/method_overriding.png\" alt=\"\" />\r\n\r\nCả hai phương thức lớp đều có tên </code>walk<code> và các tham số: </code>distance<code> và </code>time<code> giống nhau. Nếu phương thức lớp dẫn xuất được gọi, thì phương thức </code>walk` của lớp cơ sở sẽ bị ghi đè bởi phương thức của lớp dẫn xuất.</p>",
              "level": "fresher"
            },
            {
              "question": "Một try có thể có nhiều catch trong Java?",
              "answer": "<p>Có, nhiều khối catch có thể tồn tại nhưng các phương pháp tiếp cận cụ thể nên ưu tiên hơn cách tiếp cận chung vì khi khối đầu tiên thoả mãn điều kiện catch mới được thực thi. Ví dụ:\r\n\r\n``<code>java\r\npublic class MultipleCatch {\r\n    public static void main(String args[]) {\r\n        try {\r\n            int n = 1000, x = 0;\r\n            int arr[] = new int[n];\r\n            for (int i = 0; i <= n; i++) {\r\n                arr[i] = i / x;\r\n            }\r\n        }\r\n        catch (ArrayIndexOutOfBoundsException exception) {\r\n            System.out.println(\"1st block = ArrayIndexOutOfBoundsException\");\r\n        }\r\n        catch (ArithmeticException exception) {\r\n            System.out.println(\"2nd block = ArithmeticException\");\r\n        }\r\n        catch (Exception exception) {\r\n            System.out.println(\"3rd block = Exception\");\r\n        }\r\n    }\r\n}\r\n</code>`<code>\r\n\r\nỞ đây khối catch thứ hai sẽ được thực thi vì phép chia bởi </code>0(i/x)`. Trong trường hợp x lớn 0 thì khối catch đầu tiên sẽ thực thi vì vòng lặp chạy đến khi i = n và chỉ số mảng đến n-1.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích từ khoá final trong biến, phương thức và lớp?",
              "answer": "<p>Trong Java, từ khoá <code>final</code> được dùng cho xác định một thứ gì đó là một hằng và không thể chỉnh sửa nữa.\r<ul><li>biến <code>final</code>:</li></ul>\r<ul><li>Khi một biến được khai báo là final trong Java, giá trị không thể chỉnh sửa sau khi gán.</li></ul>\r<ul><li>Nếu không có bất kỳ giá trị nào được gán cho biến, nó có thể được gán bằng constructor của lớp.</li></ul>\r<ul><li>phương thức <code>final</code>:</li></ul>\r<ul><li>Một phương thức được khai báo là final nó sẽ không thể bị ghi đè bởi lớp con của nó.</li></ul>\r<ul><li>Một constructor không thể là final vì nếu một lớp được kế thừa thì constructor cũng kế thừa theo. Do đó, khi đánh dấu constructor là final, Java sẽ trả về lỗi - <code>modifier final not allowed here</code></li></ul>\r<ul><li>lớp <code>final</code>:</li></ul>\r<ul><li>Một lớp được khai báo là final thì không có bất kỳ lớp nào có thể kế thừa lớp đó.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Các từ khoá final, finally và finalize là giống nhau?",
              "answer": "<p><strong>Final:</strong> dùng cho các lớp, biến hoặc phương thức. Việc kế thừa một lớp final hay ghi đè một phương thức final sẽ bị hạn chế bởi việc sử dụng từ khoá final. Giá trị biến trở thành hằng sau khi dùng từ khoá final. Ví dụ:\r\n\r\n``<code>java\r\nfinal int a=100;\r\na = 0;  // error\r\n</code>`<code>\r\n\r\n<strong>Finally:</strong> Nó là khối hiện diện trong chương trình nơi tất cả code được viết bên trong nó được thực thi kể cả việc xử lý ngoại lệ. Ví dụ:\r\n\r\n</code>`<code>java\r\ntry {\r\n    int variable = 5;\r\n}\r\ncatch (Exception exception) {\r\n    System.out.println(\"Exception occurred\");\r\n}\r\nfinally {\r\n    System.out.println(\"Execution of finally block\");\r\n}\r\n</code>`<code>\r\n\r\n<strong>Finalize:</strong> Trước khi thu gom rác của một đối tượng, phương thức finalize được gọi để hoạt động dọn dẹp được thực hiện. Ví dụ:\r\n\r\n</code>`<code>java\r\npublic static void main(String[] args) {\r\n    String example = new String(\"InterviewBit\");\r\n    example = null;\r\n    System.gc(); // Garbage collector called\r\n}\r\npublic void finalize() {\r\n    // Finalize called\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Khi nào dùng từ khoá super?",
              "answer": "<p>Từ khoá <code>super</code> được dùng để truy cập các trường ẩn và ghi đề phương thức hoặc thuộc tính của lớp cha.\r\nNó dùng trong các trường hợp sau:\r<ul><li>Truy cập dữ liệu thành viên của lớp cha khi tên thành viên của lớp cha và lớp con giống nhau.</li></ul>\r<ul><li>Để gọi phương thức khởi tạo tham số và mặc định của lớp cha bên trong lớp con.</li></ul>\r<ul><li>Truy cập phương thức lớp cha khi lớp con ghi đè chúng.</li></ul>\r\n\r\nVí dụ:\r\n\r\n``<code>java\r\npublic class Parent{\r\n    protected int num = 1;\r\n    \r\n    Parent(){\r\n        System.out.println(\"Parent class default constructor.\");\r\n    }\r\n    \r\n    Parent(String x){\r\n        System.out.println(\"Parent class parameterised constructor.\");\r\n    }\r\n    \r\n    public void foo(){\r\n        System.out.println(\"Parent class foo!\");\r\n    }\r\n}\r\n   \r\npublic class Child extends Parent{\r\n    private int num = 2;\r\n    \r\n    Child(){\r\n        System.out.println(\"Child class default Constructor\");\r\n        \r\n        super();    // to call default parent constructor\r\n        super(\"Call Parent\");    // to call parameterised constructor.\r\n    }\r\n    \r\n    void printNum(){\r\n        System.out.println(num);\r\n        System.out.println(super.num); //prints the value of num of parent class\r\n    }\r\n    \r\n    @Override\r\n    public void foo(){\r\n        System.out.println(\"Parent class foo!\");\r\n        super.foo();    //Calls foo method of Parent class inside the Overriden foo method of Child class.\r\n    }\r\n}\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Các cách tạo đối tượng trong Java?",
              "answer": "<p><ul><li>Sử dụng từ khoá new:</li></ul>\r\n\r\n``<code>java\r\nclass ObjectCreationExample{\r\n\tString Owner;\r\n}\r\npublic class MainClass {\r\n\tpublic static void main(String[] args) {\r\n\t\t// Here we are creating Object of JBT using new keyword\r\n\t\tObjectCreationExample obj = new ObjectCreationExample();\r\n\t}\r\n}\r\n</code>`<code>\r<ul><li>Sử dụng reflection:</li></ul>\r\n\r\n</code>`<code>java\r\nclass CreateObjectClass {\r\n\tstatic int j = 10;\r\n\tCreateObjectClass() {\r\n\t\ti = j++;\r\n\t}\r\n\tint i;\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Value of i :\" + i;\r\n\t}\r\n}\r\n\r\nclass MainClass {\r\n\tpublic static void main(String[] args) {\r\n\t\ttry {\r\n\t\t\tClass cls = Class.forName(\"CreateObjectClass\");\r\n\t\t\tCreateObjectClass obj = (CreateObjectClass) cls.newInstance();\r\n\t\t\tCreateObjectClass obj1 = (CreateObjectClass) cls.newInstance();\r\n\t\t\tSystem.out.println(obj);\r\n\t\t\tSystem.out.println(obj1);\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (InstantiationException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (IllegalAccessException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n}\r\n</code>`<code>\r<ul><li>Sử dụng clone:</li></ul>\r\n\r\n</code>`<code>java\r\n class CreateObjectWithClone implements Cloneable {\r\n\t@Override\r\n\tprotected Object clone() throws CloneNotSupportedException {\r\n\t\treturn super.clone();\r\n\t}\r\n\tint i;\r\n\tstatic int j = 10;\r\n\tCreateObjectWithClone() {\r\n\t\ti = j++;\r\n\t}\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Value of i :\" + i;\r\n\t}\r\n}\r\n\r\nclass MainClass {\r\n\tpublic static void main(String[] args) {\r\n\t\tCreateObjectWithClone obj1 = new CreateObjectWithClone();\r\n\t\tSystem.out.println(obj1);\r\n\t\ttry {\r\n\t\t\tCreateObjectWithClone obj2 = (CreateObjectWithClone) obj1.clone();\r\n\t\t\tSystem.out.println(obj2);\r\n\t\t} catch (CloneNotSupportedException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n}\r\n</code>`<code>\r<ul><li>Sử dụng ClassLoader:</li></ul>\r\n\r\n</code>`<code>java\r\nclass CreateObjectWithClassLoader {\r\n\tstatic int j = 10;\r\n\tCreateObjectWithClassLoader() {\r\n\t\ti = j++;\r\n\t}\r\n\tint i;\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Value of i :\" + i;\r\n\t}\r\n}\r\n\r\npublic class MainClass {\r\n\tpublic static void main(String[] args) {\r\n\t\tCreateObjectWithClassLoader obj = null;\r\n\t\ttry {\r\n\t\t\tobj = (CreateObjectWithClassLoader) new MainClass().getClass()\r\n\t\t\t\t\t.getClassLoader().loadClass(\"CreateObjectWithClassLoader\").newInstance();\r\n        // Fully qualified classname should be used.\r\n\t\t} catch (InstantiationException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (IllegalAccessException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\tSystem.out.println(obj);\r\n\t}\r\n}\r\n</code>``</p>",
              "level": "fresher"
            }
          ]
        },
        {
          "id": "react-native",
          "name": "Câu hỏi phỏng vấn React Native",
          "description": "",
          "questions": [
            {
              "question": "Sự khác biệt giữa ReactJS và React Native?",
              "answer": "<p><ul><li>Mục đích:</li></ul>\r<ul><li>ReactJS là thư viện dùng cho xây dựng giao diện người dùng trên ứng dụng web</li></ul>\r<ul><li>React Native là framework cho tạo ứng dụng di động ở như một ứng dụng native.</li></ul>\r<ul><li>Cú pháp: cả hai đều dùng JSX nhưng React dùng cú pháp <code><div></code>, <code><h1></code>, <code><p></code> còn React Native dùng <code><view></code>, <code><text></code>,...</li></ul>\r<ul><li>Animation:</li></ul>\r<ul><li>ReactJS sử dụng CSS animation để tạo ảnh động trên ứng dụng web.</li></ul>\r<ul><li>React Native sử dụng Animated API</li></ul>\r<ul><li>Cơ chế routing:</li></ul>\r<ul><li>React dùng react-router cho chuyển hướng trang</li></ul>\r<ul><li>React Native sử dụng thư viện Navigator cho chuyển hướng trên ứng dụng di động.</li></ul>\r\n\r\n<img src=\"/interview-assets/reactjs_vs_react_native.png\" alt=\"\" />\r\n\r\n| React JS | React Native |\r\n|-|-|\r\n| Dùng cho phát triển ứng dụng web | Dùng cho phát triển ứng dụng di động |\r\n| Dùng react-router cho điều hướng trang | Dùng thư viện navigator cho điều hướng trong ứng dụng di động |\r\n| Dùng thẻ HTML | Không dùng thẻ HTML |\r\n| Cung cấp bảo mật cao | Bảo mật thấp hơn so với ReactJS |\r\n| Sử dụng virtual DOM để render trên trình duyệt | Dùng API để render cho ứng dụng di động |</p>",
              "level": "fresher"
            },
            {
              "question": "Flexbox là gì?",
              "answer": "<p>Nó là mô hình bố cục cho phép phần tử được căn chỉnh và cách đều trong container. Với flexbox ta có thể tuỳ chỉnh width và height một cách linh hoạt, tất cả bên trong container chính có thể được căn chỉnh để lấp đầy hoặc cách khoảng giữa các phần tử, điều này làm cho nó trở thành một công cụ tuyệt vời để sử dụng cho các hệ thống thiết kế reponsive.\r\n\r\n| Property | Values | Desc |\r\n|-|-|-|\r\n| flexDirection | 'column', 'row' | Dùng cho căn chỉnh phần tử theo chiều dọc hay ngang |\r\n| justifyContent | 'center','flex-start','flex-end','space-around','space-between' | Được sử dụng để xác định cách các phần tử nên được cách khoảng bên trong container |\r\n| alignItems | 'center','flex-start','flex-end','stretched' | Được sử dụng để xác định cách các phần tử nên được cách khoảng bên trong container dọc theo trục thứ cấp (ngược với flexDirection) |</p>",
              "level": "fresher"
            },
            {
              "question": "Ưu điểm của React Native?",
              "answer": "<p><strong>Cộng đồng lớn</strong>\r\n\r\nReact Native là một Framework mã nguồn mở, nó hoàn toàn do cộng đồng thúc đẩy phát triển nên mọi vấn đề đều có thể được giải quyết bằng cách nhận trợ giúp trực tuyến từ các nhà phát triển khác.\r\n \r\n<strong>Khả năng tái sử dụng</strong>\r\n\r\nCode có thể được viết một lần và có thể được sử dụng cho cả iOS và Android, giúp duy trì và cũng như debug các ứng dụng phức tạp lớn vì không cần nhóm riêng biệt để hỗ trợ cả hai nền tảng, điều này cũng làm giảm chi phí ở mức độ lớn.\r\n \r\n<strong>Hot Reloading</strong>\r\n\r\nThói quen thông thường của dev khi code là test các thay đổi mỗi lần code được viết. Để thực hiện được, app cần phải được đóng gói lại và cài đặt hoặc trong 1 simulator hoặc một thiết bị thật sự.\r\n\r\nVới React Native, phần lớn thời gian, bạn không cần phải tổng hợp lại app mỗi lần có thay đổi. Bạn chỉ cần làm mới app trong simulator, emulator hoặc thiết bị. Thậm chí còn có một tính năng là Live Reload để tự động refresh app mỗi lần phát hiện 1 thay đổi trong code.\r\n\r\n<strong>Các plugin bổ sung của bên thứ ba</strong>\r\nNếu các module hiện có không đáp ứng yêu cầu nghiệp vụ trong React Native, chúng ta cũng có thể sử dụng các plugin của Bên thứ ba để giúp tăng tốc quá trình phát triển.</p>",
              "level": "fresher"
            },
            {
              "question": "Giải thích các luồng khác nhau trong React Native?",
              "answer": "<p><img src=\"/interview-assets/Image-2.png\" alt=\"\" />\r\n\r\n<strong>React Native sử dụng 3 luồng</strong>\r<ul><li><strong>Luồng MAIN/UI</strong> - Đây là luồng chính mà ứng dụng Android/iOS của bạn đang chạy. Giao diện người dùng của ứng dụng có thể được thay đổi bởi luồng chính và có quyền truy cập vào nó.</li></ul>\r<ul><li><strong>Luồng Shadow</strong> - bố cục được tạo bởi thư viện React trong React Native.</li></ul>\r<ul><li><strong>Luồng JavaScript</strong> - code JavaScript sẽ được thực thi ở luồng này.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "defaultProps có khả dụng trong React Native không?",
              "answer": "<p>Có, nó hoạt động trong React Native tương tự như ở ReactJS.\r\n\r\n``<code>jsx\r\nimport {View, Text} from 'react-native';\r\n\r\nclass DefaultPropComponent extends Component {\r\n    render() {\r\n        return ( \r\n            </code><View>\r\n                <code><Text></code> \r\n                {this.props.name} \r\n                <code></Text></code> \r\n            <code></View>\r\n        )\r\n    }\r\n}\r\nDemo.defaultProps = {\r\n   name: 'BOB'\r\n}\r\n\r\nexport default DefaultPropComponent;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Xử lý input trong React Native?",
              "answer": "<p>TextInput là component chính cho phép người dùng nhập văn bản vào. Nó có <code>onChangeText</code> để nhận một hàm gọi mỗi khi văn bản có thay đổi, và <code>onSubmitEditing</code> để nhận một hàm gọi mỗi khi có submit.\r\n\r\n``<code>jsx\r\nimport React, { useState } from 'react';\r\nimport { Text, TextInput, View } from 'react-native';\r\n\r\nconst PizzaTranslator = () => {\r\n    const [text, setText] = useState('');\r\n    return (\r\n        <View style={{padding: 10}}>\r\n            <TextInput\r\n                style={{height: 40}}\r\n                placeholder=\"Type here to translate!\"\r\n                onChangeText={text => setText(text)}\r\n                defaultValue={text}\r\n            />\r\n            <Text style={{padding: 10, fontSize: 42}}>\r\n                {text.split(' ').map((word) => word && '🍕').join(' ')}\r\n            </Text>\r\n        </View>\r\n    );\r\n}\r\n\r\nexport default PizzaTranslator;\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Cách sử dụng state trong React Native?",
              "answer": "<p>Nó dùng cho điều khiển component. Biến dữ liệu có thể lưu trong state, và nó có thể thay đổi giá trị bất cứ lúc nào. Ví dụ\r\n\r\n``<code>jsx\r\nimport React, {Component} from 'react';    \r\nimport { Text, View } from 'react-native';\r\n\r\nexport default class App extends Component {    \r\n    state = {\r\n        myState: 'State of Text Component'\r\n    }\r\n\r\n    updateState = () =></code> this.setState({myState: 'The state is updated'})\r\n    render() {\r\n        return (\r\n            <code><View></code>    \r\n                <code><Text onPress={this.updateState}></code> {this.state.myState} <code></Text></code>    \r\n            <code></View></code> \r\n        ); \r\n    } \r\n}\r\n```</p>",
              "level": "fresher"
            },
            {
              "question": "Redux trong React Native?",
              "answer": "<p>Redux là một công cụ quản lý trạng thái được dùng cho các ứng dụng JavaScript. Nó giúp toàn bộ luồng dữ liệu của ứng dụng được xử lý trong một container duy nhất không khi trạng thái trước đó vẫn tồn tại.\r\n\r\n<img src=\"/interview-assets/react-native-redux.png\" alt=\"\" />\r\n\r\n<em>Actions</em>: là khối lượng thông tin gửi dữ liệu từ ứng dụng của bạn đến store. Chúng là nguồn thông tin duy nhất cho store. Điều này có nghĩa là nếu bất kỳ thay đổi trạng thái nào là cần thiết, sẽ được thực hiện thông qua các action.\r\n\r\n<em>Reducers</em>: Các action mô tả thực tế là có điều gì đó đã xảy ra, nhưng không chỉ rõ trạng thái của ứng dụng thay đổi như thế nào để phản hồi. Đây là công việc của những reducer.\r\n\r\n<em>Store</em>: một store có thể được tạo ra với sự trợ giúp của các reducers lưu giữ toàn bộ trạng thái của ứng dụng. Cách được khuyến khích là sử dụng một store duy nhất cho toàn bộ ứng dụng, vì có nhiều store sẽ vi phạm việc sử dụng redux vốn chỉ có một store duy nhất.\r\n\r\n<em>Component</em>: đây là nơi lưu giữ giao diện người dùng của ứng dụng.</p>",
              "level": "fresher"
            },
            {
              "question": "Các hàm thời gian trong React Native?",
              "answer": "<p><ul><li><strong>setTimeout, clearTimeout</strong></li></ul>\r\n\r\nCó các yêu cầu nghiệp vụ, <code>setTimeout</code> để thực thi một mẫu code sau một khoảng thời gian chờ đợi. <code>clearTimeout</code> dùng để xoá timer lại thời gian được bắt đầu.\r\n\r\n``<code>js\r\nsetTimeout(() =></code> {\r\n    yourFunction();\r\n}, 3000);\r\n``<code>\r<ul><li><strong>setInterval, clearInterval</strong></li></ul>\r\n\r\nLà phương thức để gọi một hàm hoặc chạy code sau những khoảng thời gian cụ thể, được chỉ định trong tham số thứ hai.\r\n\r\n</code>`<code>js\r\nsetInterval(() =></code> {\r\n    console.log('Interval triggered');\r\n}, 1000);\r\n``<code>\r\n\r\nMột hàm hoặc khối code được liên kết với một khoảng thời gian sẽ thực thi cho đén khi nó bị dừng. Để dùng khoảng thời gian, ta dùng phương thức </code>clearInterval()<code>.\r<ul><li><strong>setImmediate, clearImmediate</strong></li></ul>\r\n\r\nGọi hàm thực thi sớm nhất có thể.\r\n\r\n</code>`<code>js\r\nvar immediateID = setImmediate(function);\r\n// The below code displays the alert dialog immediately.\r\nvar immediateId = setImmediate(\r\n    () =></code> {    alert('Immediate Alert');\r\n}\r\n``<code>\r\n\r\n</code>clearImmediate()<code> dùng để huỷ hành động ngay lập tức nếu nó được thiết lập bằng </code>setImmediate()<code>.\r<ul><li><strong>requestAnimationFrame, cancelAnimationFrame</strong></li></ul>\r\n\r\nLà chuẩn để thực hiện ảnh động.\r\n\r\nGọi một hàm để cập nhật ảnh động trước khi đến frame ảnh động kế tiếp.\r\n\r\n</code>`<code>js\r\nvar requestID = requestAnimationFrame(function);\r\n// The following code performs the animation.\r\nvar requestId = requestAnimationFrame(\r\n    () =></code> { // animate something}\r\n)\r\n``<code>\r\n\r\n</code>cancelAnimationFrame()<code> dùng để huỷ hàm được thiết lập bởi </code>requestAnimationFrame()`.</p>",
              "level": "fresher"
            },
            {
              "question": "Cách debug ứng dụng React Native và các công cụ cần thiết?",
              "answer": "<p>Trong React Native, có rất nhiều cách debug khác nhau với nhiều công cụ khác nhau, do React Native chạy trên cả hai môi trường Android và iOS. \r<ul><li>Developer Menu:</li></ul>\r<ul><li>Reload: tải lại ứng dụng</li></ul>\r<ul><li>Debug JS Remotely: mở một kênh mới cho JavaScript debugger</li></ul>\r<ul><li>Enable Live Reload: làm cho ứng dụng tự động tải lại khi click vào Save</li></ul>\r<ul><li>Enable Hot Reloading: theo dõi các thay đổi được tích lũy trong một file đã thay đổi</li></ul>\r<ul><li>Toggle Inspector: chuyển đổi giao diện kiểm tra, cho phép chúng ta kiểm tra bất kỳ phần tử UI nào trên màn hình và các thuộc tính của nó, đồng thời trình bày một giao diện có các tab khác như mạng, hiển thị cho chúng ta các lệnh gọi HTTP và một tab cho hiệu suất.</li></ul>\r\n\r\n<img src=\"/interview-assets/developer-menu.png\" alt=\"\" />\r<ul><li><strong>Chrome's DevTools:</strong></li></ul>\r\n\r\nChrome có thể là công cụ đầu tiên có thể nghĩ đến để debug React Native. DevTools của Chrome chủ yếu để debug các ứng dụng web, nhưng chúng ta cũng có thể sử dụng chúng để debug React Native vì nó được hỗ trợ bởi JavaScript. Để sử dụng DevTool với React Native, trước tiên đảm bảo chúng có cùng kết nối Wifi, sau đó nhấn lệnh <code>R</code> nếu dùng MacOS, <code>Ctrl + M</code> nếu là Window/Linux. Trong menu, chọn Debug JS Remotely, nó sẻ mở ra JS Debugger mặc định.\r<ul><li><strong>React Developer Tools:</strong></li></ul>\r\n\r\nTa có thể cài đặt package react-devtoools như sau:\r\n\r\n``<code>\r\nnpm install react-devtools --save\r\n</code>`<code>\r\n\r\nReact's Developer Tool là công cụ tốt nhất cho debug trên React Native với hai lý do\r<ul><li>Nó cho phép debug component.</li></ul>\r<ul><li>Nó còn có thể debug style trong React Native. Ngoài ra còn có một phiên bản mới đi kèm với tính năng này cũng hoạt động với inspector trong developer menu. Trước đây, việc viết các style là một vấn đề và phải đợi ứng dụng tải lại để xem các thay đổi. Giờ đây, chúng ta có thể debug và triển khai các thuộc tính style và xem tác động của thay đổi ngay lập tức mà không cần tải lại ứng dụng.</li></ul>\r<ul><li><strong>React Native Debugger</strong></li></ul>\r\n\r\nKhi sử dụng Redux trong ứng dụng React Native của bạn, React Native Debugger có lẽ là trình debug phù hợp với bạn. Đây là một ứng dụng desktop hoạt động độc lập trên macOS, Windows và Linux. Nó thậm chí còn tích hợp cả Redux’s DevTools và React’s Developer Tools trong một ứng dụng, do đó bạn không phải làm việc với hai ứng dụng riêng biệt để debug.\r<ul><li><strong>React Native CLI</strong></li></ul>\r\n\r\nBạn cũng có thể sử dụng React Native CLI để debug. Nó cũng có thể được sử dụng để hiển thị loga của ứng dụng. Nhấn vào </code>react-native log-android<code> sẽ hiển thị cho bạn log của db logcat trên Android và để xem log trong iOS, bạn có thể chạy react-native log-ios và với </code>console.log<code>, bạn có thể gửi log đến terminal:\r\n\r\n</code>`<code>\r\nconsole.log(\"some error🛑\")\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Props Drilling là gì?",
              "answer": "<p>Props Drilling là một khái niệm đề cập đến quá trình truyền dữ liệu từ component cha đến component con chính xác NHƯNG ở giữa có rất nhiều component truyền props như một chuỗi.\r\n\r\n<img src=\"/interview-assets/Props_Drilling.png\" alt=\"\" />\r\n\r\n#</p>",
              "level": "fresher"
            },
            {
              "question": "Mô tả kết nối mạng trong React Native?",
              "answer": "<p>React Native cung cấp fetch API cho kết nối mạng. Để lấy nội dung từ một URL, ta có thể làm như sau:\r\n\r\n``<code>js\r\nfetch('https://mywebsite.com/endpoint/', {\r\n    method: 'POST',\r\n    headers: {\r\n        Accept: 'application/json',\r\n        'Content-Type': 'application/json'\r\n    },\r\n    body: JSON.stringify({\r\n        firstParam: 'yourValue',\r\n        secondParam: 'yourOtherValue'\r\n    })\r\n});\r\n</code>`<code>\r\n\r\nKết nối mạng là một hoạt động bất đồng bộ. Các phương thức fetch sẽ trả về một Promise giúp dễ dàng viết code hoạt động theo cách bất đồng bộ:\r\n\r\n</code>`<code>js\r\nconst getMoviesFromApi = () => {\r\n    return fetch('https://reactnative.dev/movies.json')\r\n        .then((response) => response.json())\r\n        .then((json) => {\r\n            return json.movies;\r\n        })\r\n        .catch((error) => {\r\n            console.error(error);\r\n        });\r\n};\r\n</code>`<code>\r\n\r\nAPI XMLHttpRequest là api sẵn có trong React Native. Ta cũng có thể sử dụng axios với frisbee với api này.\r\n\r\n</code>`<code>js\r\nvar request = new XMLHttpRequest();\r\nrequest.onreadystatechange = (e) => {\r\n    if (request.readyState !== 4) {\r\n        return;\r\n    }\r\n\r\n    if (request.status === 200) {\r\n        console.log('success', request.responseText);\r\n    } else {\r\n        console.warn('error');\r\n    }\r\n};\r\n\r\nrequest.open('GET', 'https://mywebsite.com/endpoint/');\r\nrequest.send();\r\n</code>``</p>",
              "level": "fresher"
            },
            {
              "question": "Liệt kê các điểm chính để tích hợp React Native trong một ứng dụng Android?",
              "answer": "<p>Các điểm chính cần lưu ý để tích hợp các React Native vào ứng dụng Android của bạn là:\r<ul><li>Thiết lập cấu trúc thư mục và phụ thuộc React Native.</li></ul>\r<ul><li>Phát triển các component React Native của bạn trong JavaScript.</li></ul>\r<ul><li>Thêm ReactRootView vào ứng dụng Android của bạn. View này sẽ đóng vai trò là container cho component React Native của bạn.</li></ul>\r<ul><li>Khởi động React Native server và chạy ứng dụng native của bạn.</li></ul>\r<ul><li>Cuối cùng, chúng ta cần xác minh việc React Native trong ứng dụng của bạn hoạt động như mong đợi.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Code React Native được xử lý như thế nào?",
              "answer": "<p><ul><li>Khi bắt đầu khởi động ứng dụng, luồng chính bắt đầu thực thi và tải JS bundles.</li></ul>\r<ul><li>Khi code JS đã được tải hoàn tất, luồng chính gửi nó vào luồng JS khác vì JS thực hiện các tính toán nặng trong một thời gian, luồng UI sẽ không phải chịu ảnh hưởng gì cả.</li></ul>\r<ul><li>Khi React bắt đầu render, Reconciler bắt đầu \"driffing\", và nó tạo một virtual DOM (layout) mới, nó gửi các thay đổi đến luồng khác. (Luồng shadow)</li></ul>\r<ul><li>Luồng shadow tính toán bố cụ và gửi tham số/đối tượng bố cục đến luồng chính. </li></ul>\r<ul><li>Vì chỉ luồng chính mới có thể hiển thị thứ gì đó trên màn hình, nên luồng shadow sẽ gửi bố cục đã tạo đến luồng chính và chỉ khi đó giao diện người dùng mới hiển thị.</li></ul></p>",
              "level": "fresher"
            },
            {
              "question": "Bridge trong React Native là gì?",
              "answer": "<p>Bridge là một lớp hoặc một kết nối chịu trách nhiệm gắn kết môi trường Native và JavaScript lại với nhau.\r\n\r\nSơ đồ:\r\n\r\n<img src=\"/interview-assets/bridge_in_react_native.png\" alt=\"\" />\r<ul><li>Lớp gần nhất với thiết bị mà ứng dụng chạy trên đó là Lớp Native.</li></ul>\r<ul><li>Bridge về cơ bản là một lớp truyền tải hoạt động như một kết nối giữa các module Javascript và Native, nó thực hiện công việc vận chuyển các thông báo phản hồi được tuần tự hóa bất đồng bộ từ JavaScript đến các module Native.</li></ul>\r\n\r\nVí dụ bây giờ, có một số thay đổi trạng thái xảy ra, do đó React Native sẽ cập nhật hàng loạt UI và gửi nó đến Bridge. Bridge sẽ chuyển phản hồi được tuần tự hóa này đến lớp Native, lớp này sẽ xử lý tất cả các lệnh mà nó có thể phân biệt với phản hồi được tuần tự hóa và sẽ cập nhật giao diện người dùng cho phù hợp.\r\n\r\n<strong>Nền tảng iOS</strong>\r\n\r\n<img src=\"/interview-assets/IOS_Platform.png\" alt=\"\" />\r\n\r\n<strong>Nền tảng Android</strong>\r\n\r\n<img src=\"/interview-assets/android_platform.png\" alt=\"\" /></p>",
              "level": "fresher"
            }
          ]
        }
      ]
    }
  ]
}