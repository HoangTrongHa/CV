{
  "id": "javascript",
  "name": "Câu hỏi phỏng vấn JavaScript",
  "description": "Tổng hợp các kiến thức cốt lõi về JavaScript từ cơ bản đến nâng cao.",
  "questions": [
    {
      "question": "Giải thích chi tiết cơ chế Event Loop: Microtask queue khác gì Macrotask queue?",
      "answer": "Event Loop điều phối việc thực thi code. Điểm mấu chốt là thứ tự ưu tiên:\n1. Macrotask (Task Queue): gồm setTimeout, setInterval, I/O.\n2. Microtask (Job Queue): gồm Promise, MutationObserver.\n\nQuy tắc: Sau khi thực thi xong một Macrotask (hoặc code đồng bộ), Event Loop sẽ kiểm tra và thực thi HẾT sạch các công việc trong Microtask queue trước khi chuyển sang Macrotask tiếp theo. Do đó, Promise thường được ưu tiên chạy trước setTimeout.",
      "level": "senior"
    },
    {
      "question": "Cơ chế Garbage Collection (Dọn dẹp bộ nhớ) trong JS hoạt động thế nào? Khi nào thì Memory Leak xảy ra?",
      "answer": "JS chủ yếu dùng thuật toán 'Mark-and-Sweep' (Đánh dấu và Quét). Nó bắt đầu từ gốc (root - thường là window/global), duyệt qua tất cả các tham chiếu có thể truy cập được và 'đánh dấu' chúng. Những gì không được đánh dấu (không thể truy cập từ root) sẽ bị 'quét' đi để giải phóng bộ nhớ.\n\nMemory Leak xảy ra khi biến không còn cần thiết nhưng vẫn còn tham chiếu từ root nên không bị quét, ví dụ: quên xóa setInterval, Closures giữ tham chiếu không cần thiết, hoặc biến toàn cục vô tình được tạo ra.",
      "level": "senior"
    },
    {
      "question": "Sự khác biệt giữa CommonJS và ES Modules (ESM)?",
      "answer": "Đây là 2 chuẩn module chính:\n- CommonJS (require/module.exports): Là chuẩn của Node.js cũ. Nó load module đồng bộ (synchronous) và dynamic (có thể gọi require trong câu lệnh if).\n- ES Modules (import/export): Là chuẩn chính thức của JS hiện đại. Nó load module bất đồng bộ (asynchronous), static (phải import ở đầu file) giúp hỗ trợ Tree Shaking (loại bỏ code thừa) tốt hơn.",
      "level": "senior"
    },
    {
      "question": "Giải thích về khái niệm 'Pure Function' và 'Immutability'. Tại sao chúng quan trọng trong JS hiện đại?",
      "answer": "- Pure Function (Hàm thuần khiết): Là hàm luôn trả về cùng một kết quả nếu đầu vào giống nhau và KHÔNG gây ra side effects (không sửa đổi biến ngoài, không gọi API, không log...).\n- Immutability (Bất biến): Dữ liệu không bị thay đổi trực tiếp sau khi tạo. Muốn sửa thì phải tạo bản copy mới.\n\nQuan trọng vì: Giúp code dễ dự đoán, dễ test, tránh lỗi do thay đổi trạng thái ngầm, và là nền tảng của các thư viện như Redux hay React.",
      "level": "senior"
    },
    {
      "question": "Proxy và Reflect trong ES6 là gì và ứng dụng thực tế?",
      "answer": "Proxy là một đối tượng dùng để bao bọc một đối tượng khác nhằm can thiệp (intercept) vào các thao tác cơ bản như: đọc/ghi thuộc tính, gọi hàm...\nReflect là một API cung cấp các phương thức mặc định để thực hiện các thao tác đó.\n\nỨng dụng: Dùng để làm Validation (kiểm tra dữ liệu trước khi gán), Data Binding (tự động cập nhật UI khi dữ liệu đổi - cốt lõi của VueJS 3), hoặc tạo các thuộc tính ảo, logging.",
      "level": "senior"
    },
    {
      "question": "Làm thế nào để xử lý các tác vụ tính toán nặng (CPU intensive) mà không làm đơ trình duyệt (Main Thread)?",
      "answer": "JavaScript chạy đơn luồng (Single Thread) trên Main Thread. Để xử lý tác vụ nặng không gây treo UI, ta có thể:\n1. Sử dụng Web Workers: Tạo ra một luồng riêng biệt chạy ngầm để xử lý tính toán, giao tiếp với main thread qua message.\n2. Kỹ thuật chia nhỏ task (Time Slicing): Chia tác vụ lớn thành nhiều phần nhỏ và dùng setTimeout hoặc requestIdleCallback để chạy lần lượt, nhường thời gian cho UI render.",
      "level": "senior"
    },
    {
      "question": "Sự khác biệt giữa Promise.all(), Promise.allSettled(), Promise.race() và Promise.any()?",
      "answer": "- Promise.all(): Chờ TẤT CẢ thành công. Nếu 1 cái thất bại, nó dừng và báo lỗi ngay lập tức.\n- Promise.allSettled(): Chờ TẤT CẢ hoàn thành (dù thành công hay thất bại). Trả về mảng trạng thái của từng cái.\n- Promise.race(): Trả về kết quả của cái nào hoàn thành ĐẦU TIÊN (bất kể thành công hay lỗi).\n- Promise.any(): Chờ cái THÀNH CÔNG đầu tiên. Chỉ báo lỗi nếu tất cả đều lỗi.",
      "level": "senior"
    },
    {
      "question": "Giải thích về Debounce và Throttle? Khi nào nên dùng cái nào?",
      "answer": "Cả hai đều dùng để giới hạn số lần gọi hàm:\n- Debounce: Chỉ thực thi hàm sau khi người dùng NGỪNG thao tác một khoảng thời gian (VD: Search box - chỉ search khi người dùng gõ xong).\n- Throttle: Giới hạn hàm chỉ được thực thi tối đa 1 lần trong 1 khoảng thời gian nhất định, dù người dùng thao tác liên tục (VD: Sự kiện scroll hoặc resize màn hình).",
      "level": "senior"
    },
    {
      "question": "Sự khác biệt giữa Event Bubbling và Event Capturing?",
      "answer": "Đây là thứ tự lan truyền sự kiện trong DOM:\n- Event Capturing (Pha bắt): Sự kiện đi từ gốc (Window) xuống phần tử đích.\n- Event Bubbling (Pha nổi bọt): Sự kiện đi từ phần tử đích nổi lên lại gốc.\nMặc định, các sự kiện xử lý ở pha Bubbling. Ta có thể dùng `stopPropagation()` để chặn quá trình nổi bọt này. Delegation (ủy quyền sự kiện) dựa trên cơ chế Bubbling.",
      "level": "senior"
    },
    {
      "question": "Làm sao để bảo mật ứng dụng JavaScript khỏi lỗi XSS (Cross-Site Scripting)?",
      "answer": "XSS xảy ra khi kẻ tấn công chèn được script độc hại vào web. Để phòng chống:\n1. Không bao giờ tin tưởng dữ liệu đầu vào (Input Sanitization).\n2. Tránh sử dụng các hàm nguy hiểm như `innerHTML` (thay bằng `innerText` hoặc `textContent`).\n3. Sử dụng Content Security Policy (CSP) để chặn các nguồn script lạ.\n4. Với React/Vue/Angular, cơ chế mặc định đã tự động encode dữ liệu, nhưng cần cẩn thận khi dùng các hàm như `dangerouslySetInnerHTML`.",
      "level": "senior"
    },
    {
      "question": "Sự khác biệt giữa các kiểu dữ liệu trong JavaScript?",
      "answer": "JavaScript có 2 nhóm kiểu dữ liệu chính:\n\n1. Kiểu nguyên thủy (Primitive Types): Lưu trữ giá trị đơn lẻ, bao gồm: String (chuỗi), Number (số), Boolean (đúng/sai), undefined (chưa xác định), null (rỗng), BigInt (số nguyên lớn) và Symbol (giá trị duy nhất).\n2. Kiểu tham chiếu (Reference Types): Lưu trữ các tập hợp dữ liệu phức tạp, chủ yếu là Object (bao gồm Array, Function).\n\nTa dùng lệnh 'typeof' để kiểm tra kiểu dữ liệu của biến.",
      "level": "fresher"
    },
    {
      "question": "Giải thích về Hoisting trong Javascript?",
      "answer": "Hoisting là cơ chế mặc định của JavaScript, trong đó các khai báo biến (dùng var) và khai báo hàm (function declaration) được đưa lên đầu phạm vi (scope) của chúng trước khi code được thực thi.\n\nĐiều này cho phép bạn gọi một hàm trước khi nó được định nghĩa trong code. Tuy nhiên, với 'let' và 'const', hoisting vẫn xảy ra nhưng biến sẽ rơi vào 'Vùng chết tạm thời' (TDZ) và không thể truy cập trước khi khai báo.",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa toán tử '==' và '===' là như thế nào?",
      "answer": "- Toán tử '==' (so sánh trừu tượng): Chỉ so sánh giá trị. Nếu hai vế khác kiểu dữ liệu, nó sẽ tự động ép kiểu (convert) về cùng một loại rồi mới so sánh.\n- Toán tử '===' (so sánh nghiêm ngặt): So sánh cả giá trị VÀ kiểu dữ liệu. Không có ép kiểu xảy ra. Đây là cách so sánh được khuyến khích dùng để tránh lỗi logic.",
      "level": "fresher"
    },
    {
      "question": "Giải thích về ép kiểu ngầm (Implicit Coercion) trong JavaScript?",
      "answer": "Ép kiểu ngầm là việc trình duyệt tự động chuyển đổi một giá trị từ kiểu dữ liệu này sang kiểu dữ liệu khác khi thực hiện các phép toán.\n\nVí dụ điển hình:\n- Khi cộng số với chuỗi: Số sẽ bị biến thành chuỗi để nối (Ví dụ: 1 + '2' = '12').\n- Khi dùng phép trừ, nhân, chia chuỗi số: Chuỗi sẽ bị biến thành số (Ví dụ: '5' - 2 = 3).\n- Trong câu lệnh điều kiện (if): Các giá trị sẽ được ép về Boolean (True/False).",
      "level": "fresher"
    },
    {
      "question": "JavaScript là ngôn ngữ kiểu tĩnh hay kiểu động?",
      "answer": "JavaScript là ngôn ngữ kiểu động (Dynamic Typing). Điều này có nghĩa là bạn không cần khai báo kiểu dữ liệu cho biến khi viết code. Kiểu dữ liệu của biến sẽ được xác định tự động trong quá trình chương trình đang chạy (runtime) và một biến có thể thay đổi kiểu dữ liệu liên tục (ví dụ: đang là số có thể gán lại thành chuỗi).",
      "level": "fresher"
    },
    {
      "question": "Thuộc tính NaN trong JavaScript là gì?",
      "answer": "NaN viết tắt của 'Not-a-Number'. Đây là một giá trị đặc biệt thuộc kiểu Number, xuất hiện khi bạn thực hiện một phép toán không hợp lệ (ví dụ: lấy chữ chia cho số). Dù tên là 'không phải số', nhưng typeof của NaN vẫn trả về 'number'. Để kiểm tra một giá trị có phải NaN không, ta dùng hàm isNaN().",
      "level": "fresher"
    },
    {
      "question": "Giải thích về tham trị (Pass by Value) và tham chiếu (Pass by Reference)?",
      "answer": "- Tham trị (Dùng cho kiểu nguyên thủy): Khi gán biến A cho biến B, giá trị được sao chép sang ô nhớ mới. Thay đổi B không ảnh hưởng đến A.\n- Tham chiếu (Dùng cho Object/Array): Khi gán biến A cho biến B, cả hai cùng trỏ đến một địa chỉ bộ nhớ. Thay đổi thuộc tính của B sẽ làm thay đổi cả A vì chúng cùng thao tác trên một vật thể.",
      "level": "fresher"
    },
    {
      "question": "IIFE là gì trong JavaScript?",
      "answer": "IIFE (Immediately Invoked Function Expression) là một hàm được thực thi ngay lập tức sau khi nó được định nghĩa. Nó thường được dùng để tạo ra một phạm vi riêng (scope), giúp đóng gói code và tránh làm ô nhiễm biến toàn cục.",
      "level": "fresher"
    },
    {
      "question": "Giải thích về HOC (Higher Order Functions)?",
      "answer": "Higher Order Function (Hàm bậc cao) là hàm thỏa mãn ít nhất một trong hai điều kiện: nhận một hàm khác làm tham số đầu vào, hoặc trả về một hàm khác ở đầu ra. Các ví dụ phổ biến của HOC trong xử lý mảng là: map(), filter(), reduce().",
      "level": "fresher"
    },
    {
      "question": "Giải thích về từ khóa 'this'?",
      "answer": "Từ khóa 'this' tham chiếu đến đối tượng đang thực thi đoạn code đó. Giá trị của 'this' thay đổi tùy ngữ cảnh:\n1. Trong phương thức của đối tượng: 'this' là chính đối tượng đó.\n2. Trong hàm đơn thuần: 'this' là đối tượng toàn cục (window) hoặc undefined (nếu dùng strict mode).\n3. Trong sự kiện (event): 'this' là phần tử HTML nhận sự kiện.\n4. Arrow function không có 'this' riêng, nó lấy 'this' từ phạm vi bao quanh nó.",
      "level": "fresher"
    },
    {
      "question": "Giải thích về phương thức call(), apply() và bind()?",
      "answer": "Cả 3 đều dùng để thay đổi ngữ cảnh (giá trị của 'this') cho một hàm:\n- call(): Gọi hàm ngay lập tức, các tham số truyền vào lần lượt (cách nhau bởi dấu phẩy).\n- apply(): Gọi hàm ngay lập tức, nhưng các tham số được truyền vào dưới dạng một mảng.\n- bind(): Không gọi hàm ngay, mà trả về một hàm mới với giá trị 'this' đã được cố định, dùng để thực thi sau này.",
      "level": "fresher"
    },
    {
      "question": "Currying trong JavaScript là gì?",
      "answer": "Currying là kỹ thuật chuyển đổi một hàm có nhiều tham số thành một chuỗi các hàm con, mỗi hàm chỉ nhận một tham số duy nhất. Ví dụ thay vì gọi sum(a, b), ta gọi sum(a)(b). Kỹ thuật này giúp tái sử dụng code và cấu hình hàm linh hoạt hơn.",
      "level": "fresher"
    },
    {
      "question": "Giải thích về Scope (Phạm vi) và Scope Chain?",
      "answer": "Scope là vùng không gian mà tại đó các biến hoặc hàm có thể truy cập được. Có 3 loại chính: Global Scope (Toàn cục), Function Scope (Trong hàm), và Block Scope (Trong khối {} của let/const).\n\nScope Chain (Chuỗi phạm vi) là cơ chế tìm kiếm biến: Nếu biến không tìm thấy ở phạm vi hiện tại, JS sẽ tìm lên phạm vi cha, cứ thế cho đến khi tới Global Scope. Nếu vẫn không thấy sẽ báo lỗi.",
      "level": "fresher"
    },
    {
      "question": "Giải thích về Closures trong JavaScript?",
      "answer": "Closure là một chức năng cho phép một hàm ghi nhớ và truy cập được các biến ở phạm vi bên ngoài (lexical scope) của nó, ngay cả khi hàm bên ngoài đó đã thực thi xong. Ứng dụng phổ biến của Closure là để tạo ra các biến private (riêng tư) hoặc trong các hàm callback.",
      "level": "fresher"
    },
    {
      "question": "Prototype là gì?",
      "answer": "Trong JavaScript, các đối tượng kế thừa tính năng từ đối tượng khác thông qua cơ chế Prototype. Mỗi đối tượng đều có một thuộc tính ẩn (prototype) chứa các phương thức và thuộc tính chia sẻ. Khi truy cập một thuộc tính, nếu không tìm thấy ở đối tượng hiện tại, JS sẽ tự động tìm trong prototype của nó, tạo thành một chuỗi gọi là Prototype Chain.",
      "level": "fresher"
    },
    {
      "question": "Callback là gì?",
      "answer": "Callback là một hàm được truyền vào một hàm khác dưới dạng tham số, và sẽ được gọi lại (thực thi) sau khi hàm kia hoàn tất nhiệm vụ. Callback rất quan trọng trong xử lý bất đồng bộ (như gọi API, xử lý sự kiện click, timer).",
      "level": "fresher"
    },
    {
      "question": "Memoization là gì?",
      "answer": "Memoization là kỹ thuật tối ưu hóa tốc độ, bằng cách ghi nhớ (cache) lại kết quả của các lần tính toán trước đó. Nếu hàm được gọi lại với cùng tham số đầu vào, nó sẽ trả về kết quả đã lưu trong cache thay vì tính toán lại từ đầu.",
      "level": "fresher"
    },
    {
      "question": "Đệ quy là gì?",
      "answer": "Đệ quy là kỹ thuật mà một hàm tự gọi lại chính nó để giải quyết vấn đề nhỏ hơn của bài toán. Hàm đệ quy bắt buộc phải có một 'điểm dừng' (base case) để tránh việc gọi vô tận gây tràn bộ nhớ.",
      "level": "fresher"
    },
    {
      "question": "Hàm khởi tạo (Constructor functions) là gì?",
      "answer": "Hàm khởi tạo là các hàm dùng làm bản mẫu để tạo ra nhiều đối tượng có cấu trúc giống nhau. Tên hàm thường viết hoa chữ cái đầu (PascalCase) và được gọi cùng từ khóa 'new'.",
      "level": "fresher"
    },
    {
      "question": "DOM là gì?",
      "answer": "DOM (Document Object Model) là mô hình các đối tượng tài liệu. Nó coi trang HTML như một cây cấu trúc (DOM Tree). Thông qua DOM, JavaScript có thể truy cập, thay đổi nội dung, cấu trúc và kiểu dáng (CSS) của trang web.",
      "level": "fresher"
    },
    {
      "question": "Hàm Arrow (Arrow Function) khác gì hàm thường?",
      "answer": "Arrow Function (giới thiệu ở ES6) có cú pháp ngắn gọn hơn (dùng dấu =>). Sự khác biệt lớn nhất là Arrow Function không có 'this' của riêng nó (nó lấy this từ phạm vi cha), không có biến 'arguments', và không thể dùng làm hàm khởi tạo (constructor).",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa var, let và const?",
      "answer": "- var: Có phạm vi function scope, có thể khai báo lại, bị hoisting với giá trị undefined.\n- let: Có phạm vi block scope (trong {}), có thể gán lại giá trị nhưng không thể khai báo lại trong cùng scope, không được hoisting (rơi vào TDZ).\n- const: Giống let (block scope, không hoisting), nhưng KHÔNG thể gán lại giá trị (hằng số). Lưu ý: với object/array khai báo bằng const, ta vẫn có thể sửa đổi nội dung bên trong nó.",
      "level": "fresher"
    },
    {
      "question": "Tham số còn lại (Rest) và toán tử Spread là gì?",
      "answer": "Cả hai đều dùng dấu ba chấm (...), nhưng ngữ cảnh khác nhau:\n- Spread (...): Dùng để 'giải nén' các phần tử của mảng/đối tượng ra. Thường dùng để gộp mảng, sao chép đối tượng.\n- Rest (...): Dùng để 'gom' các tham số dư thừa vào thành một mảng. Thường dùng trong khai báo hàm khi không biết trước số lượng đối số.",
      "level": "fresher"
    },
    {
      "question": "Promise là gì và dùng để làm gì?",
      "answer": "Promise là một đối tượng đại diện cho kết quả của một tác vụ bất đồng bộ (sẽ hoàn thành hoặc thất bại trong tương lai). Nó giúp xử lý bất đồng bộ dễ đọc hơn so với callback, tránh lỗi 'Callback Hell'. Promise có 3 trạng thái: Pending (đang chờ), Fulfilled (thành công), Rejected (thất bại).",
      "level": "fresher"
    },
    {
      "question": "Class (Lớp) trong JavaScript là gì?",
      "answer": "Được giới thiệu trong ES6, Class là cú pháp mới (syntactic sugar) giúp việc viết lập trình hướng đối tượng dễ dàng và rõ ràng hơn so với dùng Prototype. Nó hỗ trợ các từ khóa như class, constructor, extends (kế thừa) nhưng bản chất bên dưới vẫn hoạt động dựa trên Prototype.",
      "level": "fresher"
    },
    {
      "question": "Hàm Generator là gì?",
      "answer": "Generator là một loại hàm đặc biệt có thể tạm dừng thực thi giữa chừng và tiếp tục lại sau đó. Nó dùng từ khóa 'function*' và 'yield'. Khi gọi generator, nó không chạy ngay mà trả về một iterator, ta dùng phương thức next() để chạy từng bước qua các điểm yield.",
      "level": "fresher"
    },
    {
      "question": "Giải thích WeakSet trong JavaScript?",
      "answer": "WeakSet là một tập hợp tương tự như Set (chứa các giá trị duy nhất), nhưng có điểm khác: chỉ được chứa Object (không chứa số, chuỗi...), và các tham chiếu đến object là 'yếu'. Nghĩa là nếu object đó không còn dùng ở đâu khác, nó sẽ tự động bị dọn dẹp khỏi bộ nhớ (Garbage Collection) ngay cả khi nó đang ở trong WeakSet.",
      "level": "fresher"
    },
    {
      "question": "Giải thích về WeakMap trong JavaScript?",
      "answer": "Tương tự Map (lưu cặp key-value), nhưng WeakMap yêu cầu key bắt buộc phải là Object. Cơ chế tham chiếu cũng là 'yếu' giống WeakSet, giúp quản lý bộ nhớ tốt hơn, tránh rò rỉ bộ nhớ (memory leak) khi các key object không còn cần thiết.",
      "level": "fresher"
    },
    {
      "question": "Destructuring (Hủy cấu trúc) là gì?",
      "answer": "Destructuring là cú pháp cho phép trích xuất dữ liệu từ mảng (Array) hoặc đối tượng (Object) và gán vào các biến riêng biệt một cách nhanh chóng, ngắn gọn mà không cần viết nhiều dòng code gán thủ công.",
      "level": "fresher"
    },
    {
      "question": "Temporal Dead Zone (Vùng chết tạm thời) là gì?",
      "answer": "Đây là thuật ngữ chỉ khoảng thời gian từ khi bắt đầu một scope cho đến khi biến (được khai báo bằng let hoặc const) thực sự được khai báo. Trong khoảng thời gian này, nếu cố gắng truy cập biến đó, chương trình sẽ báo lỗi ReferenceError.",
      "level": "fresher"
    }
  ]
}