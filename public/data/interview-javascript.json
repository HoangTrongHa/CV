{
  "id": "javascript",
  "name": "Câu hỏi phỏng vấn JavaScript",
  "description": "",
  "questions": [
    {
      "question": "Sự khác biệt giữa các kiểu dữ liệu trong JavaScript?",
      "answer": "<p>Trong JavaScript các kiểu dữ liệu được chia làm hai loại là kiểu nguyên thuỷ và đối tượng. Để biết kiểu dữ liệu của các biến JavaScript, ta có thể sử dụng <strong>typeof</strong>.\r\n\r\n<strong>Kiểu nguyên thuỷ</strong>\r\n\r\n<em><strong>String</strong></em> - biểu diễn một mảng ký tự hay một chuỗi. Kiểu chuỗi trong javascript có thể sử dụng một cặp dấu ngoặc kép hoặc dấu ngoặc kép đơn.\r\n\r\n``<code>js\r\n var str = &quot;Vivek Singh Bisht&quot;; //sử dụng dấu ngoặc kép\r\n var str2 = &#39;John Doe&#39;; // sử dụng dấu ngoặc đơn\r\n</code>`<code>\r\n\r\n<em><strong>Number</strong></em> - biểu diễn cả số nguyên và số thực.\r\n\r\n</code>`<code>js\r\nvar x = 3; // số nguyên\r\nvar y = 3.6; // số thực\r\n</code>`<code>\r\n\r\n<em><strong>BigInt</strong></em> - kiểu dữ liệu này được sử dụng để lưu trữ các số vượt quá giới hạn của kiểu dữ liệu Number. Nó có thể lưu trữ các số nguyên lớn và được biểu diễn bằng cách thêm “n” vào một chữ số nguyên.\r\n\r\n</code>`<code>js\r\nvar bigInteger =  234567890123456789012345678901234567890;\r\n</code>`<code>\r\n\r\n<em><strong>Boolean</strong></em> - kiểu luận lý, có hai giá trị là <em>true</em> và <em>false</em>. Thường được dùng với điều kiện.\r\n\r\n</code>`<code>js\r\nvar a = 2;\r\nvar b =  3;\r\nvar c =  2;\r\n(a == b) // trả về false\r\n(a == c) // trả về true\r\n</code>`<code>\r\n\r\n<em><strong>undefined</strong></em> - khi giá trị của một biến là không xác định.\r\n\r\n</code>`<code>js\r\nvar x; // giá trị của x là undefined\r\nvar y = undefined; // ta cũng có thể gán một biến là undefined\r\n</code>`<code>\r\n\r\n<em><strong>null</strong></em> - biểu diễn giá trị null. Vì JavaScript là case-sensitive, null sẽ không giống với</code> Null<code>, </code>NULL<code>, hoặc bất kỳ biến thể khác.\r\n\r\n</code>`<code>js\r\nvar z = null;\r\n</code>`<code>\r\n\r\n<em><strong>Symbol</strong></em> - mới được giới thiệu trong ES6. Nó lưu trữ các giá trị duy nhất và ẩn danh.\r\n\r\n</code>`<code>js\r\nvar symbol1 = Symbol(&#39;symbol&#39;);\r\n</code>`<code>\r\n\r\nSử dụng </code>typeof<code> để tìm kiểu nguyên thuỷ:\r\n\r\n</code>`<code>js\r\ntypeof &quot;John Doe&quot; // Returns &quot;string&quot;\r\ntypeof 3.14 // Returns &quot;number&quot;\r\ntypeof true // Returns &quot;boolean&quot;\r\ntypeof 234567890123456789012345678901234567890n // Returns bigint\r\ntypeof undefined // Returns &quot;undefined&quot;\r\ntypeof null // Returns &quot;object&quot; (đặc trưng của JavaScript)\r\ntypeof Symbol(&#39;symbol&#39;) // Returns Symbol\r\n</code>`<code>\r\n\r\nTrong JavaScript nếu dữ liệu không phải là kiểu nguyên thuỷ thì tất cả đều là object.\r\n\r\n<strong>Object</strong> dùng để lưu trữ tập hợp dữ liệu\r\n\r\n</code>`<code>js\r\n// Tập hợp dữ liệu dạng key-value \r\n\r\nvar obj1 = {\r\n   x:  43,\r\n   y:  &quot;Hello world!&quot;,\r\n   z: function(){\r\n      return this.x;\r\n   }\r\n}\r\n      \r\n// Tập hợp dữ liệu dạng danh sách\r\n      \r\nvar array1 = [5, &quot;Hello&quot;, true, 4.1];  \r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích về Hoisting trong Javascript?",
      "answer": "<p>Hoisting là một hành vi mặc định trong Javascript, nó sẽ chuyển tất cả khai báo biến và hàm lên trên cùng.\r\n\r\n<img src=\"/interview-assets/hoisting-in-js.png\" alt=\"hoisting\" />\r\n\r\nĐiều này có nghĩa là bất kể hàm và biến được khai báo ở đâu, chúng cũng sẽ đuọc chuyển lên đầu scope. Scope có thể là toàn cục hoặc cục bộ.\r\n\r\nVí dụ 1:\r\n\r\n``<code>js\r\nhoistedVariable = 3;\r\nconsole.log(hoistedVariable);\r\n// output là 3 vì biến được khởi tạo trước khi khai báo.\r\nvar hoistedVariable;\r\n</code>`<code>\r\n\r\nVí dụ 2:\r\n\r\n</code>`<code>js\r\nhoistedFunction();  \r\n// Outputs &quot; Hello world! &quot; kể cả khi hàm được khai báo sau khi gọi.\r\n\r\nfunction hoistedFunction(){ \r\n  console.log(&quot; Hello world! &quot;);\r\n}\r\n</code>`<code>\r\n\r\nVí dụ 3:\r\n\r\n</code>`<code>js\r\n// Hoisting takes place in the local scope as well\r\nfunction doSomething(){\r\n  x = 33;\r\n  console.log(x);\r\n  var x;\r\n}\r\n</code>`<code>\r\n\r\n<em>Lưu ý</em>: Khai báo biến được hoisting chứ phép gán biến thì không.\r\n\r\n</code>`<code>js\r\nvar x;\r\nconsole.log(x); // Output sẽ trả về &quot;undefined&quot; vì phép gán không được hoisting\r\nx = 23;\r\n</code>`<code>\r\n\r\n<em>Lưu ý</em>: Để tránh hoisting bạn có thể dùng &quot;use strict&quot;\r\n\r\n</code>`<code>js\r\n&quot;use strict&quot;;\r\nx = 23; // Báo lỗi x  chưa được khai báo\r\nvar x; \r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa toán tử \"==\" và \"===\" là như thế nào?",
      "answer": "<p>Cả hai đều dùng để so sánh, nhưng \"==\" có thể dùng với bất kỳ kiểu dữ liệu nào còn \"===\" chỉ dành cho cùng kiểu.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nvar x = 2;\r\nvar y = &quot;2&quot;;\r\n(x == y)  // Trả về true vì cả hai cùng giá trị\r\n\r\n(x === y) // Trả về false vì typeof x là &quot;number&quot; còn typeof y là &quot;string\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích về ép kiểu ngầm trong JavaScript?",
      "answer": "<p>Ép kiểu ngầm trong javascript là sự chuyển đổi tự động của giá trị từ kiểu dữ liệu này sang kiểu khác. Nó xảy ra khi thực hiện một biểu thức với các kiểu dữ liệu khác nhau.\r\n\r\n<strong>Ép kiểu String</strong>\r\n\r\nÉp kiểu string xảy ra khi dùng toán tử <code>+</code>. Một số cộng với một chuỗi, kiểu số sẽ bị ép thành kiểu chuỗi.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nvar x = 3;\r\nvar y = &quot;3&quot;;\r\nx + y // Returns &quot;33&quot; \r\n</code>`<code>\r\n\r\n</code>`<code>js\r\nvar x = 24;\r\nvar y = &quot;Hello&quot;;\r\nx + y   // Returns &quot;24Hello&quot;;\r\n</code>`<code>\r\n\r\nĐể hiểu về hai ví dụ khi ta cộng một số vào chuỗi, thì khi JavaScript thấy biểu thức </code>x+y<code> với hai kiểu khác nhau (một số và một chuỗi), nó chuyển đổi kiểu số thành chuỗi để thực hiện hành động. Sau khi chuyển đổi, cả hai biến đều là kiểu chuỗi, thao tác </code>+<code> lúc này sẽ thành phép nối chuỗi kết quả là ra chuỗi &quot;33&quot; và &quot;24Hello&quot;.\r\n\r\nNgược lại, khi thực hiện phép toán </code>-<code>, thì chuỗi lại bị ép kiểu ngầm thành số. Ví dụ:\r\n\r\n</code>`<code>js\r\nvar x = 3;\r\nVar y = &quot;3&quot;;\r\nx - y    //Returns 0 since the variable y (string type) is converted to a number type\r\n</code>`<code>\r\n\r\n<strong>Ép kiểu Boolean</strong>\r\n\r\nÉp kiểu boolean xảy ra khi sử dụng các toán tử logic, lệnh if hay kiểm tra vòng lặp. Để hiểu về ép kiểu logic, ta cần hiểu về giá trị <em>truthy</em> và <em>falsy</em>.\r\n\r\nGiá trị <em>truthy</em> là cái sẽ được ép kiểu thành <strong>true</strong>. Còn <em>falsy</em> sẽ được ép kiểu thành <strong>false</strong>.\r\n\r\nTất cả các giá trị ngoại trừ </code>0<code>, </code>0n<code>, </code>-0<code>, </code>\"\"<code>, </code>null<code>, </code>undefined<code>, và </code>NaN<code> thì đều là truthy.\r\n\r\nCâu lệnh If:\r\n\r\n</code>`<code>js\r\nvar x = 0;\r\nvar y = 23;\r\n        \r\nif(x) { console.log(x) }   // The code inside this block will not run since the value of x is 0(Falsy)  \r\n        \r\nif(y) { console.log(y) }    // The code inside this block will run since the value of y is 23 (Truthy)\r\n</code>`<code>\r\n\r\nToán tử Logic:\r\n\r\nToán tử logic trong javascript không giống các ngôn ngữ lập trình khác, <strong>nó không trả về true hay false, mà nó trả về một toán hạng</strong>.\r\n\r\nOR ( || ) - Nếu giá trị đầu tiên là truthy, giá trị đầu tiên sẽ được trả về, ngược lại thì nó trả về giá trị thứ hai.\r\n\r\nAND ( &amp;&amp; ) - Nếu hai giá trị đều là truthy, giá trị thứ hai sẽ được trả về. Nếu giá trị đầu là falsy sẽ trả về giá trị đầu hoặc giá trị hai là falsy sẽ trả về giá trị hai.\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nvar x = 220;\r\nvar y = &quot;Hello&quot;;\r\nvar z = undefined;\r\n        \r\nx | | y    // Returns 220 since the first value is truthy\r\n        \r\nx | | z   // Returns 220 since the first value is truthy\r\n        \r\nx &amp;&amp; y    // Returns &quot;Hello&quot; since both the values are truthy\r\n        \r\ny &amp;&amp; z   // Returns undefined since the second value is falsy\r\n        \r\nif( x &amp;&amp; y ){ \r\n  console.log(&quot;Code runs&quot; ); // This block runs because x &amp;&amp; y returns &quot;Hello&quot; (Truthy)\r\n}   \r\n        \r\nif( x || z ){\r\n  console.log(&quot;Code runs&quot;);  // This block runs because x || y returns 220(Truthy)\r\n}\r\n</code>`<code>\r\n\r\n<strong>Ép kiểu dấu bằng</strong>\r\n\r\nXảy ra khi thực hiện phép &quot;==&quot;. Nhớ lại thì phép <strong>&quot;==&quot; được dùng để so sánh hai giá trị khác kiểu</strong>.\r\n\r\nThực tế khi sử dụng &quot;==&quot; một ép kiểu ngầm đã xảy ra, chuyển đổi tất cả toán hạng về cùng kiểu và so sánh chúng.\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nvar a = 12;\r\nvar b = &quot;12&quot;;\r\na == b // Returns true because both &#39;a&#39; and &#39;b&#39; are converted to the same type and then compared. Hence the operands are equal.\r\n</code>`<code>\r\n\r\nÉp kiểu ngầm không xảy ra khi dùng &quot;===&quot;. \r\n\r\n</code>`<code>js\r\nvar a = 226;\r\nvar b = &quot;226&quot;;\r\n\r\na === b // Returns false because coercion does not take place and the  operands are of different types. Hence they are not equal.\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "JavaScript là ngôn ngữ kiểu tĩnh hay kiểu động?",
      "answer": "<p>JavaScript là ngôn ngữ kiểu động. Trong ngôn ngữ kiểu động, kiểu dữ liệu của biến được kiểm tra trong khi đang chạy chương trình ngược lại với kiểu tĩnh, nơi kiểu dữ liệu của biến được kiểm tra khi biên dịch.\r\n\r\n<img src=\"/interview-assets/static_vs_dynamic_typing.png\" alt=\"\" />\r\n\r\nVì Javascript là ngôn ngữ kiểu động, nên một biến có thể giữ bất kỳ kiểu dữ liệu nào. Ví dụ:\r\n\r\n``<code>js\r\nvar a = 23;\r\nvar a = &quot;Hello World!&quot;;\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Thuộc tính NaN trong JavaScript là gì?",
      "answer": "<p>Thuộc tính NaN biểu diễn một giá trị <strong>Not-a-Number</strong>. Nó biểu thị một giá trị không phải là số.\r\n\r\n<code>typeof</code> của NaN trả về <code>Number</code>. Muốn kiểm tra một giá trị có phải NaN không, có thể dùng hàm <code>isNaN()</code>.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nisNaN(&quot;Hello&quot;)  // Returns true\r\nisNaN(345)   // Returns false\r\nisNaN(&#39;1&#39;)  // Returns false, since &#39;1&#39; is converted to Number type which results in 0 ( a number) \r\nisNaN(true) // Returns false, since true converted to Number type results in 1 ( a number)\r\nisNaN(false) // Returns false\r\nisNaN(undefined) // Returns true\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích về phép gán quá giá trị và phép gán qua tham chiếu?",
      "answer": "<p>Trong JavaScript, kiểu dữ liệu nguyên thuỷ được gán với giá trị, còn kiểu đối tượng được gán bằng tham chiếu.\r\n\r\nTrước tiên, ta cần hiểu về điều gì xảy ra khi ta tạo một biến và gán giá trị cho nó.\r\n\r\n``<code>js\r\nvar x = 2;\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, ta tạo một biến </code>x<code> và gán nó giá trị là &quot;2&quot;. Phép &quot;=&quot; chỉ định một vài không gian trong bộ nhớ, để lưu trữ giá trị là &quot;2&quot; và trả về vị trí được chỉ định trong bộ nhớ. Do đó, biến </code>x<code> ở trên trỏ đến vị trí trong bộ nhớ thay vì trỏ trực tiếp đến giá trị 2.\r\n\r\nPhép gán thực hiện hành vi khác nhau khi làm việc với kiểu nguyên thuỷ và kiểu đối tượng.\r\n\r\n<strong>Phép gán với kiểu nguyên thuỷ</strong>\r\n\r\n<img src=\"/interview-assets/passed_by_value.png\" alt=\"\" />\r\n\r\n</code>`<code>js\r\nvar y = 234;\r\nvar z = y;\r\n</code>`<code>\r\n\r\nỞ ví dụ này, dòng đầu phép gán giá trị cho </code>y<code> là kiểu nguyên thuỷ, sau đó ở dòng thứ hai, giá trị của </code>y<code> được gán cho </code>z<code>. Phép gán chỉ định một vùng không gian mới trong bộ nhớ và trả về địa chỉ của nó. Do đó, biến </code>z<code> không chỉ đến vị trí của biến </code>y<code> thay vào đó nó chỉ đến vùng không gian mới trong bộ nhớ.\r\n\r\n</code>`<code>js\r\nvar y = #8454; // y pointing to address of the value 234\r\n\r\nvar z = y; \r\n        \r\nvar z = #5411; // z pointing to a completely new address of the value 234\r\n        \r\n// Changing the value of y\r\ny = 23;\r\nconsole.log(z);  // Returns 234, since z points to a new address in the memory so changes in y will not effect z\r\n</code>`<code>\r\n\r\nTừ ví dụ trên, ta có thể thấy rằng các kiểu dữ liệu nguyên thủy khi được truyền cho một biến khác sẽ được truyền theo giá trị. Thay vì chỉ gán cùng một địa chỉ cho một biến khác, giá trị sẽ được gán và không gian bộ nhớ mới được tạo ra.\r\n\r\n<strong>Phép gán với kiểu đối tượng</strong>\r\n\r\n<img src=\"/interview-assets/passed_by_reference.png\" alt=\"\" />\r\n\r\n</code>`<code>js\r\nvar obj = { name: &quot;Vivek&quot;, surname: &quot;Bisht&quot; };\r\n\r\nvar obj2 = obj;\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, phép gán truyền trực tiếp vị trí của biến </code>obj<code> đến biến </code>obj2<code>. Nói cách khác, tham chiếu của biến </code>obj<code> được chuyển cho biến </code>obj2<code>.\r\n\r\n</code>`<code>js\r\nvar obj = #8711;  // obj pointing to address of { name: &quot;Vivek&quot;, surname: &quot;Bisht&quot; }\r\n\r\nvar obj2 = obj;\r\n        \r\nvar obj2 = #8711; // obj2 pointing to the same address \r\n        \r\n        \r\n// changing the value of obj1\r\n        \r\nobj1.name = &quot;Akki&quot;;\r\n        \r\nconsole.log(obj2);\r\n        \r\n// Returns {name:&quot;Akki&quot;, surname:&quot;Bisht&quot;} since both the variables are pointing to the same address.\r\n</code>``\r\n\r\nTừ ví dụ trên, ta có thể thấy rằng trong khi truyền các kiểu dữ liệu đối tượng, phép gán trực tiếp truyền địa chỉ (tham chiếu).\r\n\r\nDo đó, các kiểu dữ liệu đối tượng luôn được truyền bằng tham chiếu.</p>",
      "level": "fresher"
    },
    {
      "question": "IIFE là gì trong JavaScript?",
      "answer": "<p>Immediately Invoked Function (IIFE) là một hàm được chạy ngay sau khi nó được định nghĩa.\r\n\r\nCú pháp của IIFE:\r\n\r\n``<code>js\r\n(function(){ \r\n  // Do something;\r\n})();\r\n</code>`<code>\r\n\r\nĐể hiểu về IIFE, trước hết cần hiểu về hai dấu ngoặc đơn được thêm vào để tạo IIFE.\r\n\r\nDấu ngoặc đơn đầu tiên:\r\n\r\n</code>`<code>js\r\n(function (){\r\n   //Do something;\r\n})\r\n</code>`<code>\r\n\r\nKhi thực thi code javascript, bất cứ khi nào trình biên dịch bắt gặp từ &quot;function&quot; nó cũng sẽ cho rằng ta đang khai báo một function. Do đó, nếu ta không dùng dấu ngoặc đơn, trình biên dịch sẽ báo lỗi vì nó nghĩa ta đang khái báo một function và theo cú pháp thì các function buộc phải có tên.\r\n\r\nĐể tránh lỗi ta thêm dấu ngoặc đơn vào để trình biên dịch biết đây không phải là khai báo function mà là một biểu thức function.\r\n\r\nDấu ngoặc đơn thứ hai:\r\n\r\n</code>`<code>js\r\n(function (){\r\n  //Do something;\r\n})();\r\n</code>``\r\n\r\nTừ định nghĩa IIFE, ta biết rằng code sẽ chạy ngay sai khi khai báo. Một function chỉ chạy khi nó được gọi. Nếu ta không gọi, thì chúng ta chỉ nhận về được khai báo hàm.\r\n\r\nDo đó để gọi function ta sử dụng dấu ngoặc đơn thứ hai.</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích về HOC(Higher Order Functions) trong JavaScript?",
      "answer": "<p>Các hàm hoạt động trên các hàm khác bằng cách sử dụng chúng làm tham số hoặc kết quả trả về thì được gọi là Higher Order Functions - HOC. Ví dụ:\r\n\r\n``<code>js\r\nfunction higherOrder(fn) {\r\n  fn();\r\n}\r\n     \r\nhigherOrder(function() { console.log(&quot;Hello world&quot;) }); \r\n</code>`<code>\r\n\r\n</code>`<code>js\r\nfunction higherOrder2() {\r\n  return function() {\r\n    return &quot;Do something&quot;;\r\n  }\r\n}\r\n        \r\nvar x = higherOrder2();\r\nx()   // Returns &quot;Do something&quot;\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích về \"this\"?",
      "answer": "<p>Từ khoá \"this\" trong javascript tham chiếu đến một đối tượng có thuộc tính là một hàm.\r\n\r\nGiá trị của \"this\" phụ thuộc vào đối tượng đang gọi hàm.\r\n\r\nGiả sử ta có code sau:\r\n\r\n``<code>js\r\nfunction doSomething() {\r\n  console.log(this);\r\n}\r\n        \r\ndoSomething();\r\n</code>`<code>\r\n\r\nNhư vậy theo định nghĩa, this tham chiếu đến một đối tượng có hàm là thuộc tính. Vậy trong đoạn code trên hàm là thuộc tính của đối tượng nào?\r\n\r\nVì hàm được gọi từ ngữ cảnh tổng thể, nên <strong>hàm sẽ là thuộc tính của đối tượng toàn cục</strong>. Do đó, nếu ta chạy đoạn code trên trình duyệt kết quả sẽ là <strong>window object</strong>.\r\n\r\nVí dụ 2:\r\n\r\n</code>`<code>js\r\nvar obj = {\r\n    name:  &quot;vivek&quot;,\r\n    getName: function(){\r\n    console.log(this.name);\r\n  }\r\n}\r\n        \r\nobj.getName();\r\n</code>`<code>\r\n\r\nTrong đoạn code này, hàm </code>getName<code> là thuộc tính của </code>obj<code>. Do đó, <strong>this</strong> sẽ tham chiếu đến đối tượng </code>obj<code>, và output sẽ là &quot;vivek&quot;.\r\n\r\nVí dụ 3:\r\n\r\n</code>`<code>js\r\nvar obj = {\r\n    name:  &quot;vivek&quot;,\r\n    getName: function(){\r\n    console.log(this.name);\r\n  }\r\n        \r\n}\r\n        \r\nvar getName = obj.getName;\r\n        \r\nvar obj2 = {name:&quot;akshay&quot;, getName };\r\nobj2.getName();\r\n</code>`<code>\r\n\r\nOutput sẽ là &quot;akshay&quot;. Mặc dù hàm </code>getName<code> được khai báo trong đối tượng </code>obj<code>, nhưng ở thời điểm gọi thì </code>getName()<code> lại là thuộc tính của </code>obj2<code>, do đó &quot;this&quot; sẽ tham chiếu đến </code>obj2<code>. \r\n\r\nCách ngớ ngẩn để hiểu &quot;this&quot; là, bất cứ khi nào hàm được gọi, hãy kiểm tra đối tượng trước dấu chấm. Giá trị của this sẽ luôn là đối tượng trước dấu chấm.\r\n\r\nNếu không có đối tượng nào như ở ví dụ 1, giá trị sẽ là đối tượng toàn cục.\r\n\r\nVí dụ 4:\r\n\r\n</code>`<code>js\r\nvar obj1 = {\r\n    address : &quot;Mumbai,India&quot;,\r\n    getAddress: function(){\r\n    console.log(this.address); \r\n  }\r\n}\r\n       \r\nvar getAddress = obj1.getAddress;\r\nvar obj2 = {name:&quot;akshay&quot;};\r\nobj2.getAddress();   \r\n</code>`<code>\r\n\r\nKết quả sẽ là lỗi, vì từ khóa this tham chiếu đến đối tượng </code>obj2<code>, nhưng </code>obj2<code> không có thuộc tính “address” ‘, do đó hàm </code>getAddress` sẽ xảy ra lỗi.</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích về phương thức call(), aplly() và bind()?",
      "answer": "<p>#</p>",
      "level": "fresher"
    },
    {
      "question": "Currying trong JavaScript là gì?",
      "answer": "<p>Currying là một kỹ thuật nâng cao để biến đổi một hàm với n tham số, thành n hàm với một tham số duy nhất.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nfunction add (a) {\r\n  return function(b){\r\n    return a + b;\r\n  }\r\n}\r\n\r\nadd(3)(4)\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, ta có hàm </code>f(a,b)<code> sau khi currying ta đã biến đổi nó thành </code>f(a)(b)<code>.\r\n\r\nBằng cách sử dụng kỹ thuật currying, chúng ta không thay đổi chức năng của một hàm, mà chỉ thay đổi cách nó được gọi.\r\n\r\n</code>`<code>js\r\nfunction multiply(a,b){\r\n  return a*b;\r\n}\r\n\r\nfunction currying(fn){\r\n  return function(a){\r\n    return function(b){\r\n      return fn(a,b);\r\n    }\r\n  }\r\n}\r\n\r\nvar curriedMultiply = currying(multiply);\r\n\r\nmultiply(4, 3); // Returns 12\r\n\r\ncurriedMultiply(4)(3); // Also returns 12\r\n</code>`<code>\r\n\r\nNhư ta có thể thấy trong đoạn code trên, chúng ta đã chuyển đổi hàm </code>multiply(a, b)<code> thành một hàm </code>curriedMultiply`, nhận một tham số tại một thời điểm.</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích về Scope và Scope Chain?",
      "answer": "<p>Scope trong JS, xác định khả năng truy cập của các biến, hàm ở các phần khác nhau trong một đoạn code.\r\n\r\nNói chung, Scope cho biết phạm vi mà biến và hàm của ta có thể hay không thể truy cập. Có 3 loại scope trong JS:\r<ul><li>Global Scope</li></ul>\r<ul><li>Local hay Function Scope</li></ul>\r<ul><li>Block Scope</li></ul>\r\n\r\n#</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích về Closures trong JavaScript?",
      "answer": "<p>Closures là khả năng của một hàm ghi nhớ các biến và hàm được khai báo bên ngoài phạm vi của nó.\r\n\r\n``<code>js\r\nvar Person = function(pName){\r\n  var name = pName;\r\n\r\n  this.getName = function(){\r\n    return name;\r\n  }\r\n}\r\n\r\nvar person = new Person(&quot;Neelesh&quot;);\r\nconsole.log(person.getName());\r\n</code>`<code>\r\n\r\nHiểu closure qua ví dụ sau:\r\n\r\n</code>`<code>js\r\nfunction randomFunc(){\r\n  var obj1 = {name:&quot;Vivian&quot;, age:45};\r\n\r\n  return function(){\r\n    console.log(obj1.name + &quot; is &quot;+ &quot;awesome&quot;); // Has access to obj1 even when the randomFunc function is executed\r\n\r\n  }\r\n}\r\n\r\nvar initialiseClosure = randomFunc(); // Returns a function\r\n\r\ninitialiseClosure(); \r\n</code>`<code>\r\n\r\nTrong đoạn code trên:\r\n\r\nHàm </code>randomFunc()<code> được thực thi và trả về một hàm khi ta thực hiện phép gán:\r\n\r\n</code>`<code>js\r\nvar initialiseClosure = randomFunc();\r\n</code>`<code>\r\n\r\nHàm được trả về được thực thi khi ta gọi </code>initialiseClosure<code>:\r\n\r\n</code>`<code>js\r\ninitialiseClosure();\r\n</code>`<code>\r\n\r\nKết quả sẽ là &quot;Vivian is awesome&quot; điều này xảy ra là do closure.\r\n\r\nKhi hàm </code>randomFunc()<code> chạy, nó sẽ thấy rằng hàm trả về đang sử dụng biến </code>obj1<code> bên trong nó: \r\n\r\n</code>`<code>js\r\nconsole.log(obj1.name + &quot; is &quot;+ &quot;awesome&quot;);\r\n</code>`<code>\r\n\r\nDo đó, </code>randomFunc()<code>, thay vì hủy giá trị của </code>obj1` sau khi thực thi, sẽ lưu giá trị lại vào trong bộ nhớ để tham khảo thêm. Đây là lý do tại sao hàm trả về có thể sử dụng biến được khai báo bên ngoài phạm vi ngay cả sau khi hàm đã được thực thi.\r\n\r\n<strong>Khả năng này của một hàm nhằm lưu trữ một biến để tham khảo thêm ngay cả sau khi nó được thực thi, được gọi là Closure.</strong></p>",
      "level": "fresher"
    },
    {
      "question": "Prototype là gì?",
      "answer": "<p>Tất cả các đối tượng javascript đều kế thừa các thuộc tính từ một <strong>prototype</strong>.\r\n\r\nVí dụ:\r\n\r\nĐối tượng Date kế thừa các thuộc tính từ prototype Date.\r\n\r\nĐối tượng Math kế thừa các thuộc tính từ prototype Math.\r\n\r\nĐối tượng Array kế thừa các thuộc tính từ prototype Array.\r\n\r\nTrên đầu chuỗi là <code>Object.prototype</code>. Mọi prototype đều kế thừa các thuộc tính và phương thức từ <code>Object.prototype</code>.\r\n\r\nPrototype là một bản thiết kế của một đối tượng. Prototype cho phép chúng ta sử dụng các thuộc tính và phương thức trên một đối tượng ngay cả khi các thuộc tính và phương thức không tồn tại trên đối tượng hiện tại.\r\n\r\n<img src=\"/interview-assets/object_prototype.png\" alt=\"\" />\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nvar arr = [];\r\narr.push(2);\r\n\r\nconsole.log(arr); // Outputs [2]\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, có thể thấy ta chưa xác định bất kỳ thuộc tính hoặc phương thức nào được gọi là push trên mảng </code>arr<code> nhưng javascript engine không đưa ra lỗi.\r\n\r\nLý do là việc sử dụng các prototype. Như đã thảo luận trước đây, các đối tượng Array kế thừa các thuộc tính từ prototype Array.\r\n\r\nJavascript engine thấy rằng phương thức </code>push` không tồn tại trên đối tượng mảng hiện tại, do đó nó tìm kiếm phương thức push bên trong prototype Array và nó tìm thấy phương thức.\r\n\r\nBất cứ khi nào thuộc tính hoặc phương thức không được tìm thấy trên đối tượng hiện tại, javascript engine sẽ luôn tìm kiếm trong prototype của nó và nếu nó vẫn không tồn tại, nó sẽ tìm bên trong prototype của prototype, v.v.</p>",
      "level": "fresher"
    },
    {
      "question": "Callback là gì?",
      "answer": "<p>Callback là một hàm sẽ được thực thi sau khi một hàm khác được thực thi.\r\n\r\nTrong javascript, các hàm được coi như là <strong>first-class citizens</strong>, chúng có thể được sử dụng như một tham số của một hàm khác, có thể được trả về bởi một hàm khác và có thể được sử dụng như một thuộc tính của một đối tượng.\r\n\r\nCác hàm được sử dụng làm tham số cho một hàm khác được gọi là hàm callback.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nfunction divideByHalf(sum){\r\n  console.log(Math.floor(sum / 2));\r\n}\r\n\r\nfunction multiplyBy2(sum){\r\n  console.log(sum * 2);\r\n}\r\n\r\nfunction operationOnSum(num1,num2,operation){\r\n  var sum = num1 + num2;\r\n  operation(sum);\r\n}\r\n\r\noperationOnSum(3, 3, divideByHalf); // Outputs 3\r\n\r\noperationOnSum(5, 5, multiplyBy2); // Outputs 20\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta đang thực hiện các phép toán cộng hai số.\r\n\r\nHàm </code>operationOnSum<code> nhận 3 tham số, </code>num1<code>, </code>num2<code> và </code>operator<code> sẽ được thực hiện trên tổng của chúng (callback).\r\n\r\nCả hai hàm </code>splitByHalf<code> và </code>MultiBy2<code> đều được sử dụng làm hàm callback trong đoạn code trên.\r\n\r\nCác hàm callback này chỉ được thực thi sau khi thực thi hàm </code>operationOnSum`.\r\n\r\nDo đó, callback là một hàm sẽ được thực thi sau khi một hàm khác được thực thi.</p>",
      "level": "fresher"
    },
    {
      "question": "Memoization là gì?",
      "answer": "<p>Memoization là một dạng bộ nhớ đệm trong đó giá trị trả về của một hàm được lưu vào bộ đệm dựa trên các tham số của nó. Nếu tham số của hàm đó không được thay đổi, phiên bản được lưu trong bộ nhớ cache của hàm sẽ được trả về.\r\n\r\nChúng ta có thể hiểu memoization, bằng cách chuyển đổi một hàm đơn giản thành một hàm được ghi nhớ:\r\n\r\n``<code>js\r\nfunction addTo256(num){\r\n  return num + 256;\r\n}\r\n\r\naddTo256(20); // Returns 276\r\naddTo256(40); // Returns 296\r\naddTo256(20); // Returns 276\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, chúng ta đã viết một hàm thêm tham số vào 256 và trả về nó.\r\n\r\nKhi gọi lại hàm </code>addTo256<code> với cùng một tham số (“20” trong trường hợp trên), ta đang tính toán lại kết quả cho cùng một tham số.\r\n\r\nTính toán kết quả với cùng một tham số không phải là vấn đề lớn trong trường hợp trên, nhưng hãy tưởng tượng nếu hàm thực hiện một số công việc nặng nhọc, thì việc tính toán kết quả lặp đi lặp lại với cùng một tham số sẽ dẫn đến lãng phí thời gian.\r\n\r\nĐây là lúc memoization xuất hiện, bằng cách sử dụng memoization, chúng ta có thể lưu trữ (bộ nhớ đệm) các kết quả được tính toán dựa trên các tham số. Nếu cùng một tham số được sử dụng lại trong khi gọi hàm, thay vì tính toán kết quả, chúng tôi trực tiếp trả về giá trị đã lưu trữ (đã lưu trong bộ nhớ cache).\r\n\r\nHãy chuyển đổi hàm </code>addTo256<code> ở trên, thành một hàm được ghi nhớ:\r\n\r\n</code>`<code>js\r\nfunction memoizedAddTo256(){\r\n  var cache = {};\r\n\r\n  return function(num){\r\n    if(num in cache){\r\n      console.log(&quot;cached value&quot;);\r\n      return cache[num]\r\n\r\n    }\r\n    else{\r\n      cache[num] = num + 256;\r\n      return cache[num];\r\n    }\r\n  }\r\n}\r\n\r\nvar memoizedFunc = memoizedAddTo256();\r\n\r\nmemoizedFunc(20); // Normal return\r\nmemoizedFunc(20); // Cached return\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, nếu ta chạy hàm </code>memoizedFunc` với cùng một tham số, thay vì tính toán lại kết quả, nó sẽ trả về kết quả được lưu trong bộ nhớ cache.\r\n\r\n<em>Lưu ý</em> Mặc dù sử dụng memoization tiết kiệm thời gian, nhưng nó dẫn đến tiêu thụ bộ nhớ lớn hơn vì ta đang lưu trữ tất cả các kết quả được tính toán.</p>",
      "level": "fresher"
    },
    {
      "question": "Đệ quy là gì?",
      "answer": "<p>Đệ quy là một kỹ thuật lặp đi lặp lại một hoạt động bằng cách tự gọi hàm lặp đi lặp lại cho đến khi nó đi đến kết quả.\r\n\r\n``<code>js\r\nfunction add(number) {\r\n  if (number &lt;= 0) {\r\n    return 0;\r\n  } else {\r\n    return number + add(number - 1);\r\n  }\r\n}\r\n\r\nadd(3) =&gt; 3 + add(2)\r\n          3 + 2 + add(1)\r\n          3 + 2 + 1 + add(0)\r\n          3 + 2 + 1 + 0 = 6  \r\n</code>`<code>\r\n\r\nVí dụ về một hàm đệ quy:\r\n\r\nHàm sau đây tính tổng của tất cả các phần tử trong một mảng bằng cách sử dụng đệ quy:\r\n\r\n</code>`<code>js\r\nfunction computeSum(arr){\r\n  if(arr.length === 1){\r\n    return arr[0];\r\n  }\r\n  else{\r\n    return arr.pop() + computeSum(arr);\r\n  }\r\n}\r\n\r\ncomputeSum([7, 8, 9, 99]); // Returns 123\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Hàm khởi tạo trong JavaScript",
      "answer": "<p>Các hàm khởi tạo được sử dụng để tạo các đối tượng trong javascript.\r\n\r\nKhi nào chúng ta sử dụng các hàm khởi tạo?\r\n\r\nNếu chúng ta muốn tạo nhiều đối tượng có các thuộc tính và phương thức giống nhau, các hàm khởi tạo được sử dụng.\r\n\r\n<em>Lưu ý</em> - Tên của một hàm khởi tạo phải luôn được viết bằng Ký hiệu Pascal: mọi từ phải bắt đầu bằng một chữ cái viết hoa.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nfunction Person(name,age,gender){\r\n  this.name = name;\r\n  this.age = age;\r\n  this.gender = gender;\r\n}\r\n\r\n\r\nvar person1 = new Person(&quot;Vivek&quot;, 76, &quot;male&quot;);\r\nconsole.log(person1);\r\n\r\nvar person2 = new Person(&quot;Courtney&quot;, 34, &quot;female&quot;);\r\nconsole.log(person2);\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta đã tạo một hàm khởi tạo có tên là Person.\r\n\r\nBất cứ khi nào chúng ta muốn tạo một đối tượng mới kiểu Person,\r\n\r\nChúng tôi cần tạo nó bằng cách sử dụng từ khóa mới:\r\n\r\n</code>`<code>js\r\nvar person3 = new Person(&quot;Lilly&quot;, 17, &quot;female&quot;);\r\n</code>``\r\n\r\nDòng code trên sẽ tạo một đối tượng mới kiểu Person.\r\n\r\nCác hàm khởi tạo cho phép chúng ta nhóm các đối tượng tương tự nhau.</p>",
      "level": "fresher"
    },
    {
      "question": "DOM là gì?",
      "answer": "<p>DOM là viết tắt của Document Object Model.\r\n\r\nDOM là interface lập trình của tài liệu XML và HTML.\r\n\r\nKhi trình duyệt cố gắng hiển thị một tài liệu HTML, nó sẽ tạo một đối tượng dựa trên tài liệu HTML được gọi là DOM. Sử dụng DOM này, chúng ta có thể thao tác hoặc thay đổi các phần tử khác nhau bên trong tài liệu HTML.\r\n\r\nVí dụ về cách code HTML được chuyển đổi thành DOM:\r\n\r\n<img src=\"/interview-assets/dom.png\" alt=\"\" />\r\n\r\n## Câu hỏi dành cho Experiencer</p>",
      "level": "fresher"
    },
    {
      "question": "Hàm arrow là gì?",
      "answer": "<p>Arrow function được giới thiệu từ phiên bản ES6 của javascript.\r\n\r\nNó cung cấp một cú pháp mới và ngắn hơn cho khai báo hàm. Hàm arrow có thể xử dụng như là một biểu thức hàm. Ta sẽ so sánh khai báo hàm thông thường với hàm arrow.\r\n\r\n``<code>js\r\n// Traditional Function Expression\r\nvar add = function(a,b){\r\n  return a + b;\r\n}\r\n\r\n// Arrow Function Expression\r\nvar arrowAdd = (a,b) =&gt; a + b;\r\n</code>`<code>\r\n\r\nHàm arrow khai báo mà không cần từ khoá </code>function<code>. Nếu nó chỉ trả về một biểu thức hàm thì ta không cần sử dụng từ khoá </code>return<code> như trong ví dụ trên. Ngoài ra, đối với các hàm chỉ có một dòng, có thể bỏ qua dấu ngoặc nhọn </code>{}<code>.\r\n\r\n</code>`<code>js\r\n// Traditional function expression\r\nvar multiplyBy2 = function(num){\r\n  return num <em> 2;\r\n}\r\n// Arrow function expression\r\nvar arrowMultiplyBy2 = num =&gt; num </em> 2;\r\n</code>`<code>\r\n\r\nNếu hàm chỉ nhận một tham số, ta có thể bỏ dấu ngoặc đơn xung quanh nó như ví dụ trên.\r\n\r\n</code>`<code>js\r\nvar obj1 = {\r\n  valueOfThis: function(){\r\n    return this;\r\n  }\r\n}\r\nvar obj2 = {\r\n  valueOfThis: ()=&gt;{\r\n    return this;\r\n  }\r\n}\r\n\r\nobj1.valueOfThis(); // Will return the object obj1\r\nobj2.valueOfThis(); // Will return window/global object\r\n</code>`<code>\r\n\r\nSự khác biệt lớn nhất giữa nhất giữa hàm truyền thống với arrow, là ở từ khoá <strong>this</strong>.\r\n\r\nNhư định nghĩa, từ khoá this tham chiếu đến đối tượng chứa hàm được gọi.\r\n\r\nNhư bạn có thể thấy, </code>obj1.valueOfThis()<code> trả về </code>obj1<code>, vì từ khoá </code>this<code> tham chiếu đến đối tượng chứa hàm đang gọi.\r\n\r\nCòn ở hàm arrow, không có ràng buộc nào của từ khóa this.\r\n\r\nTừ khoá this trong hàm arrow, không tham chiếu đến đối tượng đang gọi nó. Nó kế thừa giá trị của nó từ phạm vi cha là </code>window object<code> trong trường hợp này. \r\n\r\nDo đó, trong đoạn code trên, </code>obj2.valueOfThis()` trả về window object.</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biết của biến dùng var, let và const",
      "answer": "<p>Từ phiên bản ES6, từ khoá let và const được thêm vào cho khai báo biến.\r\n\r\n| keyword | const | let | var |\r\n|---------|-------|-----|-----|\r\n|global scope | no | no | yes |\r\n|function scope | yes | yes | yes |\r\n|block scope | yes | yes | no |\r\n|can be reassigned | no | yes | yes | \r\n\r\nTa thử xem các ví dụ:\r\n\r\n``<code>js\r\nvar variable1 = 23;\r\n\r\nlet variable2 = 89;\r\n\r\nfunction catchValues(){\r\n  console.log(variable1);\r\n  console.log(variable2);\r\n\r\n// Both the variables can be accessed anywhere since they are declared in the global scope\r\n}\r\n\r\nwindow.variable1; // Returns the value 23\r\n\r\nwindow.variable2; // Returns undefined   \r\n</code>`<code>\r\n\r\nCác biến được khai báo với từ khóa </code>let<code> trong global scope sẽ hoạt động giống như biến được khai báo với từ khóa </code>var<code> trong global scope.\r\n\r\nCác biến được khai báo trong global scope với từ khóa var và let có thể được truy cập từ bất kỳ đâu trong code.\r\n\r\nNhưng, có một sự khác biệt!\r\n\r\nCác biến được khai báo với từ khóa var trong global scope được thêm vào đối tượng window/global. Do đó, chúng có thể được truy cập bằng </code>window.variableName<code>.\r\n\r\nTrong khi đó, các biến được khai báo với từ khóa let không được thêm vào đối tượng toàn cục, do đó, việc cố gắng truy cập các biến đó bằng cách sử dụng </code>window.variableName<code> sẽ dẫn đến lỗi.\r\n\r\n<strong>var và let ở function scope</strong>\r\n\r\n</code>`<code>js\r\nfunction varVsLetFunction(){\r\n  let awesomeCar1 = &quot;Audi&quot;;\r\n  var awesomeCar2 = &quot;Mercedes&quot;;\r\n}\r\n\r\nconsole.log(awesomeCar1); // Throws an error\r\nconsole.log(awesomeCar2); // Throws an error\r\n</code>`<code>\r\n\r\nCác biến được khai báo trong function scope bằng cách sử dụng </code>var<code> và </code>let<code> hoạt động hoàn toàn giống nhau, nghĩa là chúng không thể được truy cập từ bên ngoài phạm vi.\r\n\r\n</code>`<code>js\r\n{\r\n  var variable3 = [1, 2, 3, 4];\r\n}\r\n\r\nconsole.log(variable3); // Outputs [1,2,3,4]\r\n\r\n{\r\n  let variable4 = [6, 55, -1, 2];\r\n}\r\n\r\nconsole.log(variable4); // Throws error\r\n\r\nfor(let i = 0; i &lt; 2; i++){\r\n  //Do something\r\n}\r\n\r\nconsole.log(i); // Throws error\r\n\r\nfor(var j = 0; j &lt; 2; i++){\r\n  // Do something\r\n}\r\n\r\nconsole.log(j) // Outputs 2\r\n</code>`<code>\r\n\r\nTrong javascript, một khối có nghĩa là code được viết bên trong dấu ngoặc nhọn </code>{}<code>.\r\n\r\nCác biến được khai báo với từ khóa var không có block scope. Nó có nghĩa là một biến được khai báo trong block scope </code>{}` với từ khóa var cũng giống như khai báo biến trong global scope.\r\n\r\nCác biến được khai báo với từ khóa let bên trong block scope không thể được truy cập từ bên ngoài khối.\r\n\r\n#</p>",
      "level": "fresher"
    },
    {
      "question": "Tham số còn lại và toán tử spread là gì?",
      "answer": "<p>Cả hai đều được giới thiệu ở phiên bản ES6\r\n\r\n#</p>",
      "level": "fresher"
    },
    {
      "question": "Sử dụng Promise trong JavaScript",
      "answer": "<p><strong>Promise dùng cho xử lý bất đồng bộ trong JavaScript</strong>\r\n\r\nTrước promise, callback được dùng cho các thao tác bất đồng bộ. Nhưng callback có giới hạn của nó, nếu sử dụng quá nhiều callback code sẽ trở nên khó quản lý.\r\n\r\nĐối tượng promise có 4 trạng thái:\r<ul><li><strong>Pending</strong>: trạng thái bắt đầu, biểu diễn promise không phải là fulfilled, cũng không phải là rejected mà đang ở trạng thái pending.</li></ul>\r<ul><li><strong>Fulfilled</strong>: trạng thái này có nghĩa là thao tác bất đồng bộ đã hoàn tất.</li></ul>\r<ul><li><strong>Rejected</strong>: trạng này này có nghĩa là thao tác đã thất bại vì một vài lý do nào đó.</li></ul>\r<ul><li><strong>Settked</strong>: trạng thái này thể hiện promise đã rejected hoặc fulfilled.</li></ul>\r\n\r\nMột promise được tạo bằng cách sử dụng phương thức khởi tạo Promise, hàm này nhận một hàm callback với hai tham số, <code>resolve</code> và <code>reject</code> tương ứng.\r\n\r\n<img src=\"/interview-assets/js_promise_resolve_reject.png\" alt=\"\" />\r<ul><li><strong>resolve</strong> hàm được gọi, khi thao tác bất đồng bộ thực hiện thành công.</li></ul>\r<ul><li><strong>reject</strong> hàm được gọi, khi thao tác thất bại bởi một vài lỗi nào đó.</li></ul>\r\n\r\nVí dụ:\r\n\r\nPromise được dùng cho các thao tác bất đồng bộ như yêu cầu của server, để dễ hiểu ta lấy ví dụ với một phép toán để tính tổng của ba phần tử.\r\n\r\n``<code>js\r\nfunction sumOfThreeElements(...elements){\r\n  return new Promise((resolve,reject)=&gt;{\r\n    if(elements.length &gt; 3 ){\r\n      reject(&quot;Only three elements or less are allowed&quot;);\r\n    }\r\n    else{\r\n      let sum = 0;\r\n      let i = 0;\r\n      while(i &lt; elements.length){\r\n        sum += elements[i];\r\n        i++;\r\n      }\r\n      resolve(&quot;Sum has been calculated: &quot;+sum);\r\n    }\r\n  })\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta đang tính tổng của ba phần tử, nếu độ dài của mảng phần tử lớn hơn 3, thì promise sẽ bị rejected, ngược lại thì promise sẽ được resolved và tổng được trả về.\r\n\r\nChúng ta có thể sử dụng bất kỳ promise nào bằng cách gắn các phương thức </code>then()<code> và </code>catch()<code> vào đối tượng sử dụng.\r\n\r\n<img src=\"/interview-assets/js_promise_then_catch.png\" alt=\"\" />\r<ul><li><strong>then()</strong> phương này được truy cập khi kết quả của promise là <em>fulfilled</em>.</li></ul>\r<ul><li><strong>catch()</strong> phương này được truy cập khi kết quả của promise là <em>rejected</em>.</li></ul>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>js\r\nsumOfThreeElements(4, 5, 6)\r\n.then(result=&gt; console.log(result))\r\n.catch(error=&gt; console.log(error));\r\n// In the code above, the promise is fulfilled so the then() method gets executed\r\n\r\nsumOfThreeElements(7, 0, 33, 41)\r\n.then(result =&gt; console.log(result))\r\n.catch(error=&gt; console.log(error));\r\n// In the code above, the promise is rejected hence the catch() method gets executed\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Lớp trong JavaScript?",
      "answer": "<p>Được thêm vào ở phiên bản ES6, các lớp không là gì ngoài các cú pháp tuyệt vời cho các hàm khởi tạo.\r\n\r\nChúng cung cấp một cách mới để khai báo các hàm khởi tạo trong javascript.\r\n\r\nDưới đây là các ví dụ về cách các lớp được khai báo và sử dụng:\r\n\r\n``<code>js\r\n// Before ES6 version, using constructor functions\r\nfunction Student(name,rollNumber,grade,section){\r\n  this.name = name;\r\n  this.rollNumber = rollNumber;\r\n  this.grade = grade;\r\n  this.section = section;\r\n}\r\n\r\n// Way to add methods to a constructor function\r\nStudent.prototype.getDetails = function(){\r\n  return &#39;Name: ${this.name}, Roll no: ${this.rollNumber}, Grade: ${this.grade}, Section:${this.section}&#39;;\r\n}\r\n\r\n\r\nlet student1 = new Student(&quot;Vivek&quot;, 354, &quot;6th&quot;, &quot;A&quot;);\r\nstudent1.getDetails();\r\n// Returns Name: Vivek, Roll no:354, Grade: 6th, Section:A\r\n\r\n// ES6 version classes\r\nclass Student{\r\n  constructor(name,rollNumber,grade,section){\r\n    this.name = name;\r\n    this.rollNumber = rollNumber;\r\n    this.grade = grade;\r\n    this.section = section;\r\n  }\r\n\r\n  // Methods can be directly added inside the class\r\n  getDetails(){\r\n    return &#39;Name: ${this.name}, Roll no: ${this.rollNumber}, Grade:${this.grade}, Section:${this.section}&#39;;\r\n  }\r\n}\r\n\r\nlet student2 = new Student(&quot;Garry&quot;, 673, &quot;7th&quot;, &quot;C&quot;);\r\nstudent2.getDetails();\r\n// Returns Name: Garry, Roll no:673, Grade: 7th, Section:C\r\n</code>`<code>\r\n\r\nCác điều cần nhớ về lớp:\r<ul><li>Không như function, các lớp không được hoisting. Chúng cần khai báo trước khi sử dụng.</li></ul>\r<ul><li>Một lớp có thể kế thừa thuộc tính và phương thức từ lớp khác bằng từ khoá </code>extends<code>.</li></ul>\r<ul><li>Tất cả cú pháp trong lớp phải theo tuần thủ chế độ strict (</code>use strict`). Lỗi sẽ xuất hiện nếu các quy tắc trong chế độ strict không được tuân thủ.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Hàm generator là gì?",
      "answer": "<p>Được giới thiệu ở phiên bản ES6, generator function là một lớp đặc biệt của hàm.\r\n\r\n<strong>Chúng có thể được dừng lại giữa chừng và sau đó tiếp tục từ nơi nó đã dừng lại.</strong>\r\n\r\nHàm generator được khai báo với từ khoá <strong>function </strong><em>:\r\n\r\n``<code>js\r\nfunction</em> genFunc(){\r\n  // Perform operation\r\n}\r\n</code>`<code>\r\n\r\nTrong các hàm thông thường, ta sử dụng </code>return<code> để trả về giá trị, và ngay sau khi khi lệnh </code>return<code> được thực thi, việc thực thi hàm sẽ dừng lại.\r\n\r\n</code>`<code>js\r\nfunction normalFunc(){\r\n  return 22;\r\n  console.log(2); // This line of code does not get executed\r\n}\r\n</code>`<code>\r\n\r\nCòn với các hàm generator, khi được gọi nó sẽ không thực thi code thay vào đó nó trả về một đối tượng <strong>generator</strong>. Đối tượng generator này xử lý việc thực thi:\r\n\r\n</code>`<code>js\r\nfunction<em> genFunc(){\r\n  yield 3;\r\n  yield 4;\r\n}\r\ngenFunc(); // Returns Object [Generator] {}\r\n</code>`<code>\r\n\r\nĐối tượng generator bao gồm một phương thức được gọi là </code>next()<code>, phương thức này khi được gọi sẽ thực thi code cho đến câu lệnh </code>yield<code> gần nhất và trả về giá trị </code>yield<code>.\r\n\r\nVí dụ: nếu ta chạy phương thức </code>next()<code> trên đoạn code trên:\r\n\r\n</code>`<code>js\r\ngenFunc().next(); // Returns {value: 3, done:false}\r\n</code>`<code>\r\n\r\nNhư ta có thể thấy phương thức </code>next()<code> trả về một đối tượng bao gồm thuộc tính </code>value<code> và </code>done<code>.\r<ul><li>Thuộc tính value đại diện cho giá trị thu được.</li></ul>\r<ul><li>Thuộc tính done cho ta biết code của hàm đã hoàn thành hay chưa. (Trả về true nếu kết thúc).</li></ul>\r\n\r\nCác hàm generator được sử dụng để trả về các vòng lặp. Hãy xem một ví dụ trong đó một vòng lặp được trả về:\r\n\r\n</code>`<code>js\r\nfunction</em> iteratorFunc() {\r\n  let count = 0;\r\n  for (let i = 0; i &lt; 2; i++) {\r\n      count++;\r\n      yield i;\r\n  }\r\n  return count;\r\n}\r\n\r\nlet iterator = iteratorFunc();\r\nconsole.log(iterator.next()); // {value:0,done:false}\r\nconsole.log(iterator.next()); // {value:1,done:false}\r\nconsole.log(iterator.next()); // {value:2,done:true}\r\n</code>`<code>\r\n\r\nNhư bạn có thể thấy trong đoạn code trên, dòng cuối cùng trả về </code>done: true`, vì code này đạt đến cuối hàm.</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích WeakSet trong JavaScript",
      "answer": "<p>Trong Javascript, Set là tập hợp các phần tử đơn nhất và có thứ tự.\r\n\r\nGiống như Set, WeakSet cũng là tập hợp các phần tử đơn nhất và có thứ tự. Nhưng có vài điểm khác:\r<ul><li>Weakset chỉ chứa các đối tượng và không có loại nào khác.</li></ul>\r<ul><li>Một đối tượng bên trong weakset có tham chiếu yếu. Điều này có nghĩa là, nếu đối tượng bên trong weakset không có tham chiếu, nó sẽ được bộ dọn dẹp thu gom.</li></ul>\r<ul><li>Không giống như Set, WeakSet chỉ có ba phương thức, add(), delete() và has().</li></ul>\r\n\r\n``<code>js\r\nconst newSet = new Set([4, 5, 6, 7]);\r\nconsole.log(newSet);// Outputs Set {4,5,6,7}\r\n\r\nconst newSet2 = new WeakSet([3, 4, 5]); //Throws an error\r\n\r\n\r\nlet obj1 = {message:&quot;Hello world&quot;};\r\nconst newSet3 = new WeakSet([obj1]);\r\nconsole.log(newSet3.has(obj1)); // true\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích về WeakMap trong JavaScript",
      "answer": "<p>Trong JS, Map được dùng để lưu các cặp key-value. Các cặp key-value có thể là kiểu nguyên thuỷ hoặc đối tượng.\r\n\r\nWeakMap gần giống Map với vài điểm khác biệt:\r<ul><li>Key và value trong weakmap phải là kiểu đối tượng.</li></ul>\r<ul><li>Nếu không có tham chiếu đến đối tượng, đối tượng sẽ bị dọn dep.</li></ul>\r\n\r\n``<code>js\r\nconst map1 = new Map();\r\nmap1.set(&#39;Value&#39;, 1);\r\n\r\nconst map2 = new WeakMap();\r\nmap2.set(&#39;Value&#39;, 2.3); // Throws an error\r\n\r\nlet obj = {name:&quot;Vivek&quot;};\r\nconst map3 = new WeakMap();\r\nmap3.set(obj, {age:23});\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Cấu trúc đối tượng là gì?",
      "answer": "<p>Cấu trúc đối tượng là một cách mới để trích xuất các phần tử từ một đối tượng hoặc một mảng.\r\n\r\nTrước ES6:\r\n\r\n``<code>js\r\nconst classDetails = {\r\n  strength: 78,\r\n  benches: 39,\r\n  blackBoard:1\r\n}\r\n\r\nconst classStrength = classDetails.strength;\r\nconst classBenches = classDetails.benches;\r\nconst classBlackBoard = classDetails.blackBoard;\r\n</code>`<code>\r\n\r\nVí dụ tương tự sử dụng cấu trúc đối tượng:\r\n\r\n</code>`<code>js\r\nconst classDetails = {\r\n  strength: 78,\r\n  benches: 39,\r\n  blackBoard:1\r\n}\r\n\r\nconst {strength:classStrength, benches:classBenches,blackBoard:classBlackBoard} = classDetails;\r\n\r\nconsole.log(classStrength); // Outputs 78\r\nconsole.log(classBenches); // Outputs 39\r\nconsole.log(classBlackBoard); // Outputs 1\r\n</code>`<code>\r\n\r\nNhư mọi người có thể thấy, bằng cách sử dụng cấu trúc đối tượng, ta đã trích xuất tất cả các phần tử bên trong một đối tượng trong một dòng code.\r\n\r\nNếu chúng ta muốn biến mới của mình có cùng tên với thuộc tính của một đối tượng, chúng ta có thể bỏ dấu hai chấm:\r\n\r\n</code>`<code>js\r\nconst {strength:strength} = classDetails;\r\n// The above line of code can be written as:\r\nconst {strength} = classDetails;\r\n</code>``\r\n\r\n#</p>",
      "level": "fresher"
    },
    {
      "question": "Temporal Dead Zone là gì?",
      "answer": "<p>Temporal Dead Zone là hành vi xảy ra với khai báo biến sử dụng <strong>let</strong> hoặc <strong>const</strong>.\r\n\r\nNó là hành vi xảy ra khi ta truy cập một biến trước khi khởi tạo.\r\n\r\nVí dụ:\r\n\r\n``<code>js\r\nx = 23; // Gives reference error\r\n\r\nlet x;\r\n\r\n\r\nfunction anotherRandomFunc(){\r\n  message = &quot;Hello&quot;; // Throws a reference error\r\n\r\n  let message;\r\n}\r\nanotherRandomFunc();\r\n</code>``\r\n\r\nTrong đoạn code trên, cả trong global scope và function scope, ta đang cố gắng truy cập các biến chưa được khai báo. Đây được gọi là Temporal Dead Zone.</p>",
      "level": "fresher"
    }
  ]
}