{
  "id": "oop",
  "name": "Câu hỏi phỏng vấn OOP",
  "description": "Các câu hỏi về Lập trình hướng đối tượng và 4 tính chất: Trừu tượng, Đóng gói, Kế thừa, Đa hình.",
  "questions": [
    {
      "question": "Lập trình hướng đối tượng (OOP) là gì và tại sao nó quan trọng?",
      "answer": "**Lập trình hướng đối tượng (Object Oriented Programming – OOP)** là một trong những phương pháp lập trình phổ biến nhất hiện nay. OOP tổ chức code xung quanh các đối tượng (objects) thay vì các hàm và logic.\n\n**Tại sao OOP quan trọng:**\n- Mô phỏng các đối tượng thực tế trong thế giới thật một cách tự nhiên\n- Code dễ bảo trì, mở rộng và tái sử dụng\n- Giảm độ phức tạp của các dự án lớn\n- Hỗ trợ làm việc nhóm hiệu quả hơn\n\n**4 tính chất nổi bật của OOP:**\n1. **Tính trừu tượng (Abstraction)**: Tạo các lớp mô phỏng đối tượng thực tế\n2. **Tính đóng gói (Encapsulation)**: Bảo vệ dữ liệu và cung cấp phương thức truy cập an toàn\n3. **Tính kế thừa (Inheritance)**: Tái sử dụng code từ các lớp cha\n4. **Tính đa hình (Polymorphism)**: Thực hiện hành động theo nhiều cách khác nhau",
      "level": "fresher"
    },
    {
      "question": "Tính trừu tượng (Abstraction) trong OOP là gì? Cho ví dụ trong JavaScript?",
      "answer": "**Tính trừu tượng (Abstraction)** cho phép tạo ra các lớp mô phỏng các đối tượng thực tế trong thế giới thật, chỉ hiển thị những thông tin cần thiết và ẩn đi các chi tiết phức tạp bên trong.\n\n**Ví dụ:**\n```javascript\nclass Car {\n  constructor(brand, model) {\n    this.brand = brand;\n    this.model = model;\n    this.engineStatus = false;\n  }\n\n  // Người dùng chỉ cần gọi start(), không cần biết chi tiết bên trong\n  start() {\n    this._igniteEngine();\n    this._checkFuel();\n    this.engineStatus = true;\n    console.log(`${this.brand} ${this.model} đã khởi động`);\n  }\n\n  // Các phương thức private (ẩn chi tiết)\n  _igniteEngine() {\n    // Logic phức tạp để khởi động động cơ\n  }\n\n  _checkFuel() {\n    // Kiểm tra nhiên liệu\n  }\n}\n\nconst myCar = new Car('Toyota', 'Camry');\nmyCar.start(); // Đơn giản, không cần biết chi tiết bên trong\n```",
      "level": "fresher"
    },
    {
      "question": "Tính đóng gói (Encapsulation) trong OOP là gì? Lợi ích của nó?",
      "answer": "**Tính đóng gói (Encapsulation)** bảo vệ dữ liệu bên trong lớp và chỉ cung cấp các phương thức truy cập an toàn. Dữ liệu được ẩn (private) và chỉ có thể thay đổi thông qua các phương thức công khai (public methods).\n\n**Lợi ích:**\n- Bảo vệ dữ liệu khỏi truy cập trái phép\n- Kiểm soát được cách dữ liệu được thay đổi\n- Dễ bảo trì và sửa lỗi\n- Giảm sự phụ thuộc giữa các phần của code\n\n**Ví dụ trong JavaScript (ES2022+):**\n```javascript\nclass BankAccount {\n  #balance = 0; // Private field (ES2022)\n\n  constructor(owner) {\n    this.owner = owner;\n  }\n\n  // Public method để truy cập dữ liệu private\n  getBalance() {\n    return this.#balance;\n  }\n\n  deposit(amount) {\n    if (amount > 0) {\n      this.#balance += amount;\n      return true;\n    }\n    return false;\n  }\n\n  withdraw(amount) {\n    if (amount > 0 && amount <= this.#balance) {\n      this.#balance -= amount;\n      return true;\n    }\n    return false;\n  }\n}\n\nconst account = new BankAccount('John');\naccount.deposit(1000);\nconsole.log(account.getBalance()); // 1000\n// account.#balance = 999999; // Error: Private field\n```",
      "level": "middle"
    },
    {
      "question": "Tính kế thừa (Inheritance) trong OOP là gì? Ưu và nhược điểm?",
      "answer": "**Tính kế thừa (Inheritance)** cho phép tái sử dụng code hiệu quả bằng cách cho phép các lớp con (child class) kế thừa tính năng từ các lớp cha (parent class).\n\n**Ưu điểm:**\n- Tái sử dụng code, giảm duplicate code\n- Dễ dàng mở rộng chức năng\n- Tạo cấu trúc phân cấp rõ ràng\n- Dễ bảo trì và cập nhật\n\n**Nhược điểm:**\n- Tạo sự phụ thuộc chặt chẽ giữa class cha và class con\n- Có thể dẫn đến cấu trúc phức tạp nếu kế thừa nhiều tầng\n- Khó thay đổi class cha mà không ảnh hưởng class con\n\n**Ví dụ:**\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  eat() {\n    console.log(`${this.name} đang ăn`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name); // Gọi constructor của class cha\n    this.breed = breed;\n  }\n\n  bark() {\n    console.log(`${this.name} sủa: Gâu gâu!`);\n  }\n\n  // Override method của class cha\n  eat() {\n    console.log(`${this.name} đang ăn xương`);\n  }\n}\n\nconst myDog = new Dog('Buddy', 'Golden Retriever');\nmyDog.eat();  // Buddy đang ăn xương\nmyDog.bark(); // Buddy sủa: Gâu gâu!\n```\n\n**Lưu ý:** Trong JavaScript hiện đại, người ta thường ưu tiên **Composition over Inheritance** (Kết hợp hơn Kế thừa) để tránh các vấn đề phức tạp.",
      "level": "middle"
    },
    {
      "question": "Tính đa hình (Polymorphism) trong OOP là gì? Các loại đa hình?",
      "answer": "**Tính đa hình (Polymorphism)** cho phép thực hiện một hành động theo nhiều cách khác nhau tùy thuộc vào loại đối tượng cụ thể. Cùng một phương thức nhưng có thể có nhiều cách thực thi khác nhau.\n\n**Các loại đa hình:**\n\n**1. Compile-time Polymorphism (Đa hình tĩnh):**\n- Method Overloading (JavaScript không hỗ trợ trực tiếp)\n\n**2. Runtime Polymorphism (Đa hình động):**\n- Method Overriding (Ghi đè phương thức)\n\n**Ví dụ Method Overriding:**\n```javascript\nclass Shape {\n  calculateArea() {\n    return 0;\n  }\n\n  draw() {\n    console.log('Vẽ hình');\n  }\n}\n\nclass Circle extends Shape {\n  constructor(radius) {\n    super();\n    this.radius = radius;\n  }\n\n  calculateArea() {\n    return Math.PI * this.radius * this.radius;\n  }\n\n  draw() {\n    console.log('Vẽ hình tròn');\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(width, height) {\n    super();\n    this.width = width;\n    this.height = height;\n  }\n\n  calculateArea() {\n    return this.width * this.height;\n  }\n\n  draw() {\n    console.log('Vẽ hình chữ nhật');\n  }\n}\n\n// Đa hình: Cùng method nhưng hành vi khác nhau\nconst shapes = [\n  new Circle(5),\n  new Rectangle(4, 6)\n];\n\nshapes.forEach(shape => {\n  shape.draw(); // Gọi method giống nhau\n  console.log('Diện tích:', shape.calculateArea());\n});\n// Output:\n// Vẽ hình tròn\n// Diện tích: 78.54\n// Vẽ hình chữ nhật\n// Diện tích: 24\n```\n\n**Lợi ích:**\n- Code linh hoạt và dễ mở rộng\n- Giảm sự phụ thuộc (loose coupling)\n- Dễ thêm đối tượng mới mà không sửa code cũ",
      "level": "middle"
    },
    {
      "question": "Composition over Inheritance là gì? Tại sao nên ưu tiên nó?",
      "answer": "**Composition over Inheritance** (Ưu tiên Kết hợp hơn Kế thừa) là nguyên tắc thiết kế khuyến khích sử dụng composition (kết hợp các đối tượng) thay vì inheritance (kế thừa) để tái sử dụng code.\n\n**Tại sao nên ưu tiên Composition:**\n- **Linh hoạt hơn**: Có thể thay đổi hành vi lúc runtime\n- **Tránh phụ thuộc chặt**: Không bị ràng buộc với cấu trúc class cha\n- **Tránh Diamond Problem**: Không gặp vấn đề đa kế thừa\n- **Dễ test**: Các component độc lập dễ test hơn\n\n**Ví dụ so sánh:**\n\n**❌ Inheritance (Kế thừa):**\n```javascript\nclass FlyingRobot extends Robot {\n  fly() { /* ... */ }\n}\n\nclass SwimmingRobot extends Robot {\n  swim() { /* ... */ }\n}\n\n// Vấn đề: Làm sao tạo robot vừa bay vừa bơi?\n```\n\n**✅ Composition (Kết hợp):**\n```javascript\nconst canFly = {\n  fly() {\n    console.log('Đang bay');\n  }\n};\n\nconst canSwim = {\n  swim() {\n    console.log('Đang bơi');\n  }\n};\n\nclass Robot {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// Tạo robot với khả năng tùy chỉnh\nconst flyingRobot = Object.assign(new Robot('R1'), canFly);\nconst swimmingRobot = Object.assign(new Robot('R2'), canSwim);\nconst superRobot = Object.assign(new Robot('R3'), canFly, canSwim);\n\nsuperRobot.fly();  // Đang bay\nsuperRobot.swim(); // Đang bơi\n```",
      "level": "senior"
    },
    {
      "question": "Class vs Object trong JavaScript? Sự khác biệt?",
      "answer": "**Class (Lớp)** là bản thiết kế (blueprint) để tạo ra các objects. Nó định nghĩa cấu trúc và hành vi chung.\n\n**Object (Đối tượng)** là một thể hiện cụ thể (instance) được tạo từ class.\n\n**Sự khác biệt:**\n\n| Class | Object |\n|-------|--------|\n| Template/Blueprint | Instance cụ thể |\n| Định nghĩa thuộc tính và phương thức | Chứa giá trị thực tế |\n| Chỉ có 1 định nghĩa | Có thể tạo nhiều objects |\n| Không chiếm bộ nhớ | Chiếm bộ nhớ |\n\n**Ví dụ:**\n```javascript\n// CLASS - Bản thiết kế\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  introduce() {\n    console.log(`Xin chào, tôi là ${this.name}, ${this.age} tuổi`);\n  }\n}\n\n// OBJECTS - Các thể hiện cụ thể từ class Person\nconst person1 = new Person('John', 25);\nconst person2 = new Person('Mary', 30);\nconst person3 = new Person('Bob', 35);\n\nperson1.introduce(); // Xin chào, tôi là John, 25 tuổi\nperson2.introduce(); // Xin chào, tôi là Mary, 30 tuổi\n\n// person1, person2, person3 là các objects khác nhau\n// nhưng cùng được tạo từ class Person\nconsole.log(person1 === person2); // false (khác object)\n```\n\n**Quan hệ:**\n- 1 Class → Nhiều Objects\n- Class là khuôn mẫu, Object là sản phẩm từ khuôn mẫu đó",
      "level": "fresher"
    },
    {
      "question": "Constructor trong JavaScript là gì? Cách sử dụng?",
      "answer": "**Constructor** là một phương thức đặc biệt được tự động gọi khi tạo object mới từ class. Nó dùng để khởi tạo giá trị ban đầu cho các thuộc tính của object.\n\n**Đặc điểm:**\n- Tên luôn là `constructor`\n- Tự động chạy khi dùng `new ClassName()`\n- Mỗi class chỉ có 1 constructor\n- Có thể nhận tham số để khởi tạo object\n\n**Ví dụ:**\n```javascript\nclass Student {\n  // Constructor - phương thức khởi tạo\n  constructor(name, studentId, grade) {\n    // Khởi tạo các thuộc tính\n    this.name = name;\n    this.studentId = studentId;\n    this.grade = grade;\n    this.courses = []; // Giá trị mặc định\n  }\n\n  enrollCourse(courseName) {\n    this.courses.push(courseName);\n  }\n\n  getInfo() {\n    return `${this.name} (ID: ${this.studentId}) - Lớp ${this.grade}`;\n  }\n}\n\n// Khi dùng 'new', constructor tự động chạy\nconst student1 = new Student('Alice', 'S001', '10A');\nconst student2 = new Student('Bob', 'S002', '10B');\n\nconsole.log(student1.getInfo()); // Alice (ID: S001) - Lớp 10A\n```\n\n**Constructor trong kế thừa:**\n```javascript\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\nclass Employee extends Person {\n  constructor(name, age, position, salary) {\n    super(name, age); // Gọi constructor của class cha\n    this.position = position;\n    this.salary = salary;\n  }\n}\n\nconst emp = new Employee('John', 30, 'Developer', 5000);\nconsole.log(emp.name);     // John (từ Person)\nconsole.log(emp.position); // Developer (từ Employee)\n```",
      "level": "fresher"
    },
    {
      "question": "Static methods và Static properties là gì? Khi nào sử dụng?",
      "answer": "**Static methods/properties** thuộc về class chứ không thuộc về object instance. Chúng được gọi trực tiếp từ class, không cần tạo object.\n\n**Đặc điểm:**\n- Dùng từ khóa `static`\n- Gọi qua tên class: `ClassName.methodName()`\n- Không thể truy cập qua instance: `instance.methodName()` ❌\n- Không thể dùng `this` để truy cập instance properties\n- Thường dùng cho utility functions hoặc factory methods\n\n**Khi nào sử dụng:**\n- Helper/Utility functions không liên quan đến instance\n- Factory methods để tạo objects\n- Constants hoặc configuration\n- Counters hoặc shared data\n\n**Ví dụ:**\n```javascript\nclass MathUtil {\n  // Static property\n  static PI = 3.14159;\n  \n  // Static method\n  static calculateCircleArea(radius) {\n    return this.PI * radius * radius;\n  }\n  \n  static max(a, b) {\n    return a > b ? a : b;\n  }\n}\n\n// Gọi trực tiếp từ class\nconsole.log(MathUtil.PI);                    // 3.14159\nconsole.log(MathUtil.calculateCircleArea(5)); // 78.54\nconsole.log(MathUtil.max(10, 20));           // 20\n\n// ❌ Không thể gọi từ instance\nconst util = new MathUtil();\n// util.calculateCircleArea(5); // Error!\n```\n\n**Ví dụ thực tế - Factory Pattern:**\n```javascript\nclass User {\n  constructor(name, email, role) {\n    this.name = name;\n    this.email = email;\n    this.role = role;\n  }\n\n  // Static factory methods\n  static createAdmin(name, email) {\n    return new User(name, email, 'admin');\n  }\n\n  static createGuest(name, email) {\n    return new User(name, email, 'guest');\n  }\n\n  // Static counter\n  static userCount = 0;\n  \n  static incrementCount() {\n    this.userCount++;\n  }\n}\n\nconst admin = User.createAdmin('John', 'john@example.com');\nconst guest = User.createGuest('Jane', 'jane@example.com');\n\nconsole.log(admin.role); // admin\nconsole.log(guest.role); // guest\n```",
      "level": "middle"
    },
    {
      "question": "Getter và Setter trong JavaScript là gì? Tại sao sử dụng?",
      "answer": "**Getter** và **Setter** là các phương thức đặc biệt cho phép truy cập và thay đổi thuộc tính của object một cách được kiểm soát, giống như truy cập thuộc tính thông thường nhưng có logic xử lý.\n\n**Getter (get):**\n- Lấy giá trị của thuộc tính\n- Gọi như một thuộc tính, không cần dấu ngoặc ()\n- Có thể tính toán trước khi trả về\n\n**Setter (set):**\n- Thiết lập giá trị cho thuộc tính\n- Có thể validate dữ liệu trước khi gán\n- Gán giá trị như thuộc tính thông thường\n\n**Tại sao sử dụng:**\n- **Validation**: Kiểm tra dữ liệu trước khi gán\n- **Computed values**: Tính toán giá trị động\n- **Encapsulation**: Bảo vệ dữ liệu nội bộ\n- **Read-only properties**: Chỉ cho phép đọc\n\n**Ví dụ:**\n```javascript\nclass Temperature {\n  constructor(celsius) {\n    this._celsius = celsius; // Dùng _ để đánh dấu private\n  }\n\n  // Getter - Đọc giá trị Celsius\n  get celsius() {\n    return this._celsius;\n  }\n\n  // Setter - Ghi giá trị Celsius (có validation)\n  set celsius(value) {\n    if (value < -273.15) {\n      throw new Error('Nhiệt độ không thể thấp hơn -273.15°C');\n    }\n    this._celsius = value;\n  }\n\n  // Getter - Tính toán Fahrenheit từ Celsius\n  get fahrenheit() {\n    return (this._celsius * 9/5) + 32;\n  }\n\n  // Setter - Chuyển đổi Fahrenheit sang Celsius\n  set fahrenheit(value) {\n    this._celsius = (value - 32) * 5/9;\n  }\n}\n\nconst temp = new Temperature(25);\n\n// Sử dụng như thuộc tính thông thường\nconsole.log(temp.celsius);    // 25 (gọi getter)\nconsole.log(temp.fahrenheit); // 77 (gọi getter - tính toán)\n\ntemp.celsius = 30;            // Gọi setter\nconsole.log(temp.fahrenheit); // 86\n\ntemp.fahrenheit = 100;        // Gọi setter - tự chuyển đổi\nconsole.log(temp.celsius);    // 37.78\n\n// temp.celsius = -300; // Error: Nhiệt độ không thể thấp hơn -273.15°C\n```\n\n**Ví dụ thực tế - User với validation:**\n```javascript\nclass User {\n  constructor(username, email) {\n    this._username = username;\n    this._email = email;\n  }\n\n  get username() {\n    return this._username;\n  }\n\n  set username(value) {\n    if (value.length < 3) {\n      throw new Error('Username phải có ít nhất 3 ký tự');\n    }\n    this._username = value;\n  }\n\n  get email() {\n    return this._email;\n  }\n\n  set email(value) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(value)) {\n      throw new Error('Email không hợp lệ');\n    }\n    this._email = value;\n  }\n\n  // Computed property - chỉ có getter\n  get displayName() {\n    return `${this._username} (${this._email})`;\n  }\n}\n\nconst user = new User('john', 'john@example.com');\nconsole.log(user.displayName); // john (john@example.com)\n\n// user.username = 'ab'; // Error: Username phải có ít nhất 3 ký tự\n// user.email = 'invalid'; // Error: Email không hợp lệ\n```",
      "level": "middle"
    }
  ]
}
