{
  "id": "css",
  "name": "Câu hỏi phỏng vấn CSS",
  "description": "",
  "questions": [
    {
      "question": "Mô hình hộp trong CSS là gì? Thuộc tính CSS nào là một phần của nó?",
      "answer": "<p>Các phần tử trong HTML có thể được coi là những chiếc hộp. Trong CSS, thuật ngữ \"mô hình hộp\" được dùng để nói về việc thiết kế, xây dựng bố cục.\r\n\r\nVề cơ bản mô hình hộp CSS là một chiếc hộp bao xung quanh phần tử HTML, gồm margin, border, padding và nội dung bên trong. Hình ảnh dưới đây cho thấy vị trí và mối liên hệ giữa các thành phần này.\r\n\r\n<img src=\"/interview-assets/Box_Model_in_CSS.jpg\" alt=\"\" />\r\n\r\n<em> <strong>Content</strong> - nội dung trong hộp, nơi hiển thị văn bản và hình ảnh.\r\n</em> <strong>Padding</strong> - phần khoảng trắng xung quanh nội dung.\r\n<em> <strong>Border</strong> - đường viền xung quanh nội dung và padding.\r\n</em> <strong>Margin</strong> - phần lề bên ngoài đường viền.</p>",
      "level": "fresher"
    },
    {
      "question": "Ưu điểm của CSS?",
      "answer": "<p><ul><li>Tiết kiệm thời gian, công sức trong việc code web/xây dựng giao diện; kiểm soát dễ dàng các lỗi không đáng có trên web</li></ul>\r<ul><li>CSS cung cấp nhiều thuộc tính cụ thể hơn HTML giúp tạo ra nhiều style khác nhau và có thể áp dụng được cho nhiều loại web.</li></ul>\r<ul><li>CSS giúp tốc độ tải trang web nhanh chóng hơn, dễ dàng bảo trì, tương thích với các thiết bị di động.</li></ul>\r<ul><li>CSS thiết lập nhiều kiểu chữ khác nhau giúp website của bạn trở nên khác biệt hơn; tự động sắp xếp chữ khi chèn hình ảnh (thuộc tính shape-outsite); đặt nội dung theo các chiều khác nhau/ thay đổi chế độ viết theo mong muốn của mình (thuộc tính write-mode); có thể tạo chữ lớn ở đầu dòng (thuộc tính first-letter)…</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Hạn chế của CSS?",
      "answer": "<p>#</p>",
      "level": "fresher"
    },
    {
      "question": "Làm thế nào để đưa CSS vào trang web?",
      "answer": "<p>Có nhiều cách để thêm CSS vào trang web.\r\n\r\n#</p>",
      "level": "fresher"
    },
    {
      "question": "Các loại selector khác nhau trong CSS?",
      "answer": "<p>CSS Selector giống như là đường đẫn, chỉ định để cho CSS biết bạn đang muốn điều chỉnh, tạo kiểu cho phần tử HTML nào vậy.\r\n\r\n<strong>Universal Selector:</strong> hoạt động như một ký tự đại diện cho tất cả phần tử trong trang. Trong ví dụ này, các style được cung cấp sẽ được áp dụng cho tất cả các phần tử trên trang.\r\n\r\n``<code>css\r<ul><li>{</li></ul>\r\n    color: &quot;green&quot;;\r\n    font-size: 20px;\r\n    line-height: 25px;\r\n}\r\n</code>`<code>\r\n\r\n<strong>Element Type Selector:</strong> selector loại này ứng với một hoặc nhiều phần tử HTML cùng tên. Trong ví dụ này, các style được cung cấp sẽ được áp dụng cho tất cả các phần tử ul trên trang.\r\n\r\n</code>`<code>css\r\nul {\r\n    line-style: none;\r\n    border: solid 1px #ccc;\r\n}\r\n</code>`<code>\r\n\r\n<strong>ID Selector:</strong> selector này ứng với bất kỳ phần tử HTML nào có thuộc tính ID có cùng giá trị với giá trị của selector. Trong ví dụ này, các style được cung cấp sẽ được áp dụng cho tất cả các phần tử có ID trùng trên trang.\r\n\r\n</code>`<code>css\r\n#container {\r\n    width: 960px;\r\n    margin: 0 auto;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;\r\n</code>`<code>\r\n\r\n<strong>Class Selector:</strong> tương tự như ID Selector nhưng thay vì ứng với ID thì nó ứng với thuộc tính class. Trong ví dụ này, các style được cung cấp sẽ áp dụng cho tất cả phần tử có cùng tên lớp.\r\n\r\n</code>`<code>css\r\n.box {\r\n    padding: 10px;\r\n    margin: 10px;\r\n    width: 240px;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n</code>`<code>\r\n\r\n<strong>Descendant Combinator:</strong> giúp bạn kết hợp hai hoặc nhiều selector để có thể chỉ định phần tử cụ thể.\r\n\r\n</code>`<code>css\r\n#container .box {\r\n\tfloat: left;\r\n\tpadding-bottom: 15px;\r\n} \r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div id=&quot;container&quot;&gt;\r\n\t&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n\t\r\n\t&lt;div class=&quot;box-2&quot;&gt;&lt;/div&gt;\r\n&lt;/div&gt;\r\n\r\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n</code>`<code>\r\n\r\nKhối khai báo này sẽ áp dụng cho tất cả các phần tử có lớp </code>box<code> nằm bên trong phần tử có ID là </code>container<code>. Cần lưu ý rằng phần tử </code>.box<code> không nhất thiết phải là phần tử con, nó có thể có một phần tử khác bao bọc </code>.box<code> và các style vẫn sẽ áp dụng.\r\n\r\n<strong>Child Combinator:</strong> selector sử dụng bộ child combinator tương tự như descendant combinator, ngoại trừ việc nó chỉ nhắm đến các phần tử con.\r\n\r\n</code>`<code>css\r\n#container&gt; .box {\r\n\tfloat: left;\r\n\tpadding-bottom: 15px;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div id=&quot;container&quot;&gt;\r\n\t&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n\t\r\n\t&lt;div&gt;\r\n\t\t&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\r\n\t&lt;/div&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\nSelector sẽ ứng với tất cả phần tử có lớp </code>box<code> và là phần tử con của phần tử có id là </code>container<code>. Điều đó có nghĩa là các phần tử lớp </code>box<code> không phải là phần tử con của </code>container<code> sẽ không được áp dụng.\r\n\r\n<strong>General Sibling Combinator:</strong> selector này so với các phần tử có quan hệ anh chị em với phần tử tương ứng.\r\n\r\n</code>`<code>css\r\nh2 ~ p {\r\n\tmargin-bottom: 20px;\r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;h2&gt;Title&lt;/h2&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;div class=&quot;box&quot;&gt;\r\n\t&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\nTrong ví dụ này, tất cả các phần tử văn bản (</code><p><code>) sẽ được áp dụng style với các quy tắc đã chỉ định, nhưng chỉ khi chúng là anh chị em của các phần tử </code><h2><code>. Có thể có các phần tử khác ở giữa </code><h2><code> và </code><p><code> và các style sẽ vẫn áp dụng.\r\n\r\n<strong>Adjacent Sibling Combinator:</strong>: selector sử dụng ký tự </code>+<code> và gần giống với General Sibling Combinator. Sự khác biệt là phần tử được nhắm phải là anh chị ruột thịt chứ không phải enh chị em chung chung.\r\n\r\n</code>`<code>css\r\np + p {\r\n\ttext-indent: 1.Sem;\r\n\tmargin-bottom: 0;\r\n}\r\n</code>`<code>\r\n</code>`<code>html\r\n&lt;h2&gt;Title&lt;/h2&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n\r\n&lt;div class=”box”&gt;\r\n\t&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n\t&lt;p&gt;Paragraph example.&lt;/p&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\nVí dụ trên sẽ chỉ áp dụng các style được chỉ định cho các phần tử văn bản ngay sau các phần tử văn bản khác. Điều này có nghĩa là phần tử văn bản đầu tiên trên một trang sẽ không nhận được các style này. Ngoài ra, nếu một phần tử khác xuất hiện giữa hai đoạn văn, thì đoạn thứ hai của cả hai sẽ không được áp dụng style.\r\n\r\n<strong>Attribute Selector:</strong> nhắm đến các phần tử dựa trên sự xuất hiện và giá trị của thuộc tính HTML. Được khai báo bằng dấu ngoặc vuông.\r\n\r\n</code>`<code>css\r\ninput [type=”text”] {\r\n\tbackground-color: #444;\r\n\twidth: 200px;\r\n}\r\n</code>`<code>\r\n</code>`<code>html\r\n&lt;input type=&quot;text&quot;&gt;\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "CSS Preprocessor là gì? SASS vs LESS vs Stylus?",
      "answer": "<p>CSS Preprocessor là các phiên bản mở rộng của ngôn ngữ CSS (ngôn ngữ tiền xử lý CSS) được viết xử lý trước sau đó sẽ biên dịch ra các đoạn mã CSS thông thường. Nhiệm vụ của các CSS Preprocessor là giúp bạn logic hóa và cấu trúc các đoạn mã CSS, từ đó đưa CSS trở nên gần hơn với 1 ngôn ngữ lập trình. Bạn có thể viết CSS theo thứ tự rõ ràng, quản lý các biến đã được định nghĩa sẵn, có thể tự động nén tập tin CSS lại để bạn tiết kiệm dung lượng. Hiện tại có thể có rất nhiều CSS Preprocessor nhưng có phỗ biến nhất trong số đó là SASS, LESS và Stylus.\r\n\r\n#</p>",
      "level": "fresher"
    },
    {
      "question": "VH/VM trong CSS là gì?",
      "answer": "<p>Đây là một đơn vị CSS được sử dụng để đo chiều cao và chiều rộng theo tỷ lệ phần trăm đối với viewport. Nó được sử dụng chủ yếu trong các kỹ thuật thiết kế reponsive. Số đo VH bằng 1/100 chiều cao của viewport. Nếu chiều cao của trình duyệt là 1000px, thì 1vh bằng 10px. Tương tự, nếu chiều rộng là 1000px, thì 1 vw bằng 10px.</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa reset và normalize CSS?",
      "answer": "<p><strong>Reset CSS:</strong> nhằm mục đích xoá tất cả thiết lập style mặc định từ trình duyệt. Ví dụ như margin, padding, font-size của tất cả phần tử đó được reset lại giống nhau.\r\n\r\n<strong>Normalize CSS:</strong> nhằm mục đích làm cho các style mặc định nhất quán trên trình duyệt. Nó cũng sửa các lỗi phổ biến trên trình duyệt.</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa inline, block và inline-block?",
      "answer": "<p><strong>Block</strong>: Các phần tử block luôn bắt đầu trên một dòng mới. Chúng cũng sẽ chiếm không gian trên toàn bộ hàng hay chiều rộng. Danh sách các phần tử block là <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>.\r\n\r\n<strong>Inline</strong>: Các phần tử inline không bắt đầu trên dòng mới, mà nó xuất hiện cùng dòng với các thẻ bên cạnh chúng. Ví dụ các phần tử inline là <code>&lt;span&gt;</code>, <code>&lt;strong&gt;</code> và <code>&lt;img&gt;</code>.\r\n\r\n<strong>Inline Block</strong>: Các phần tử inline-block tương tự inline, ngoại trừ chúng có thể có phần padding và margin và đặt các giá trị height và width.</p>",
      "level": "fresher"
    },
    {
      "question": "Việc kiểm tra trang web trên các trình duyệt khác nhau có quan trọng không?",
      "answer": "<p>Điều quan trọng nhất là kiểm tra một trang web trong các trình duyệt khác nhau khi bạn thiết kế lần đầu tiên hoặc khi thực hiện các thay đổi lớn. Tuy nhiên, điều quan trọng là phải lặp lại các kiểm tra này theo định kỳ, vì các trình duyệt thường xuyên có các bản cập nhật và thay đổi.</p>",
      "level": "fresher"
    },
    {
      "question": "Phần tử Pseudo và các lớp Pseudo là gì?",
      "answer": "<p><strong>Phần tử pseudo</strong> cho phép ta tạo các mục thường không tồn tại trong DOM.\r<ul><li>::before</li></ul>\r<ul><li>::after</li></ul>\r<ul><li>::first-letter</li></ul>\r<ul><li>::first-line</li></ul>\r<ul><li>::selection</li></ul>\r\n\r\nTrong ví dụ bên dưới, màu sẽ xuất hiện ở dòng đầu tiên trong đoạn văn\r\n\r\n``<code>css\r\np::first-line {\r\n\tcolor: #ffOOOO;\r\n\tfont-variant: small-caps;\r\n}\r\n</code>`<code>\r\n\r\n<strong>Lớp pseudo</strong>  chọn các phần tử thông thường nhưng trong các điều kiện nhất định như khi người dùng di chuột qua liên kết.\r<ul><li>:link</li></ul>\r<ul><li>:visited</li></ul>\r<ul><li>:hover</li></ul>\r<ul><li>:active</li></ul>\r<ul><li>:focus</li></ul>\r\n\r\nTrong ví dụ này, màu xuất hiện khi bạn di chuyển chuột qua thẻ liên kết.\r\n\r\n</code>`<code>css\r\n/<em> mouse over link </em>/\r\na:hover {\r\n\tcolor: #FFOOFF;\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Làm thế nào để chỉ định các đơn vị trong CSS? Những cách khác nhau để làm điều đó là gì?",
      "answer": "<p>Có nhiều cách khác nhau để chỉ định các đơn vị trong CSS như <code>px</code>, <code>em</code>, <code>pt</code>, phần trăm (<code>%</code>). \r<ul><li>Pixel (px) cung cấp khả năng kiểm soát chi tiết và duy trì căn chỉnh vì 1 hoặc nhiều px được đảm bảo sự sắc nét. px không phân tầng.</li></ul>\r<ul><li>em duy trì kích thước tương đối. Bạn có thể có phông chữ reponse. Em, sẽ xếp tầng 1em bằng kích thước phông chữ hiện tại của phần tử hoặc mặc định của trình duyệt. Nếu bạn để font-size thành 16px thì 1em = 16px. Thực tế phổ biến là đặt kích thước phông chữ nội dung mặc định thành 62,5% (bằng 10px).</li></ul>\r<ul><li>pt (điểm) thường được sử dụng trong in ấn. 1pt = 1/72 inch và nó là một đơn vị có kích thước cố định.</li></ul>\r<ul><li>% (phần trăm) đặt kích thước phông chữ so với kích thước phông của nội dung. Do đó, bạn phải đặt kích thước phông chữ của phần nội dung thành kích thước hợp lý.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Liệu margin-top hoặc margin-bottom có ảnh hưởng đến các phần tử inline không?",
      "answer": "<p>Không, nó không ảnh hưởng đến các phần tử inline. Các phần tử inline ở cùng dòng với nội dung của trang.</p>",
      "level": "fresher"
    },
    {
      "question": "Thuộc tính nào được sử dụng để thay đổi dạng phông chữ?",
      "answer": "<p>Chúng ta có thể sử dụng thuộc tính <code>font-family</code> để thực hiện được điều này. Thuộc tính font-family được sử dụng để chỉ định phông chữ nào cần được áp dụng trên phần tử DOM. Nó có thể chứa một số tên phông chữ như một phần của cơ chế “dự phòng” trong trường hợp trình duyệt không hỗ trợ phông chữ. Ví dụ, chúng ta có thể sử dụng:\r\n\r\n``<code>css\r\np {\r\n    font-family: &quot;Times New Roman&quot;, Times, serif;\r\n}\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, ta đang áp dụng thuộc tính font-family cho phần tử đoạn văn.\r<ul><li>Nó yêu cầu trình duyệt tìm kiếm phông chữ &quot;Times New Roman&quot; và áp dụng nó.</li></ul>\r<ul><li>Nếu phông chữ &quot;Times New Roman&quot; không được cài đặt hoặc hỗ trợ, thì nó sẽ yêu cầu trình duyệt sử dụng phông chữ Times.</li></ul>\r<ul><li>Nếu cả &quot;Times New Roman&quot; và &quot;Times&quot; đều không được hỗ trợ, thì nó sẽ yêu cầu trình duyệt sử dụng bất kỳ phông chữ chung nào được hỗ trợ thuộc serif.</li></ul>\r\n\r\nNếu bạn không muốn </code>font-face<code> của phần tử văn bản là phông chữ Times New Roman/ Times/serif và bạn muốn sử dụng phông chữ Arial/Helvetica/sans-serif, thì ta có thể cập nhật thuộc tính CSS của phần tử văn bản như:\r\n\r\n</code>`<code>css\r\np {\r\n    font-family: Arial, Helvetica, sans-serif;\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa adaptive design và responsive design?",
      "answer": "<p>| Adaptive Design | Responsive Design |\r\n|-----------------|-------------------|\r\n| Tập trung vào thiết kế trang web dựa trên nhiều kích thước bố cục cố định | Tập trung vào việc hiển trị nội dung trên cơ sở không gian trình duyệt có sẵn |\r\n| Khi một trang web được phát triển bằng cách sử dụng thiết kế adaptive được mở trên trình duyệt máy tính để bàn, trước tiên không gian có sẵn sẽ được phát hiện và sau đó bố cục có kích thước phù hợp nhất sẽ được chọn và sử dụng để hiển thị nội dung. Thay đổi kích thước của cửa sổ trình duyệt không ảnh hưởng đến thiết kế | Khi một trang web được phát triển bằng cách sử dụng thiết kế responsive được mở trên trình duyệt trên máy tính để bàn và khi ta thay đổi kích thước cửa sổ trình duyệt, nội dung của trang web được sắp xếp động và tối ưu để phù hợp với cửa sổ |\r\n| Thông thường, các thiết kế adaptive sử dụng sáu chiều rộng màn hình tiêu chuẩn - 320px, 480px, 760px, 960px, 1200px, 1600 . Các kích thước này được phát hiện và các bố cục thích hợp được tải | Thiết kế này sử dụng các truy vấn CSS để thay đổi kiểu tùy thuộc vào thuộc tính thiết bị mục tiêu để thích ứng với các màn hình khác nhau |\r\n| Đầu tiên phải mất rất nhiều thời gian và nỗ lực để xem xét các lựa chọn và thực tế của người dùng cuối, sau đó thiết kế các giải pháp thích ứng tốt nhất có thể cho họ | Nói chung, thiết kế responsive cần ít công việc hơn để xây dựng và thiết kế các trang web linh hoạt có thể chứa nội dung từ màn hình tùy thuộc vào kích thước màn hình |\r\n| Cung cấp nhiều quyền kiểm soát thiết kế để phát triển các trang web cho các màn hình cụ thể | Không có nhiều quyền kiểm soát thiết kế được cung cấp ở đây |</p>",
      "level": "fresher"
    },
    {
      "question": "Làm thế nào để các CSS Selector ứng với các phần tử của trình duyệt?",
      "answer": "<p>Thứ tự của các selector phù hợp đi từ phải sang trái của biểu thức selector. Các phần tử trong DOM được trình duyệt lọc dựa trên các khóa selector và sau đó được chuyển đến các phần tử mẹ để xác định các kết quả phù hợp. Tốc độ xác định các phần tử phụ thuộc vào độ dài của chuỗi các selector. Hãy xem xét một ví dụ:\r\n\r\n``<code>css\r\np span{ \r\n    color: black;\r\n}\r\n</code>`<code>\r\n\r\n<img src=\"/interview-assets/CSS_selectors_matched_against_the_elements_by_the_browser.png\" alt=\"\" />\r\n\r\nỞ đây, trước tiên trình duyệt tìm tất cả các phần tử </code>span<code> trong DOM và sau đó nó chuyển đến từng phần tử cha của nó để kiểm tra xem chúng có phải là phần tử của đoạn </code>p<code> hay không.\r\n\r\nSau khi trình duyệt tìm thấy tất cả các thẻ </code>span<code> phù hợp có các phần tử </code>p` là cha và áp dụng màu đen cho nội dung, quá trình so sánh sẽ bị dừng lại.</p>",
      "level": "fresher"
    },
    {
      "question": "Border-box khác với content-box như thế nào?",
      "answer": "<p><code>content-box</code> là thuộc tính xác định giá trị mặc định cho kích thước hộp. Thuộc tính width và height chỉ bao gồm nội dung bằng cách loại trừ border và padding. Hãy xem xét một ví dụ như sau:\r\n\r\n``<code>css\r\ndiv{\r\n    width:300px;\r\n    height:200px;\r\n    padding:15px;\r\n    border: 5px solid grey;\r\n    margin:30px;\r\n    -moz-box-sizing:content-box;\r\n    -webkit-box-sizing:content-box;\r\n    box-sizing:content-box;\r\n}\r\n</code>`<code>\r\n\r\nỞ đây, kích thước hộp cho phần tử div được cung cấp dưới dạng </code>content-box<code>. Điều đó có nghĩa là height và width được xem xét cho nội dung div sẽ loại trừ padding và border. Chúng ta sẽ nhận được đầy đủ các thông số chiều cao và chiều rộng được chỉ định cho nội dung như trong hình bên dưới.\r\n\r\n<img src=\"/interview-assets/content_box.png\" alt=\"\" />\r\n\r\n</code>border-box<code> là thuộc tính bao gồm nội dung và padding, border trong thuộc tính height và width. Hãy xem ví dụ sau:\r\n\r\n</code>`<code>css\r\ndiv{\r\n    width:300px;\r\n    height:200px;\r\n    padding:15px;\r\n    border: 5px solid grey;\r\n    margin:30px;\r\n    -moz-box-sizing:border-box;\r\n    -webkit-box-sizing:border-box;\r\n    box-sizing:border-box;\r\n}\r\n</code>`<code>\r\n\r\nỞ đây, kích thước hộp cho phần tử div được cung cấp dưới dạng </code>border-box`. Điều đó có nghĩa là height và width được xem xét cho nội dung div cũng sẽ bao gồm phần border và padding. Điều này có nghĩa là chiều cao thực của nội dung div sẽ là:\r\n\r\n<img src=\"/interview-assets/border_box.png\" alt=\"\" /></p>",
      "level": "fresher"
    },
    {
      "question": "Opacity được quy định như thế nào trong CSS3?",
      "answer": "<p>Opacity ám chỉ mức độ nội dung trong suốt hoặc không trong suốt. Chúng ta có thể sử dụng thuộc tính có tên opacity nhận các giá trị từ 0 đến 1. 0 chỉ định rằng phần tử là hoàn toàn trong suốt, trong khi 1 có nghĩa là phần tử hoàn toàn không trong suốt. Chúng ta có thể sử dụng thuộc tính opacity như sau:\r\n\r\n``<code>css\r\ndiv { \r\n    opacity: 0.6;\r\n}\r\n</code>`<code>\r\n\r\nTrong ví dụ trên, độ mờ 60% được áp dụng cho phần div. Thuộc tính opacity không được trình duyệt internet explorer hỗ trợ. Để làm cho nó hoạt động ở đó, chúng ta cần sử dụng thuộc tính filter là polyfill như ví dụ bên dưới.\r\n\r\n</code>`<code>css\r\ndiv { \r\n    opacity: 0.6;\r\n    filter: alpha(opacity=60);\r\n}\r\n</code>``\r\n\r\n<img src=\"/interview-assets/opacity_in_css3.png\" alt=\"\" /></p>",
      "level": "fresher"
    },
    {
      "question": "Tại sao chúng ta nên sử dụng thuộc tính float trong CSS?",
      "answer": "<p>Thuộc tính float được sử dụng để định vị các phần tử HTML theo chiều ngang về phía bên trái hoặc bên phải của container. Ví dụ,\r\n\r\n``<code>css\r\nfloat-demo {\r\n\tfloat: right;\r\n}\r\n</code>``\r\n\r\nỞ đây, phần tử mà lớp được áp dụng đảm bảo rằng phần tử được định vị ở bên phải của container. Nếu bạn chỉ định giá trị của float ở bên trái, thì phần tử sẽ được đặt ở bên trái của container.</p>",
      "level": "fresher"
    },
    {
      "question": "z-index là gì? Nó hoạt động như thế nào?",
      "answer": "<p>z-index được sử dụng để chỉ định cách xếp chồng theo chiều sâu của các phần tử chồng lên nhau xảy ra tại thời điểm định vị nó. Nó chỉ định thứ tự ngăn xếp theo chiều sâu của các phần tử được định vị giúp xác định cách hiển thị các phần tử diễn ra như thế nào trong trường hợp chồng chéo.\r\n\r\nGiá trị mặc định của thuộc tính này là 0 và có thể là số dương hoặc số âm. Ngoài 0, các giá trị của z-index có thể là:\r<ul><li>Auto: Thứ tự ngăn xếp bằng với phần tử cha.</li></ul>\r<ul><li>Number: Có thể là dương hoặc âm. Nó xác định thứ tự ngăn xếp.</li></ul>\r<ul><li>Initial: Giá trị mặc định là 0.</li></ul>\r<ul><li>Inherit: Kế thừa giá trị từ phần tử cha.</li></ul>\r\n\r\nCác phần tử có giá trị z-index nhỏ hơn được xếp chồng thấp hơn các phần tử có z-index cao hơn.\r\n\r\n<img src=\"/interview-assets/z-index.png\" alt=\"\" />\r\n\r\nTừ hình trên, chúng ta có thể thấy rằng khi giá trị của z-index tăng dọc theo trục z, thứ tự xếp chồng sẽ hướng về phía trên cùng của các phần tử khác dọc theo trục tung.</p>",
      "level": "fresher"
    },
    {
      "question": "Các CSS selector sau đây có nghĩa là gì?",
      "answer": "<p><em> div, p\r\n</em> div p\r\n<em> div ~ p\r\n</em> div + p\r\n<em> div > p\r\n\r\nÝ nghĩa của chúng như sau:\r\n\r\n</em> <code>div, p</code>: Selector này ngụ ý chọn tất cả các phần tử div và tất cả các phần tử p.\r\n\r\n``<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n\tDivision 1\r\n\t&lt;p&gt; paragraph 1&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt; \r\n&lt;p&gt; paragraph 3&lt;/p&gt; \r\n&lt;div&gt;\r\n\tDivision 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nỞ đây, tất cả các phần tử div và phần tử p sẽ được trình duyệt chọn bất kể cha mẹ của chúng hay chúng được đặt ở đâu. Các thẻ còn lại như h1 và span bị bỏ qua.\r\n\r\n<em> </code>div p<code>: Selector cho biết chọn tất cả các phần tử p nằm bên trong các phần tử div. Hãy xem xét một ví dụ dưới đây:\r\n\r\n</code>`<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n    Division 1\r\n    &lt;p&gt; paragraph 1&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n    &lt;div&gt;\r\n        &lt;p&gt; Inner Div Paragraph &lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n    &lt;/div&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt;\r\n&lt;p&gt; paragraph 3&lt;/p&gt;\r\n&lt;div&gt;\r\n    Division 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nỞ dây, </code><p> paragraph 1</p><code> và </code><p> Inner Div Paragraph </p><code> sẽ được chọn bởi trình duyệt và thuộc tính được áp dụng. Phần còn lại sẽ không được chọn.\r\n\r\n</em> </code>div ~ p<code>: Selector này chọn tất cả các phần tử p có phần tử div đứng trước ở bất kỳ đâu.\r\n\r\n</code>`<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n   Division 1\r\n   &lt;p&gt; paragraph 1&lt;/p&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;p&gt; paragraph 3&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;div&gt;\r\n   Division 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nỞ đây, các phần tử của paragraph 2 và paragraph 3 sẽ được chọn như được đánh dấu trong đoạn code trên.\r\n\r\n<em> </code>div + p<code>: Selector nàychọn tất cả các phần tử p được đặt ngay sau phần tử div.\r\n\r\n</code>`<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n\tDivision 1\r\n\t&lt;p&gt; paragraph 1&lt;/p&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;p&gt; paragraph 3&lt;/p&gt; \r\n&lt;div&gt;\r\n\tDivision 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nTrong trường hợp này, chúng ta có phần tử paragraph 2 ngay sau thẻ div. Do đó, chỉ phần tử đó sẽ được chọn.\r\n\r\n</em> </code>div > p<code>: Selector này chọn tất cả các phần tử p có div là cha trực tiếp. Trong cùng một ví dụ dưới đây:\r\n\r\n</code>`<code>html\r\n&lt;h1&gt;Heading 1&lt;/h1&gt;\r\n&lt;div&gt;\r\n\tDivision 1\r\n\t&lt;p&gt; paragraph 1&lt;/p&gt; &lt;!-- Will be selected --&gt;\r\n&lt;/div&gt;\r\n&lt;p&gt; paragraph 2&lt;/p&gt; \r\n&lt;p&gt; paragraph 3&lt;/p&gt; \r\n&lt;div&gt;\r\n\tDivision 2\r\n&lt;/div&gt;\r\n&lt;span&gt; Span 1 &lt;/span&gt;\r\n</code>`<code>\r\n\r\nChỉ </code><p> paragraph 1</p>` được chọn trong trường hợp này vì nó có div là cha trực tiếp.</p>",
      "level": "fresher"
    },
    {
      "question": "Thuộc tính flexbox là gì?",
      "answer": "<p>Flexbox Layout (hay còn gọi là Flexible Box) là một kiểu bố cục trang có khả năng tự cân đối kích thước, thay đổi chiều rộng/chiều cao và thứ tự phần tử bên trong để phù hợp với tất cả các loại thiết bị hiển thị và kích thước màn hình.\r\n\r\nVới bố cục thông thường, bạn cần phải thiết lập kích thước của phần tử, thiết lập hiển thị dạng block hay inline, cho nó float, còn với Flexbox bạn chỉ cần thiết lập phần hiển thị theo chiều ngang hay chiều dọc, lúc đó các phần tử bên trong có thể hiển thị theo ý muốn.\r\n\r\n<img src=\"/interview-assets/flex-terminology.png\" alt=\"\" />\r\n\r\nCác thuộc tính flexbox:\r<ul><li><strong>flex-direction</strong>: Thuộc tính này giúp xác định hướng container sẽ xếp chồng các mục cho linh hoạt. Các giá trị của thuộc tính này có thể là:</li></ul>\r<ul><li>row: xếp các mục theo chiều ngang từ trái sang phải trong flex container.</li></ul>\r<ul><li>column: xếp các mục theo chiều dọc từ trước ra sau trong flex container.</li></ul>\r<ul><li>row-reverse: xếp các mục theo chiều ngang từ phải sang trái trong flex container.</li></ul>\r<ul><li>column-reverse: xếp các mục theo chiều dọc từ sau ra trước trong flex container.</li></ul>\r<ul><li><strong>flex-wrap</strong>: Thuộc tính này chỉ định các mục flex nên được bọc hay không. Giá trị có thể là:</li></ul>\r<ul><li>wrap: mục flex nên được bọc.</li></ul>\r<ul><li>nowrap: giá trị mặc định này là mục không được bọc.</li></ul>\r<ul><li>wrap-reverse: chỉ định này cho biết mục sẽ được bọc nếu cần nhưng theo thứ tự ngược.</li></ul>\r<ul><li><strong>flex-flow</strong>: thuộc tính này thiết lập cả flex-direction và flex-wrap trong một dòng.</li></ul>\r<ul><li><strong>justify-content</strong>: dùng cho căn chỉnh mục. Các giá trị có thể:</li></ul>\r<ul><li>center: có nghĩa là các mục hiện ở trung tâm của container.</li></ul>\r<ul><li>flex-start: đây là giá trị mặc định, sẽ được căn chỉnh từ điểm bắt đầu container.</li></ul>\r<ul><li>flex-end: các mục sẽ được căn chỉnh từ điểm cuối của container.</li></ul>\r<ul><li>space-around: các mục sẽ được căn chỉnh với khoảng trắng giữa, trước và xung quanh các mục.</li></ul>\r<ul><li>space-between: các mục sẽ được căn chỉnh với khoảng trắng giữa các mục.</li></ul>\r<ul><li><strong>align-items</strong>: sử dụng cho căn chỉnh mục flex.</li></ul>\r<ul><li><strong>align-content</strong>: sử dụng cho căn chỉnh dòng flex.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Xếp tầng trong CSS là gì?",
      "answer": "<p>Cascanding hay xếp tầng, đề cập đến quá trình xem xét các khai báo kiểu và xác định trọng lượng hoặc tầm quan trọng của các quy tắc tạo kiểu giúp trình duyệt chọn quy tắc nào phải được áp dụng trong thời gian xung đột. Xung đột ở đây đề cập đến nhiều quy tắc có thể áp dụng cho một phần tử HTML cụ thể. Trong những trường hợp như vậy, chúng ta cần cho trình duyệt biết phong cách nào cần được áp dụng cho phần tử. Điều này được thực hiện bằng cách xếp tầng danh sách các phần tử khai báo kiểu.\r\n\r\nVí dụ:\r\n\r\n``<code>css\r\np {\r\n    color:white;\r\n}\r\n</code>`<code>\r\n\r\nvà chúng ta cũng có khai báo sau bên dưới nó hoặc trong một biểu định kiểu khác đã được liên kết với trang:\r\n\r\n</code>`<code>css\r\np {\r\n    color:black;\r\n}\r\n</code>`<code>\r\n\r\nỎ đây, chúng ta có xung đột về thuộc tính màu cho các phần tử của đoạn văn. Trình duyệt chỉ cần phân tầng để xác định đâu là kiểu mới nhất và cụ thể nhất và áp dụng kiểu đó. Vì ta có </code>color:black;<code> như một khai báo cụ thể nhất, màu đen được áp dụng cho các phần tử của đoạn văn. Bây giờ nếu bạn muốn đảm bảo màu trắng được áp dụng cho đoạn văn, chúng ta có thể xác định trọng số cho kiểu đó bằng cách thêm </code>!important<code> như hình dưới đây:\r\n\r\n</code>`<code>css\r\np {\r\n    color:white !important;\r\n}\r\n</code>`<code>\r\n\r\n</code>!important` đảm bảo rằng thuộc tính có trọng lượng tối đa khi có các thuộc tính xung đột khác.\r\n\r\n## Câu hỏi phỏng vấn CSS cho Experienced</p>",
      "level": "fresher"
    },
    {
      "question": "Giải thích thuộc tính position CSS?",
      "answer": "<p><ul><li><strong>static</strong>: vị trí mặc định/tĩnh của phần tử và bạn đặt đâu phần tử sẽ nằm ở đó.</li></ul>\r<ul><li><strong>relative</strong>: vị trí của phần tử sẽ tương đối so với vị trí tĩnh bạn đặt và khoản không gian xung quanh phần tử sẽ được giữ nguyên.</li></ul>\r<ul><li><strong>fixed</strong>: vị trí sẽ nằm cố định một chỗ, dù bạn có làm gì, phần tử vẫn nằm cố định 1 vị trí trên màn hình.</li></ul>\r<ul><li><strong>absolute</strong>: vị trí của phần tử sẽ được xác định từ padding của phần tử cha.</li></ul>\r<ul><li><strong>sticky</strong>: vị trí của phần tử sẽ được định vị khi người dùng sử dụng thanh scroll.</li></ul>\r\n\r\n<img src=\"/interview-assets/CSS_Position_Property.jpg\" alt=\"\" /></p>",
      "level": "fresher"
    },
    {
      "question": "Khi nào thì xảy ra DOM reflow?",
      "answer": "<p>Reflow là tên của quá trình mà trình duyệt web tính toán lại vị trí và hình dạng của các phần tử trong document, nhằm mục đích hiển thị lại một phần hoặc toàn bộ document.\r\n\r\nReflow xảy ra khi:\r<ul><li>Chèn, xóa hoặc cập nhật một phần tử trong DOM.</li></ul>\r<ul><li>Sửa đổi nội dung trên trang, ví dụ: văn bản trong hộp nhập liệu.</li></ul>\r<ul><li>Di chuyển một phần tử DOM.</li></ul>\r<ul><li>Tạo hoạt ảnh cho một phần tử DOM.</li></ul>\r<ul><li>Thực hiện các phép đo một phần tử như <code>offsetHeight</code> hoặc <code>getComputedStyle</code>.</li></ul>\r<ul><li>Thay đổi kiểu CSS.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa các thuộc tính Box Sizing?",
      "answer": "<p>Thuộc tính CSS box-sizing quy định cách tính tổng chiều rộng và chiều cao của một phần tử.\r<ul><li><strong>Context-box:</strong> Giá trị chiều rộng và chiều cao mặc định chỉ áp dụng cho nội dung của phần tử. Padding và border nằm ở bên ngoài hộp.</li></ul>\r<ul><li><strong>Padding-box:</strong> Giá trị chiều rộng và chiều cao mặc định chỉ áp dụng cho nội dung của phần tử và padding của nó. Border nằm ở bên ngoài hộp. Hiện tại chỉ có Firefox hỗ trợ padding-box.</li></ul>\r<ul><li><strong>Border-box:</strong>  Giá trị chiều rộng và chiều cao áp dụng cho nội dung, padding và border.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Làm sao để căn giữa một div trong một div khác?",
      "answer": "<p>Ta có :\r\n\r\n``<code>html\r\n&lt;div class=&quot;cn&quot;&gt;&lt;div class=&quot;inner&quot;&gt;your content&lt;/div&gt;&lt;/div&gt;\r\n</code>`<code>\r<ul><li>Căn giữa với Table</li></ul>\r\n\r\n</code>`<code>css\r\n.cn {\r\n\tdisplay: table-cell;\r\n\twidth: 500px;\r\n\theight: 500px;\r\n\tvertical-align: middle;\r\n\ttext-align: center;\r\n}\r\n\r\n.inner {\r\n\tdisplay: inline-block;\r\n\twidth: 200px; height: 200px;\r\n}\r\n</code>`<code>\r<ul><li>Căn giữa với Transform</li></ul>\r\n\r\n</code>`<code>css\r\n.cn {\r\n\tposition: relative;\r\n\twidth: 500px;\r\n\theight: 500px;\r\n}\r\n\r\n.inner {\r\n\tposition: absolute;\r\n\ttop: 50%; left: 50%;\r\n\ttransform: translate(-50%,-50%);\r\n\twidth: 200px;\r\n\theight: 200px;\r\n}\r\n</code>`<code>\r<ul><li>Căn giữa với Flexbox</li></ul>\r\n\r\n</code>`<code>css\r\n.cn {\r\n\tdisplay: flex;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n}\r\n</code>`<code>\r<ul><li>Căn giữa với Grid</li></ul>\r\n\r\n</code>`<code>html\r\n&lt;div class=&quot;wrap_grid&quot;&gt;\r\n\t&lt;div id=&quot;container&quot;&gt;vertical aligned text&lt;br /&gt;some more text here\r\n\t&lt;/div&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\n</code>`<code>css\r\n.wrap-grid {\r\n\tdisplay: grid;\r\n\tplace-content: center;\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Kể tên bốn loại thuộc tính @media?",
      "answer": "<p>1. All -> Thuộc tính mặc định dùng cho tất cả thiết bị.\r\n2. Screen -> sử dụng màn hình máy tính, điện thoại.\r\n3. Print -> Sử dụng cho máy in.\r\n4. Speech -> Sử dụng cho màn hình người đọc.</p>",
      "level": "fresher"
    },
    {
      "question": "Hệ thống grid là gì?",
      "answer": "<p>CSS Grid layout là một hệ thống layout 2 chiều (x,y) được dùng trong thiết kế UI. Theo định nghĩa từ Mozilla, grid (lưới) là một tổ hợp của những đường ngang và dọc cắt nhau – một nhóm xác định các cột và nhóm kia xác định các hàng. Các phần tử có thể được đặt lên grid, dựa vào các đường hàng và cột này.\r\n\r\n<img src=\"/interview-assets/grid-term.jpg\" alt=\"\" />\r<ul><li>Grid Item: Phần container bao gồm các grid items.</li></ul>\r<ul><li>Grid Line: Đường thẳng theo chiều dọc và ngang để xây dựng cấu trúc grid.</li></ul>\r<ul><li>Grid Cell: Đơn vị nhỏ nhất trong grid. Nó là không gian giữa các hàng và cột.</li></ul>\r<ul><li>Rows: Là đường nằm ngang trong grid.</li></ul>\r<ul><li>Columns: Là đường nằm dọc trong grid.</li></ul>\r<ul><li>Gutter: Là độ rộng không gian của hàng hay cột trong grid.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Các cách để ẩn phần tử với CSS?",
      "answer": "<p><ul><li>Sử dụng thuộc tính <code>display: none</code>. Phần tử sẽ không xuất hiện trong DOM. </li></ul>\r<ul><li>Sử dụng thuộc tính <code>visibility: hidden</code>, phần tử có xuất hiện trong DOM, nhưng không hiển thị trên màn hình cho người dùng.</li></ul>\r<ul><li>Sử dụng thuộc tính <code>position: absolute</code>. Khả dụng bên ngoài màn hình.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": ":root pseudo-class đề cập tới cái gì?",
      "answer": "<p>:root selector cho phép bạn chỉ đến phần tử \"cha\" cao nhất trong DOM, hoặc cây document. Nó được xác định trong tài liệu đặc tả CSS Selectors Level 3.</p>",
      "level": "fresher"
    },
    {
      "question": "Chiến lược mobile-first là gì?",
      "answer": "<p>Để reponsive một trang web có nghĩa là các phần tử sẽ thay đổi kích thước hoặc chức năng tuỳ theo kích thước màn hình của thiết bị, thường là thay đổi chiều rộng (width), thông qua các truy vấn media CSS, chẳng hạn như làm nhỏ kích thước phông chữ trên các thiết bị nhỏ hơn.\r\n\r\n``<code>css\r\n@media (min-width: 601px) {\r\n  .my-class {\r\n    font-size: 24px;\r\n  }\r\n}\r\n@media (max-width: 600px) {\r\n  .my-class {\r\n    font-size: 12px;\r\n  }\r\n}\r\n</code>`<code>\r\n\r\nChiến lược mobile-first là một reponsive mà ta nên xác định các style trên thiết bị di động và chỉ thay đổi quy tắc cho các thiết bị khác sau. Ví dụ như:\r\n\r\n</code>`<code>css\r\n.my-class {\r\n  font-size: 12px;\r\n}\r\n\r\n@media (min-width: 600px) {\r\n  .my-class {\r\n    font-size: 24px;\r\n  }\r\n}\r\n</code>`<code>\r\n\r\nChiến lược mobile-first có hai ưu điểm:\r<ul><li>Nó hoạt động hiệu quả hơn trên thiết bị di động, vì tất cả các quy tắc áp dụng cho chúng không cần phải được xác thực dựa trên bất kỳ truy vấn </code>media<code> nào.</li></ul>\r<ul><li>Nó buộc phải viết code rõ ràng hơn liên quan đến các quy tắc CSS reponsive.</li></ul>\r\n\r\nVí dụ\r\n\r\n</code>`<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n  &lt;head&gt;\r\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\r\n  &lt;title&gt;CSS Media Query&lt;/title&gt;\r\n  &lt;style&gt;\r\n    body {\r\n        background-color: lightgreen;\r\n    }\r\n\r\n    @media only screen and (max-width: 800px) {\r\n        body {\r\n            background-color: rgb(233, 50, 18);\r\n        }\r\n    }\r\n  &lt;/style&gt;\r\n  &lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;h1&gt;Resize the browser window&lt;/h1&gt;\r\n    &lt;h2&gt;When the width of this document is 800px or less, the background-color is &quot;green&quot;, \r\n      otherwise it is &quot;Red&quot;.&lt;/h2&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Làm thế nào để khôi phục giá trị mặc định của thuộc tính?",
      "answer": "<p>Từ khoá <code>initial</code> có thể được dùng để khôi phục giá trị mặc định.</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa CSS grid và flexbox?",
      "answer": "<p>1. CSS Grid là hệ thống dựng layout 2 chiều, có nghĩa là chúng ta có thể xử lý theo cột và hàng, không giống như Flexbox là hệ thống layout 1 chiều. ( xử lý theo 1 cột hoặc 1 hàng ).\r\n\r\n2. Điểm khác biệt cốt lõi giữa CSS Grid và Flexbox đó là: CSS Grid tiếp cận theo hướng bố cục (layout) dung còn Flexbox tiếp cận theo hướng nội dung. Nếu bạn biết được rõ trước nội dung mình cần trình bày hãy dùng CSS Flexbox ngược lại thì chọn CSS Grid.\r\n\r\n3. Flexbox phù hợp với các website có bố cục đơn giản, CSS Grid phù hợp với website có bố cục phức tạp hơn.\r\n\r\n4. Nếu bạn chỉ cần dựng layout theo 1 hàng hoặc 1 cột thì Flexbox sẽ phù hợp hơn. Ngược lại, nếu bạn muốn xác định grid và điều chỉnh nội dung theo 2 chiều - CSS Grid sẽ là lựa chọn của bạn.\r\n\r\n<img src=\"/interview-assets/flex.png\" alt=\"\" />\r\n\r\n<img src=\"/interview-assets/grid.png\" alt=\"\" />\r\n\r\nVí dụ\r\n\r\n``<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n  &lt;head&gt;\r\n    &lt;title&gt;Grid vs Flexbox Layout&lt;/title&gt;\r\n  &lt;/head&gt;\r\n  &lt;style&gt;\r\n    /<em> Grid layout </em>/\r\n    .row {\r\n        display: grid;\r\n        grid-template-columns: auto auto auto;\r\n        background-color: #2196f3;\r\n        padding: 5px;\r\n    }\r\n\r\n    .col-item {\r\n        background-color: rgba(255, 255, 255, 0.8);\r\n        border: 1px solid rgba(0, 0, 0, 0.8);\r\n        padding: 10px;\r\n        font-size: 30px;\r\n        text-align: center;\r\n    }\r\n\r\n    /<em> Flexbox layout </em>/\r\n    .wrapper {\r\n        border: 2px solid #f76707;\r\n        border-radius: 5px;\r\n        background-color: #fff4e6;\r\n    }\r\n\r\n    .wrapper &gt; div {\r\n        border: 2px solid #ffa94d;\r\n        border-radius: 5px;\r\n        background-color: #ffd8a8;\r\n        padding: 1em;\r\n        color: #d9480f;\r\n    }\r\n\r\n    .wrapper {\r\n        display: flex;\r\n        width: 500px;\r\n        flex-wrap: wrap;\r\n    }\r\n\r\n    .wrapper &gt; div {\r\n        flex: 1 1 150px;\r\n    }\r\n  &lt;/style&gt;\r\n  &lt;body&gt;\r\n    &lt;p&gt;&lt;h1&gt;Grid Layout Example&lt;hr/&gt;&lt;/h1&gt;&lt;/p&gt;\r\n    &lt;div class=&quot;row&quot;&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 1&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 2&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 3&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 1&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 2&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 3&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 1&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 2&lt;/div&gt;\r\n        &lt;div class=&quot;col-item&quot;&gt;Column - 3&lt;/div&gt;\r\n    &lt;/div&gt;\r\n\r\n    &lt;p&gt;&lt;h1&gt;&lt;br/&gt;Flexbox Layout Example&lt;hr/&gt;&lt;/h1&gt;&lt;/p&gt;\r\n    &lt;div class=&quot;wrapper&quot;&gt;\r\n        &lt;div&gt;One&lt;/div&gt;\r\n        &lt;div&gt;Two&lt;/div&gt;\r\n        &lt;div&gt;Three&lt;/div&gt;\r\n        &lt;div&gt;Four&lt;/div&gt;\r\n        &lt;div&gt;Five&lt;/div&gt;\r\n    &lt;/div&gt;\r\n  &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Calc dùng để làm gì?",
      "answer": "<p>Trong CSS3, hàm <code>calc()</code> cho phép ta thực hiện các phép tiến trên giá trị thuộc tính. Thay vì khai báo trực tiếp, với <strong>width</strong> là giá trị tĩnh ta có thể dùng <code>calc()</code> để chỉ định giá trị <strong>width</strong> bằng các phép tính trên các giá trị số.\r\n\r\n``<code>css\r\n.foo {\r\n\twidth: calc(100px + 50px)\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Tuỳ chỉnh thuộc tính biến trong CSS?",
      "answer": "<p>Tuỳ chỉnh thuộc tính (thỉnh thoảng đề cập đến biến CSS) được định nghĩa bởi người dùng bao gồm giá trị cụ thể để sử dụng nhiều lần trong document. Giá trị là một tập hợp sử dụng ký hiệu <strong>--</strong>. Và giá trị được truy cập bằng hàm <code>var()</code>.\r\n\r\n``<code>css\r\n:root {\r\n\t--main-bg-color: brown\r\n}\r\n\r\n.one {\r\n\tcolor: white;\r\n\tbackground-color· var (--main-bg-color);\r\n\tmargin: l0px,\r\n\twidth: 50px,\r\n\theight: 5Opx;\r\n\tdisplay: inline-block;\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt của biến CSS và biến preprocessor (SASS, LESS, Stylus)?",
      "answer": "<p><ul><li>Biến CSS có thể dùng mà không cần preprocessor. Đồng thời, tất cả trình duyệt đều hỗ trợ biến CSS.</li></ul>\r<ul><li>Biến CSS có tác động nối tiếp. Còn preprocessor không cần.</li></ul>\r<ul><li>Biến CSS có thể truy cập và quản lý trong JavaScript</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "`* { box-sizing: border-box }` là gì?",
      "answer": "<p><ul><li>Nó điều chỉnh tất cả phần tử có bao gồm padding, border trong không gian phần tử cho tính toàn chiều dài và chiều rộng.</li></ul>\r<ul><li>Trong <code>box-sizing: border-box</code>, chiều cao phần tử được tính toán với: height + padding dọc + độ dài border dọc. Còn chiều dài là width + padding ngang + độ dài border ngang.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "!important trong CSS là gì?",
      "answer": "<p>Các style có từ khoá important sẽ được ưu tiên cao nhất và ghi đè lên các thuộc tính bị trùng.\r\n\r\n``<code>css\r\np {\r\n \tcolor: red !important;\r\n}\r\n#thing {\r\n \tcolor: green;\r\n} \r\n&lt;p id=&quot;thing&quot;&gt;Will be RED.&lt;/p&gt;\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Tính đặc hiệu trong CSS?",
      "answer": "<p>Tính đặc hiệu hay độ ưu tiên (specificity) là cách mà trình duyệt quyết định sẽ áp dụng thuộc tính css nào với một phần tử khi có nhiều quy tắc css cùng trỏ đến phần tử đó. \r\n\r\nInline style sẽ được ưu tiên so với ID rồi đến giá trị lớp (pseudo-class hoặc attribute selector), universal selector *<em>(</em>)** sẽ không có độ ưu tiên. ID Selector có độ ưu tiên cao hơn attribute selector.</p>",
      "level": "fresher"
    },
    {
      "question": "Progressive rendering là gì?",
      "answer": "<p>Progressive rendering là một kỹ thuật sử dụng để cải thiện hiệu suất trang web (cụ thể là cải thiện thời gian tải web) để render nội dung cho hiển thị nhanh nhất có thể.\r\n\r\nTa có thể triển khai progressive rendering bằng cách lazy loading với hình ảnh. Ta sử dụng Intersection Observer API cho lazy load ảnh. API giúp đơn giản hoá việc phát hiện một phần tử đi vào viewport và thực hiện hành động khi phần tử đó thực hiện hành động. Khi image vào viewport, ta mới bắt đầu tải ảnh. \r\n\r\nVí dụ:\r\n\r\n``<code>html\r\n&lt;img class=&quot;lazy&quot;\r\nsrc=&quot;placeholder-image.jpg&quot;\r\ndata-src=&quot;image-to-lazy-load-1x.jpg&quot;\r\ndata-srcset=&quot;image-to-lazy-load-2x.jpg 2x, image-to-lazy-load-1x.jpg 1x&quot;\r\nalt=&quot;I&#39;m an image!&quot;&gt;\r\n</code>`<code>\r\n\r\n</code>`<code>js\r\ndocument.addEventListener(&quot;DOMContentLoaded&quot;, function() {\r\n\tvar lazyImages = [].slice.call(document.querySelectorAll(&quot;img.lazy&quot;));\r\n\r\n\tif (&quot;IntersectionObserver&quot; in window) {\r\n\t\tlet lazyImageObserver = new IntersectionObserver(function(entries, observer) {\r\n\t\t\tentries.forEach(function(entry) {\r\n\t\t\t\tif (entry.isIntersecting) {\r\n\t\t\t\tlet lazyImage = entry.target;\r\n\t\t\t\tlazyImage.src = lazyImage.dataset.src;\r\n\t\t\t\tlazyImage.srcset = lazyImage.dataset.srcset;\r\n\t\t\t\tlazyImage.classList.remove(&quot;lazy&quot;);\r\n\t\t\t\tlazyImageObserver.unobserve(lazyImage);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tlazyImages.forEach(function(lazyImage) {\r\n\t\t\tlazyImageObserver.observe(lazyImage);\r\n\t\t});\r\n\t} else {\r\n\t\t// Possibly fall back to event handlers here\r\n\t}\r\n});\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Lợi thế của dùng translate() thay vì position absolute?",
      "answer": "<p>Translate() không làm cho trình duyệt kích hoạt vẽ lại layout, mà chỉ thực hiện soạn thảo. Còn position: absolute làm trình duyệt phải vẽ lại các luồng DOM. Thế nền <code>translate()</code> đem về hiệu suất tốt hơn.</p>",
      "level": "fresher"
    },
    {
      "question": "Style nào sẽ được tải và áp dụng trước trong code sau?",
      "answer": "<p>``<code>html\r\n&lt;head&gt;\r\n\t&lt;link href=&quot;style1.css&quot; rel=&quot; stylesheet&quot;&gt;\r\n\t&lt;link href=&quot;style2.css&quot; rel=&quot;stylesheet&quot;&gt;\r\n&lt;/head&gt;\r\n</code>``\r\n\r\nStyle1.css sẽ được áp dụng trước vì CSS thực hiện theo thứ tự xuất hiện trong HTML.</p>",
      "level": "fresher"
    },
    {
      "question": "Làm sao để biết trình duyệt có hỗ trợ một tính năng nhất định không?",
      "answer": "<p>Sử dụng <code>@supports</code> trong CSS để biết trình duyệt có hỗ trợ tính năng hay không.\r\n\r\n``<code>css\r\n@supports (display: grid) {\r\n\tdiv {\r\n\t\tdisplay: grid;\r\n\t}\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Cách position absolute hoạt động?",
      "answer": "<p>Absolute là một cơ chế định vị mạnh mẽ cho phép người dùng đặt bất kỳ phần tử ở đâu vào một vị trí chính xác. Thuộc tính CSS như <code>right</code>, <code>left</code>, <code>top</code>, <code>bottom</code> sẽ xác định vị trí chính xác cần đặt phần tử. Trong absolute cần xem xét các điểm sau:\r<ul><li>Các phần tử được áp dụng absolute sẽ bị xoá khỏi luồng thông thường của HTML document.</li></ul>\r<ul><li>Bố cục HTML sẽ không tạo bất kỳ không gian nào cho các phần tử này trong bố cục trang.</li></ul>\r<ul><li>Các phần tử sẽ được định vị relative với phần tử cha (tổ tiên) gần nhất. Nếu không có phần tử cha nào nó sẽ được đặt tương ứng với container ban đầu.</li></ul>\r<ul><li>Vị trí cuối cùng của phần tử được xác định dựa trên các giá trị <code>top</code>, <code>left</code>, <code>right</code> và <code>bottom</code> được cung cấp.</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Các thuộc tính của overflow trong CSS?",
      "answer": "<p>Thuộc tính overflow trong CSS dùng để xử lý khi kích thước nội dụng vượt qua kích thước container.\r\n\r\nCú pháp:\r\n\r\n``<code>css\r\noverflow: visible|hidden|scroll|auto|initial|inherit;\r\n</code>`<code>\r\n\r\nCác thuộc tính:\r<ul><li>visible: phần nội dung tràn sẽ được hiển thị bên ngoài box phần tử.</li></ul>\r<ul><li>hidden: phần nội dung tràn bị ẩn đi.</li></ul>\r<ul><li>scroll: phần nội dung tràn được cắt, những sẽ được hiển thị khi scroll xuống.</li></ul>\r<ul><li>auto: tương tự như scroll</li></ul>\r<ul><li>initial: thiết lập giá trị mặc định</li></ul>\r<ul><li>inherit: kế thừa thuộc tính của phần tử cha</li></ul>\r<ul><li>overflow-x: chỉ định đỉnh trái/phải của nội dung nếu nội dung tràn khỏi phạm vi của nó.</li></ul>\r<ul><li>overflow-y: chỉ định đỉnh trên/dưới của nội dung nếu nội dung tràn khỏi phạm vi của nó.</li></ul>\r\n\r\nVí dụ:\r\n\r\n</code>`<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n\t&lt;head&gt;\r\n\t\t&lt;title&gt;CSS Overflow Property&lt;/title&gt;\r\n\t\t&lt;style&gt;\r\n\t\tdiv {\r\n\t\t\tbackground-color: #eee;\r\n\t\t\twidth: 200px;\r\n\t\t\theight: 100px;\r\n\t\t\tborder: 1px dotted black;\r\n\t\t\toverflow: scroll;\r\n\t\t\tpadding: 10px;\r\n\t\t}\r\n\t\t&lt;/style&gt;\r\n\t&lt;/head&gt;\r\n\t&lt;body&gt;\r\n\t\t&lt;h2&gt;CSS Overflow Property&lt;/h2&gt;\r\n\t\t&lt;p&gt;Setting the overflow value to scroll, the overflow is clipped and a scrollbar\r\n\t\t\tis added to scroll inside the box.\r\n\t\t&lt;/p&gt;\r\n\r\n\t\t&lt;div&gt;You can use the overflow property when you want to have better control of \r\n\t\t\tthe layout. The overflow property specifies what happens if content overflows \r\n\t\t\tan element&#39;s box.\r\n\t\t&lt;/div&gt;\r\n\t&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Bạn có thể căn chỉnh nội dung của thẻ `<p>` nằm ngay trung tâm của thẻ `<div>`?",
      "answer": "<p>Ta có thể dùng thuộc tính <code>text-align: center</code> bên trong div cha, để căn chỉnh nội dung nằm ngay trung tâm theo chiều ngang. Nhưng không ngay trung tâm chiều dọc. Để chỉnh nó theo chiều dọc ta cần làm gán position của phần tử cha là <code>relative</code> và ở phần tử con là <code>absolute</code>. Các phần tử con có giá trị <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code> là 0 để nó nằm ở giữa theo chiều dọc. Sau đó ta thiết lập margin là auto. Nó giả sử cả phần tử con và cha sẽ có giá trị height và width.\r\n\r\nXem như ta có height và width của phần tử div là 20% kích cỡ màn hình. Ta có height văn bản là 1.2em và width là 20%. Nếu muốn chỉnh văn bản nằm ở trung tâm div ta làm như sau:\r\n\r\n``<code>css\r\ndiv {\r\n    position : relative;  // Make position relative\r\n    height : 20%;\r\n    width : 20%;\r\n    text-align : center; //Align to center horizontally\r\n}\r\np {\r\n    position : absolute; // Make position absolute\r\n    top:0;                // Give values of top, bottom,left, right to 0\r\n    bottom:0;\r\n    left:0;\r\n    right:0;\r\n    margin : auto;        // Set margin as auto\r\n    height : 1.2 em;\r\n    width : 20%;\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Margin khác Padding như thế nào?",
      "answer": "<p>Thuộc tính margin được dùng để tạo không gian xung quanh phần tử. Ta có thể tạo không gian được xác định ở bên ngoài border. Ta có các thuộc tính sau cho margin:\r\n\r\n<em> margin-top\r\n</em> margin-right\r\n<em> margin-bottom\r\n</em> margin-left\r\n\r\nCác giá trị mà thuộc tính có thể có:\r\n\r\n<em> auto – Trình duyệt tự động tính toán margin khi ta sử dụng.\r\n</em> length – Giá trị có thể là <code>px</code>, <code>pt</code>, <code>cm</code>, <code>em</code>,... các giá trị có thể âm hoặc dương.\r\n<em> % - Ta cũng có thể cung cấp giá trị phần trăm cho margin\r\n</em> inherit - sử dụng giá trị từ phần tử cha.\r\n\r\nThuộc tính padding dùng cho tạo không gian xung quanh nội dung phần tử và bên trong border. Padding có các thuộc tính con sau:\r\n\r\n<em> padding-top\r\n</em> padding-right\r\n<em> padding-bottom\r\n</em> padding-left\r\n\r\nLưu ý: padding không có giá trị âm.\r\n\r\n<img src=\"/interview-assets/CSS_Margin_vs._Padding.png\" alt=\"\" /></p>",
      "level": "fresher"
    },
    {
      "question": "Cách để tự động đánh số giá trị heading của section và category?",
      "answer": "<p>Ta có thể dùng khái niệm CSS counter (bộ đếm). Điều này cho phép chúng ta điều chỉnh hình thức của nội dung dựa trên vị trí trong document. Để sử dụng nó, trước tiên chúng ta cần khởi tạo giá trị của thuộc tính <code>counter-reset</code>, giá trị này là 0 theo mặc định. Thuộc tính tương tự cũng được sử dụng để thay đổi giá trị thành bất kỳ số nào mà chúng ta cần. Sau khi khởi tạo, giá trị của bộ đếm có thể tăng hoặc giảm bằng cách sử dụng thuộc tính <code>counter-increment</code>. Tên của bộ đếm không được là các từ khóa CSS như <code>none</code>, <code>initial</code>, <code>inherit</code>, v.v. Nếu các từ khóa CSS được sử dụng, thì khai báo sẽ bị bỏ qua.\r\n\r\nVí dụ:\r\n\r\n``<code>css\r\nbody {\r\n  \tcounter-reset: header;   /<em> define counter named &#39;header&#39; whose initial value is 0 by default </em>/\r\n}\r\n\r\nh2::before {\r\n\tcounter-increment: header;   /<em> The value of header counter by 1.</em>/\r\n\tcontent: &quot;Header &quot; counter(header) &quot;: &quot;;  /<em> To display word Header and the value of the counter with colon before it.</em>/\r\n}\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "Sự khác biệt giữa nth-child() và nth-of-type()?",
      "answer": "<p>Cả hai đều là pseudo-classes.\r\n\r\n<code>nth-child()</code> được dùng để so khớp các phần tử dựa trên số đại diện cho vị trí của một phần tử dựa trên các phần tử anh chị em.\r\n\r\nVí dụ, trong đoạn code dưới đây, ta cung cấp <code>nth-child(4)</code> thì phần tử con thứ 4 sẽ được chọn bất kể loại. \r\n\r\n``<code>css\r\n.example:nth-child(4) {   \r\n    background: black; \r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div class=&quot;example&quot;&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt; &lt;!-- 4th Element to select and apply style--&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt; \r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt;\r\n&lt;/div&gt;\r\n</code>`<code>\r\n\r\n</code>nth-of-type()<code> cũng tương tự nhưng chỉ so khớp với các phần tử anh chị em cùng loại. Số để xác định trong </code>nth-of-type()<code> có thể là một hàm hoặc từ khoá như odd hay even.\r\n\r\nVí dụ: nếu ta cấp </code>p:nth-of-type(even)<code> thì các thẻ </code><p><code> và số thứ tự chẵn được áp dụng. \r\n\r\n</code>`<code>css\r\n.example p:nth-of-type(even) { \r\n    background: black; \r\n}\r\n</code>`<code>\r\n\r\n</code>`<code>html\r\n&lt;div class=&quot;example&quot;&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; \r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;!-- Select this and apply style--&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; \r\n\t&lt;div&gt;This is a div.&lt;/div&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt; \r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;!-- Select this and apply style--&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; \r\n\t&lt;div&gt;This is a div.&lt;/div&gt;\r\n\t&lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;!-- Select this and apply style--&gt;\r\n\t&lt;div&gt;This is a div.&lt;/div&gt;\r\n&lt;/div&gt;\r\n</code>``</p>",
      "level": "fresher"
    },
    {
      "question": "CSS Sprite là gì?",
      "answer": "<p>CSS Sprite dùng cho kết hợp nhiều hình ảnh thành một hình ảnh lớn. Nó thường dùng cho biểu diễn icons. Các ưu điểm của nó là:\r<ul><li>Giảm số lượng yêu cầu HTTP để lấy nhiều ảnh vì nó cho phép chỉ gửi một yêu cầu.</li></ul>\r<ul><li>Nó giúp tải trước các nội dung giúp hiển thị các icon hoặc hình ảnh khi di chuột và các pseudo-state khác.</li></ul>\r<ul><li>Khi có nhiều hình ảnh, trình duyệt sẽ thực hiện các lệnh gọi riêng biệt để lấy hình ảnh cho từng hình ảnh đó.</li></ul>\r\n\r\nSử dụng sprites, các hình ảnh được kết hợp thành một và chúng ta chỉ cần gọi hình ảnh đó bằng một lệnh gọi.\r\n\r\nHãy xem xét một ví dụ trong đó ứng dụng của chúng ta yêu cầu 3 hình ảnh như hình dưới đây (Không có Section Sprites). Nếu chúng ta đang cố gắng tải các hình ảnh một cách độc lập, chúng ta cần 3 yêu cầu HTTP khác nhau để lấy dữ liệu. Nhưng nếu chúng ta có CSS Sprites trong đó cả 3 hình ảnh được kết hợp thành 1 được phân tách bằng một số khoảng trắng, thì chúng ta chỉ yêu cầu 1 HTTP Request.\r\n\r\n<img src=\"/interview-assets/CSS_Sprites.png\" alt=\"\" />\r\n\r\n``<code>html\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n\t&lt;head&gt;\r\n\t\t&lt;style&gt;\r\n\t\t\t#home-icon {\r\n\t\t\t\tleft: 0px;\r\n\t\t\t\twidth: 46px;\r\n\t\t\t\tbackground: url(&#39;spriteFile.gif&#39;) 0 0;\r\n\t\t\t}\r\n\r\n\t\t\t#prev-icon {\r\n\t\t\t\tleft: 63px;\r\n\t\t\t\twidth: 43px;\r\n\t\t\t\tbackground: url(&#39;spriteFile.gif&#39;) -47px 0;\r\n\t\t\t}\r\n\r\n\t\t\t#next-icon {\r\n\t\t\t\tleft: 129px;\r\n\t\t\t\twidth: 43px;\r\n\t\t\t\tbackground: url(&#39;spriteFile.gif&#39;) -91px 0;\r\n\t\t\t}\r\n\t\t&lt;/style&gt;\r\n\t&lt;/head&gt;\r\n\t&lt;body&gt;\r\n\r\n\t\t&lt;img id=&quot;home-icon&quot; src=&quot;spriteFile.gif&quot; width=&quot;1&quot; height=&quot;1&quot;&gt;    &lt;!-- To display home icon here --&gt;\r\n\t\t&lt;img id=&quot;next-icon&quot; src=&quot;spriteFile.gif&quot; width=&quot;1&quot; height=&quot;1&quot;&gt;    &lt;!-- To display next icon icon here --&gt;\r\n\t\t&lt;img id=&quot;prev-icon&quot; src=&quot;spriteFile.gif&quot; width=&quot;1&quot; height=&quot;1&quot;&gt;    &lt;!-- To display previous icon icon here --&gt;\r\n\r\n\t&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code>`<code>\r\n\r\nTrong đoạn code trên, chúng ta đang cố gắng truy cập từng phần tử - </code>home<code>, </code>previous<code> và </code>next<code> - từ file sprite bằng cách sử dụng thuộc tính left, width. Hình ảnh được hiển thị trong phần img nhờ thuộc tính </code>background<code>. Lưu ý rằng nguồn của hình ảnh (thuộc tính </code>src<code> của thẻ img) chỉ là một file là </code>spriteFile.gif` và tùy thuộc vào các quy tắc được chỉ định trong id selector, hình ảnh được tải tương ứng.</p>",
      "level": "fresher"
    },
    {
      "question": "Tweening trong CSS?",
      "answer": "<p>Tweening là quá trình lấp đầy khoảng trống giữa các chuỗi khóa, tức là giữa các keyframes đã được tạo. Keyframes là những frame đại diện cho điểm bắt đầu và điểm kết thúc của hành động hoạt ảnh. Tweening liên quan đến việc tạo keyframe giữa hai hình ảnh để tạo ấn tượng rằng hình ảnh đầu tiên đã di chuyển mượt mà sang hình ảnh thứ hai. Với mục đích này, chúng ta sử dụng các thuộc tính như transforms - matrix, translate, scale, rotate,...\r\n\r\nTrong đoạn code bên dưới, ta tạo frame trung gian của các phần tử <code>&lt;p&gt;</code> để chuyển từ đầu đến phía bên trái của trình duyệt.\r\n\r\n``<code>css\r\np {\r\n\tanimation-duration: 2s;\r\n\tanimation-name: slidethrough;\r\n}\r\n\r\n@keyframes slidethrough {\r\n\tfrom {\r\n\t\tmargin-left: 100%;\r\n\t\twidth: 300%; \r\n\t}\r\n\r\n\tto {\r\n\t\tmargin-left: 0%;\r\n\t\twidth: 100%;\r\n\t}\r\n}\r\n</code>`<code>\r\n\r\nỞ đây, phần tử đoạn văn chỉ định rằng quá trình hoạt ảnh sẽ mất 2 giây để thực hiện từ đầu đến cuối. Điều này được thực hiện bằng cách sử dụng thuộc tính </code>animation-duration<code>. Tên hoạt ảnh của </code>@keyframes<code> được xác định bằng cách sử dụng thuộc tính </code>animation-name<code>. Keyframe trung gian được xác định bằng cách sử dụng quy tắc </code>@keyframes<code>. \r\n\r\nTrong ví dụ, chúng ta chỉ có 2 keyframe. Keyframe đầu tiên bắt đầu ở </code>0%<code> và chạy cho đến lề trái </code>100%<code>, là cạnh ngoài cùng bên phải của phần tử container. Keyframe thứ hai bắt đầu ở </code>100%<code> trong đó lề trái được đặt là </code>0%<code> và chiều rộng được đặt là </code>100%`, kết quả là kết thúc hoạt ảnh nghiêng về phía bên trái của container.</p>",
      "level": "fresher"
    },
    {
      "question": "DOM là gì và cách nó liên kết với CSS?",
      "answer": "<p>DOM (Document Object Model) là một interface lập trình cho HTML và XML. Nó xác định cấu trsuc của document và cách mà document được hiển thị và quản lý. Document này cho phép javascript truy cập và quản lý phần tử và style của web. Mô hình được xây dựng theo cấu trúc cây đối tượng và xác định:\r<ul><li>Các phần tử HTML là đối tượng</li></ul>\r<ul><li>Thuộc tính của tất cả phần tử HTML</li></ul>\r<ul><li>Phương thức truy cập đến tất cả phần tử HTML</li></ul>\r<ul><li>Sự kiện với tất cả phần tử HTML</li></ul>\r\n\r\n<img src=\"/interview-assets/DOM.png\" alt=\"\" />\r\n\r\n#</p>",
      "level": "fresher"
    },
    {
      "question": "Chi tiết cách CSS hoạt động?",
      "answer": "<p>Ngôn ngữ CSS được thiết kế để sử dụng cùng với ngôn ngữ \"đánh dấu\" như HTML. CSS xác định cách các phần tử HTML được định dạng - kiểm soát bố cục, màu sắc, phông chữ của chúng, ... Khi trình duyệt hiển thị một document, nó phải kết hợp nội dung của document với thông tin style của nó. Nó xử lý document theo một số giai đoạn, mà chúng ta đã liệt kê bên dưới.\r\n\r\n1. Trình duyệt tải HTML (ví dụ: nhận nó từ mạng).\r\n2. Nó chuyển đổi HTML thành DOM.\r\n3. Sau đó, trình duyệt sẽ tìm nạp hầu hết các tài nguyên được liên kết với tài liệu HTML, chẳng hạn như hình ảnh và video được nhúng và CSS được liên kết.\r\n4. Trình duyệt phân tích cú pháp CSS đã nạp và sắp xếp các quy tắc khác nhau theo kiểu selector của chúng thành các \"nhóm\" khác nhau, ví dụ: phần tử, lớp, ID, ... Dựa trên các selector mà nó tìm thấy, nó sẽ tìm ra các quy tắc nên được áp dụng cho các nút nào trong DOM và đính kèm kiểu cho chúng theo yêu cầu (bước trung gian này được gọi là cây render).\r\n5. Cây render được bố trí trong cấu trúc mà nó sẽ xuất hiện sau khi các quy tắc đã được áp dụng cho nó.\r\n6. Hiển thị trực quan của trang được hiển thị trên màn hình.\r\n\r\nSơ đồ sau đây cũng cung cấp một cái nhìn đơn giản về quy trình:\r\n\r\n<img src=\"/interview-assets/css-dom.png\" alt=\"\" />\r\n\r\n#</p>",
      "level": "fresher"
    }
  ]
}