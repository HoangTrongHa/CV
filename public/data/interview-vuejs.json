{
  "id": "vuejs",
  "name": "Câu hỏi phỏng vấn Vue.js 3",
  "description": "Tổng hợp câu hỏi phỏng vấn Vue.js 3 từ Fresher đến Senior",
  "questions": [
    {
      "question": "Vue.js là gì?",
      "answer": "<p>Vue.js là một framework JavaScript progressive để xây dựng giao diện người dùng. Khác với các framework nguyên khối, Vue được thiết kế từ đầu để có thể áp dụng dần dần. Thư viện lõi tập trung vào lớp view và rất dễ tích hợp với các thư viện khác hoặc các dự án hiện có.</p><p><strong>Đặc điểm chính:</strong></p><ul><li>Reactive và component-based</li><li>Virtual DOM</li><li>Kích thước nhỏ (~20KB gzipped)</li><li>Hiệu suất cao</li><li>Dễ học và dễ sử dụng</li></ul>",
      "level": "fresher"
    },
    {
      "question": "Ưu điểm của Vue.js?",
      "answer": "<p><ul><li><strong>Dễ học:</strong> Cú pháp đơn giản, dễ hiểu, phù hợp cho người mới</li><li><strong>Kích thước nhỏ:</strong> Chỉ khoảng 20KB min+gzip</li><li><strong>Tài liệu tốt:</strong> Documentation rất chi tiết và dễ hiểu</li><li><strong>Hiệu suất cao:</strong> Virtual DOM và hệ thống reactivity tối ưu</li><li><strong>Component-based:</strong> Tái sử dụng code dễ dàng</li><li><strong>Two-way binding:</strong> Đồng bộ dữ liệu tự động</li><li><strong>Ecosystem phong phú:</strong> Vue Router, Pinia, Vuex, Nuxt.js</li><li><strong>TypeScript support:</strong> Hỗ trợ TypeScript tốt</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Vue 2 vs Vue 3: Những thay đổi chính?",
      "answer": "<p><strong>Composition API:</strong> Thay thế Options API, tổ chức code theo logic thay vì option type, dễ reuse logic hơn.</p><p><strong>Performance:</strong> Virtual DOM viết lại nhanh hơn 2x, tree-shaking tốt hơn, bundle size nhỏ hơn.</p><p><strong>TypeScript:</strong> Được viết hoàn toàn bằng TypeScript với type inference tốt hơn nhiều.</p><p><strong>Fragments:</strong> Cho phép multiple root elements trong template, không cần wrapper div nữa, code sạch hơn và ít DOM nodes hơn.</p><p><strong>Teleport:</strong> Render component content ở vị trí khác trong DOM, dùng cho modals, tooltips, notifications. Logic vẫn trong component nhưng DOM ở nơi khác.</p><p><strong>Suspense:</strong> Handle async dependencies trong component tree, hiển thị fallback UI khi đang load, dùng với async setup() hoặc async components.</p>",
      "level": "fresher"
    },
    {
      "question": "v-model vs v-bind: Khác nhau như thế nào?",
      "answer": "<p><strong>v-bind (one-way binding):</strong> Bind data từ parent/component state xuống attribute hoặc prop, chỉ một chiều từ data → view. Khi data thay đổi, view tự động update nhưng ngược lại thì không.</p><p><strong>v-model (two-way binding):</strong> Kết hợp v-bind và v-on để tạo two-way data binding. Data đồng bộ hai chiều: data ↔ view. Thay đổi ở view sẽ update data và ngược lại.</p><p><strong>v-model là syntax sugar:</strong> v-model tương đương với :value + @input cho input elements, hoặc :modelValue + @update:modelValue cho components.</p><p><strong>Khi nào dùng:</strong> Dùng v-bind khi chỉ cần hiển thị data hoặc bind attributes. Dùng v-model cho form inputs và components cần two-way sync.</p><p><strong>Modifiers:</strong> v-model hỗ trợ .lazy (update sau blur), .number (auto convert), .trim (auto trim whitespace).</p><p><strong>Multiple v-model:</strong> Vue 3 cho phép multiple v-model trên cùng component với tên khác nhau.</p>",
      "level": "fresher"
    },
    {
      "question": "ref() vs reactive(): Khác nhau như thế nào?",
      "answer": "<p><strong>ref():</strong> Tạo reactive reference cho primitive values (string, number, boolean), truy cập qua .value trong script nhưng unwrap tự động trong template.</p><p><strong>reactive():</strong> Tạo reactive proxy cho objects và arrays, không cần .value, có deep reactivity cho nested properties.</p><p><strong>Khi nào dùng:</strong> Dùng ref() cho primitive values và single values. Dùng reactive() cho objects với multiple related values.</p><p><strong>Lưu ý:</strong> ref() có thể wrap object, reactive() chỉ dùng cho objects. Destructure reactive() sẽ mất reactivity, cần dùng toRefs().</p>",
      "level": "middle"
    },
    {
      "question": "Computed vs Watch vs WatchEffect?",
      "answer": "<p><strong>computed:</strong> Cached based on dependencies, chỉ re-compute khi dependency thay đổi, return value, dùng cho derived state (data phụ thuộc vào data khác).</p><p><strong>watch:</strong> Thực hiện side effects khi data thay đổi, lazy by default, có thể access old và new value, watch specific sources.</p><p><strong>watchEffect:</strong> Tự động track dependencies, chạy ngay lập tức (eager), không access old value, cleanup tự động.</p><p><strong>Khi nào dùng:</strong> Dùng computed cho derived data. Dùng watch khi cần compare old/new values hoặc async operations. Dùng watchEffect cho simple side effects với auto dependency tracking.</p>",
      "level": "middle"
    },
    {
      "question": "Lifecycle hooks trong Vue 3 Composition API?",
      "answer": "<p><strong>Setup phase:</strong> setup() chạy trước tất cả hooks, thay thế beforeCreate và created, là nơi khởi tạo reactive state và logic.</p><p><strong>Mounting:</strong> onBeforeMount() gọi trước khi component mount vào DOM, onMounted() gọi sau khi mounted và DOM available, dùng cho DOM manipulation, fetch data, setup third-party libraries.</p><p><strong>Updating:</strong> onBeforeUpdate() gọi trước khi re-render, onUpdated() gọi sau khi DOM updated, tránh update state để tránh infinite loop.</p><p><strong>Unmounting:</strong> onBeforeUnmount() gọi trước khi unmount, onUnmounted() gọi sau unmount, dùng cleanup: remove listeners, clear timers, cancel requests.</p><p><strong>Error handling:</strong> onErrorCaptured() bắt lỗi từ child components, dùng tạo error boundaries.</p><p><strong>Server-side:</strong> onServerPrefetch() - SSR only, fetch data trên server trước render.</p>",
      "level": "middle"
    },
    {
      "question": "nextTick() trong Vue là gì? Khi nào cần dùng?",
      "answer": "<p><strong>nextTick() là gì:</strong> Utility function đợi cho đến khi DOM được update sau khi data thay đổi. Vue update DOM asynchronously (batch updates), không ngay lập tức khi data thay đổi.</p><p><strong>Tại sao cần:</strong> Vue sử dụng async update queue để batch DOM updates, tối ưu performance. Khi thay đổi reactive data, Vue queue update và flush ở tick tiếp theo.</p><p><strong>Cú pháp:</strong> Có thể dùng với async/await, Promise, hoặc callback. Khuyến khích dùng async/await cho code readable.</p><p><strong>Use cases:</strong> Focus element sau khi render, scroll to element sau khi thêm vào list, access computed dimensions sau update, update editor/third-party library sau Vue update DOM.</p><p><strong>So sánh onUpdated():</strong> nextTick() chạy sau next DOM update (on-demand), onUpdated() chạy mỗi lần component update (auto trigger).</p><p><strong>Best practices:</strong> Chỉ dùng khi thực sự cần access DOM, không abuse cho mọi data change.</p>",
      "level": "middle"
    },
    {
      "question": "Props vs Emit: Communication giữa components?",
      "answer": "<p><strong>Props (Parent → Child):</strong> Truyền data từ parent xuống child component, one-way data flow, child không nên mutate props.</p><p><strong>Emit (Child → Parent):</strong> Child emit events lên parent để thông báo thay đổi, parent handle event và update data.</p><p><strong>Best practices:</strong> Props down, events up (one-way data flow), validate props với type và validator, emit events với tên rõ ràng, dùng v-model cho two-way binding.</p><p><strong>Props validation:</strong> Có thể define type, required, default, validator function để validate props.</p>",
      "level": "fresher"
    },
    {
      "question": "v-if vs v-show: Khi nào dùng?",
      "answer": "<p><strong>v-if:</strong> Conditional rendering - destroy/create DOM elements, lazy rendering, higher toggle cost, dùng khi điều kiện ít thay đổi.</p><p><strong>v-show:</strong> Toggle CSS display property, always render DOM, higher initial render cost, dùng khi toggle thường xuyên.</p><p><strong>Performance:</strong> v-show tốt cho elements toggle nhiều lần. v-if tốt cho conditional logic phức tạp và điều kiện ít thay đổi.</p><p><strong>v-if với v-else:</strong> Có thể dùng v-else-if và v-else để handle multiple conditions.</p>",
      "level": "fresher"
    },
    {
      "question": "v-bind vs {{}} (Interpolation): Khác nhau như thế nào?",
      "answer": "<p><strong>Interpolation {{}}:</strong> Dùng để render text content bên trong HTML tags, Vue tự động escape HTML để prevent XSS attacks.</p><p><strong>v-bind (:):</strong> Dùng để bind data vào HTML attributes một cách reactive, có thể bind vào bất kỳ attribute nào (src, href, class, style, disabled, etc.).</p><p><strong>Vị trí sử dụng:</strong> {{}} dùng bên trong tags cho text content, v-bind dùng trong HTML attributes.</p><p><strong>Tại sao không dùng {{}} trong attributes:</strong> Browser parse attributes trước khi Vue có thể process {{}}, nên phải dùng v-bind.</p><p><strong>JavaScript expressions:</strong> Cả hai đều support JavaScript expressions, nhưng nên giữ logic đơn giản.</p><p><strong>v-html:</strong> Dùng v-html để render raw HTML, nhưng chỉ với trusted content (XSS risk).</p>",
      "level": "fresher"
    },
    {
      "question": "v-for và :key directive",
      "answer": "<p><strong>v-for:</strong> Render list bằng cách iterate qua array/object, có thể dùng với array, object, range, hoặc components.</p><p><strong>Tại sao cần :key:</strong> Giúp Vue identify từng node, reuse và reorder elements hiệu quả, tránh side-effects khi update list, maintain component state.</p><p><strong>Key best practices:</strong> Dùng unique, stable ID (không dùng index trừ static list), không dùng random values, dùng string hoặc number, nhất quán trong app.</p><p><strong>v-if và v-for:</strong> Không dùng v-if và v-for cùng element (Vue 3: v-if có priority cao hơn, sẽ error). Dùng computed property để filter hoặc template wrapper.</p><p><strong>Performance:</strong> Proper :key usage giúp Vue reuse DOM nodes efficiently, tránh unnecessary re-renders.</p>",
      "level": "fresher"
    },
    {
      "question": "Slot trong Vue.js là gì?",
      "answer": "<p><strong>Default slot:</strong> Cho phép parent component truyền content vào child component, child định nghĩa vị trí render bằng &lt;slot /&gt;.</p><p><strong>Named slots:</strong> Multiple slots với tên khác nhau trong cùng component, parent dùng #slotName để target specific slot.</p><p><strong>Scoped slots:</strong> Child expose data cho parent thông qua slot props, parent access data và customize rendering.</p><p><strong>Fallback content:</strong> Có thể define default content trong slot, hiển thị khi parent không provide content.</p><p><strong>Use cases:</strong> Reusable components với flexible layout, wrapper components, plugin systems.</p>",
      "level": "middle"
    },
    {
      "question": "Provide/Inject pattern trong Vue 3?",
      "answer": "<p><strong>Provide/Inject:</strong> Cơ chế truyền dữ liệu từ ancestor component xuống descendant components bất kể cấp độ lồng nhau, không cần props drilling qua nhiều levels.</p><p><strong>Provide:</strong> Component cha/ancestor provide value bằng provide(key, value), có thể provide reactive values (ref, reactive).</p><p><strong>Inject:</strong> Component con/descendant inject value bằng inject(key, defaultValue), có thể provide default value nếu không tìm thấy.</p><p><strong>Use cases:</strong> Tránh prop drilling, plugin systems, theme/config sharing, dependency injection cho services.</p><p><strong>Lưu ý:</strong> Không thay thế props/emit cho parent-child trực tiếp, khó trace data flow, nên dùng Symbol keys và TypeScript để type-safe.</p><p><strong>App-level provide:</strong> Có thể provide ở app level cho global state.</p>",
      "level": "middle"
    },
    {
      "question": "Composables trong Vue 3 là gì?",
      "answer": "<p><strong>Composable:</strong> Function sử dụng Composition API để đóng gói và tái sử dụng stateful logic, pattern quan trọng trong Vue 3.</p><p><strong>Naming convention:</strong> Luôn prefix với 'use' (useCounter, useMouse, useFetch).</p><p><strong>Return values:</strong> Return reactive values để components có thể reactivity, thường return object với state và methods.</p><p><strong>Best practices:</strong> Accept parameters để flexible, cleanup side effects trong onUnmounted, single responsibility, mỗi composable làm một việc.</p><p><strong>Lợi ích:</strong> Tái sử dụng logic dễ dàng, code dễ test, TypeScript support tốt, tổ chức code theo logic.</p>",
      "level": "middle"
    },
    {
      "question": "Pinia vs Vuex: Sự khác biệt?",
      "answer": "<p><strong>Pinia (recommended for Vue 3):</strong> TypeScript support tốt hơn, không cần mutations, không cần modules/namespaces, đơn giản hơn với ít boilerplate, Devtools support tốt, Composition API friendly.</p><p><strong>Vuex:</strong> Mature và stable, phức tạp hơn với state/mutations/actions/getters pattern, cần commit mutations, module system phức tạp.</p><p><strong>API differences:</strong> Pinia dùng defineStore với state/getters/actions, Vuex dùng createStore với state/mutations/actions/getters.</p><p><strong>Migration:</strong> Vue 3 projects nên dùng Pinia, Vuex vẫn support nhưng đang legacy.</p>",
      "level": "middle"
    },
    {
      "question": "Làm thế nào để quản lý shared state trong Vue?",
      "answer": "<p><strong>1. Pinia (Official - Recommended):</strong> State management library chính thức, thay thế Vuex, với TypeScript support tuyệt vời, không cần mutations, devtools integration, modular by design.</p><p><strong>2. Provide/Inject Pattern:</strong> Built-in cho shared state trong component tree, không cần external library, dùng readonly() để tránh mutation trực tiếp, tốt cho plugin và theme systems.</p><p><strong>3. Composables với Reactive State:</strong> Tạo composable với reactive state declared ngoài function để share giữa components, flexible và đơn giản.</p><p><strong>4. Reactive Global Object:</strong> Tạo global reactive object đơn giản cho small apps hoặc prototypes.</p><p><strong>5. Vuex (Legacy):</strong> Vẫn được dùng nhưng verbose hơn Pinia, cần mutations/actions pattern.</p><p><strong>6. Browser Storage:</strong> LocalStorage/SessionStorage cho persistent data với reactive composable wrapper.</p><p><strong>7. Event Bus (Deprecated):</strong> Không khuyến khích vì khó debug, memory leaks, không type-safe.</p><p><strong>Khi nào dùng:</strong> Pinia cho production apps, Provide/Inject cho plugin/themes, Composables cho reusable logic, Global Reactive cho simple state.</p>",
      "level": "middle"
    },
    {
      "question": "Async Components và Code Splitting trong Vue?",
      "answer": "<p><strong>Async Components:</strong> Lazy load components chỉ khi cần thiết, giúp giảm bundle size ban đầu và tăng performance.</p><p><strong>defineAsyncComponent:</strong> Tạo async component với loader function, có thể define loading/error components, delay, timeout.</p><p><strong>Route-based code splitting:</strong> Chia code theo routes để mỗi page load riêng chunk, dùng dynamic imports trong route config.</p><p><strong>Benefits:</strong> Smaller initial bundle, lazy loading khi cần, faster Time to Interactive, better caching, parallel loading.</p><p><strong>Khi nào dùng:</strong> Components lớn ít dùng, route-based splitting, third-party heavy components.</p>",
      "level": "middle"
    },
    {
      "question": "Custom Directives trong Vue?",
      "answer": "<p><strong>Custom Directives:</strong> Tạo directives riêng để tái sử dụng DOM manipulation logic, khác components (quản lý data/template), directives tập trung vào low-level DOM operations.</p><p><strong>Lifecycle hooks:</strong> beforeMount, mounted, beforeUpdate, updated, beforeUnmount, unmounted.</p><p><strong>Directive arguments:</strong> binding.arg (argument), binding.modifiers (modifiers object), binding.value (value).</p><p><strong>Registration:</strong> Có thể register local trong component hoặc global với app.directive().</p><p><strong>Use cases:</strong> Auto-focus inputs, click outside detection, scroll behavior, tooltips, lazy loading images, permission-based hiding.</p>",
      "level": "middle"
    },
    {
      "question": "Teleport trong Vue 3?",
      "answer": "<p><strong>Teleport:</strong> Render component content ở nơi khác trong DOM tree, outside component hierarchy, giữ nguyên logic trong component.</p><p><strong>Use cases:</strong> Modals, tooltips, notifications, full-screen components cần render ở specific DOM location.</p><p><strong>Target:</strong> Dùng 'to' prop để specify target selector (body, #id, .class).</p><p><strong>Multiple Teleports:</strong> Có thể có multiple teleports đến cùng hoặc khác target.</p><p><strong>Disabled prop:</strong> Có thể disable teleport conditionally, render content ở vị trí ban đầu.</p>",
      "level": "middle"
    },
    {
      "question": "Suspense trong Vue 3?",
      "answer": "<p><strong>Suspense:</strong> Handle async dependencies trong component tree, hiển thị fallback UI khi đang load.</p><p><strong>Slots:</strong> #default slot cho async content, #fallback slot cho loading state.</p><p><strong>Async setup:</strong> Components có thể dùng async setup() để fetch data, Suspense sẽ handle loading state.</p><p><strong>Multiple async components:</strong> Có thể wrap multiple async components trong một Suspense, fallback hiện đến khi tất cả resolved.</p><p><strong>Error handling:</strong> Dùng onErrorCaptured để handle errors từ async components.</p>",
      "level": "senior"
    },
    {
      "question": "Reactivity Transform và $ref, $computed?",
      "answer": "<p><strong>Reactivity Transform:</strong> Đã bị deprecated trong Vue 3.3, nhưng vẫn hữu ích để biết.</p><p><strong>$ref:</strong> Syntax sugar cho ref() mà không cần .value, compile-time transformation.</p><p><strong>$computed:</strong> Tương tự cho computed, không cần .value.</p><p><strong>Tại sao deprecated:</strong> Cognitive overhead, khác biệt compile-time vs runtime, TypeScript integration issues, confusion cho developers.</p><p><strong>Alternative:</strong> Dùng ref/reactive như bình thường, đây là recommended approach.</p>",
      "level": "senior"
    },
    {
      "question": "Performance Optimization trong Vue?",
      "answer": "<p><strong>v-once:</strong> Render content một lần, không re-render khi data thay đổi, dùng cho static content.</p><p><strong>v-memo:</strong> Conditional re-render based on dependencies array, chỉ re-render khi dependencies thay đổi.</p><p><strong>Computed caching:</strong> Computed properties được cache, chỉ re-compute khi dependencies thay đổi, tốt hơn methods.</p><p><strong>Virtual scrolling:</strong> Render only visible items trong long lists, dùng thư viện như vue-virtual-scroller.</p><p><strong>Lazy loading:</strong> Code splitting, route-based chunks, async components để giảm initial bundle.</p><p><strong>KeepAlive:</strong> Cache component state khi switch giữa components, tránh re-render từ đầu.</p><p><strong>Shallow reactive:</strong> shallowRef/shallowReactive cho large objects, chỉ track top-level changes.</p>",
      "level": "senior"
    },
    {
      "question": "Làm thế nào để tối ưu một Vue app chạy chậm?",
      "answer": "<p><strong>PHÁT HIỆN VẤN ĐỀ:</strong></p><p><strong>Vue DevTools Performance:</strong> Enable app.config.performance, dùng Performance tab để xem component render times, Timeline để track events, Component inspector để check re-renders.</p><p><strong>Chrome DevTools:</strong> Performance tab để analyze CPU/rendering, Lighthouse cho performance score, Network tab cho bundle sizes, Memory tab để detect leaks.</p><p><strong>Debug render triggers:</strong> Dùng onRenderTracked và onRenderTriggered để log khi component re-render và track dependencies.</p><p><strong>COMPONENT OPTIMIZATION:</strong></p><p><strong>v-once:</strong> Cho static content không bao giờ thay đổi.</p><p><strong>v-memo:</strong> Conditional re-render chỉ khi specific values thay đổi.</p><p><strong>Computed caching:</strong> Dùng computed thay vì methods để cache calculations.</p><p><strong>Shallow reactivity:</strong> shallowRef/shallowReactive cho large objects/arrays.</p><p><strong>LIST RENDERING:</strong></p><p><strong>Virtual scrolling:</strong> Render only visible items cho long lists.</p><p><strong>Pagination:</strong> Chia data thành pages, infinite scroll.</p><p><strong>Proper :key:</strong> Dùng unique ID thay vì index để Vue reuse DOM efficiently.</p><p><strong>CODE SPLITTING:</strong></p><p><strong>Route-based splitting:</strong> Lazy load route components.</p><p><strong>Async components:</strong> defineAsyncComponent với loading states.</p><p><strong>Dynamic imports:</strong> Load modules on-demand.</p><p><strong>BUNDLE OPTIMIZATION:</strong></p><p><strong>Analyze bundle:</strong> Dùng visualizer plugin để identify large dependencies.</p><p><strong>Tree shaking:</strong> Import specific functions thay vì entire libraries.</p><p><strong>Manual chunks:</strong> Split vendor và app code để better caching.</p><p><strong>DATA FETCHING:</strong></p><p><strong>Debounce/Throttle:</strong> Giảm số lượng API calls.</p><p><strong>Cache responses:</strong> Cache API responses để tránh duplicate requests.</p><p><strong>Parallel requests:</strong> Dùng Promise.all cho multiple independent requests.</p><p><strong>REACTIVITY OPTIMIZATION:</strong></p><p><strong>Tránh unnecessary reactivity:</strong> Không wrap constants trong reactive.</p><p><strong>markRaw:</strong> Cho third-party instances và large non-reactive data.</p><p><strong>Batch updates:</strong> Multiple state changes được batched trong một re-render.</p><p><strong>DOM OPTIMIZATION:</strong></p><p><strong>v-show vs v-if:</strong> v-show cho frequent toggles, v-if cho conditional rendering.</p><p><strong>KeepAlive:</strong> Cache expensive components khi switch.</p><p><strong>Functional components:</strong> Cho simple presentational components không cần reactivity.</p><p><strong>IMAGE & ASSETS:</strong></p><p><strong>Lazy load images:</strong> Dùng loading='lazy' attribute.</p><p><strong>Image optimization:</strong> Compress và optimize images, dùng proper formats.</p><p><strong>WebP/AVIF:</strong> Modern image formats với better compression.</p><p><strong>MEMORY LEAK PREVENTION:</strong></p><p><strong>Cleanup timers:</strong> Clear intervals/timeouts trong onUnmounted.</p><p><strong>Remove event listeners:</strong> Remove window/document listeners khi unmount.</p><p><strong>Cancel requests:</strong> Abort pending API requests khi component unmount.</p><p><strong>PERFORMANCE CHECKLIST:</strong> Rendering (v-once, v-memo, computed) - High impact, Lists (virtual scrolling, pagination) - High impact, Code (lazy loading, splitting) - High impact, Bundle (tree shaking) - Medium impact, Data (debounce, cache) - High impact, Reactivity (shallow, markRaw) - Medium impact, DOM (v-show, KeepAlive) - Low-Medium impact, Assets (lazy images, WebP) - Medium impact, Memory (cleanup listeners) - Critical.</p><p><strong>QUICK WINS:</strong> Enable production mode, add v-once cho static content, dùng computed thay methods, lazy load routes, lazy load images, cleanup trong onUnmounted.</p><p><strong>MONITORING TOOLS:</strong> Vue DevTools, Chrome DevTools, webpack-bundle-analyzer, Google PageSpeed Insights, WebPageTest.</p>",
      "level": "senior"
    },
    {
      "question": "Vue Router: Navigation Guards?",
      "answer": "<p><strong>Global guards:</strong> beforeEach chạy trước mỗi navigation (authentication check), afterEach chạy sau navigation (analytics, title update).</p><p><strong>Per-route guards:</strong> beforeEnter trong route config, chỉ chạy khi enter specific route.</p><p><strong>In-component guards:</strong> beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave trong component để handle navigation logic.</p><p><strong>Composition API:</strong> onBeforeRouteLeave, onBeforeRouteUpdate hooks cho Composition API.</p><p><strong>Use cases:</strong> Authentication, authorization, confirm unsaved changes, fetch data before enter, cleanup before leave.</p>",
      "level": "middle"
    },
    {
      "question": "defineModel trong Vue 3.3+?",
      "answer": "<p><strong>defineModel:</strong> Simplified v-model implementation, giảm boilerplate code cho two-way binding.</p><p><strong>Before Vue 3.3:</strong> Cần define props, emit, và computed để implement v-model.</p><p><strong>With defineModel:</strong> Chỉ cần const model = defineModel(), Vue handle props/emit automatically.</p><p><strong>Multiple v-models:</strong> Có thể define multiple models với tên khác nhau.</p><p><strong>Options:</strong> Có thể define type, required, default, validator như props.</p><p><strong>Benefits:</strong> Less boilerplate, clearer intent, easier to maintain.</p>",
      "level": "senior"
    },
    {
      "question": "Testing Vue Components?",
      "answer": "<p><strong>Vue Test Utils:</strong> Official testing library cho Vue components, dùng mount/shallowMount để render components.</p><p><strong>Testing user interaction:</strong> Trigger events (click, input), check DOM updates, verify component behavior.</p><p><strong>Testing Composables:</strong> Test composables như pure functions, verify reactive state và methods.</p><p><strong>Mocking:</strong> Mock global properties ($route, $store), stub child components, mock API calls.</p><p><strong>Best practices:</strong> Test user behavior không phải implementation, isolate components, use factories cho reusable setup.</p>",
      "level": "senior"
    },
    {
      "question": "Server-Side Rendering với Vue?",
      "answer": "<p><strong>Benefits của SSR:</strong> Better SEO (search engines see full content), faster initial load (server sends rendered HTML), better social media sharing (meta tags available immediately).</p><p><strong>Nuxt.js:</strong> Framework cho Vue SSR với file-based routing, automatic code splitting, built-in optimizations.</p><p><strong>Hydration:</strong> Server render HTML, client hydrate thành interactive app, tránh hydration mismatch giữa server và client.</p><p><strong>Vite SSR:</strong> Có thể setup manual SSR với Vite, dùng createSSRApp và renderToString.</p><p><strong>Lưu ý:</strong> Không dùng window/document trong setup, lifecycle hooks khác nhau server vs client, state management cần special handling.</p>",
      "level": "senior"
    },
    {
      "question": "TypeScript với Vue 3?",
      "answer": "<p><strong>defineComponent:</strong> Provide type inference cho component options, props được typed automatically.</p><p><strong>Script setup với TypeScript:</strong> Dùng lang='ts', define Props interface, emit types với generics.</p><p><strong>Composables typing:</strong> Type return values, function parameters, ref/reactive với generics.</p><p><strong>Props validation:</strong> Define props với type safety, validator functions với proper types.</p><p><strong>Benefits:</strong> Better IDE support, catch errors at compile time, self-documenting code, refactoring safety.</p>",
      "level": "senior"
    },
    {
      "question": "Khi nào không nên dùng Vue?",
      "answer": "<p><strong>Không phù hợp khi:</strong> App cực kỳ phức tạp (React/Angular có ecosystem lớn hơn), native mobile chủ yếu (React Native mature hơn), team đã expertise framework khác (switching cost cao), cần strong typing từ đầu (Angular có TypeScript built-in sâu hơn), corporate backing quan trọng (React-Meta, Angular-Google vs Vue-community).</p><p><strong>Phù hợp khi:</strong> Cần learning curve thấp, team nhỏ/prototype nhanh, progressive enhancement, balance giữa flexibility và structure, documentation quality quan trọng.</p>",
      "level": "senior"
    },
    {
      "question": "Security best practices trong Vue?",
      "answer": "<p><strong>XSS Prevention:</strong> Vue tự động escape HTML trong interpolation, không dùng v-html với user input, sanitize data trước khi render.</p><p><strong>CSRF Protection:</strong> Dùng CSRF tokens, SameSite cookies, verify origin headers.</p><p><strong>Authentication:</strong> Không store tokens trong localStorage (XSS risk), dùng HttpOnly cookies, proper session management.</p><p><strong>API Security:</strong> Validate inputs server-side, rate limiting, CORS configuration, HTTPS only.</p><p><strong>Dependencies:</strong> Regular updates, audit npm packages, use lock files, remove unused dependencies.</p>",
      "level": "senior"
    },
    {
      "question": "Error Handling trong Vue?",
      "answer": "<p><strong>Global error handler:</strong> app.config.errorHandler để catch all errors, log to service, show user-friendly messages.</p><p><strong>Component error boundary:</strong> onErrorCaptured hook để catch errors từ child components, return false để stop propagation.</p><p><strong>Async error handling:</strong> Try-catch blocks cho async operations, handle rejected promises.</p><p><strong>Router error handling:</strong> router.onError để handle navigation errors.</p><p><strong>Best practices:</strong> Graceful degradation, user-friendly error messages, log errors to monitoring service.</p>",
      "level": "senior"
    },
    {
      "question": "State Management patterns ngoài Pinia/Vuex?",
      "answer": "<p><strong>Provide/Inject pattern:</strong> Create store với reactive state, provide ở root, inject ở children, dùng Symbol để type-safe.</p><p><strong>Composable-based state:</strong> Shared reactive state trong composable, export state và methods.</p><p><strong>Event bus:</strong> Không khuyến khích, dùng mitt hoặc tương tự, khó debug và maintain.</p><p><strong>Browser storage:</strong> LocalStorage, SessionStorage, IndexedDB cho persistent state.</p><p><strong>Khi nào dùng:</strong> Provide/Inject cho component tree state, Composables cho simple shared state, Browser storage cho persistence.</p>",
      "level": "senior"
    },
    {
      "question": "Migration từ Vue 2 lên Vue 3?",
      "answer": "<p><strong>Breaking changes:</strong> Global API thành instance API, v-model changes, filters removed, $listeners merged vào $attrs, functional components changes.</p><p><strong>Migration build:</strong> Dùng @vue/compat để run Vue 3 trong compat mode, gradually migrate.</p><p><strong>Steps:</strong> Update dependencies, run migration build, fix deprecation warnings, update syntax, test thoroughly, remove compat mode.</p><p><strong>Tools:</strong> Vue 3 Migration Guide, ESLint plugin vue/vue3-recommended, Vue DevTools.</p>",
      "level": "senior"
    },
    {
      "question": "Memory leaks trong Vue: Nguyên nhân và cách tránh?",
      "answer": "<p><strong>Event listeners không cleanup:</strong> Remove window/document listeners trong onUnmounted.</p><p><strong>Timers không clear:</strong> Clear intervals/timeouts khi component unmount.</p><p><strong>DOM references:</strong> Clear refs khi unmount, tránh keeping DOM references.</p><p><strong>Subscriptions:</strong> Unsubscribe từ stores, event buses khi unmount.</p><p><strong>Best practices:</strong> Always cleanup trong onUnmounted, use composables để abstract cleanup logic, test for leaks với Chrome DevTools Memory profiler.</p>",
      "level": "senior"
    },
    {
      "question": "Debugging Vue applications?",
      "answer": "<p><strong>Vue DevTools:</strong> Component inspector, Vuex/Pinia state, events timeline, performance profiling.</p><p><strong>Console debugging:</strong> Component name trong console, log lifecycle hooks, debug reactive dependencies.</p><p><strong>Debug hooks:</strong> onRenderTracked và onRenderTriggered để track re-renders và dependencies.</p><p><strong>Error tracking:</strong> Services như Sentry, LogRocket, Bugsnag cho production monitoring.</p><p><strong>Performance:</strong> Chrome DevTools Performance tab, Lighthouse audits, Vue DevTools Performance.</p>",
      "level": "senior"
    },
    {
      "question": "nextTick() trong Vue 2 vs Vue 3: API khác biệt như thế nào?",
      "answer": "<p><strong>Vue 2 API:</strong> this.$nextTick() trong Options API, Vue.nextTick() cho global API, support callback và Promise.</p><p><strong>Vue 3 API:</strong> Import nextTick từ 'vue', dùng như standalone function, khuyến khích async/await, vẫn support this.$nextTick() trong Options API.</p><p><strong>Tree-shaking:</strong> Vue 3 import-based cho better tree-shaking, Vue 2 global API không tree-shakeable.</p><p><strong>Internal implementation:</strong> Vue 2 dùng microtask hoặc fallback macro task, Vue 3 luôn dùng Promise microtask.</p><p><strong>Best practices Vue 3:</strong> Import và dùng async/await, consistent với Composition API style.</p>",
      "level": "senior"
    },
    {
      "question": "Làm thế nào để hủy API request khi component bị unmount trong Vue?",
      "answer": "<p><strong>Tại sao cần cancel:</strong> Tránh memory leaks, warning về state update trên unmounted component, unnecessary network traffic.</p><p><strong>Method 1 - AbortController (Recommended):</strong> Tạo AbortController, pass signal vào fetch, abort trong onUnmounted, check AbortError trong catch.</p><p><strong>Method 2 - Axios CancelToken:</strong> Dùng axios.CancelToken.source(), cancel trong onUnmounted, check axios.isCancel().</p><p><strong>Method 3 - Axios AbortController:</strong> Axios 0.22+ support native AbortController.</p><p><strong>Method 4 - Flag-based:</strong> Simple fallback với isMounted flag, check trước khi update state.</p><p><strong>Method 5 - Composable:</strong> Tạo reusable useFetch composable với auto cleanup.</p><p><strong>Method 6 - Multiple requests:</strong> Track multiple controllers trong Set, abort all khi unmount.</p><p><strong>Best practices:</strong> Dùng AbortController cho fetch, cleanup trong onUnmounted, handle abort errors riêng, tạo composable để reuse.</p>",
      "level": "senior"
    },
    {
      "question": "v-for hoạt động như thế nào? Tại sao không nên dùng v-if và v-for cùng element?",
      "answer": "<p><strong>v-for hoạt động:</strong> Iterate qua array/object và tạo VNodes, Vue dùng in-place patch strategy để update efficiently.</p><p><strong>Virtual DOM diffing:</strong> Với :key - Vue track và reorder elements, không có :key - in-place patch content.</p><p><strong>Tại sao cần :key:</strong> Identity tracking để phân biệt elements, state preservation khi reorder, transition animations, performance optimization.</p><p><strong>Key best practices:</strong> Dùng unique stable ID, không dùng index (trừ static list), không dùng random values.</p><p><strong>Tại sao KHÔNG v-if và v-for cùng element:</strong></p><p><strong>Priority conflict:</strong> Vue 2 - v-for priority cao hơn, Vue 3 - v-if priority cao hơn (sẽ error vì item chưa defined).</p><p><strong>Performance issue:</strong> Phải evaluate cả hai mỗi render, không efficient.</p><p><strong>Code clarity:</strong> Khó đọc và maintain.</p><p><strong>Solutions:</strong></p><p><strong>Computed property (Best):</strong> Filter array trước, chỉ loop qua filtered items, cached và efficient.</p><p><strong>Template wrapper:</strong> v-if bên trong v-for template, hoặc wrapper div.</p><p><strong>v-show:</strong> Cho frequent toggles, elements vẫn render nhưng hide.</p><p><strong>v-if bên ngoài:</strong> Show/hide entire list conditionally.</p>",
      "level": "senior"
    }
  ]
}
