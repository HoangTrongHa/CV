{
  "id": "vuejs",
  "name": "Câu hỏi phỏng vấn Vue.js 3",
  "description": "Tổng hợp câu hỏi phỏng vấn Vue.js 3 từ Fresher đến Senior",
  "questions": [
    {
      "question": "Vue.js là gì?",
      "answer": "<p>Vue.js là một framework JavaScript progressive để xây dựng giao diện người dùng. Khác với các framework nguyên khối, Vue được thiết kế từ đầu để có thể áp dụng dần dần. Thư viện lõi tập trung vào lớp view và rất dễ tích hợp với các thư viện khác hoặc các dự án hiện có.</p><p><strong>Đặc điểm chính:</strong></p><ul><li>Reactive và component-based</li><li>Virtual DOM</li><li>Kích thước nhỏ (~20KB gzipped)</li><li>Hiệu suất cao</li><li>Dễ học và dễ sử dụng</li></ul>",
      "level": "fresher"
    },
    {
      "question": "Ưu điểm của Vue.js?",
      "answer": "<p><ul><li><strong>Dễ học:</strong> Cú pháp đơn giản, dễ hiểu, phù hợp cho người mới</li><li><strong>Kích thước nhỏ:</strong> Chỉ khoảng 20KB min+gzip</li><li><strong>Tài liệu tốt:</strong> Documentation rất chi tiết và dễ hiểu</li><li><strong>Hiệu suất cao:</strong> Virtual DOM và hệ thống reactivity tối ưu</li><li><strong>Component-based:</strong> Tái sử dụng code dễ dàng</li><li><strong>Two-way binding:</strong> Đồng bộ dữ liệu tự động</li><li><strong>Ecosystem phong phú:</strong> Vue Router, Pinia, Vuex, Nuxt.js</li><li><strong>TypeScript support:</strong> Hỗ trợ TypeScript tốt</li></ul></p>",
      "level": "fresher"
    },
    {
      "question": "Vue 2 vs Vue 3: Những thay đổi chính?",
      "answer": "<p><strong>Composition API:</strong></p><ul><li>Thay thế Options API</li><li>Tổ chức code theo logic thay vì option type</li><li>Dễ reuse logic hơn</li></ul><p><strong>Performance:</strong></p><ul><li>Virtual DOM viết lại, nhanh hơn 2x</li><li>Tree-shaking tốt hơn</li><li>Bundle size nhỏ hơn</li></ul><p><strong>TypeScript:</strong></p><ul><li>Được viết hoàn toàn bằng TypeScript</li><li>Type inference tốt hơn nhiều</li></ul><p><strong>Fragments:</strong></p><ul><li>Cho phép multiple root elements trong template</li><li>Không cần wrapper div nữa</li><li>Code sạch hơn, ít DOM nodes hơn</li></ul><pre><code>&lt;template&gt;\r\n  &lt;h1&gt;Title&lt;/h1&gt;\r\n  &lt;p&gt;Content&lt;/p&gt;\r\n  &lt;!-- Vue 2 phải wrap trong div --&gt;\r\n&lt;/template&gt;</code></pre><p><strong>Teleport:</strong></p><ul><li>Render component content ở vị trí khác trong DOM</li><li>Dùng cho modals, tooltips, notifications</li><li>Logic vẫn trong component nhưng DOM ở nơi khác</li></ul><pre><code>&lt;Teleport to=\"body\"&gt;\r\n  &lt;div class=\"modal\"&gt;Modal content&lt;/div&gt;\r\n&lt;/Teleport&gt;</code></pre><p><strong>Suspense:</strong></p><ul><li>Handle async dependencies trong component tree</li><li>Hiển thị fallback UI khi đang load</li><li>Dùng với async setup() hoặc async components</li></ul><pre><code>&lt;Suspense&gt;\r\n  &lt;template #default&gt;\r\n    &lt;AsyncComponent /&gt;\r\n  &lt;/template&gt;\r\n  &lt;template #fallback&gt;\r\n    &lt;Loading /&gt;\r\n  &lt;/template&gt;\r\n&lt;/Suspense&gt;</code></pre>",
      "level": "fresher"
    },
    {
      "question": "Reactive và Ref trong Vue 3 là gì?",
      "answer": "<p><strong>ref():</strong></p><ul><li>Tạo reactive reference cho primitive values</li><li>Truy cập qua .value</li><li>Unwrap tự động trong template</li></ul><pre><code>const count = ref(0)\nconsole.log(count.value) // 0\ncount.value++</code></pre><p><strong>reactive():</strong></p><ul><li>Tạo reactive proxy cho objects</li><li>Không cần .value</li><li>Deep reactivity</li></ul><pre><code>const state = reactive({ count: 0 })\nconsole.log(state.count) // 0\nstate.count++</code></pre><p><strong>Khi nào dùng gì?</strong></p><ul><li>ref: primitive values, single values</li><li>reactive: objects, multiple related values</li></ul>",
      "level": "middle"
    },
    {
      "question": "Computed vs Watch vs WatchEffect?",
      "answer": "<p><strong>computed:</strong></p><ul><li>Cached based on dependencies</li><li>Chỉ re-compute khi dependency thay đổi</li><li>Return value</li><li>Dùng cho derived state</li></ul><pre><code>const fullName = computed(() => \n  firstName.value + ' ' + lastName.value\n)</code></pre><p><strong>watch:</strong></p><ul><li>Side effects khi data thay đổi</li><li>Lazy by default</li><li>Access old và new value</li><li>Watch specific sources</li></ul><pre><code>watch(count, (newVal, oldVal) => {\n  console.log(`Count changed from ${oldVal} to ${newVal}`)\n})</code></pre><p><strong>watchEffect:</strong></p><ul><li>Tự động track dependencies</li><li>Chạy ngay lập tức</li><li>Không access old value</li><li>Cleanup tự động</li></ul><pre><code>watchEffect(() => {\n  console.log(`Count is ${count.value}`)\n})</code></pre>",
      "level": "middle"
    },
    {
      "question": "Lifecycle hooks trong Vue 3 Composition API?",
      "answer": "<p>Lifecycle hooks trong Vue 3 Composition API tương tự Options API nhưng có prefix 'on' và được gọi trong setup().</p><p><strong>Setup phase:</strong></p><ul><li><code>setup()</code> - Chạy trước tất cả hooks, thay thế beforeCreate và created. Đây là nơi khởi tạo reactive state và logic.</li></ul><p><strong>Mounting (Gắn kết component):</strong></p><ul><li><code>onBeforeMount()</code> - Gọi trước khi component được mount vào DOM. Template đã compiled nhưng chưa render.</li><li><code>onMounted()</code> - Gọi sau khi component đã mount, DOM đã available. Dùng cho DOM manipulation, fetch data, setup third-party libraries.</li></ul><pre><code>onMounted(() => {\n  console.log('Component mounted')\n  // Access DOM, call APIs\n})</code></pre><p><strong>Updating (Cập nhật):</strong></p><ul><li><code>onBeforeUpdate()</code> - Gọi trước khi component re-render do reactive data thay đổi</li><li><code>onUpdated()</code> - Gọi sau khi component đã re-render và DOM updated. Tránh update state ở đây để tránh infinite loop.</li></ul><p><strong>Unmounting (Hủy component):</strong></p><ul><li><code>onBeforeUnmount()</code> - Gọi trước khi component bị unmount</li><li><code>onUnmounted()</code> - Gọi sau khi component đã unmount. Dùng để cleanup: remove listeners, clear timers, cancel requests.</li></ul><pre><code>onUnmounted(() => {\n  clearInterval(timer)\n  window.removeEventListener('resize', handler)\n})</code></pre><p><strong>Error handling:</strong></p><ul><li><code>onErrorCaptured()</code> - Bắt lỗi từ child components, dùng để tạo error boundaries</li></ul><p><strong>Server-side:</strong></p><ul><li><code>onServerPrefetch()</code> - SSR only, fetch data trên server trước khi render</li></ul>",
      "level": "middle"
    },
    {
      "question": "nextTick() trong Vue là gì? Khi nào cần dùng?",
      "answer": "<p><strong>nextTick() là gì?</strong></p><p>nextTick() là utility function đợi cho đến khi DOM được update sau khi data thay đổi. Vue update DOM <strong>asynchronously</strong> (batch updates), không phải ngay lập tức khi bạn thay đổi data. nextTick() giúp bạn access DOM sau khi Vue đã apply những thay đổi.</p><p><strong>Tại sao cần nextTick?</strong></p><p>Vue sử dụng <strong>async update queue</strong> để batch DOM updates, tối ưu performance:</p><ol><li>Bạn thay đổi reactive data</li><li>Vue queue update, không update DOM ngay</li><li>Trong cùng một event loop tick, nhiều data changes được batch lại</li><li>Ở tick tiếp theo, Vue flush queue và update DOM một lần</li></ol><p><strong>Cú pháp:</strong></p><pre><code>import { nextTick } from 'vue'\n\n// Async/await (khuyến khích)\nawait nextTick()\n\n// Promise\nnextTick().then(() => {\n  // DOM updated\n})\n\n// Callback\nnextTick(() => {\n  // DOM updated\n})</code></pre><p><strong>Ví dụ cơ bản:</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, nextTick } from 'vue'\n\nconst count = ref(0)\nconst message = ref('Initial')\n\nconst updateAndLog = async () => {\n  count.value++\n  \n  // DOM chưa update\n  console.log(document.querySelector('.count').textContent) // '0'\n  \n  // Đợi DOM update\n  await nextTick()\n  \n  // DOM đã update\n  console.log(document.querySelector('.count').textContent) // '1'\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div class=\"count\"&gt;{{ count }}&lt;/div&gt;\n  &lt;button @click=\"updateAndLog\"&gt;Update&lt;/button&gt;\n&lt;/template&gt;</code></pre><p><strong>Use case 1: Focus element sau khi render</strong></p><pre><code>const showInput = ref(false)\nconst inputRef = ref(null)\n\nconst openInput = async () => {\n  showInput.value = true\n  \n  // inputRef.value vẫn null ở đây\n  \n  await nextTick()\n  \n  // Giờ input đã render, có thể focus\n  inputRef.value.focus()\n}</code></pre><p><strong>Use case 2: Scroll to element sau khi thêm vào list</strong></p><pre><code>const items = ref(['Item 1'])\nconst listRef = ref(null)\n\nconst addItem = async () => {\n  items.value.push(`Item ${items.value.length + 1}`)\n  \n  await nextTick()\n  \n  // Scroll to bottom sau khi item mới được render\n  listRef.value.scrollTop = listRef.value.scrollHeight\n}</code></pre><p><strong>Use case 3: Access computed dimensions sau update</strong></p><pre><code>const content = ref('Short text')\nconst containerRef = ref(null)\n\nconst expandContent = async () => {\n  content.value = 'Very long text...'.repeat(100)\n  \n  await nextTick()\n  \n  // Lấy height sau khi content expanded\n  const height = containerRef.value.offsetHeight\n  console.log('New height:', height)\n}</code></pre><p><strong>Use case 4: Update editor hoặc third-party library</strong></p><pre><code>const editorContent = ref('')\n\nconst updateEditor = async (newContent) => {\n  editorContent.value = newContent\n  \n  await nextTick()\n  \n  // Refresh editor sau khi Vue update DOM\n  editor.refresh()\n}</code></pre><p><strong>nextTick trong Options API:</strong></p><pre><code>export default {\n  data() {\n    return {\n      message: 'Hello'\n    }\n  },\n  methods: {\n    async updateMessage() {\n      this.message = 'Updated'\n      \n      // this.$nextTick\n      await this.$nextTick()\n      \n      // hoặc callback\n      this.$nextTick(() => {\n        console.log('DOM updated')\n      })\n    }\n  }\n}</code></pre><p><strong>So sánh với onUpdated():</strong></p><table><tr><th>Aspect</th><th>nextTick()</th><th>onUpdated()</th></tr><tr><td>Khi chạy</td><td>Sau next DOM update</td><td>Mỗi lần component update</td></tr><tr><td>Use case</td><td>Specific update cần handle</td><td>Mọi DOM update</td></tr><tr><td>Control</td><td>Call khi cần</td><td>Auto trigger</td></tr><tr><td>Performance</td><td>Efficient, on-demand</td><td>Runs cho mọi update</td></tr></table><p><strong>Khi nào dùng nextTick?</strong></p><ul><li>✅ Cần access/manipulate DOM sau khi data thay đổi</li><li>✅ Focus/scroll to elements vừa render</li><li>✅ Get computed dimensions/positions</li><li>✅ Update third-party libraries sau Vue update</li><li>✅ Đảm bảo DOM reflect latest state</li><li>❌ KHÔNG cần nếu chỉ work với reactive data (Vue auto handle)</li><li>❌ KHÔNG dùng cho mọi data change (overhead)</li></ul><p><strong>Best practices:</strong></p><ul><li>Dùng async/await cho code readable hơn callback</li><li>Chỉ dùng khi thực sự cần access DOM</li><li>Combine với ref templates để access DOM elements</li><li>Tránh abuse - không phải lúc nào cũng cần</li></ul><p><strong>Internal implementation (đơn giản hóa):</strong></p><pre><code>// Vue queue pending updates\nconst queue = []\nlet pending = false\n\nfunction queueUpdate(update) {\n  queue.push(update)\n  if (!pending) {\n    pending = true\n    Promise.resolve().then(flushQueue)\n  }\n}\n\nfunction flushQueue() {\n  queue.forEach(update => update())\n  queue.length = 0\n  pending = false\n}</code></pre>",
      "level": "middle"
    },
    {
      "question": "Props vs Emit: Communication giữa components?",
      "answer": "<p><strong>Props (Parent → Child):</strong></p><pre><code>// Parent\n&lt;ChildComponent :message=\"hello\" /&gt;\n\n// Child\nconst props = defineProps({\n  message: String\n})</code></pre><p><strong>Emit (Child → Parent):</strong></p><pre><code>// Child\nconst emit = defineEmits(['update'])\nemit('update', newValue)\n\n// Parent\n&lt;ChildComponent @update=\"handleUpdate\" /&gt;</code></pre><p><strong>Best practices:</strong></p><ul><li>Props down, events up (one-way data flow)</li><li>Validate props với type và validator</li><li>Emit events với tên rõ ràng</li><li>Dùng v-model cho two-way binding</li></ul>",
      "level": "fresher"
    },
    {
      "question": "v-if vs v-show: Khi nào dùng?",
      "answer": "<p><strong>v-if:</strong></p><ul><li>Conditional rendering - destroy/create DOM</li><li>Lazy rendering</li><li>Higher toggle cost</li><li>Dùng khi: điều kiện ít thay đổi</li></ul><pre><code>&lt;div v-if=\"isVisible\"&gt;Content&lt;/div&gt;</code></pre><p><strong>v-show:</strong></p><ul><li>Toggle CSS display property</li><li>Always render DOM</li><li>Higher initial render cost</li><li>Dùng khi: toggle thường xuyên</li></ul><pre><code>&lt;div v-show=\"isVisible\"&gt;Content&lt;/div&gt;</code></pre><p><strong>Performance tip:</strong></p><ul><li>v-show cho elements toggle nhiều</li><li>v-if cho conditional logic phức tạp</li><li>v-if với v-else-if, v-else</li></ul>",
      "level": "fresher"
    },
    {
      "question": "v-for và :key directive",
      "answer": "<p><strong>v-for:</strong></p><pre><code>&lt;li v-for=\"item in items\" :key=\"item.id\"&gt;\n  {{ item.name }}\n&lt;/li&gt;</code></pre><p><strong>Tại sao cần :key?</strong></p><ul><li>Giúp Vue identify từng node</li><li>Reuse và reorder elements hiệu quả</li><li>Tránh side-effects khi update list</li><li>Maintain component state</li></ul><p><strong>Key best practices:</strong></p><ul><li>Dùng unique, stable ID (không dùng index)</li><li>Không dùng random values</li><li>String hoặc number</li><li>Nhất quán trong app</li></ul><p><strong>Lưu ý:</strong></p><ul><li>Không dùng v-if và v-for cùng element</li><li>v-if có priority cao hơn v-for</li><li>Wrap bằng template nếu cần</li></ul>",
      "level": "fresher"
    },
    {
      "question": "Slot trong Vue.js là gì?",
      "answer": "<p><strong>Default slot:</strong></p><pre><code>// Parent\n&lt;MyComponent&gt;\n  &lt;p&gt;Content here&lt;/p&gt;\n&lt;/MyComponent&gt;\n\n// MyComponent\n&lt;div&gt;\n  &lt;slot /&gt;\n&lt;/div&gt;</code></pre><p><strong>Named slots:</strong></p><pre><code>// Parent\n&lt;MyComponent&gt;\n  &lt;template #header&gt;\n    &lt;h1&gt;Title&lt;/h1&gt;\n  &lt;/template&gt;\n  &lt;template #footer&gt;\n    &lt;p&gt;Footer&lt;/p&gt;\n  &lt;/template&gt;\n&lt;/MyComponent&gt;\n\n// MyComponent\n&lt;div&gt;\n  &lt;slot name=\"header\" /&gt;\n  &lt;slot /&gt; &lt;!-- default --&gt;\n  &lt;slot name=\"footer\" /&gt;\n&lt;/div&gt;</code></pre><p><strong>Scoped slots:</strong></p><pre><code>// Child\n&lt;slot :user=\"user\" :count=\"count\" /&gt;\n\n// Parent\n&lt;template #default=\"{ user, count }\"&gt;\n  {{ user.name }} - {{ count }}\n&lt;/template&gt;</code></pre>",
      "level": "middle"
    },
    {
      "question": "Provide/Inject pattern trong Vue 3?",
      "answer": "<p><strong>Provide/Inject là gì?</strong></p><p>Provide/Inject là cơ chế để truyền dữ liệu từ ancestor component xuống descendant components bất kể cấp độ lồng nhau, không cần props drilling qua nhiều levels.</p><p><strong>Provide (Component cha/ancestor):</strong></p><pre><code>import { provide, ref } from 'vue'\n\n// Provide reactive value\nconst theme = ref('dark')\nprovide('theme', theme)\n\n// Provide object\nprovide('config', {\n  theme: 'dark',\n  apiUrl: 'https://api.example.com'\n})\n\n// Provide với Symbol key (recommended)\nconst ThemeKey = Symbol()\nprovide(ThemeKey, theme)</code></pre><p><strong>Inject (Component con/descendant):</strong></p><pre><code>import { inject } from 'vue'\n\n// Inject value\nconst theme = inject('theme')\n\n// Inject với default value\nconst theme = inject('theme', 'light')\n\n// Inject với Symbol\nconst theme = inject(ThemeKey)</code></pre><p><strong>Use cases thực tế:</strong></p><ul><li><strong>Prop drilling:</strong> Tránh truyền props qua nhiều component levels</li><li><strong>Plugin systems:</strong> Plugin provide services cho toàn app</li><li><strong>Theme/Config:</strong> Chia sẻ theme, i18n, config globally</li><li><strong>Dependency injection:</strong> Inject services như API client, auth</li></ul><p><strong>Lưu ý quan trọng:</strong></p><ul><li><strong>Không thay thế props/emit:</strong> Vẫn dùng props/emit cho parent-child trực tiếp</li><li><strong>Data flow:</strong> Khó trace hơn props, nên document rõ ràng</li><li><strong>TypeScript:</strong> Dùng Symbol keys và type definitions để type-safe</li><li><strong>Reactivity:</strong> Provide ref/reactive để maintain reactivity</li><li><strong>App-level:</strong> Provide ở app.provide() cho global state</li></ul><p><strong>Ví dụ thực tế:</strong></p><pre><code>// App.vue\nconst user = ref(null)\nconst setUser = (newUser) => user.value = newUser\nprovide('user', { user, setUser })\n\n// Bất kỳ component con nào\nconst { user, setUser } = inject('user')</code></pre>",
      "level": "middle"
    },
    {
      "question": "Composables trong Vue 3 là gì?",
      "answer": "<p><strong>Composable là gì?</strong></p><p>Composable là function sử dụng Composition API để đóng gói và tái sử dụng stateful logic. Đây là pattern quan trọng trong Vue 3 giúp chia sẻ logic giữa các components một cách hiệu quả.</p><p><strong>Ví dụ useCounter:</strong></p><pre><code>// composables/useCounter.js\nimport { ref } from 'vue'\n\nexport function useCounter(initialValue = 0) {\n  const count = ref(initialValue)\n  \n  const increment = () => count.value++\n  const decrement = () => count.value--\n  const reset = () => count.value = initialValue\n  \n  return {\n    count,\n    increment,\n    decrement,\n    reset\n  }\n}</code></pre><p><strong>Sử dụng trong component:</strong></p><pre><code>import { useCounter } from '@/composables/useCounter'\n\nconst { count, increment, decrement } = useCounter(10)\n// Có thể dùng ở nhiều components khác nhau</code></pre><p><strong>Best practices khi viết Composables:</strong></p><ul><li><strong>Naming:</strong> Luôn prefix với 'use' (useCounter, useMouse, useFetch)</li><li><strong>Return values:</strong> Return reactive values để components có thể reactivity</li><li><strong>Parameters:</strong> Accept parameters để flexible và reusable</li><li><strong>Cleanup:</strong> Cleanup side effects trong onUnmounted (timers, listeners)</li><li><strong>Single responsibility:</strong> Mỗi composable nên làm một việc và làm tốt</li></ul><p><strong>Lợi ích:</strong></p><ul><li>Tái sử dụng logic dễ dàng giữa các components</li><li>Code dễ test hơn Options API</li><li>TypeScript support tốt</li><li>Tổ chức code theo logic thay vì lifecycle</li></ul>",
      "level": "middle"
    },
    {
      "question": "Pinia vs Vuex: Sự khác biệt?",
      "answer": "<p><strong>Pinia (recommended for Vue 3):</strong></p><ul><li>TypeScript support tốt hơn</li><li>Không cần mutations</li><li>Không cần modules/namespaces</li><li>Đơn giản hơn, ít boilerplate</li><li>Devtools support tốt</li><li>Composition API friendly</li></ul><pre><code>// Pinia store\nimport { defineStore } from 'pinia'\n\nexport const useUserStore = defineStore('user', {\n  state: () => ({\n    name: 'John'\n  }),\n  actions: {\n    updateName(newName) {\n      this.name = newName\n    }\n  }\n})</code></pre><p><strong>Vuex:</strong></p><ul><li>Mature, stable</li><li>Phức tạp hơn (state, mutations, actions, getters)</li><li>Cần commit mutations</li><li>Module system phức tạp</li></ul><p><strong>Migration:</strong> Vue 3 nên dùng Pinia</p>",
      "level": "middle"
    },
    {
      "question": "Async Components và Code Splitting trong Vue?",
      "answer": "<p><strong>Async Components là gì?</strong></p><p>Async components cho phép lazy load components chỉ khi cần thiết, giúp giảm bundle size ban đầu và tăng performance.</p><p><strong>Cách sử dụng cơ bản:</strong></p><pre><code>import { defineAsyncComponent } from 'vue'\n\n// Lazy load component\nconst AsyncComp = defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n)\n\n// Dùng như component bình thường\n&lt;AsyncComp /&gt;</code></pre><p><strong>Với loading và error states:</strong></p><pre><code>const AsyncComp = defineAsyncComponent({\n  // Loader function\n  loader: () => import('./MyComponent.vue'),\n  \n  // Component hiển thị khi đang load\n  loadingComponent: LoadingSpinner,\n  \n  // Component hiển thị khi có lỗi\n  errorComponent: ErrorComponent,\n  \n  // Delay trước khi show loading (ms)\n  delay: 200,\n  \n  // Timeout nếu load quá lâu (ms)\n  timeout: 3000\n})</code></pre><p><strong>Route-based code splitting:</strong></p><p>Chia code theo routes để mỗi page load riêng chunk:</p><pre><code>const routes = [\n  {\n    path: '/users',\n    // Lazy load route component\n    component: () => import('./views/Users.vue')\n  },\n  {\n    path: '/admin',\n    component: () => import('./views/Admin.vue')\n  }\n]</code></pre><p><strong>Benefits (Lợi ích):</strong></p><ul><li><strong>Smaller initial bundle:</strong> Giảm bundle size ban đầu, load nhanh hơn</li><li><strong>Lazy loading:</strong> Chỉ load khi user cần (vào route, click button)</li><li><strong>Better performance:</strong> Faster Time to Interactive (TTI)</li><li><strong>Parallel loading:</strong> Browser có thể load nhiều chunks song song</li><li><strong>Better caching:</strong> Chunks ít thay đổi được cache lâu hơn</li></ul><p><strong>Khi nào nên dùng:</strong></p><ul><li>Components lớn, ít dùng (modals, admin panels)</li><li>Route-based splitting cho SPA</li><li>Third-party heavy components (charts, editors)</li></ul>",
      "level": "middle"
    },
    {
      "question": "Custom Directives trong Vue?",
      "answer": "<p><strong>Custom Directives là gì?</strong></p><p>Custom directives cho phép tạo các directives riêng để tái sử dụng DOM manipulation logic. Khác với components (quản lý data và template), directives tập trung vào low-level DOM operations.</p><p><strong>Tạo directive đơn giản:</strong></p><pre><code>// directives/focus.js\nexport const vFocus = {\n  // Tự động focus khi element mounted\n  mounted(el) {\n    el.focus()\n  }\n}</code></pre><p><strong>Directive với lifecycle đầy đủ:</strong></p><pre><code>export const vColor = {\n  // Trước khi mount\n  beforeMount(el, binding) {\n    el.style.color = binding.value\n  },\n  \n  // Khi data update\n  updated(el, binding) {\n    // binding.value là giá trị mới\n    // binding.oldValue là giá trị cũ\n    el.style.color = binding.value\n  }\n}</code></pre><p><strong>Sử dụng directive:</strong></p><pre><code>&lt;!-- Local registration --&gt;\n&lt;script setup&gt;\nimport { vFocus } from './directives/focus'\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;input v-focus /&gt;\n  &lt;p v-color=\"'red'\"&gt;Red text&lt;/p&gt;\n&lt;/template&gt;</code></pre><p><strong>Register global directive:</strong></p><pre><code>// main.js\nimport { vFocus } from './directives/focus'\n\napp.directive('focus', vFocus)\n// Dùng ở mọi nơi: &lt;input v-focus /&gt;</code></pre><p><strong>Directive Lifecycle hooks:</strong></p><ul><li><code>beforeMount</code> - Trước khi element mount</li><li><code>mounted</code> - Element đã mount, có thể access DOM</li><li><code>beforeUpdate</code> - Trước khi component update</li><li><code>updated</code> - Sau khi component updated</li><li><code>beforeUnmount</code> - Trước khi unmount</li><li><code>unmounted</code> - Cleanup khi unmount</li></ul><p><strong>Directive arguments và modifiers:</strong></p><pre><code>// &lt;div v-example:arg.modifier=\"value\"&gt;\napp.directive('example', {\n  mounted(el, binding) {\n    console.log(binding.arg)      // 'arg'\n    console.log(binding.modifiers) // { modifier: true }\n    console.log(binding.value)     // 'value'\n  }\n})</code></pre><p><strong>Use cases:</strong></p><ul><li>Auto-focus inputs</li><li>Click outside detection</li><li>Scroll behavior</li><li>Tooltips</li><li>Lazy loading images</li><li>Permission-based element hiding</li></ul>",
      "level": "middle"
    },
    {
      "question": "Teleport trong Vue 3?",
      "answer": "<p><strong>Teleport:</strong> Render component content ở nơi khác trong DOM tree, outside component hierarchy.</p><pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;My Component&lt;/h1&gt;\n    \n    &lt;Teleport to=\"body\"&gt;\n      &lt;div class=\"modal\"&gt;\n        Modal content\n      &lt;/div&gt;\n    &lt;/Teleport&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre><p><strong>Use cases:</strong></p><ul><li>Modals</li><li>Tooltips</li><li>Notifications</li><li>Full-screen components</li></ul><p><strong>Multiple Teleports:</strong></p><pre><code>&lt;Teleport to=\"#modal-container\"&gt;\n  &lt;Modal /&gt;\n&lt;/Teleport&gt;\n\n&lt;Teleport to=\"#toast-container\"&gt;\n  &lt;Toast /&gt;\n&lt;/Teleport&gt;</code></pre><p><strong>Disabled prop:</strong></p><pre><code>&lt;Teleport to=\"body\" :disabled=\"isMobile\"&gt;\n  &lt;Modal /&gt;\n&lt;/Teleport&gt;</code></pre>",
      "level": "middle"
    },
    {
      "question": "Suspense trong Vue 3?",
      "answer": "<p><strong>Suspense:</strong> Handle async dependencies trong component tree.</p><pre><code>&lt;Suspense&gt;\n  &lt;template #default&gt;\n    &lt;AsyncComponent /&gt;\n  &lt;/template&gt;\n  \n  &lt;template #fallback&gt;\n    &lt;LoadingSpinner /&gt;\n  &lt;/template&gt;\n&lt;/Suspense&gt;</code></pre><p><strong>Với async setup:</strong></p><pre><code>// AsyncComponent.vue\n&lt;script setup&gt;\nconst data = await fetch('/api/data')\n&lt;/script&gt;</code></pre><p><strong>Multiple async components:</strong></p><pre><code>&lt;Suspense&gt;\n  &lt;template #default&gt;\n    &lt;UserProfile /&gt;\n    &lt;UserPosts /&gt;\n    &lt;UserComments /&gt;\n  &lt;/template&gt;\n  \n  &lt;template #fallback&gt;\n    &lt;Loading /&gt;\n  &lt;/template&gt;\n&lt;/Suspense&gt;</code></pre><p><strong>Error handling:</strong></p><pre><code>import { onErrorCaptured } from 'vue'\n\nonErrorCaptured((err) =&gt; {\n  console.error('Async error:', err)\n  return false\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "Reactivity Transform và $ref, $computed?",
      "answer": "<p><strong>Note:</strong> Reactivity Transform đã bị deprecated trong Vue 3.3, nhưng vẫn hữu ích để biết.</p><p><strong>$ref (trước đây):</strong></p><pre><code>// Thay vì\nconst count = ref(0)\nconsole.log(count.value)\n\n// Dùng $ref\nlet count = $ref(0)\nconsole.log(count) // no .value needed</code></pre><p><strong>$computed:</strong></p><pre><code>let double = $computed(() => count * 2)</code></pre><p><strong>Tại sao deprecated?</strong></p><ul><li>Cognitive overhead</li><li>Khác biệt giữa compile-time và runtime</li><li>TypeScript integration issues</li><li>Confusion cho developers</li></ul><p><strong>Alternative:</strong> Dùng ref/reactive như bình thường</p>",
      "level": "senior"
    },
    {
      "question": "Performance Optimization trong Vue?",
      "answer": "<p><strong>1. v-once:</strong></p><pre><code>&lt;div v-once&gt;{{ heavyComputation() }}&lt;/div&gt;</code></pre><p><strong>2. v-memo (Vue 3.2+):</strong></p><pre><code>&lt;div v-memo=\"[valueA, valueB]\"&gt;\n  Only re-render when valueA or valueB changes\n&lt;/div&gt;</code></pre><p><strong>3. Computed caching:</strong></p><pre><code>const filtered = computed(() => \n  items.value.filter(i => i.active)\n)</code></pre><p><strong>4. Virtual scrolling:</strong></p><ul><li>Dùng thư viện vue-virtual-scroller</li><li>Render only visible items</li></ul><p><strong>5. Lazy loading:</strong></p><ul><li>Code splitting</li><li>Route-based chunks</li><li>Async components</li></ul><p><strong>6. KeepAlive:</strong></p><pre><code>&lt;KeepAlive&gt;\n  &lt;component :is=\"currentView\" /&gt;\n&lt;/KeepAlive&gt;</code></pre><p><strong>7. Shallow reactive:</strong></p><pre><code>import { shallowRef, shallowReactive } from 'vue'\nconst state = shallowReactive({ deep: { object: 1 } })</code></pre>",
      "level": "senior"
    },
    {
      "question": "Vue Router: Navigation Guards?",
      "answer": "<p><strong>Global guards:</strong></p><pre><code>// beforeEach\nrouter.beforeEach((to, from, next) => {\n  if (to.meta.requiresAuth && !isAuthenticated) {\n    next('/login')\n  } else {\n    next()\n  }\n})\n\n// afterEach\nrouter.afterEach((to, from) => {\n  document.title = to.meta.title\n})</code></pre><p><strong>Per-route guards:</strong></p><pre><code>{\n  path: '/admin',\n  component: Admin,\n  beforeEnter: (to, from, next) => {\n    if (hasAdminRole()) next()\n    else next('/forbidden')\n  }\n}</code></pre><p><strong>In-component guards:</strong></p><pre><code>// Options API\nexport default {\n  beforeRouteEnter(to, from, next) {},\n  beforeRouteUpdate(to, from, next) {},\n  beforeRouteLeave(to, from, next) {}\n}\n\n// Composition API\nimport { onBeforeRouteLeave } from 'vue-router'\n\nonBeforeRouteLeave((to, from) => {\n  const answer = window.confirm('Unsaved changes!')\n  if (!answer) return false\n})</code></pre>",
      "level": "middle"
    },
    {
      "question": "defineModel trong Vue 3.3+?",
      "answer": "<p><strong>defineModel:</strong> Simplified v-model implementation</p><p><strong>Trước Vue 3.3:</strong></p><pre><code>const props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n\nconst value = computed({\n  get: () => props.modelValue,\n  set: (val) => emit('update:modelValue', val)\n})</code></pre><p><strong>Với defineModel:</strong></p><pre><code>const model = defineModel()\n// That's it!</code></pre><p><strong>Multiple v-models:</strong></p><pre><code>const firstName = defineModel('firstName')\nconst lastName = defineModel('lastName')\n\n// Usage\n&lt;MyComponent \n  v-model:firstName=\"first\" \n  v-model:lastName=\"last\" \n/&gt;</code></pre><p><strong>With options:</strong></p><pre><code>const model = defineModel({\n  type: String,\n  required: true,\n  default: ''\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "Testing Vue Components?",
      "answer": "<p><strong>Vue Test Utils:</strong></p><pre><code>import { mount } from '@vue/test-utils'\nimport MyComponent from './MyComponent.vue'\n\ntest('renders message', () => {\n  const wrapper = mount(MyComponent, {\n    props: { msg: 'Hello' }\n  })\n  \n  expect(wrapper.text()).toContain('Hello')\n})</code></pre><p><strong>Testing user interaction:</strong></p><pre><code>test('button click', async () => {\n  const wrapper = mount(Counter)\n  \n  await wrapper.find('button').trigger('click')\n  \n  expect(wrapper.find('.count').text()).toBe('1')\n})</code></pre><p><strong>Testing Composables:</strong></p><pre><code>import { useCounter } from './useCounter'\n\ntest('useCounter', () => {\n  const { count, increment } = useCounter()\n  \n  expect(count.value).toBe(0)\n  increment()\n  expect(count.value).toBe(1)\n})</code></pre><p><strong>Mocking:</strong></p><pre><code>const wrapper = mount(MyComponent, {\n  global: {\n    mocks: {\n      $route: { params: { id: '1' } }\n    },\n    stubs: ['RouterLink']\n  }\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "Server-Side Rendering với Vue?",
      "answer": "<p><strong>Benefits của SSR:</strong></p><ul><li>Better SEO</li><li>Faster initial load</li><li>Better social media sharing</li></ul><p><strong>Nuxt.js:</strong> Framework cho Vue SSR</p><pre><code>// pages/index.vue\r\nexport default {\r\n  async asyncData() {\r\n    const data = await $fetch('/api/data')\r\n    return { data }\r\n  }\r\n}</code></pre><p><strong>Hydration:</strong></p><ul><li>Server render HTML</li><li>Client hydrate thành interactive app</li><li>Tránh hydration mismatch</li></ul><p><strong>Vite SSR:</strong></p><pre><code>// server.js\r\nimport { createSSRApp } from 'vue'\r\nimport { renderToString } from 'vue/server-renderer'\r\n\r\nconst app = createSSRApp(App)\r\nconst html = await renderToString(app)</code></pre><p><strong>Lưu ý:</strong></p><ul><li>Không dùng window, document trong setup</li><li>Lifecycle hooks khác nhau</li><li>State management cần special handling</li></ul>",
      "level": "senior"
    },
    {
      "question": "TypeScript với Vue 3?",
      "answer": "<p><strong>defineComponent:</strong></p><pre><code>import { defineComponent } from 'vue'\n\nexport default defineComponent({\n  props: {\n    name: String,\n    count: Number\n  },\n  setup(props) {\n    // props is typed\n    console.log(props.name)\n  }\n})</code></pre><p><strong>Script setup với TypeScript:</strong></p><pre><code>&lt;script setup lang=\"ts\"&gt;\ninterface Props {\n  name: string\n  count?: number\n}\n\nconst props = defineProps&lt;Props&gt;()\n\nconst emit = defineEmits&lt;{\n  update: [value: string]\n  delete: [id: number]\n}&gt;()\n&lt;/script&gt;</code></pre><p><strong>Composables typing:</strong></p><pre><code>export function useUser() {\n  const user = ref&lt;User | null&gt;(null)\n  \n  const login = async (credentials: Credentials): Promise&lt;void&gt; => {\n    user.value = await api.login(credentials)\n  }\n  \n  return { user, login }\n}</code></pre>",
      "level": "senior"
    },
    {
      "question": "Khi nào không nên dùng Vue?",
      "answer": "<p><strong>Vue không phù hợp khi:</strong></p><ul><li><strong>App cực kỳ phức tạp:</strong> React/Angular có ecosystem lớn hơn cho enterprise</li><li><strong>Native mobile chủ yếu:</strong> React Native mature hơn</li><li><strong>Team đã expertise framework khác:</strong> Switching cost cao</li><li><strong>Cần strong typing từ đầu:</strong> Angular có TypeScript built-in sâu hơn</li><li><strong>Corporate backing quan trọng:</strong> React (Meta), Angular (Google) vs Vue (community-driven)</li></ul><p><strong>Vue phù hợp khi:</strong></p><ul><li>Cần learning curve thấp</li><li>Team nhỏ, prototype nhanh</li><li>Progressive enhancement</li><li>Balance giữa flexibility và structure</li><li>Documentation quality quan trọng</li></ul>",
      "level": "senior"
    },
    {
      "question": "Security best practices trong Vue?",
      "answer": "<p><strong>1. XSS Prevention:</strong></p><ul><li>Vue tự động escape HTML trong {{ }}</li><li>KHÔNG dùng v-html với user input</li><li>Sanitize data trước khi render</li></ul><pre><code>// BAD\n&lt;div v-html=\"userInput\"&gt;&lt;/div&gt;\n\n// GOOD\n&lt;div&gt;{{ sanitize(userInput) }}&lt;/div&gt;</code></pre><p><strong>2. CSRF Protection:</strong></p><ul><li>Dùng CSRF tokens</li><li>SameSite cookies</li><li>Verify origin headers</li></ul><p><strong>3. Authentication:</strong></p><ul><li>NEVER store tokens trong localStorage (XSS risk)</li><li>Dùng HttpOnly cookies</li><li>Implement proper session management</li></ul><p><strong>4. API Security:</strong></p><ul><li>Validate inputs</li><li>Rate limiting</li><li>CORS configuration</li><li>HTTPS only</li></ul><p><strong>5. Dependencies:</strong></p><ul><li>Regular updates</li><li>Audit npm packages</li><li>Use lock files</li></ul>",
      "level": "senior"
    },
    {
      "question": "Error Handling trong Vue?",
      "answer": "<p><strong>Global error handler:</strong></p><pre><code>const app = createApp(App)\n\napp.config.errorHandler = (err, instance, info) => {\n  console.error('Global error:', err)\n  console.log('Component:', instance)\n  console.log('Error info:', info)\n  // Send to logging service\n}</code></pre><p><strong>Component error boundary:</strong></p><pre><code>import { onErrorCaptured } from 'vue'\n\nonErrorCaptured((err, instance, info) => {\n  console.error('Caught error:', err)\n  // Return false to stop propagation\n  return false\n})</code></pre><p><strong>Async error handling:</strong></p><pre><code>const fetchData = async () => {\n  try {\n    const data = await api.getData()\n    return data\n  } catch (error) {\n    console.error('Fetch error:', error)\n    // Handle error\n  }\n}</code></pre><p><strong>Router error handling:</strong></p><pre><code>router.onError((error) => {\n  console.error('Router error:', error)\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "State Management patterns ngoài Pinia/Vuex?",
      "answer": "<p><strong>1. Provide/Inject pattern:</strong></p><pre><code>// store.js\nimport { reactive, provide, inject } from 'vue'\n\nconst StoreSymbol = Symbol()\n\nexport function createStore() {\n  const state = reactive({\n    count: 0\n  })\n  \n  const increment = () => state.count++\n  \n  return { state, increment }\n}\n\nexport function provideStore() {\n  provide(StoreSymbol, createStore())\n}\n\nexport function useStore() {\n  return inject(StoreSymbol)\n}</code></pre><p><strong>2. Composable-based state:</strong></p><pre><code>// useGlobalState.js\nconst state = reactive({\n  user: null\n})\n\nexport function useGlobalState() {\n  return { state }\n}</code></pre><p><strong>3. Event bus (không khuyến khích):</strong></p><pre><code>import mitt from 'mitt'\nconst emitter = mitt()\n\nexport { emitter }</code></pre><p><strong>4. Browser storage:</strong></p><ul><li>LocalStorage</li><li>SessionStorage</li><li>IndexedDB</li></ul>",
      "level": "senior"
    },
    {
      "question": "Migration từ Vue 2 lên Vue 3?",
      "answer": "<p><strong>Breaking changes chính:</strong></p><ul><li>Global API thành instance API</li><li>v-model changes</li><li>Filters removed</li><li>$listeners merged vào $attrs</li><li>Functional components changes</li></ul><p><strong>Migration build:</strong></p><pre><code>npm install @vue/compat\n\n// vite.config.js\nexport default {\n  resolve: {\n    alias: {\n      vue: '@vue/compat'\n    }\n  }\n}</code></pre><p><strong>Step by step:</strong></p><ol><li>Update dependencies</li><li>Run migration build</li><li>Fix deprecation warnings</li><li>Update syntax (Options → Composition)</li><li>Test thoroughly</li><li>Remove compat mode</li></ol><p><strong>Tools:</strong></p><ul><li>Vue 3 Migration Guide</li><li>ESLint plugin</li><li>Vue DevTools</li></ul>",
      "level": "senior"
    },
    {
      "question": "Memory leaks trong Vue: Nguyên nhân và cách tránh?",
      "answer": "<p><strong>Nguyên nhân phổ biến:</strong></p><p><strong>1. Event listeners không cleanup:</strong></p><pre><code>// BAD\nonMounted(() => {\n  window.addEventListener('resize', handler)\n})\n\n// GOOD\nonMounted(() => {\n  window.addEventListener('resize', handler)\n})\n\nonUnmounted(() => {\n  window.removeEventListener('resize', handler)\n})</code></pre><p><strong>2. Timers không clear:</strong></p><pre><code>// BAD\nconst timer = setInterval(() => {}, 1000)\n\n// GOOD\nconst timer = setInterval(() => {}, 1000)\n\nonUnmounted(() => {\n  clearInterval(timer)\n})</code></pre><p><strong>3. DOM references:</strong></p><pre><code>// Avoid keeping DOM references\nconst element = ref(null)\n\nonUnmounted(() => {\n  element.value = null\n})</code></pre><p><strong>4. Subscriptions không unsubscribe:</strong></p><pre><code>let subscription\n\nonMounted(() => {\n  subscription = store.subscribe(handler)\n})\n\nonUnmounted(() => {\n  subscription()\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "Debugging Vue applications?",
      "answer": "<p><strong>1. Vue DevTools:</strong></p><ul><li>Component inspector</li><li>Vuex/Pinia state</li><li>Events timeline</li><li>Performance profiling</li></ul><p><strong>2. Console debugging:</strong></p><pre><code>// Component name trong console\nexport default {\n  name: 'MyComponent',\n  setup() {\n    console.log('Setup running')\n  }\n}</code></pre><p><strong>3. Debug hooks:</strong></p><pre><code>import { onRenderTracked, onRenderTriggered } from 'vue'\n\nonRenderTracked((event) => {\n  console.log('Tracked:', event)\n})\n\nonRenderTriggered((event) => {\n  console.log('Triggered:', event)\n})</code></pre><p><strong>4. Error tracking:</strong></p><ul><li>Sentry</li><li>LogRocket</li><li>Bugsnag</li></ul><p><strong>5. Performance:</strong></p><ul><li>Chrome DevTools Performance tab</li><li>Lighthouse</li><li>Vue DevTools Performance</li></ul>",
      "level": "senior"
    },
    {
      "question": "nextTick() trong Vue 2 vs Vue 3: API khác biệt như thế nào?",
      "answer": "<p><strong>Vue 2 - this.$nextTick():</strong></p><p>Trong Vue 2 Options API, nextTick được access qua instance method <code>this.$nextTick()</code>:</p><pre><code>// Vue 2 - Options API\nexport default {\n  data() {\n    return {\n      message: 'Hello'\n    }\n  },\n  methods: {\n    updateMessage() {\n      this.message = 'Updated'\n      \n      // Method 1: Callback\n      this.$nextTick(function() {\n        // 'this' context được preserve\n        console.log(this.$el.textContent)\n      })\n      \n      // Method 2: Arrow function\n      this.$nextTick(() => {\n        console.log(this.$el.textContent)\n      })\n      \n      // Method 3: Promise (Vue 2.1+)\n      this.$nextTick().then(() => {\n        console.log(this.$el.textContent)\n      })\n    }\n  }\n}</code></pre><p><strong>Vue 2 - Global Vue.nextTick():</strong></p><pre><code>import Vue from 'vue'\n\n// Global API\nVue.nextTick(() => {\n  // DOM updated\n})\n\n// hoặc Promise\nVue.nextTick().then(() => {\n  // DOM updated\n})</code></pre><p><strong>Vue 3 - Import from 'vue':</strong></p><p>Vue 3 chuyển sang Composition API, nextTick trở thành standalone function:</p><pre><code>// Vue 3 - Composition API\nimport { ref, nextTick } from 'vue'\n\nexport default {\n  setup() {\n    const message = ref('Hello')\n    \n    const updateMessage = async () => {\n      message.value = 'Updated'\n      \n      // Method 1: async/await (recommended)\n      await nextTick()\n      console.log('DOM updated')\n      \n      // Method 2: Promise\n      nextTick().then(() => {\n        console.log('DOM updated')\n      })\n      \n      // Method 3: Callback (legacy support)\n      nextTick(() => {\n        console.log('DOM updated')\n      })\n    }\n    \n    return { message, updateMessage }\n  }\n}</code></pre><p><strong>Vue 3 - Script Setup (modern syntax):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, nextTick } from 'vue'\n\nconst count = ref(0)\nconst elementRef = ref(null)\n\nconst increment = async () => {\n  count.value++\n  \n  await nextTick()\n  \n  // Access updated DOM\n  console.log(elementRef.value.textContent)\n}\n&lt;/script&gt;</code></pre><p><strong>Vue 3 - Options API (vẫn support):</strong></p><pre><code>// Vue 3 vẫn support this.$nextTick()\nexport default {\n  methods: {\n    updateData() {\n      this.message = 'New'\n      \n      // Vẫn work như Vue 2\n      this.$nextTick(() => {\n        console.log('Updated')\n      })\n    }\n  }\n}</code></pre><p><strong>Bảng so sánh Vue 2 vs Vue 3:</strong></p><table><tr><th>Aspect</th><th>Vue 2</th><th>Vue 3</th></tr><tr><td>Instance method</td><td>this.$nextTick()</td><td>this.$nextTick() (Options API)</td></tr><tr><td>Global API</td><td>Vue.nextTick()</td><td>nextTick() import</td></tr><tr><td>Composition API</td><td>Không có</td><td>import { nextTick } from 'vue'</td></tr><tr><td>Callback support</td><td>✅ Primary way</td><td>✅ Legacy support</td></tr><tr><td>Promise support</td><td>✅ Vue 2.1+</td><td>✅ Recommended</td></tr><tr><td>async/await</td><td>✅ Supported</td><td>✅ Recommended way</td></tr><tr><td>Tree-shaking</td><td>❌ Global API</td><td>✅ Import only when used</td></tr></table><p><strong>Migration từ Vue 2 sang Vue 3:</strong></p><pre><code>// Vue 2\nexport default {\n  methods: {\n    async doSomething() {\n      this.data = 'new value'\n      await this.$nextTick()\n      console.log(this.$el)\n    }\n  }\n}\n\n// Vue 3 - Composition API (recommended)\nimport { ref, nextTick } from 'vue'\n\nexport default {\n  setup() {\n    const data = ref('old value')\n    const el = ref(null)\n    \n    const doSomething = async () => {\n      data.value = 'new value'\n      await nextTick()\n      console.log(el.value)\n    }\n    \n    return { data, el, doSomething }\n  }\n}\n\n// Vue 3 - Options API (nếu chưa migrate)\nexport default {\n  methods: {\n    async doSomething() {\n      this.data = 'new value'\n      await this.$nextTick() // Vẫn work!\n      console.log(this.$el)\n    }\n  }\n}</code></pre><p><strong>Internal implementation khác biệt:</strong></p><p><strong>Vue 2:</strong> Sử dụng microtask queue (Promise) hoặc fallback về macro task (setTimeout) tùy browser support.</p><p><strong>Vue 3:</strong> Luôn dùng Promise microtask, performance tốt hơn và consistent hơn.</p><p><strong>Best practices cho Vue 3:</strong></p><ul><li><strong>Composition API:</strong> Import và dùng async/await với nextTick()</li><li><strong>Tree-shaking:</strong> Chỉ import khi cần, giảm bundle size</li><li><strong>TypeScript:</strong> Type inference tốt hơn với import</li><li><strong>Consistency:</strong> Dùng cùng pattern với reactive API (ref, computed, watch)</li></ul><pre><code>// ✅ GOOD - Vue 3 modern way\nimport { ref, nextTick } from 'vue'\n\nconst data = ref(0)\n\nconst update = async () => {\n  data.value++\n  await nextTick()\n  // DOM updated\n}\n\n// ❌ AVOID - Mixing old and new\nconst update2 = function() {\n  this.data++\n  this.$nextTick(() => {\n    // Mixes this context with Composition API\n  })\n}</code></pre>",
      "level": "senior"
    },
    {
      "question": "Làm thế nào để hủy API request khi component bị unmount trong Vue?",
      "answer": "<p><strong>Tại sao cần cancel API requests?</strong></p><p>Khi component bị unmount trước khi API request hoàn thành, việc update state sau khi unmount sẽ gây ra:</p><ul><li>Memory leaks</li><li>Warning: \"Can't perform a React state update on an unmounted component\"</li><li>Unnecessary network traffic</li><li>Potential bugs nếu callback vẫn chạy</li></ul><p><strong>Method 1: AbortController (Modern, Recommended):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nconst data = ref(null)\nconst loading = ref(false)\nconst error = ref(null)\n\n// Tạo AbortController\nconst abortController = new AbortController()\n\nconst fetchData = async () => {\n  loading.value = true\n  error.value = null\n  \n  try {\n    const response = await fetch('/api/data', {\n      signal: abortController.signal // Pass signal vào fetch\n    })\n    \n    if (!response.ok) throw new Error('Failed')\n    \n    data.value = await response.json()\n  } catch (err) {\n    // Kiểm tra nếu error là do abort\n    if (err.name === 'AbortError') {\n      console.log('Request was cancelled')\n    } else {\n      error.value = err.message\n    }\n  } finally {\n    loading.value = false\n  }\n}\n\nonMounted(() => {\n  fetchData()\n})\n\n// Cancel khi unmount\nonUnmounted(() => {\n  abortController.abort()\n  console.log('API request cancelled')\n})\n&lt;/script&gt;</code></pre><p><strong>Method 2: Axios với CancelToken:</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\nimport axios from 'axios'\n\nconst data = ref(null)\nconst source = axios.CancelToken.source()\n\nconst fetchData = async () => {\n  try {\n    const response = await axios.get('/api/data', {\n      cancelToken: source.token\n    })\n    data.value = response.data\n  } catch (err) {\n    if (axios.isCancel(err)) {\n      console.log('Request cancelled:', err.message)\n    } else {\n      console.error('Error:', err)\n    }\n  }\n}\n\nonMounted(() => {\n  fetchData()\n})\n\nonUnmounted(() => {\n  source.cancel('Component unmounted')\n})\n&lt;/script&gt;</code></pre><p><strong>Method 3: Axios với AbortController (Axios 0.22+):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\nimport axios from 'axios'\n\nconst data = ref(null)\nconst abortController = new AbortController()\n\nconst fetchData = async () => {\n  try {\n    const response = await axios.get('/api/data', {\n      signal: abortController.signal\n    })\n    data.value = response.data\n  } catch (err) {\n    if (err.name === 'CanceledError') {\n      console.log('Request cancelled')\n    }\n  }\n}\n\nonMounted(() => {\n  fetchData()\n})\n\nonUnmounted(() => {\n  abortController.abort()\n})\n&lt;/script&gt;</code></pre><p><strong>Method 4: Flag-based approach (Simple fallback):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nconst data = ref(null)\nlet isMounted = true\n\nconst fetchData = async () => {\n  const response = await fetch('/api/data')\n  const result = await response.json()\n  \n  // Chỉ update state nếu component vẫn mounted\n  if (isMounted) {\n    data.value = result\n  }\n}\n\nonMounted(() => {\n  isMounted = true\n  fetchData()\n})\n\nonUnmounted(() => {\n  isMounted = false\n})\n&lt;/script&gt;</code></pre><p><strong>Method 5: Composable để reuse logic:</strong></p><pre><code>// composables/useFetch.js\nimport { ref, onUnmounted } from 'vue'\n\nexport function useFetch(url) {\n  const data = ref(null)\n  const error = ref(null)\n  const loading = ref(false)\n  \n  const abortController = new AbortController()\n  \n  const fetchData = async () => {\n    loading.value = true\n    error.value = null\n    \n    try {\n      const response = await fetch(url, {\n        signal: abortController.signal\n      })\n      \n      if (!response.ok) throw new Error(`HTTP ${response.status}`)\n      \n      data.value = await response.json()\n    } catch (err) {\n      if (err.name !== 'AbortError') {\n        error.value = err.message\n      }\n    } finally {\n      loading.value = false\n    }\n  }\n  \n  const abort = () => {\n    abortController.abort()\n  }\n  \n  // Auto cleanup on unmount\n  onUnmounted(() => {\n    abort()\n  })\n  \n  return { data, error, loading, fetchData, abort }\n}\n\n// Sử dụng trong component\nimport { useFetch } from '@/composables/useFetch'\n\nconst { data, error, loading, fetchData } = useFetch('/api/users')\n\nonMounted(() => {\n  fetchData()\n})</code></pre><p><strong>Method 6: Multiple requests với Promise.race:</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nconst data = ref(null)\nlet cancelPromise\nlet resolveCancelPromise\n\nconst fetchData = async () => {\n  // Tạo cancel promise\n  cancelPromise = new Promise((resolve) => {\n    resolveCancelPromise = resolve\n  })\n  \n  try {\n    const dataPromise = fetch('/api/data').then(r => r.json())\n    \n    // Race giữa data và cancel\n    const result = await Promise.race([\n      dataPromise,\n      cancelPromise\n    ])\n    \n    if (result) {\n      data.value = result\n    }\n  } catch (err) {\n    console.error(err)\n  }\n}\n\nonMounted(() => {\n  fetchData()\n})\n\nonUnmounted(() => {\n  // Resolve cancel promise để win the race\n  resolveCancelPromise(null)\n})\n&lt;/script&gt;</code></pre><p><strong>Advanced: Handle multiple concurrent requests:</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nconst data = ref(null)\nconst controllers = new Set()\n\nconst fetchData = async (endpoint) => {\n  const controller = new AbortController()\n  controllers.add(controller)\n  \n  try {\n    const response = await fetch(endpoint, {\n      signal: controller.signal\n    })\n    data.value = await response.json()\n  } catch (err) {\n    if (err.name !== 'AbortError') {\n      console.error(err)\n    }\n  } finally {\n    controllers.delete(controller)\n  }\n}\n\nconst cancelAll = () => {\n  controllers.forEach(controller => controller.abort())\n  controllers.clear()\n}\n\nonMounted(() => {\n  // Multiple requests\n  fetchData('/api/users')\n  fetchData('/api/posts')\n  fetchData('/api/comments')\n})\n\nonUnmounted(() => {\n  cancelAll()\n})\n&lt;/script&gt;</code></pre><p><strong>Browser compatibility:</strong></p><table><tr><th>Method</th><th>Browser Support</th><th>Pros</th><th>Cons</th></tr><tr><td>AbortController</td><td>Modern browsers (IE ❌)</td><td>Native, standard, clean API</td><td>Polyfill cần cho old browsers</td></tr><tr><td>Axios CancelToken</td><td>All (library handles)</td><td>Works everywhere, easy</td><td>Axios-specific, deprecated</td></tr><tr><td>Axios AbortController</td><td>Modern browsers</td><td>Standard + Axios benefits</td><td>Requires Axios 0.22+</td></tr><tr><td>Flag-based</td><td>All browsers</td><td>Simple, no dependencies</td><td>Request vẫn chạy, waste bandwidth</td></tr></table><p><strong>Best practices:</strong></p><ul><li>✅ Dùng AbortController cho fetch API (modern, standard)</li><li>✅ Dùng Axios với AbortController (Axios 0.22+)</li><li>✅ Cleanup trong onUnmounted hook</li><li>✅ Handle AbortError/CanceledError riêng, không log error</li><li>✅ Tạo composable để reuse logic</li><li>❌ KHÔNG ignore cleanup - gây memory leaks</li><li>❌ KHÔNG dùng flag-based nếu có AbortController</li></ul><p><strong>Testing:</strong></p><pre><code>// Test với Vue Test Utils\nimport { mount } from '@vue/test-utils'\nimport { nextTick } from 'vue'\n\ntest('cancels request on unmount', async () => {\n  const wrapper = mount(MyComponent)\n  \n  // Component mounted, request started\n  \n  wrapper.unmount()\n  \n  // Verify abort was called\n  await nextTick()\n  \n  // Request should be cancelled\n})</code></pre>",
      "level": "senior"
    },
    {
      "question": "v-for hoạt động như thế nào? Tại sao không nên dùng v-if và v-for cùng element?",
      "answer": "<p><strong>v-for hoạt động như thế nào?</strong></p><p>v-for render list bằng cách iterate qua array/object và tạo VNode (Virtual DOM node) cho mỗi item. Vue sử dụng <strong>in-place patch strategy</strong> để update efficiently.</p><p><strong>Cú pháp v-for:</strong></p><pre><code>&lt;!-- Array --&gt;\n&lt;li v-for=\"(item, index) in items\" :key=\"item.id\"&gt;\n  {{ index }}: {{ item.name }}\n&lt;/li&gt;\n\n&lt;!-- Object --&gt;\n&lt;div v-for=\"(value, key, index) in object\" :key=\"key\"&gt;\n  {{ key }}: {{ value }}\n&lt;/div&gt;\n\n&lt;!-- Range --&gt;\n&lt;span v-for=\"n in 10\" :key=\"n\"&gt;{{ n }}&lt;/span&gt;\n\n&lt;!-- Component --&gt;\n&lt;MyComponent \n  v-for=\"item in items\" \n  :key=\"item.id\"\n  :data=\"item\" \n/&gt;</code></pre><p><strong>Virtual DOM diffing algorithm:</strong></p><p>Khi list thay đổi, Vue compare old VNodes với new VNodes:</p><ol><li><strong>Với :key:</strong> Vue track từng node bằng key, reuse & reorder elements efficiently</li><li><strong>Không có :key:</strong> Vue dùng \"in-place patch\" - update content của existing elements theo thứ tự, không move DOM nodes</li></ol><pre><code>// Có :key - Vue track và reorder\n&lt;div v-for=\"item in items\" :key=\"item.id\"&gt;\n  {{ item.name }}\n&lt;/div&gt;\n\n// items = [{ id: 1, name: 'A' }, { id: 2, name: 'B' }]\n// → [{ id: 2, name: 'B' }, { id: 1, name: 'A' }]\n// Vue sẽ MOVE DOM nodes\n\n// Không có :key - in-place patch\n&lt;div v-for=\"item in items\"&gt;\n  {{ item.name }}\n&lt;/div&gt;\n// Vue sẽ UPDATE content của existing divs, không move</code></pre><p><strong>Tại sao cần :key unique và stable?</strong></p><ul><li><strong>Identity tracking:</strong> Vue phân biệt được element nào tương ứng với data item nào trong array</li><li><strong>State preservation:</strong> Component state, form input values được preserve đúng khi list reorder</li><li><strong>Transition animations:</strong> Vue track chính xác element nào move/add/remove để animate</li><li><strong>Performance:</strong> Reuse existing DOM nodes thay vì destroy/create mới</li></ul><pre><code>// ❌ BAD - Dùng index làm key\n&lt;div v-for=\"(item, index) in items\" :key=\"index\"&gt;\n  &lt;input v-model=\"item.value\" /&gt;\n&lt;/div&gt;\n// Khi xóa item, index thay đổi → Vue nhầm lẫn identity\n\n// ✅ GOOD - Dùng unique ID\n&lt;div v-for=\"item in items\" :key=\"item.id\"&gt;\n  &lt;input v-model=\"item.value\" /&gt;\n&lt;/div&gt;</code></pre><p><strong>Tại sao KHÔNG nên dùng v-if và v-for cùng element?</strong></p><p><strong>Lý do 1: Priority conflict</strong></p><p>Vue 2 và Vue 3 có priority khác nhau:</p><ul><li><strong>Vue 2:</strong> v-for có priority cao hơn v-if</li><li><strong>Vue 3:</strong> v-if có priority cao hơn v-for</li></ul><pre><code>&lt;!-- Vue 2 --&gt;\n&lt;div v-for=\"item in items\" v-if=\"item.isActive\"&gt;\n  {{ item.name }}\n&lt;/div&gt;\n// v-for chạy trước → v-if check từng item (WORK nhưng không tối ưu)\n\n&lt;!-- Vue 3 --&gt;\n&lt;div v-for=\"item in items\" v-if=\"item.isActive\"&gt;\n  {{ item.name }}\n&lt;/div&gt;\n// v-if chạy trước → 'item' chưa defined → ERROR!</code></pre><p><strong>Lý do 2: Performance issue</strong></p><p>Khi v-for và v-if cùng element, Vue phải evaluate cả hai mỗi lần render:</p><pre><code>&lt;!-- ❌ BAD - Check condition cho MỌI item mỗi render --&gt;\n&lt;li v-for=\"user in users\" v-if=\"user.isActive\" :key=\"user.id\"&gt;\n  {{ user.name }}\n&lt;/li&gt;\n// Nếu users = 1000 items → 1000 checks mỗi render!</code></pre><p><strong>Lý do 3: Code clarity</strong></p><p>Mixing v-for và v-if làm code khó đọc và maintain.</p><p><strong>Solutions - Cách đúng để combine filtering với v-for:</strong></p><p><strong>Solution 1: Computed property (RECOMMENDED):</strong></p><pre><code>&lt;script setup&gt;\nimport { ref, computed } from 'vue'\n\nconst users = ref([\n  { id: 1, name: 'John', isActive: true },\n  { id: 2, name: 'Jane', isActive: false },\n  { id: 3, name: 'Bob', isActive: true }\n])\n\n// Filter một lần, cache result\nconst activeUsers = computed(() =&gt; \n  users.value.filter(user =&gt; user.isActive)\n)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;!-- ✅ GOOD - Chỉ loop qua filtered items --&gt;\n  &lt;li v-for=\"user in activeUsers\" :key=\"user.id\"&gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/template&gt;\n\n&lt;!-- Benefits:\n  - Filter chỉ chạy khi users thay đổi (cached)\n  - v-for chỉ loop qua items cần thiết\n  - Code clear và maintainable\n--&gt;</code></pre><p><strong>Solution 2: Wrapper template với v-if bên ngoài:</strong></p><pre><code>&lt;!-- ✅ GOOD - v-if wrapper --&gt;\n&lt;template v-for=\"user in users\" :key=\"user.id\"&gt;\n  &lt;li v-if=\"user.isActive\"&gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/template&gt;\n\n&lt;!-- hoặc --&gt;\n&lt;div v-for=\"user in users\" :key=\"user.id\"&gt;\n  &lt;div v-if=\"user.isActive\"&gt;\n    {{ user.name }}\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!-- Dùng khi:\n  - Không thể/không muốn dùng computed\n  - Condition phức tạp, depends on multiple factors\n  - Cần preserve DOM structure\n--&gt;</code></pre><p><strong>Solution 3: v-show cho toggle visibility:</strong></p><pre><code>&lt;!-- Nếu cần toggle thường xuyên --&gt;\n&lt;li \n  v-for=\"user in users\" \n  v-show=\"user.isActive\"\n  :key=\"user.id\"\n&gt;\n  {{ user.name }}\n&lt;/li&gt;\n\n&lt;!-- v-show chỉ toggle CSS display\n  - Tốt khi toggle frequently\n  - Elements vẫn render, chỉ ẩn/hiện\n  - Không có performance benefit cho filtering\n--&gt;</code></pre><p><strong>Solution 4: v-if bên ngoài v-for (show/hide entire list):</strong></p><pre><code>&lt;!-- ✅ GOOD - Conditional rendering của entire list --&gt;\n&lt;div v-if=\"hasUsers\"&gt;\n  &lt;li v-for=\"user in users\" :key=\"user.id\"&gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/div&gt;\n&lt;div v-else&gt;\n  &lt;p&gt;No users found&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;!-- Dùng khi cần show/hide toàn bộ list --&gt;</code></pre><p><strong>Performance comparison:</strong></p><pre><code>// Scenario: 1000 users, 100 active\n\n// ❌ BAD - v-if trên v-for\n&lt;div v-for=\"user in users\" v-if=\"user.isActive\"&gt;\n// → 1000 iterations mỗi render\n// → 1000 condition checks\n\n// ✅ GOOD - Computed\nconst activeUsers = computed(() =&gt; \n  users.value.filter(u =&gt; u.isActive)\n)\n&lt;div v-for=\"user in activeUsers\"&gt;\n// → Filter 1 lần khi users change (cached)\n// → 100 iterations mỗi render\n// → 10x faster!</code></pre><p><strong>Vue 3 specific - Template v-for:</strong></p><pre><code>&lt;!-- Vue 3 allows v-for on template without wrapper --&gt;\n&lt;template v-for=\"item in items\" :key=\"item.id\"&gt;\n  &lt;div&gt;{{ item.title }}&lt;/div&gt;\n  &lt;div&gt;{{ item.description }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;!-- Key phải ở template, không phải child elements --&gt;</code></pre><p><strong>ESLint rule:</strong></p><pre><code>// .eslintrc.js\nrules: {\n  'vue/no-use-v-if-with-v-for': 'error'\n}\n\n// Sẽ warning khi dùng v-if và v-for cùng element</code></pre><p><strong>Best practices summary:</strong></p><ul><li>✅ Luôn dùng :key với unique, stable ID</li><li>✅ KHÔNG dùng index làm key (trừ static list)</li><li>✅ Filter bằng computed property thay vì v-if trên v-for</li><li>✅ Dùng template wrapper nếu cần v-if cho từng item</li><li>✅ v-if bên ngoài v-for để show/hide entire list</li><li>✅ Enable ESLint rule để catch mistakes</li><li>❌ KHÔNG dùng v-if và v-for cùng element</li><li>❌ KHÔNG dùng random/unstable keys</li></ul>",
      "level": "senior"
    }
  ]
}
